[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19306 (refactor: Replace RecursiveMutex with Mutex in CTxMemPool by hebasto)\n* #19134 (test: Replace global wait_until with BitcoinTestFramework.wait_until and mininode.wait_until by dboures)\n* #19107 (p2p: Move all header verification into the network layer, extend logging by troygiorshev)\n* #18985 (bloom: use Span instead of std::vector for `insert` and `contains` [ZAP3] by jb55)\n* #18044 (Use wtxid for transaction relay by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-06-06T12:51:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-640056405",
      "id" : 640056405,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MDA1NjQwNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-21T05:56:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/640056405",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\n\r\nI was reading the description and this part is a bit unclear:\r\n\r\n>Transactions are requested from new candidates as soon as old requests expire, or NOTFOUND is received, or invalid transactions are received (i.e. this includes the functionality added by, and replaces,  [#18238](https://github.com/bitcoin/bitcoin/pull/18238) ).\r\n\r\nWhy invalid transactions are re-requested? Maybe I can figure out after reading the code, but right now this is confusing.\r\n\r\n",
      "created_at" : "2020-06-09T15:41:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-641389060",
      "id" : 641389060,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTM4OTA2MA==",
      "updated_at" : "2020-06-09T15:41:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641389060",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Why invalid transactions are re-requested? Maybe I can figure out after reading the code, but right now this is confusing.\r\n\r\nIt requires invalid witnesses. When you request a txid T from peer A, and get a response with a transaction with invalid witness, but txid T, then the announcement (T,A) gets marked as COMPLETED.",
      "created_at" : "2020-06-09T16:29:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-641416882",
      "id" : 641416882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTQxNjg4Mg==",
      "updated_at" : "2020-06-09T16:29:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641416882",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK ",
      "created_at" : "2020-06-18T17:30:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-646202215",
      "id" : 646202215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NjIwMjIxNQ==",
      "updated_at" : "2020-06-18T17:30:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/646202215",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443046657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443046657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This isn't required. We never copy construct a priority computer.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T21:14:45Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443046657",
      "id" : 443046657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NjY1Nw==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443046657",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443048114"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443048114"
         }
      },
      "author_association" : "MEMBER",
      "body" : "missing `*`. I don't know if this messes with doxygen parsing.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T21:20:01Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443048114",
      "id" : 443048114,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0ODExNA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443048114",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a reason to specify the underlying type here? Is it required so that it can be packed into 3 bits in the Entry bitfield below?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T21:30:10Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051085",
      "id" : 443051085,
      "line" : 109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTA4NQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 109,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 109,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051085",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: sort this above `REQUESTED` so it's next to the other `CANDIDATE_` entries.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T21:31:10Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051438",
      "id" : 443051438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTQzOA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051438",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076494"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T23:26:41Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076494",
      "id" : 443076494,
      "in_reply_to_id" : 443046657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjQ5NA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434378979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076494",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T23:26:47Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076518",
      "id" : 443076518,
      "in_reply_to_id" : 443048114,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjUxOA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434378996,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076518",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076681"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, my concern is that otherwise an unsigned type may be picked, and I don't know how that would interact with it being used as a bitfield.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T23:27:52Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076681",
      "id" : 443076681,
      "in_reply_to_id" : 443051085,
      "line" : 109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjY4MQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 109,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 109,
      "pull_request_review_id" : 434379183,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076681",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076966"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That doesn't work directly, as EntryTxid's sort order relies on the ordering of these fields. It could use its own enum with the necessary order, that ExtractTxid maps to, but that feels like overkill.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-19T23:29:46Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076966",
      "id" : 443076966,
      "in_reply_to_id" : 443051438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3Njk2Ng==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434379485,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076966",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443105454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443105454"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe worth adding a comment in the enum definition that the ordering is relied upon by the code that uses the ByTxid indexes. Reordering in ExtractTxid seems like overkill to me too fwiw.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-20T06:09:43Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443105454",
      "id" : 443105454,
      "in_reply_to_id" : 443051438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNTQ1NA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434406412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443105454",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443148041"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443148041"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-20T17:51:26Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443148041",
      "id" : 443148041,
      "in_reply_to_id" : 443051438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0ODA0MQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434443825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443148041",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I think that's a great move to dissociate message paths by class (addr, block, transaction, filters) instead of having all of them melt down in `net_processing`.\r\n\r\nI will do an approach ACK soon, but sounds to me this add more reliance on `boost` ? Also as it's a critical part of the codebase how do we build confidence of the correctness of this new transaction request logic implementation with regards to substituted old part ? (It would be great to come with a model for this as I think it would be desirable to do the same kind of changes for the messy `COMPACT_BLOCKS part of the codebase)",
      "created_at" : "2020-06-22T09:39:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647405500",
      "id" : 647405500,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzQwNTUwMA==",
      "updated_at" : "2020-06-22T09:39:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647405500",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> sounds to me this add more reliance on `boost` ?\r\n\r\nIt uses boost multi_index, which is also needed by the mempool (which does lookups by txid and feerate eg). If we found (or created) a replacement for that there, it should work here too, so I don't think it's much of an increase in the dependency.",
      "created_at" : "2020-06-22T17:34:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647672729",
      "id" : 647672729,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzY3MjcyOQ==",
      "updated_at" : "2020-06-22T17:34:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647672729",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ariard As @ajtowns said, we're already relying on boost/multi_index for CTxMemPool. I also spent a week or two thinking about how to implement this with custom data structures, but it's... really hard to match the same performance/memory usage characteristics without multi_index. So I think it's just the right tool for the job, plus it's a headers-only library (so it doesn't introduce runtime dependencies, which is a large part of what makes boost annoying).\r\n\r\nAs far as correctness/desirability of the behavior goes:\r\n\r\n* Reasoning about whether the behavior is desirable, when considered standalone, I believe is much easier than the current one. The current behavior is very much defined by interactions of randomized insertion orders in a queue, and has few guarantees about what those actually accomplish. You can look at the fuzz test, which contains a complete reimplementation of the semantics (without optimized performance).\r\n\r\n* At a (very) high level you can see that the existing behavior is maintained (apart from the max-in-flight rule) by looking at the changes in test/functional/p2p_tx_download.py. But at a lower level it's again hard to say much because the existing behavior is already so hard to describe exactly.",
      "created_at" : "2020-06-22T18:55:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647711219",
      "id" : 647711219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzcxMTIxOQ==",
      "updated_at" : "2020-06-22T19:59:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647711219",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444343931"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444343931"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\n```suggestion\r\n#endif // BITCOIN_TXREQUEST_H\r\n```\r\n\r\nSee: [Source code organization](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#source-code-organization)",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T16:12:53Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->m_state == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_NEW entry into a CANDIDATE_OTHER. If this makes it the new best CANDIDATE_OTHER (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_NEW entries with reqtime <= now are turned into CANDIDATE_{OTHER,BEST}.\n+    //! - CANDIDATE_{OTHER,BEST} entries with reqtime > now are turned into CANDIDATE_NEW.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+        bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.\n+    void ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<uint256> GetRequestable(uint64_t peer, std::chrono::microseconds now);\n+\n+    //! Inform the data structure that a txid was requested. This can only be called for txids returned by the last\n+    //! GetRequestable call (which must have been for the same peer), with only other RequestedTx and AlreadyHaveTx\n+    //! calls in between (which must have been for the same peer but different txids).\n+    void RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! We received a response (a tx, or a NOTFOUND) for txid from peer. Note that if a good tx is received (such\n+    //! that we don't need it anymore), AlreadyHaveTx should be called instead of (or in addition to)\n+    //! ReceivedResponse.\n+    void ReceivedResponse(uint64_t peer, const uint256& txid);\n+\n+    //! Count how many in-flight transactions a peer has.\n+    size_t CountInFlight(uint64_t peer) const;\n+\n+    //! Count how many transactions are being tracked for a peer (including timed-out ones and in-flight ones).\n+    size_t CountTracked(uint64_t peer) const;\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Query configuration parameter inbound delay.\n+    std::chrono::microseconds GetInboundDelay() const { return m_inbound_delay; }\n+\n+    //! Query configuration parameter timeout.\n+    std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+};\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444343931",
      "id" : 444343931,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzkzMQ==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 332,
      "original_position" : 332,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444343931",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444348343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444348343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\nnanonit: the word \"completed\" associates with a \"success\" for me (but I'm not a native English speaker though). These entries are not processed successfully, i.e., a transaction has not been received. Maybe rename `COMPLETED` to more general `PROCESSED` or something similar?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T16:19:51Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444348343",
      "id" : 444348343,
      "line" : 72,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0ODM0Mw==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 72,
      "original_position" : 71,
      "original_start_line" : 68,
      "path" : "src/txrequest.h",
      "position" : 72,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 69,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444348343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444351986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444351986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\nIt is not clear for me why the `ReceivedResponse()` \"should be called whenever a transaction ... was received from a peer\". It is not the case for a `COMPLETED` entry, no?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T16:25:41Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444351986",
      "id" : 444351986,
      "line" : 86,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1MTk4Ng==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 86,
      "original_position" : 85,
      "original_start_line" : 83,
      "path" : "src/txrequest.h",
      "position" : 86,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 84,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444351986",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444515524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444515524"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm trying not to leave too many nits at this stage, but what kind of maniac breaks lines between the type and parameter name?!",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T21:20:50Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444515524",
      "id" : 444515524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTUyNA==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436167063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444515524",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444543479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444543479"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree that a comment is sufficient. ",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T22:29:02Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444543479",
      "id" : 444543479,
      "in_reply_to_id" : 443051438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzQ3OQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436203658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444543479",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444545289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm getting this build warning:\r\n\r\n```\r\nIn file included from txrequest.cpp:5:0:\r\n./txrequest.h:158:25: warning: TxRequestTracker::Entry::m_state is too small to hold all values of enum class TxRequestTracker::State\r\n         State m_state : 3;\r\n                         ^\r\n```\r\n\r\nconfigure output:\r\n\r\n```\r\n  target os     = linux\r\n  build os      = linux-gnu\r\n\r\n  CC            = /usr/bin/ccache gcc\r\n  CFLAGS        = -g -O2\r\n  CPPFLAGS      =   -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2  -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\r\n  CXX           = /usr/bin/ccache g++ -std=c++11\r\n  CXXFLAGS      =   -fstack-reuse=none -Wstack-protector -fstack-protector-all  -Wall -Wextra -Wformat -Wvla -Wswitch -Wformat-security -Wredundant-decls -Wunused-variable -Wdate-time -Wsign-compare  -Wno-unused-parameter -Wno-implicit-fallthrough   -g -O2 -fno-extended-identifiers\r\n  LDFLAGS       = -pthread  -Wl,-z,relro -Wl,-z,now -pie  \r\n  ARFLAGS       = cr\r\n```\r\n\r\ngcc version:\r\n\r\n```\r\n gcc --version\r\ngcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\r\n```",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T22:34:19Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289",
      "id" : 444545289,
      "in_reply_to_id" : 443051085,
      "line" : 109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0NTI4OQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 109,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 109,
      "pull_request_review_id" : 436206011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444545289",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444548281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444548281"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I didn't understand why you were defining this alias until I tried to recompile without and it barfed. Do you think a comment that this is required for the Key Extractor concept (https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors) would help, or is this well known?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T22:43:32Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444548281",
      "id" : 444548281,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0ODI4MQ==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 226,
      "original_position" : 207,
      "original_start_line" : 206,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444548281",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444549027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444549027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/CANDIDATE{OTHER,_DELAYED,_BEST}/CANDIDATE_{NEW,BEST,OTHER}/`",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-23T22:45:47Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444549027",
      "id" : 444549027,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTAyNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444549027",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444579417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444579417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this will ever do anything. By the time we process this orphan transaction, we will have already called `AlreadyHaveTx()` in a `SendMessages()` call.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T00:29:53Z",
      "diff_hunk" : "@@ -1951,6 +1835,7 @@ void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uin\n         if (setMisbehaving.count(fromPeer)) continue;\n         if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+            g_txrequest.AlreadyHaveTx(orphanHash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444579417",
      "id" : 444579417,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU3OTQxNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 1838,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444579417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444581417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444581417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's a slight inconsistency here: if the transaction is successfully accepted to the mempool, then we call `AlreadyHaveTx()` immediately to remove it from `g_txrequest`, but if it's an orphan, then we only call `AlreadyHaveTx()` the next time a peer would potentially request it in `SendMessages()` (and I think the `AlreadyHaveTx()` call in `ProcessOrphanTx()` is basically always a no-op).\r\n\r\nFor consistency, perhaps we should only call `AlreadyHaveTx()` in `SendMessages()`.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T00:37:43Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444581417",
      "id" : 444581417,
      "line" : 2738,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4MTQxNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2738,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 231,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444581417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444584736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444584736"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looks like that warning is kind-of a bug in gcc (you can [apparently](https://gcc.gnu.org/legacy-ml/gcc/2017-10/msg00129.html) put any value from the underlying type in the enum, and it's complaining that they won't all fit), but it's not fixed until gcc 8.4 or 9.3 -- https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414\r\n\r\nEDIT: (the example given in the linked list post for putting values from the underlying type in a scoped enum without a static_cast doesn't work for me in g++, so not really sure what's going on there)",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T00:50:48Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444584736",
      "id" : 444584736,
      "in_reply_to_id" : 443051085,
      "line" : 109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4NDczNg==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 109,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 109,
      "pull_request_review_id" : 436253001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444584736",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615293"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615293"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've struggled with a good name for this, actually, and changed it a few times. The problem is that it corresponds to a number of scenarios:\r\n\r\n* We've received the transaction (but we don't know (yet) if it's a valid one)\r\n* We've received the transaction with an invalid witness\r\n* We've received a NOTFOUND message for the transaction\r\n* The request timed out\r\n\r\nI don't think `PROCESSED` is an improvement, but I admit `COMPLETED` isn't perfect either.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T02:50:57Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615293",
      "id" : 444615293,
      "in_reply_to_id" : 444348343,
      "line" : 72,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNTI5Mw==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 72,
      "original_position" : 71,
      "original_start_line" : 68,
      "path" : "src/txrequest.h",
      "position" : 72,
      "pull_request_review_id" : 436289015,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 69,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615293",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`ReceivedResponse` is what marks the entry as `COMPLETED`.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T02:51:50Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615509",
      "id" : 444615509,
      "in_reply_to_id" : 444351986,
      "line" : 86,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNTUwOQ==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 86,
      "original_position" : 85,
      "original_start_line" : 83,
      "path" : "src/txrequest.h",
      "position" : 86,
      "pull_request_review_id" : 436289287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 84,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615509",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615824"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jnewbery Does it help if you remove the `: uint8_t`?\r\n\r\nIf this is too annoying we can just store the state as a non-`enum` type.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T02:53:14Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615824",
      "id" : 444615824,
      "in_reply_to_id" : 443051085,
      "line" : 109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNTgyNA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 109,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 109,
      "pull_request_review_id" : 436289700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615824",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444616552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444616552"
         }
      },
      "author_association" : "MEMBER",
      "body" : "",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T02:56:11Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444616552",
      "id" : 444616552,
      "in_reply_to_id" : 444515524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNjU1Mg==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436290592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444616552",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625237"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Changed to store it as a `uint8_t`.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T03:33:55Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625237",
      "id" : 444625237,
      "in_reply_to_id" : 443051085,
      "line" : 109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTIzNw==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 109,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 109,
      "pull_request_review_id" : 436300947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625237",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T03:34:05Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->m_state == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_NEW entry into a CANDIDATE_OTHER. If this makes it the new best CANDIDATE_OTHER (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_NEW entries with reqtime <= now are turned into CANDIDATE_{OTHER,BEST}.\n+    //! - CANDIDATE_{OTHER,BEST} entries with reqtime > now are turned into CANDIDATE_NEW.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+        bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.\n+    void ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<uint256> GetRequestable(uint64_t peer, std::chrono::microseconds now);\n+\n+    //! Inform the data structure that a txid was requested. This can only be called for txids returned by the last\n+    //! GetRequestable call (which must have been for the same peer), with only other RequestedTx and AlreadyHaveTx\n+    //! calls in between (which must have been for the same peer but different txids).\n+    void RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! We received a response (a tx, or a NOTFOUND) for txid from peer. Note that if a good tx is received (such\n+    //! that we don't need it anymore), AlreadyHaveTx should be called instead of (or in addition to)\n+    //! ReceivedResponse.\n+    void ReceivedResponse(uint64_t peer, const uint256& txid);\n+\n+    //! Count how many in-flight transactions a peer has.\n+    size_t CountInFlight(uint64_t peer) const;\n+\n+    //! Count how many transactions are being tracked for a peer (including timed-out ones and in-flight ones).\n+    size_t CountTracked(uint64_t peer) const;\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Query configuration parameter inbound delay.\n+    std::chrono::microseconds GetInboundDelay() const { return m_inbound_delay; }\n+\n+    //! Query configuration parameter timeout.\n+    std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+};\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625278",
      "id" : 444625278,
      "in_reply_to_id" : 444343931,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTI3OA==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 332,
      "original_position" : 332,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625278",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T03:34:16Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625313",
      "id" : 444625313,
      "in_reply_to_id" : 444515524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTMxMw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301047,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625313",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625506"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes sorry John, you're obviously an idiot if you don't know the boost reference documentation by heart ;)\r\n\r\nDone.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T03:35:03Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625506",
      "id" : 444625506,
      "in_reply_to_id" : 444548281,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTUwNg==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 226,
      "original_position" : 207,
      "original_start_line" : 206,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625506",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625532"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625532"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T03:35:12Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625532",
      "id" : 444625532,
      "in_reply_to_id" : 444549027,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTUzMg==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625532",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444627285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444627285"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thinking about the case where someone malleates the witness for a tx relayed by txid not wtxid; should we maybe ... I don't know, track the other peers that offered the tx as part of the orphan record, so that we can try getting the correct witness data once we have the parents and can actually see if maybe the witness data was malleated?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T03:42:48Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444627285",
      "id" : 444627285,
      "in_reply_to_id" : 444581417,
      "line" : 2738,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNzI4NQ==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2738,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 231,
      "pull_request_review_id" : 436303362,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444627285",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444894338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444894338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pieter and I were discussing just this yesterday. The behaviour you describe (not rerequesting an orphan transaction from another announcing peer if we later discover that its witness is mutated) also exists in master. As soon as we put a transaction in `mapOrphanTransactions` it'll return true from `AlreadyHave()` and will then be removed from each peer's `TxDownloadState`.\r\n\r\nI think it's ok to keep this behaviour. Orphan handling is to some extent best effort, so shouldn't be relied on for timely transaction propagation. If an adversary is able to poison a transaction in the orphan set, then we won't rerequest it from other peers when `AcceptToMemoryPool()` fails, but it won't be added to our recent rejects filter, and if just one other peer later announces it to us, we'll attempt to fetch it again.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-24T13:30:33Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444894338",
      "id" : 444894338,
      "in_reply_to_id" : 444581417,
      "line" : 2738,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg5NDMzOA==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2738,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 231,
      "pull_request_review_id" : 436647539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444894338",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446623480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446623480"
         }
      },
      "author_association" : "MEMBER",
      "body" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51\r\n\r\nThere is `SipHashUint256Extra(uint64_t, uint64_t, uint256&, uint32_t)` in the `crypto/siphash` module.\r\nIs it worth to add the reusable `SipHashUint256Extra64(uint64_t, uint64_t, uint256&, uint64_t)` there?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-28T09:03:53Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446623480",
      "id" : 446623480,
      "line" : 41,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzQ4MA==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 41,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 41,
      "pull_request_review_id" : 438760405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446623480",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446629277"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446629277"
         }
      },
      "author_association" : "MEMBER",
      "body" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51\r\n\r\nNo warnings are observed on GCC 9.3.0.\r\nWhat GCC version you are referring to?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-28T09:59:41Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{NEW,BEST,OTHER} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446629277",
      "id" : 446629277,
      "line" : 158,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyOTI3Nw==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 158,
      "original_position" : 159,
      "original_start_line" : 158,
      "path" : "src/txrequest.h",
      "position" : 158,
      "pull_request_review_id" : 438764703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 157,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446629277",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446633732"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446633732"
         }
      },
      "author_association" : "MEMBER",
      "body" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51\r\n\r\nCould passing the `peer` to `SetTimePoint()` improve efficiency by not processing entries related to other peers?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-28T10:41:55Z",
      "diff_hunk" : "@@ -0,0 +1,241 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+    bool deterministic) :\n+    m_inbound_delay(inbound_delay),\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_NEW);\n+    // Convert CANDIDATE_NEW to CANDIDATE_OTHER first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _NEW, then\n+    // _BEST/REQUESTED, then _OTHER). Within the _OTHER entries, the best one (lowest priority) comes first. Thus, if\n+    // an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately precede\n+    // the newly created _OTHER.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_NEW) {\n+        // This is the new best CANDIDATE_OTHER, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_OTHER, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_OTHER) {\n+            // If one such CANDIDATE_OTHER exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_NEW and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_OTHER and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_NEW && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_OTHER entries back\n+        // to CANDIDATE_NEW. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_NEW);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_NEW, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);\n+        // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+        // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+        if (MakeCompleted(m_index.project<ByTxid>(it))) {\n+            // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+            Erase<ByPeer>(it);\n+        }\n+        it = it_next;\n+    }\n+}\n+\n+void TxRequestTracker::ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now)\n+{\n+    // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+    // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+    // automatically.\n+    if (m_index.get<ByPeer>().count(EntryPeer{peer, true, txid})) return;\n+\n+    auto time = outbound ? now : now + m_inbound_delay;\n+    auto ret = m_index.get<ByPeer>().emplace(txid, peer, !outbound, time, m_sequence);\n+    if (ret.second) {\n+        auto it = m_index.project<ByTxid>(ret.first);\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+        if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != txid) &&\n+            (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != txid)) {\n+            // This is both the first and the last entry for a given txid; set its m_first.\n+            ret.first->m_first = true;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now)\n+{\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+    // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+    // which preserve the state of other txids).\n+    assert(it != m_index.get<ByPeer>().end());\n+    assert(it->GetState() == State::CANDIDATE_BEST);\n+    Modify<ByPeer>(it, [now,this](Entry& entry) {\n+        entry.SetState(State::REQUESTED);\n+        entry.m_time = now + m_timeout;\n+    });\n+}\n+\n+void TxRequestTracker::ReceivedResponse(uint64_t peer, const uint256& txid)\n+{\n+    // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, txid});\n+    if (it == m_index.get<ByPeer>().end()) it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxid>(it));\n+}\n+\n+size_t TxRequestTracker::CountInFlight(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_requested;\n+    return 0;\n+}\n+\n+size_t TxRequestTracker::CountTracked(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_total;\n+    return 0;\n+}\n+\n+std::vector<uint256> TxRequestTracker::GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+{\n+    // Move time.\n+    SetTimePoint(now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446633732",
      "id" : 446633732,
      "line" : 220,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMzczMg==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 220,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 220,
      "pull_request_review_id" : 438767993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446633732",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446646962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446646962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IIUC, `TxRequestTracker::MakeCompleted()` relies on the fact that `COMPLETED` is the last entry in the enum `State`.\r\nCould a relevant comment be added here to preserve any breakdown in the future?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-06-28T12:48:35Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446646962",
      "id" : 446646962,
      "line" : 120,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY0Njk2Mg==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 120,
      "original_position" : 121,
      "original_start_line" : 120,
      "path" : "src/txrequest.h",
      "position" : 120,
      "pull_request_review_id" : 438777492,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 119,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446646962",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-06-29T14:23:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-651155144",
      "id" : 651155144,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MTE1NTE0NA==",
      "updated_at" : "2020-06-29T14:23:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/651155144",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@gmaxwell suggested that the \"first\" feature (the very first peer to announce a transaction gets priority over other outbound or other inbounds) is changed to instead apply to the first not-max-in-flight peer. The idea is that this would prevent an attacker who races announcements, but doesn't respond, will (as soon as they reach their max-in-flight) not be able to interfere with chains of dependent transactions (which we'd like to request from the same peer).\r\n\r\nThis seems like a good idea, and easy to implement, but it'll require some changes to tests.",
      "created_at" : "2020-07-01T04:40:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-652185602",
      "id" : 652185602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MjE4NTYwMg==",
      "updated_at" : "2020-07-01T04:40:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/652185602",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-07-01T14:25:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-652450597",
      "id" : 652450597,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MjQ1MDU5Nw==",
      "updated_at" : "2020-07-01T14:25:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/652450597",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448628973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448628973"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's a good suggestion, but I don't think it would actually be desirable (but fortunately, it also wouldn't gain any efficiency). An earlier design of this code worked like that, but I decided to move off that.\r\n\r\nSay we're calling `GetRequestable` for peer A. There is a txid T that was announced by peer A and peer B. For some reason, peer B is currently the `CANDIDATE_BEST` peer for T, but its exptime is in the past. That means that the (T,B) pair in reality should be `COMPLETED` now (but the data structure hasn't been updated to reflect that), and peer A is actually the best match. If `GetRequestable` for A would only invoke `SetTimePoint` for currently-`CANDIDATE_BEST` entries, T won't be returned, at it'll only be when B calls `GetRequestable` that its expiration happens. This is probably not terrible behavior, but makes it *much* harder to exactly specify the behavior, and perhaps it introduces a bias in the selection - it's hard to say.\r\n\r\nThankfully, it also doesn't gain anything. Every (txid,peer) pair only ever transitions once to `COMPLETED`, so certainly in bulk work there cannot be any difference. Furthermore, `SetTimePoint` only iterates over all expired entries in its first loop, as they're sorted by time. So no time is wasted processing unexpired entries.\r\n\r\nA similar reasoning applies to the second loop.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-01T21:36:11Z",
      "diff_hunk" : "@@ -0,0 +1,241 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+    bool deterministic) :\n+    m_inbound_delay(inbound_delay),\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_NEW);\n+    // Convert CANDIDATE_NEW to CANDIDATE_OTHER first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _NEW, then\n+    // _BEST/REQUESTED, then _OTHER). Within the _OTHER entries, the best one (lowest priority) comes first. Thus, if\n+    // an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately precede\n+    // the newly created _OTHER.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_NEW) {\n+        // This is the new best CANDIDATE_OTHER, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_OTHER, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_OTHER) {\n+            // If one such CANDIDATE_OTHER exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_NEW and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_OTHER and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_NEW && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_OTHER entries back\n+        // to CANDIDATE_NEW. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_NEW);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_NEW, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);\n+        // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+        // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+        if (MakeCompleted(m_index.project<ByTxid>(it))) {\n+            // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+            Erase<ByPeer>(it);\n+        }\n+        it = it_next;\n+    }\n+}\n+\n+void TxRequestTracker::ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now)\n+{\n+    // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+    // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+    // automatically.\n+    if (m_index.get<ByPeer>().count(EntryPeer{peer, true, txid})) return;\n+\n+    auto time = outbound ? now : now + m_inbound_delay;\n+    auto ret = m_index.get<ByPeer>().emplace(txid, peer, !outbound, time, m_sequence);\n+    if (ret.second) {\n+        auto it = m_index.project<ByTxid>(ret.first);\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+        if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != txid) &&\n+            (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != txid)) {\n+            // This is both the first and the last entry for a given txid; set its m_first.\n+            ret.first->m_first = true;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now)\n+{\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+    // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+    // which preserve the state of other txids).\n+    assert(it != m_index.get<ByPeer>().end());\n+    assert(it->GetState() == State::CANDIDATE_BEST);\n+    Modify<ByPeer>(it, [now,this](Entry& entry) {\n+        entry.SetState(State::REQUESTED);\n+        entry.m_time = now + m_timeout;\n+    });\n+}\n+\n+void TxRequestTracker::ReceivedResponse(uint64_t peer, const uint256& txid)\n+{\n+    // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, txid});\n+    if (it == m_index.get<ByPeer>().end()) it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxid>(it));\n+}\n+\n+size_t TxRequestTracker::CountInFlight(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_requested;\n+    return 0;\n+}\n+\n+size_t TxRequestTracker::CountTracked(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_total;\n+    return 0;\n+}\n+\n+std::vector<uint256> TxRequestTracker::GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+{\n+    // Move time.\n+    SetTimePoint(now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448628973",
      "id" : 448628973,
      "in_reply_to_id" : 446633732,
      "line" : 220,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyODk3Mw==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 220,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 220,
      "pull_request_review_id" : 441212388,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448628973",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448629480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448629480"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-01T21:37:29Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{NEW,BEST,OTHER} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448629480",
      "id" : 448629480,
      "in_reply_to_id" : 446629277,
      "line" : 158,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyOTQ4MA==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 158,
      "original_position" : 159,
      "original_start_line" : 158,
      "path" : "src/txrequest.h",
      "position" : 158,
      "pull_request_review_id" : 441213009,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 157,
      "start_side" : "RIGHT",
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448629480",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448629656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448629656"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this may make sense as a follow-up, but probably deserves benchmarks etc.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-01T21:37:57Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448629656",
      "id" : 448629656,
      "in_reply_to_id" : 446623480,
      "line" : 41,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYyOTY1Ng==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 41,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 41,
      "pull_request_review_id" : 441213227,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448629656",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448636680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448636680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c204530ae289c263f0a9b791bbcd031a552c3253\r\n\r\n> and std::next(it) may be deleted in the process\r\n\r\nAnd is it safe to use `it` if next is erased? Otherwise I was expecting `lower_bound` call in each iteration.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-01T21:55:15Z",
      "diff_hunk" : "@@ -0,0 +1,241 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+    bool deterministic) :\n+    m_inbound_delay(inbound_delay),\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_NEW);\n+    // Convert CANDIDATE_NEW to CANDIDATE_OTHER first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _NEW, then\n+    // _BEST/REQUESTED, then _OTHER). Within the _OTHER entries, the best one (lowest priority) comes first. Thus, if\n+    // an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately precede\n+    // the newly created _OTHER.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_NEW) {\n+        // This is the new best CANDIDATE_OTHER, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_OTHER, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_OTHER) {\n+            // If one such CANDIDATE_OTHER exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_NEW and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_OTHER and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_NEW && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_OTHER entries back\n+        // to CANDIDATE_NEW. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_NEW);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_NEW, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448636680",
      "id" : 448636680,
      "line" : 150,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzNjY4MA==",
      "original_commit_id" : "c204530ae289c263f0a9b791bbcd031a552c3253",
      "original_line" : 150,
      "original_position" : 152,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 150,
      "pull_request_review_id" : 441221565,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448636680",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448645723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448645723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, iterator validation for multi_index entries is like std::set; erasing entries does not affect the validity of iterators to other entries.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-01T22:20:50Z",
      "diff_hunk" : "@@ -0,0 +1,241 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+    bool deterministic) :\n+    m_inbound_delay(inbound_delay),\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_NEW);\n+    // Convert CANDIDATE_NEW to CANDIDATE_OTHER first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _NEW, then\n+    // _BEST/REQUESTED, then _OTHER). Within the _OTHER entries, the best one (lowest priority) comes first. Thus, if\n+    // an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately precede\n+    // the newly created _OTHER.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_NEW) {\n+        // This is the new best CANDIDATE_OTHER, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_OTHER, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_OTHER) {\n+            // If one such CANDIDATE_OTHER exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_NEW and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_OTHER and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_NEW && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_OTHER entries back\n+        // to CANDIDATE_NEW. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_NEW);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_NEW, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r448645723",
      "id" : 448645723,
      "in_reply_to_id" : 448636680,
      "line" : 150,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY0NTcyMw==",
      "original_commit_id" : "c204530ae289c263f0a9b791bbcd031a552c3253",
      "original_line" : 150,
      "original_position" : 152,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 150,
      "pull_request_review_id" : 441232686,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448645723",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-07-04T13:21:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-653765803",
      "id" : 653765803,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Mzc2NTgwMw==",
      "updated_at" : "2020-07-04T13:21:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/653765803",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r449824561"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/449824561"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I prefer to keep the fast-path AlreadyHaveTx calls when transactions/blocks come in, as they may in some cases be much faster than the AlreadyHave detection after GetRequestable (in particular, when the only alternative peer(s) are timing out).\r\n\r\nYou're right though that the code is inconsistent: orphans in the orphan pool are considered AlreadyHave, so txids should be reported as AlreadyHaveTx as soon as they're added to the orphan pool. I've adopted that approach now.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-05T02:53:58Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r449824561",
      "id" : 449824561,
      "in_reply_to_id" : 444581417,
      "line" : 2738,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgyNDU2MQ==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2738,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 231,
      "pull_request_review_id" : 442641485,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/449824561",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r450180923"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/450180923"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Somewhat related ;) https://github.com/bitcoin/bitcoin/pull/18014",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-06T12:17:59Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r450180923",
      "id" : 450180923,
      "in_reply_to_id" : 446623480,
      "line" : 41,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE4MDkyMw==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 41,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 41,
      "pull_request_review_id" : 443023073,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-21T02:03:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/450180923",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nVery nice fuzzing harness!",
      "created_at" : "2020-07-10T21:29:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-656899884",
      "id" : 656899884,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njg5OTg4NA==",
      "updated_at" : "2020-07-10T21:29:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656899884",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-07-16T07:31:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-659216716",
      "id" : 659216716,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1OTIxNjcxNg==",
      "updated_at" : "2020-07-16T07:31:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/659216716",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've made a few changes:\r\n* Instead of having an outbound/inbound flag, `ReceivedInv` now just takes an explicit delay parameter. Entries with delay 0 are preferred. This matches reality more closely (as the `outbound` property wasn't exactly for outbound peers, but also other whitelisted ones). It is also more compatible with the approach taken in #18044 (where the delay becomes a function of both outboundness and wtxidness).\r\n* Renamed CANDIDATE_NEW to CANDIDATE_DELAYED\r\n* Renamed CANDIDATE_OTHER to CANDIDATE_READY\r\n\r\nAs there are still other changes I want to make to the behavior, I've marked this as Draft for now.",
      "created_at" : "2020-07-18T03:27:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-660416603",
      "id" : 660416603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MDQxNjYwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-18T03:28:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/660416603",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459133311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459133311"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nIt wasn't clear at first read if `m_first` was applying for each set or the union of them. Why not restrain `m_first` to non-delayed peer only to favor fastest among more trusted peers ? We always favor non-delayed ones over delayed ones, so in `PromoteCandidateNew`, an entry from the former is likely to be favored but we sorting them uniformly randomly obviously don't favor the fastest one. Or do you assume we receive and fetch in same threading sequence  (`ThreadMessageHandler`) and `reqtime` initialized to now ensure this ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:08:11Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459133311",
      "id" : 459133311,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMzMxMQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 29,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459133311",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459133991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459133991"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nI think it's a bit confusing to talk about delayed/non-delayed peers. Transaction entries in function of their announcing peers types but we may process those uniformly in other context. Also random order minus bias for first announcer ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:10:23Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459133991",
      "id" : 459133991,
      "line" : 51,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMzk5MQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 51,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 51,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459133991",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459134558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459134558"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nWhat do you mean exactly here ? If a transaction has been successfully received (AlreadyHave() == true) we won't re-request anyway, unless `g_recently_confirmed` rolls over ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:12:07Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459134558",
      "id" : 459134558,
      "line" : 55,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDU1OA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 55,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 55,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459134558",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459138430"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459138430"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nI think you might laid out more high-level properties of transaction request logic here, among others:\r\n\r\n\"Transaction downloads never guarantee to succeed, namely receiving transaction if you hear about its identifier. Success should be define as a best-effort, guaranteeing we advance towards entry removal for any peer who announced a txid\"\r\n\r\n\"To optimize bandwidth-saving, we limit parallel-fetching and favor sequential fetching (there MUST be only one REQUESTED entry at anytime for any given txid)\"\r\n\r\n\"We don't guarantee fetching again a transaction for which validity/standardness may have change between re-announcements, until next block announcement (a AlreadyHave() triggers all txid entries removal)\"\r\n\r\n\"Assuming a fast-inbound attacker-controlled peer and low outbound not-controlled ones, a transaction propagation can be delayed at most for one GETDATA_TX_INTERVAL period\"",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:24:08Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459138430",
      "id" : 459138430,
      "line" : 57,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzODQzMA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 57,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459138430",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459139468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459139468"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nYou should underscore state transition to CANDIDATE_BEST for the highest-scored CANDIDATE_READY. If we reintroduce in-flight rate-limiting we should avoid that a malicious A disconnecting can slowdown fetching from B, unique peer also announcing the malevolent set of txn max-in-flight-sized.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:27:26Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459139468",
      "id" : 459139468,
      "line" : 79,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTQ2OA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 79,
      "original_position" : 79,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 79,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459139468",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459139843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459139843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nAh naming is hard, `AlreadyEvaluatedTx`/`AlreadyProcessedTx` to avoid collision with `AlreadyHave` ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:28:41Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459139843",
      "id" : 459139843,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTg0Mw==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 81,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459139843",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459140164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459140164"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nWhy make it configurable ? A minority of nodes tuning this variable would break privacy attackers assumptions ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:29:42Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459140164",
      "id" : 459140164,
      "line" : 103,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MDE2NA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 103,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 103,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459140164",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459142436"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459142436"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259bf92\r\n\r\nActually I think this state only exists between `GetRequestable` and `RequestedTx`. Accessing `AlreadyHave` inside TxRequestTracker would allow to remove it and directly transition from READY to REQUESTED (though you have to tight more `PromoteCandidateNew` and `GetRequestable` because former yells BEST among txid indice). I guess you thought about it but deferred to future work ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:36:57Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459142436",
      "id" : 459142436,
      "line" : 114,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MjQzNg==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 114,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 114,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459142436",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459143538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459143538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92 \r\n\r\nCan you underscore more rational of m_sequence ? As it is only effect is to implicitly ensure transaction topology-order of GETDATAs if INVs received have been so but without guaranteeing chain of transactions are all fetched from same announcing peer ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:40:51Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459143538",
      "id" : 459143538,
      "line" : 142,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MzUzOA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 142,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 142,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459143538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459143938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459143938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nMaybe annotate worst-case memory size of this data structure : `MAX_PEER_ANNOUNCEMENTS` * max_connections * sizeof(Entry) ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:42:15Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459143938",
      "id" : 459143938,
      "line" : 248,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MzkzOA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 248,
      "original_position" : 248,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 248,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459143938",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459144236"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459144236"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nAfter last changes, `PromoteCandidateReady` ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-22T23:43:17Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459144236",
      "id" : 459144236,
      "line" : 291,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NDIzNg==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 291,
      "original_position" : 291,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 291,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459144236",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459151052"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459151052"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nWe call `ReceivedInv` on the behalf of a peer sending us an orphan tx. Is following scenario plausible ?\r\n* Malicia sends N txn to Alice and N' conflicting to Bob\r\n* Malicia sends txB child spending from all parent of N to Alice\r\n* Alice sends txB to Bob, at reception Bob calls `RequestTx/ReceivedInv` on behalf of Alice\r\n* Malicia repeats this trick until reaching Alice's  MAX_PEER_TX_ANNOUNCEMENTS (and also avoid hitting MAX_STANDARD_TX_WEIGHT for orphan)\r\n* When Bob calls `GetRequestable` at GETDATA sending to Alice, only MAX_GETDATA_SZ will be effectively processed, the rest obstructing Alice's announced invs until GETDATA_TX_INTERVAL expiration\r\n* Alice sends transaction for the MAX_GETDATA_SZ set\r\n* Malicia may repeat timely repeat trick to maintain transaction propagation blocking anticipating Alice-Bob round-trips\r\n\r\nAttack might seem costly because you have to fulfill Alice mempool with parent transaction but making them conflicted with the rest of network mempools avoid to effectively pay their feerate.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:07:39Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds timeout, bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459151052",
      "id" : 459151052,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1MTA1Mg==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 318,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459151052",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459151500"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459151500"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nnit: The first-sorted _READY ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:09:30Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459151500",
      "id" : 459151500,
      "line" : 99,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1MTUwMA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 99,
      "original_position" : 99,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 99,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459151500",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459152310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459152310"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Time going backward wouldn't be a hint of some clock manipulation and thus we should interpret this as a system failure and halting ? AFAICT, `GetAdjustedTime()` can go backward due to relying on peers clocks but we are relying on `GetTime<T>` here.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:12:30Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459152310",
      "id" : 459152310,
      "line" : 121,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1MjMxMA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 121,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 121,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459152310",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459153327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459153327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nMaybe add as a comment \"If transaction has already been evaluated once for this block tip, delete unconditionally all its entries.\"\r\n\r\nIs this a slight behavior change ?  Previously we would have only delete transaction from download for this peer. If you received a block between peers processing you have flushed `recentRejects` and so here return a different evaluation.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:16:10Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+        // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_DELAYED);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_DELAYED, 0});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459153327",
      "id" : 459153327,
      "line" : 135,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1MzMyNw==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 135,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 135,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459153327",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459154501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459154501"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nThe ByPeer index second member as true signals a state equal to CANDIDATE_BEST but I'm not sure if you can effectively hit here. An entry state is _BEST only between `GetRequestable` and either `RequestedTx/AlreadyHaveTx`, both of them respectively transitioning to REQUESTED/entry removal.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:20:47Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+        // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_DELAYED);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_DELAYED, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);\n+        // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+        // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+        if (MakeCompleted(m_index.project<ByTxid>(it))) {\n+            // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+            Erase<ByPeer>(it);\n+        }\n+        it = it_next;\n+    }\n+}\n+\n+void TxRequestTracker::ReceivedInv(uint64_t peer, const uint256& txid, std::chrono::microseconds reqtime)\n+{\n+    // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+    // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+    // automatically.\n+    if (m_index.get<ByPeer>().count(EntryPeer{peer, true, txid})) return;\n+\n+    auto ret = m_index.get<ByPeer>().emplace(txid, peer, reqtime, m_sequence);\n+    if (ret.second) {\n+        auto it = m_index.project<ByTxid>(ret.first);\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+        if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != txid) &&\n+            (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != txid)) {\n+            // This is both the first and the last entry for a given txid; set its m_first.\n+            ret.first->m_first = true;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now)\n+{\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+    // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+    // which preserve the state of other txids).\n+    assert(it != m_index.get<ByPeer>().end());\n+    assert(it->GetState() == State::CANDIDATE_BEST);\n+    Modify<ByPeer>(it, [now,this](Entry& entry) {\n+        entry.SetState(State::REQUESTED);\n+        entry.m_time = now + m_timeout;\n+    });\n+}\n+\n+void TxRequestTracker::ReceivedResponse(uint64_t peer, const uint256& txid)\n+{\n+    // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459154501",
      "id" : 459154501,
      "line" : 197,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDUwMQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 197,
      "original_position" : 197,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 197,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459154501",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459155219"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459155219"
         }
      },
      "author_association" : "MEMBER",
      "body" : "259fb92\r\n\r\nnit: I think this control flow conditional could be replaced by a method `IsLastCompleted` like we have `IsSelected/IsSelectable`. Easier to reason.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:23:34Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459155219",
      "id" : 459155219,
      "line" : 87,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NTIxOQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 87,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459155219",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459155891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459155891"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4f4f2f2\r\n\r\nIf `fAlreadyHave==true` call `AlreadyHaveTx` to clean transaction entries early ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:26:04Z",
      "diff_hunk" : "@@ -2599,7 +2482,7 @@ void ProcessMessage(\n                     pfrom.fDisconnect = true;\n                     return;\n                 } else if (!fAlreadyHave && !chainman.ActiveChainstate().IsInitialBlockDownload()) {\n-                    RequestTx(State(pfrom.GetId()), inv.hash, current_time);\n+                    RequestTx(pfrom, inv.hash, current_time);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459155891",
      "id" : 459155891,
      "line" : 2491,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NTg5MQ==",
      "original_commit_id" : "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
      "original_line" : 2485,
      "original_position" : 199,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 212,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459155891",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459156379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459156379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4f4f2f2\r\n\r\nMaybe you can parameterize `GetRequestable` with MAX_GETDATA_SZ to avoid leftover marked as REQUESTED but not effectively fetched and thus wasting a `GETDATA_TX_INTERVAL` for them ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:27:59Z",
      "diff_hunk" : "@@ -4349,59 +4221,19 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const uint256 txid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const uint256& txid : g_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(MSG_TX | GetFetchFlags(*pto), txid);\n             if (!AlreadyHave(inv, m_mempool)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                const auto last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(inv.hash, current_time);\n-                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, current_time);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload);\n-                    tx_process_time.emplace(next_process_time, txid);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= MAX_GETDATA_SZ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459156379",
      "id" : 459156379,
      "line" : 4239,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NjM3OQ==",
      "original_commit_id" : "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
      "original_line" : 4229,
      "original_position" : 304,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 330,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459156379",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459157066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459157066"
         }
      },
      "author_association" : "MEMBER",
      "body" : "75fd5dc\r\n\r\nI think `AlreadyHaveTx` and time-goes-backward of `SetTimePoint` aren't covered? I'll try to add them soon, also `ReceivedResponse` should be called unconditionally at the end of each test to verify clean state ? ",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-07-23T00:30:50Z",
      "diff_hunk" : "@@ -0,0 +1,237 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds TEST_TIMEOUT = std::chrono::minutes{2};\n+constexpr std::chrono::microseconds TEST_DELAY = std::chrono::seconds{2};\n+\n+constexpr std::chrono::microseconds ReqTime(std::chrono::microseconds now, bool delay)\n+{\n+    return delay ? now + TEST_DELAY : std::chrono::microseconds::min();\n+}\n+\n+constexpr int TEST_ITERATIONS = 1000;\n+\n+uint256 GenTxid(const TxRequestTracker& tracker, const std::vector<uint64_t>& order)\n+{\n+    const auto& computer = tracker.GetPriorityComputer();\n+\n+    uint256 ret;\n+    bool ok;\n+    do {\n+        ret = InsecureRand256();\n+\n+        ok = true;\n+        for (size_t pos = 1; pos < order.size(); ++pos) {\n+            if (computer(ret, order[pos - 1], true, false) >= computer(ret, order[pos], true, false)) {\n+                ok = false;\n+                break;\n+            }\n+        }\n+    } while(!ok);\n+\n+    return ret;\n+}\n+\n+std::vector<uint64_t> GenPeers(size_t num)\n+{\n+    std::set<uint64_t> retset;\n+    while (retset.size() < num) {\n+        retset.insert(InsecureRandBits(63));\n+    }\n+\n+    std::vector<uint64_t> ret(retset.begin(), retset.end());\n+    Shuffle(ret.begin(), ret.end(), g_insecure_rand_ctx);\n+    return ret;\n+}\n+\n+std::chrono::microseconds RandomTime(int bits=44) { return std::chrono::microseconds{InsecureRandBits(bits)}; }\n+\n+void CheckRequestable(TxRequestTracker& tracker, uint64_t peer, std::chrono::microseconds now, const std::vector<uint256>& expected)\n+{\n+    BOOST_CHECK(tracker.GetRequestable(peer, now) == expected);\n+    tracker.SanityCheck();\n+    tracker.TimeSanityCheck(now);\n+}\n+\n+void TestBasicNonDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, false)); // Announce from non-delayed peer\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestBasicDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable immediately.\n+    now += TEST_DELAY - std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable after 1.999999s.\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Does become requestable after 2s.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestFirstAnnouncementWins(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately from peer 0.\n+    CheckRequestable(tracker, peers[1], now, {}); // And not from peer 1 (very first announcement always wins)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestNoDelayPreference()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer 0\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable\n+    now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable after enough time\n+    now += RandomTime(32);\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Remains requestable after arbitrary amounts of time\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, false)); // Then announced by non-delayed peer 1\n+    CheckRequestable(tracker, peers[1], now, {txid}); // Immediately becomes requestable from peer 1 (non-delayed)\n+    CheckRequestable(tracker, peers[0], now, {}); // And stops being requestable from peer 0 (can only be assigned to one peer)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestPriorityPreference(bool delay, int remove_reason)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[2], txid, ReqTime(now, delay)); // Slightly later, announce from peer 2\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Even later, announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // As peer 0 was the very first to announce, it gets the request first\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[0]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        tracker.ReceivedResponse(peers[0], txid);\n+    }\n+\n+    CheckRequestable(tracker, peers[0], now, {}); // If peer 0 goes offline, or the request times out, or a NOTFOUND is received, does peer 1 gets it (despite peer 2 being earlier)\n+    CheckRequestable(tracker, peers[1], now, {txid});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[1]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        tracker.ReceivedResponse(peers[1], txid);\n+    }\n+    CheckRequestable(tracker, peers[0], now, {}); // Only if peer 1 also goes offline, or the request times out, does peer 2 get it.\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {txid});\n+}\n+\n+void TestOrderDependsOnPeers(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid1 = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto txid2 = GenTxid(tracker, {peers[2], peers[1]}); // A txid such that peer 2 is prioritized over peer 1\n+    auto now = RandomTime();\n+\n+    for (auto peer : peers) {\n+        tracker.ReceivedInv(peer, txid1, ReqTime(now, delay)); // Announce both txids for all peers\n+        tracker.ReceivedInv(peer, txid2, ReqTime(now, delay));\n+    }\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Both are requestable\n+    tracker.DeletedPeer(peers[0]); // Peer 0 goes offline\n+    CheckRequestable(tracker, peers[1], now, {txid1}); // txid1 is now requestable from peer 1\n+    CheckRequestable(tracker, peers[2], now, {txid2}); // While txid2 is now requestable from peer 2\n+}\n+\n+void TestRequestableOrder(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid1 = GenTxid(tracker, {});\n+    auto txid2 = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid1, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[0], txid2, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[1], txid2, ReqTime(now, delay));\n+    now -= std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid1, ReqTime(now, delay));\n+    if (delay) now += TEST_DELAY;\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Check that for each peer, requests go out in announcement order,\n+    tracker.DeletedPeer(peers[0]);\n+    CheckRequestable(tracker, peers[1], now, {txid2, txid1}); // even when the clock went backwards during announcements.\n+}\n+\n+void TestAll()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r459157066",
      "id" : 459157066,
      "line" : 215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NzA2Ng==",
      "original_commit_id" : "75fd5dcba5441b0710aa348baa014f41df3e8458",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 215,
      "pull_request_review_id" : 453744760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-07-23T00:33:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459157066",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ariard Thanks for the thorough review. I'll go over your comments soon, but know there are a few imminent changes first (namely the suggestion https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-652185602, and adding support for wtxid relay tracking from #18044). If you want to help working on the tests, it's probably best to wait until those are complete.",
      "created_at" : "2020-07-23T00:39:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-662766191",
      "id" : 662766191,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2Mjc2NjE5MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-23T00:39:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/662766191",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, on first read-through the changes look good, will review when this comes out of draft status.",
      "created_at" : "2020-07-30T05:19:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-666121050",
      "id" : 666121050,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjEyMTA1MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T05:19:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666121050",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "concept ACK",
      "created_at" : "2020-08-20T19:14:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-677849573",
      "id" : 677849573,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3Nzg0OTU3Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-20T19:14:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/677849573",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491907032"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491907032"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The \"first\" concept works differently now. Have a look at https://github.com/bitcoin/bitcoin/pull/19988 to see if your comment still applies.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:34:47Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491907032",
      "id" : 491907032,
      "in_reply_to_id" : 459133311,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwNzAzMg==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 29,
      "pull_request_review_id" : 492423249,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:34:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491907032",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491908086"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491908086"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See #19988. The \"delayed\"/\"nondelayed\" distinction doesn't exist anymore. There is an explicit separate boolean to `ReceivedInv` now for preferred/nonpreferred, and a way to specify reqtime explicitly. (in particular, because txid peers get a delay, even though they're not preferred like outbounds are - so these concepts needed to be split).",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:36:46Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491908086",
      "id" : 491908086,
      "in_reply_to_id" : 459133991,
      "line" : 51,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwODA4Ng==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 51,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 51,
      "pull_request_review_id" : 492424685,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:36:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491908086",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491909245"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491909245"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It is just clarifying when a transaction is forgotten about, which can happen when either no candidates for a tx remain, or when the transaction is successfully received. Only the first of those two matters to re-requesting, but it's still important to specify that transactions are forgotten about when they're successfully received. See if it's clearer now.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:38:49Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491909245",
      "id" : 491909245,
      "in_reply_to_id" : 459134558,
      "line" : 55,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwOTI0NQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 55,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 55,
      "pull_request_review_id" : 492426194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:38:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491909245",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491911161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491911161"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, the description here is about the specification, where the distinction between the various CANDIDATE classes doesn't exist; that's an implementation detail.\r\n\r\nThere are many caveats to having in-flight limits... I couldn't come up with a way to do it basically, and then realized it's not desirable either (if a peer is overloaded, but still the only one to announce a tx, we still want to fetch it!). There are many ways by which overfull peers could be deprioritized safely though without introducing a hard cap.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:41:57Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491911161",
      "id" : 491911161,
      "in_reply_to_id" : 459139468,
      "line" : 79,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkxMTE2MQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 79,
      "original_position" : 79,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 79,
      "pull_request_review_id" : 492428565,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:41:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491911161",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491911913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491911913"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It was made configurable to simplify testing.\r\n\r\nIn the new PR the setting is gone, and `RequestedTx` now takes an explicit `exptime` parameter instead.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:43:17Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491911913",
      "id" : 491911913,
      "in_reply_to_id" : 459140164,
      "line" : 103,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkxMTkxMw==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 103,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 103,
      "pull_request_review_id" : 492430014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:43:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491911913",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491916346"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491916346"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's not that simple, unfortunately.\r\n\r\n`GetRequestable` moves time (making things best/ready if they pass reqtime, making them completed if they pass exptime) for _all_ entries - not just those of the peer `GetRequestable` was called for. This is necessary, as otherwise you can't fairly decide what to give to which peer (the peer you're calling for may have an announcement that just became ready, but another peer may also have an announcement for the same tx with a lower priority). So it's conceptually true what you say, but only if you think of a full cycle of GetRequestable/RequestedTx for all peers.\r\n\r\nI *really* want to avoid having TxRequestTracker depend on being able to call `AlreadyHave` - it would make it much less modularized and harder to test the data structure itself.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:48:02Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491916346",
      "id" : 491916346,
      "in_reply_to_id" : 459142436,
      "line" : 114,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkxNjM0Ng==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 114,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 114,
      "pull_request_review_id" : 492434209,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:48:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491916346",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491916756"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491916756"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's it, exactly.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:48:28Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491916756",
      "id" : 491916756,
      "in_reply_to_id" : 459143538,
      "line" : 142,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkxNjc1Ng==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 142,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 142,
      "pull_request_review_id" : 492434523,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:48:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491916756",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491918140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491918140"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Time jumping backwards can happen for completely innocuous reasons, like leap seconds. Only monotonic clocks are guaranteed not to do that.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:50:40Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491918140",
      "id" : 491918140,
      "in_reply_to_id" : 459152310,
      "line" : 121,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkxODE0MA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 121,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 121,
      "pull_request_review_id" : 492436217,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:50:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491918140",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491919691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491919691"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Maybe add as a comment \"If transaction has already been evaluated once for this block tip, delete unconditionally all its entries.\"\r\n\r\nI don't understand what reevaluation has to do with that. And `TxRequestTracker` doesn't know or care about the concept of blocks. It's just told that a transaction is no longer needed, so it can forget announcements about it. Why the caller decided that was the right thing to do is not its concern.\r\n\r\n> Is this a slight behavior change ?\r\n\r\nThe whole thing is a giant behavior change - it's changing out the semantics for something conceptually similar, but very different in the details.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:53:35Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+        // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_DELAYED);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_DELAYED, 0});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491919691",
      "id" : 491919691,
      "in_reply_to_id" : 459153327,
      "line" : 135,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkxOTY5MQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 135,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 135,
      "pull_request_review_id" : 492438291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:53:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491919691",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491920166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491920166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As explained elsewhere, no, BEST exists for much longer than that, and I'm 99% sure this can be hit.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:54:31Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+        // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_DELAYED);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_DELAYED, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);\n+        // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+        // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+        if (MakeCompleted(m_index.project<ByTxid>(it))) {\n+            // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+            Erase<ByPeer>(it);\n+        }\n+        it = it_next;\n+    }\n+}\n+\n+void TxRequestTracker::ReceivedInv(uint64_t peer, const uint256& txid, std::chrono::microseconds reqtime)\n+{\n+    // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+    // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+    // automatically.\n+    if (m_index.get<ByPeer>().count(EntryPeer{peer, true, txid})) return;\n+\n+    auto ret = m_index.get<ByPeer>().emplace(txid, peer, reqtime, m_sequence);\n+    if (ret.second) {\n+        auto it = m_index.project<ByTxid>(ret.first);\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+        if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != txid) &&\n+            (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != txid)) {\n+            // This is both the first and the last entry for a given txid; set its m_first.\n+            ret.first->m_first = true;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now)\n+{\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+    // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+    // which preserve the state of other txids).\n+    assert(it != m_index.get<ByPeer>().end());\n+    assert(it->GetState() == State::CANDIDATE_BEST);\n+    Modify<ByPeer>(it, [now,this](Entry& entry) {\n+        entry.SetState(State::REQUESTED);\n+        entry.m_time = now + m_timeout;\n+    });\n+}\n+\n+void TxRequestTracker::ReceivedResponse(uint64_t peer, const uint256& txid)\n+{\n+    // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491920166",
      "id" : 491920166,
      "in_reply_to_id" : 459154501,
      "line" : 197,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkyMDE2Ng==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 197,
      "original_position" : 197,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 197,
      "pull_request_review_id" : 492438919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:54:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491920166",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491921188"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491921188"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The unit tests are completely rewritten. There aren't any for the time-moving-backward though, I'll try to add that soon.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:56:17Z",
      "diff_hunk" : "@@ -0,0 +1,237 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds TEST_TIMEOUT = std::chrono::minutes{2};\n+constexpr std::chrono::microseconds TEST_DELAY = std::chrono::seconds{2};\n+\n+constexpr std::chrono::microseconds ReqTime(std::chrono::microseconds now, bool delay)\n+{\n+    return delay ? now + TEST_DELAY : std::chrono::microseconds::min();\n+}\n+\n+constexpr int TEST_ITERATIONS = 1000;\n+\n+uint256 GenTxid(const TxRequestTracker& tracker, const std::vector<uint64_t>& order)\n+{\n+    const auto& computer = tracker.GetPriorityComputer();\n+\n+    uint256 ret;\n+    bool ok;\n+    do {\n+        ret = InsecureRand256();\n+\n+        ok = true;\n+        for (size_t pos = 1; pos < order.size(); ++pos) {\n+            if (computer(ret, order[pos - 1], true, false) >= computer(ret, order[pos], true, false)) {\n+                ok = false;\n+                break;\n+            }\n+        }\n+    } while(!ok);\n+\n+    return ret;\n+}\n+\n+std::vector<uint64_t> GenPeers(size_t num)\n+{\n+    std::set<uint64_t> retset;\n+    while (retset.size() < num) {\n+        retset.insert(InsecureRandBits(63));\n+    }\n+\n+    std::vector<uint64_t> ret(retset.begin(), retset.end());\n+    Shuffle(ret.begin(), ret.end(), g_insecure_rand_ctx);\n+    return ret;\n+}\n+\n+std::chrono::microseconds RandomTime(int bits=44) { return std::chrono::microseconds{InsecureRandBits(bits)}; }\n+\n+void CheckRequestable(TxRequestTracker& tracker, uint64_t peer, std::chrono::microseconds now, const std::vector<uint256>& expected)\n+{\n+    BOOST_CHECK(tracker.GetRequestable(peer, now) == expected);\n+    tracker.SanityCheck();\n+    tracker.TimeSanityCheck(now);\n+}\n+\n+void TestBasicNonDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, false)); // Announce from non-delayed peer\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestBasicDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable immediately.\n+    now += TEST_DELAY - std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable after 1.999999s.\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Does become requestable after 2s.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestFirstAnnouncementWins(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately from peer 0.\n+    CheckRequestable(tracker, peers[1], now, {}); // And not from peer 1 (very first announcement always wins)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestNoDelayPreference()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer 0\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable\n+    now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable after enough time\n+    now += RandomTime(32);\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Remains requestable after arbitrary amounts of time\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, false)); // Then announced by non-delayed peer 1\n+    CheckRequestable(tracker, peers[1], now, {txid}); // Immediately becomes requestable from peer 1 (non-delayed)\n+    CheckRequestable(tracker, peers[0], now, {}); // And stops being requestable from peer 0 (can only be assigned to one peer)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestPriorityPreference(bool delay, int remove_reason)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[2], txid, ReqTime(now, delay)); // Slightly later, announce from peer 2\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Even later, announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // As peer 0 was the very first to announce, it gets the request first\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[0]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        tracker.ReceivedResponse(peers[0], txid);\n+    }\n+\n+    CheckRequestable(tracker, peers[0], now, {}); // If peer 0 goes offline, or the request times out, or a NOTFOUND is received, does peer 1 gets it (despite peer 2 being earlier)\n+    CheckRequestable(tracker, peers[1], now, {txid});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[1]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        tracker.ReceivedResponse(peers[1], txid);\n+    }\n+    CheckRequestable(tracker, peers[0], now, {}); // Only if peer 1 also goes offline, or the request times out, does peer 2 get it.\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {txid});\n+}\n+\n+void TestOrderDependsOnPeers(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid1 = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto txid2 = GenTxid(tracker, {peers[2], peers[1]}); // A txid such that peer 2 is prioritized over peer 1\n+    auto now = RandomTime();\n+\n+    for (auto peer : peers) {\n+        tracker.ReceivedInv(peer, txid1, ReqTime(now, delay)); // Announce both txids for all peers\n+        tracker.ReceivedInv(peer, txid2, ReqTime(now, delay));\n+    }\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Both are requestable\n+    tracker.DeletedPeer(peers[0]); // Peer 0 goes offline\n+    CheckRequestable(tracker, peers[1], now, {txid1}); // txid1 is now requestable from peer 1\n+    CheckRequestable(tracker, peers[2], now, {txid2}); // While txid2 is now requestable from peer 2\n+}\n+\n+void TestRequestableOrder(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid1 = GenTxid(tracker, {});\n+    auto txid2 = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid1, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[0], txid2, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[1], txid2, ReqTime(now, delay));\n+    now -= std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid1, ReqTime(now, delay));\n+    if (delay) now += TEST_DELAY;\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Check that for each peer, requests go out in announcement order,\n+    tracker.DeletedPeer(peers[0]);\n+    CheckRequestable(tracker, peers[1], now, {txid2, txid1}); // even when the clock went backwards during announcements.\n+}\n+\n+void TestAll()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491921188",
      "id" : 491921188,
      "in_reply_to_id" : 459157066,
      "line" : 215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkyMTE4OA==",
      "original_commit_id" : "75fd5dcba5441b0710aa348baa014f41df3e8458",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 215,
      "pull_request_review_id" : 492440185,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:56:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491921188",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491922251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491922251"
         }
      },
      "author_association" : "MEMBER",
      "body" : "GetRequestable could be parametrized with a limit for the number of returned responses, but that would just be to avoid having it return the same thing multiple times. I don't understand what you mean with \"avoid leftover marked as REQUESTED\" and \"wasting a `GETDATA_TX_INTERVAL`.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-21T09:58:12Z",
      "diff_hunk" : "@@ -4349,59 +4221,19 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const uint256 txid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const uint256& txid : g_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(MSG_TX | GetFetchFlags(*pto), txid);\n             if (!AlreadyHave(inv, m_mempool)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                const auto last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(inv.hash, current_time);\n-                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, current_time);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload);\n-                    tx_process_time.emplace(next_process_time, txid);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= MAX_GETDATA_SZ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r491922251",
      "id" : 491922251,
      "in_reply_to_id" : 459156379,
      "line" : 4239,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkyMjI1MQ==",
      "original_commit_id" : "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
      "original_line" : 4229,
      "original_position" : 304,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 330,
      "pull_request_review_id" : 492441531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-21T09:58:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491922251",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492413989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492413989"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you're confused. `MAX_GETDATA_SZ` doesn't stop processing; it only makes the request be split up into multiple GETDATA messages.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:12:27Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds timeout, bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492413989",
      "id" : 492413989,
      "in_reply_to_id" : 459151052,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxMzk4OQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 318,
      "pull_request_review_id" : 493061060,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:12:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492413989",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492417297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492417297"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, that's not necessary anymore. As `ReceivedInv` doesn't have a \"now\" argument anymore, the time of announcement clearly doesn't matter, simply by the API being agnostic of it. I'm adding a test that has a reqtime that decreases, though.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:26:19Z",
      "diff_hunk" : "@@ -0,0 +1,237 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds TEST_TIMEOUT = std::chrono::minutes{2};\n+constexpr std::chrono::microseconds TEST_DELAY = std::chrono::seconds{2};\n+\n+constexpr std::chrono::microseconds ReqTime(std::chrono::microseconds now, bool delay)\n+{\n+    return delay ? now + TEST_DELAY : std::chrono::microseconds::min();\n+}\n+\n+constexpr int TEST_ITERATIONS = 1000;\n+\n+uint256 GenTxid(const TxRequestTracker& tracker, const std::vector<uint64_t>& order)\n+{\n+    const auto& computer = tracker.GetPriorityComputer();\n+\n+    uint256 ret;\n+    bool ok;\n+    do {\n+        ret = InsecureRand256();\n+\n+        ok = true;\n+        for (size_t pos = 1; pos < order.size(); ++pos) {\n+            if (computer(ret, order[pos - 1], true, false) >= computer(ret, order[pos], true, false)) {\n+                ok = false;\n+                break;\n+            }\n+        }\n+    } while(!ok);\n+\n+    return ret;\n+}\n+\n+std::vector<uint64_t> GenPeers(size_t num)\n+{\n+    std::set<uint64_t> retset;\n+    while (retset.size() < num) {\n+        retset.insert(InsecureRandBits(63));\n+    }\n+\n+    std::vector<uint64_t> ret(retset.begin(), retset.end());\n+    Shuffle(ret.begin(), ret.end(), g_insecure_rand_ctx);\n+    return ret;\n+}\n+\n+std::chrono::microseconds RandomTime(int bits=44) { return std::chrono::microseconds{InsecureRandBits(bits)}; }\n+\n+void CheckRequestable(TxRequestTracker& tracker, uint64_t peer, std::chrono::microseconds now, const std::vector<uint256>& expected)\n+{\n+    BOOST_CHECK(tracker.GetRequestable(peer, now) == expected);\n+    tracker.SanityCheck();\n+    tracker.TimeSanityCheck(now);\n+}\n+\n+void TestBasicNonDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, false)); // Announce from non-delayed peer\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestBasicDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable immediately.\n+    now += TEST_DELAY - std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable after 1.999999s.\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Does become requestable after 2s.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestFirstAnnouncementWins(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately from peer 0.\n+    CheckRequestable(tracker, peers[1], now, {}); // And not from peer 1 (very first announcement always wins)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestNoDelayPreference()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer 0\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable\n+    now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable after enough time\n+    now += RandomTime(32);\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Remains requestable after arbitrary amounts of time\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, false)); // Then announced by non-delayed peer 1\n+    CheckRequestable(tracker, peers[1], now, {txid}); // Immediately becomes requestable from peer 1 (non-delayed)\n+    CheckRequestable(tracker, peers[0], now, {}); // And stops being requestable from peer 0 (can only be assigned to one peer)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestPriorityPreference(bool delay, int remove_reason)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[2], txid, ReqTime(now, delay)); // Slightly later, announce from peer 2\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Even later, announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // As peer 0 was the very first to announce, it gets the request first\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[0]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        tracker.ReceivedResponse(peers[0], txid);\n+    }\n+\n+    CheckRequestable(tracker, peers[0], now, {}); // If peer 0 goes offline, or the request times out, or a NOTFOUND is received, does peer 1 gets it (despite peer 2 being earlier)\n+    CheckRequestable(tracker, peers[1], now, {txid});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[1]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        tracker.ReceivedResponse(peers[1], txid);\n+    }\n+    CheckRequestable(tracker, peers[0], now, {}); // Only if peer 1 also goes offline, or the request times out, does peer 2 get it.\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {txid});\n+}\n+\n+void TestOrderDependsOnPeers(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid1 = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto txid2 = GenTxid(tracker, {peers[2], peers[1]}); // A txid such that peer 2 is prioritized over peer 1\n+    auto now = RandomTime();\n+\n+    for (auto peer : peers) {\n+        tracker.ReceivedInv(peer, txid1, ReqTime(now, delay)); // Announce both txids for all peers\n+        tracker.ReceivedInv(peer, txid2, ReqTime(now, delay));\n+    }\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Both are requestable\n+    tracker.DeletedPeer(peers[0]); // Peer 0 goes offline\n+    CheckRequestable(tracker, peers[1], now, {txid1}); // txid1 is now requestable from peer 1\n+    CheckRequestable(tracker, peers[2], now, {txid2}); // While txid2 is now requestable from peer 2\n+}\n+\n+void TestRequestableOrder(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid1 = GenTxid(tracker, {});\n+    auto txid2 = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid1, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[0], txid2, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[1], txid2, ReqTime(now, delay));\n+    now -= std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid1, ReqTime(now, delay));\n+    if (delay) now += TEST_DELAY;\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Check that for each peer, requests go out in announcement order,\n+    tracker.DeletedPeer(peers[0]);\n+    CheckRequestable(tracker, peers[1], now, {txid2, txid1}); // even when the clock went backwards during announcements.\n+}\n+\n+void TestAll()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492417297",
      "id" : 492417297,
      "in_reply_to_id" : 459157066,
      "line" : 215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzI5Nw==",
      "original_commit_id" : "75fd5dcba5441b0710aa348baa014f41df3e8458",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 215,
      "pull_request_review_id" : 493064584,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:26:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492417297",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422381"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422381"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I added a lot of comments explaining the rationale and some analysis to txrequest.h in #19989 \r\n\r\n> \"Transaction downloads never guarantee to succeed, namely receiving transaction if you hear about its identifier. Success should be define as a best-effort, guaranteeing we advance towards entry removal for any peer who announced a txid\"\r\n\r\nI have difficulty parsing what you're trying to say here, but I've added some related comments. Please have a look to see if it's better addressed now.\r\n\r\n> \"To optimize bandwidth-saving, we limit parallel-fetching and favor sequential fetching (there MUST be only one REQUESTED entry at anytime for any given txid)\"\r\n\r\nGood idea, done.\r\n\r\n> \"We don't guarantee fetching again a transaction for which validity/standardness may have change between re-announcements, until next block announcement (a AlreadyHave() triggers all txid entries removal)\"\r\n\r\nI don't understand this. New block announcements don't affect TxRequestTracker (except for transactions that are in the block, and we don't need anymore).\r\n\r\n> \"Assuming a fast-inbound attacker-controlled peer and low outbound not-controlled ones, a transaction propagation can be delayed at most for one GETDATA_TX_INTERVAL period\"\r\n\r\nI added a much more accurate formula.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:48:05Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422381",
      "id" : 492422381,
      "in_reply_to_id" : 459138430,
      "line" : 57,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjM4MQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 57,
      "pull_request_review_id" : 493070036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:48:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422381",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed to `ForgetTx`.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:48:24Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422470",
      "id" : 492422470,
      "in_reply_to_id" : 459139843,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjQ3MA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 81,
      "pull_request_review_id" : 493070133,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:48:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422470",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422609"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a comment explaining memory usage bounds.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:48:58Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422609",
      "id" : 492422609,
      "in_reply_to_id" : 459143938,
      "line" : 248,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjYwOQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 248,
      "original_position" : 248,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 248,
      "pull_request_review_id" : 493070277,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:48:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422609",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422651"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:49:07Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422651",
      "id" : 492422651,
      "in_reply_to_id" : 459144236,
      "line" : 291,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjY1MQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 291,
      "original_position" : 291,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 291,
      "pull_request_review_id" : 493070307,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:49:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422651",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422741"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:49:23Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422741",
      "id" : 492422741,
      "in_reply_to_id" : 459151500,
      "line" : 99,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjc0MQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 99,
      "original_position" : 99,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 99,
      "pull_request_review_id" : 493070379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422741",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422931"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422931"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done. Added `IsOnlyNonCompleted`.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:50:13Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492422931",
      "id" : 492422931,
      "in_reply_to_id" : 459155219,
      "line" : 87,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMjkzMQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 87,
      "pull_request_review_id" : 493070586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:50:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492422931",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492423311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492423311"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think that's necessary - we just have to call `ForgetTx` whenever a transaction *becomes* alreadyhave, and prevent adding announcements for alreadyhave ones. If that's done correctly, an addition `ForgetTx` here would always be a no-op.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-22T00:51:33Z",
      "diff_hunk" : "@@ -2599,7 +2482,7 @@ void ProcessMessage(\n                     pfrom.fDisconnect = true;\n                     return;\n                 } else if (!fAlreadyHave && !chainman.ActiveChainstate().IsInitialBlockDownload()) {\n-                    RequestTx(State(pfrom.GetId()), inv.hash, current_time);\n+                    RequestTx(pfrom, inv.hash, current_time);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r492423311",
      "id" : 492423311,
      "in_reply_to_id" : 459155891,
      "line" : 2491,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMzMxMQ==",
      "original_commit_id" : "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
      "original_line" : 2485,
      "original_position" : 199,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 212,
      "pull_request_review_id" : 493070925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T00:51:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492423311",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497850722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497850722"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> I have difficulty parsing what you're trying to say here, but I've added some related comments. Please have a look to see if it's better addressed now.\r\n\r\nIIRC I meaned the following. \"Learning about a transaction identifier doesn't guarantee the node will successfully receive the transaction, no more take special steps to ensure it as sending non-solicited GETDATAs. An entry is guarantee to never stuck, assuming the local clock is moving forward\"\r\n\r\nThe first point is a minor. The second underscores an important property of new TxRequestTracker design, its state machine always progress towards a terminal state and should never halt. Though it's so obvious it's worthy to comment.\r\n\r\n> I don't understand this. New block announcements don't affect TxRequestTracker (except for transactions that are in the block, and we don't need anymore).\r\n\r\nIIRC I meaned the following scenario:\r\n* a peer announces and sends Tx 1, it is rejected due to its unconfirmed parent being invalid\r\n* all other pending requests for Tx 1 are deleted (ForgetTxHash)\r\n* the unconfirmed parent is re-announced, sent and accepted under a different wtxid\r\n* a peer announces Tx 1, the TxRequestTracker will never learn about it due to AlreadyHave()==true\r\n* a block is received, the rejection filter is received\r\n* a peer announces Tx 1, the TxRequestTracker learns and requests it\r\n\r\nThat said, not reevaluating validity of child transactions when the parent one has changed is already an existing issue. Maybe RequestTx comment could be updated to underscore that a received INV isn't unconditionally process by TxRequestTracker but depends of existing transaction relay state.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-30T23:12:03Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497850722",
      "id" : 497850722,
      "in_reply_to_id" : 459138430,
      "line" : 57,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg1MDcyMg==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 57,
      "pull_request_review_id" : 499873185,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-30T23:12:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497850722",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497856275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497856275"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're right on `MAX_GETDATA_SZ`.\r\n\r\nStill, do you think that a third-party can delay transaction announcement between Alice and Bob by forcing her to send him orphans until reaching MAX_PEER_TX_ANNOUNCEMENTS ?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-30T23:30:14Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds timeout, bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497856275",
      "id" : 497856275,
      "in_reply_to_id" : 459151052,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg1NjI3NQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 318,
      "pull_request_review_id" : 499880435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-30T23:30:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497856275",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497857164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497857164"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Why the caller decided that was the right thing to do is not its concern.\r\n\r\nRight, I understand comments should be concerned with other transaction relay mechanisms.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-30T23:33:18Z",
      "diff_hunk" : "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+        // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_DELAYED);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_DELAYED, 0});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497857164",
      "id" : 497857164,
      "in_reply_to_id" : 459153327,
      "line" : 135,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg1NzE2NA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 135,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 135,
      "pull_request_review_id" : 499881440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-30T23:33:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497857164",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497857473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497857473"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This comment was wrong and part of my misunderstanding you pointed above.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-30T23:34:25Z",
      "diff_hunk" : "@@ -4349,59 +4221,19 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const uint256 txid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const uint256& txid : g_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(MSG_TX | GetFetchFlags(*pto), txid);\n             if (!AlreadyHave(inv, m_mempool)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                const auto last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(inv.hash, current_time);\n-                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, current_time);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload);\n-                    tx_process_time.emplace(next_process_time, txid);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= MAX_GETDATA_SZ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497857473",
      "id" : 497857473,
      "in_reply_to_id" : 459156379,
      "line" : 4239,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg1NzQ3Mw==",
      "original_commit_id" : "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
      "original_line" : 4229,
      "original_position" : 304,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 330,
      "pull_request_review_id" : 499881814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-30T23:34:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497857473",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497858564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497858564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Learning about a transaction identifier doesn't guarantee the node will successfully receive the transaction, no more take special steps to ensure it as sending non-solicited GETDATAs.\r\n\r\nI still don't understand what you're trying to say.\r\n\r\n> The second underscores an important property of new TxRequestTracker design, its state machine always progress towards a terminal state and should never halt.\r\n\r\nI just today realized that there is some nuance here. As long as you have at least one non-attacker peer that announces a transaction, I believe it is probabilistically true (over time the probability of not reaching a final state, where the transaction is forgotten about, tends to 0), but not more than that. An attacker can disconnect and reconnect, and with (arbitrary) amounts of luck, an attacker can be chosen every time, making the transaction stay arbitrarily long.\r\n\r\nI'm not sure it's worth going that deep in comments.\r\n\r\n> That said, not reevaluating validity of child transactions when the parent one has changed is already an existing issue. Maybe RequestTx comment could be updated to underscore that a received INV isn't unconditionally process by TxRequestTracker but depends of existing transaction relay state.\r\n\r\nI don't think this has anything to do with TxRequestTracker - it just does as it's told, and the current code in net_processing, will not immediately retry for entries in recentRejects. We can document this, but it's a far more high level thing, not specifying the behavior of the TxRequestTracker. Maybe more something for the wiki?",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-09-30T23:38:29Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497858564",
      "id" : 497858564,
      "in_reply_to_id" : 459138430,
      "line" : 57,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg1ODU2NA==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 57,
      "original_position" : 57,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 57,
      "pull_request_review_id" : 499883119,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-30T23:38:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497858564",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497948559"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497948559"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I need to think about this more.",
      "commit_id" : "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "created_at" : "2020-10-01T02:21:31Z",
      "diff_hunk" : "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds timeout, bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r497948559",
      "id" : 497948559,
      "in_reply_to_id" : 459151052,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0ODU1OQ==",
      "original_commit_id" : "259bf92d4abbc8c2923754106ef965e959cfd053",
      "original_line" : 318,
      "original_position" : 318,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 318,
      "pull_request_review_id" : 499969079,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-01T02:21:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497948559",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
