[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r102890169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102890169"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`le` is the same name as the first argument here, it will bring shadow warning.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-02-24T07:19:20Z",
      "diff_hunk" : "@@ -0,0 +1,788 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (!isLogRowContinuation(row)) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r102890169",
      "id" : 102890169,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMjg5MDE2OQ==",
      "original_commit_id" : "563ec9e94744e0050ced5aff9d3db54c2fffb3ee",
      "original_position" : 552,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 23659997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102890169",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6848764?v=4",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "node_id" : "MDQ6VXNlcjY4NDg3NjQ=",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This is how it looks like here on testnet:\r\n\r\n<img width=\"1167\" alt=\"screen shot 2017-02-24 at 08 22 39\" src=\"https://cloud.githubusercontent.com/assets/6848764/23294190/86f5186e-fa6a-11e6-83bd-dfa5811b8b68.png\">\r\n",
      "created_at" : "2017-02-24T07:24:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-282222921",
      "id" : 282222921,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDI4MjIyMjkyMQ==",
      "updated_at" : "2017-02-24T07:24:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282222921",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/6848764?v=4",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "node_id" : "MDQ6VXNlcjY4NDg3NjQ=",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks. Will review.\r\nI just played a bit with it and had massive locking issues on mainnet during catch-up of 2-3 weeks.",
      "created_at" : "2017-02-24T07:30:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-282223846",
      "id" : 282223846,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDI4MjIyMzg0Ng==",
      "updated_at" : "2017-02-24T07:30:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/282223846",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Running this PR (built over gitian: https://bitcoin.jonasschnelli.ch/build/54) makes Bitcoin-Qt and also the rest of my apps almost unusable. Had to force kill the process.",
      "created_at" : "2017-03-17T15:26:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-287385325",
      "id" : 287385325,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDI4NzM4NTMyNQ==",
      "updated_at" : "2017-03-17T15:26:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/287385325",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106676794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106676794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO reading each block will cause a massive slow down during IBD / catchup.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T15:29:26Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106676794",
      "id" : 106676794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjY3Njc5NA==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 619,
      "path" : "src/qt/netwatch.cpp",
      "position" : 649,
      "pull_request_review_id" : 27613799,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106676794",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106677143"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106677143"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What we probably should do is adding each blocks size and vtx.size() to CBlockIndex* (would require to alter the block index, migration, etc. yes).",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T15:30:54Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106677143",
      "id" : 106677143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjY3NzE0Mw==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 623,
      "path" : "src/qt/netwatch.cpp",
      "position" : 653,
      "pull_request_review_id" : 27614161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106677143",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The OS should have the data cached already?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T22:49:33Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759495",
      "id" : 106759495,
      "in_reply_to_id" : 106676794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjc1OTQ5NQ==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 619,
      "path" : "src/qt/netwatch.cpp",
      "position" : 649,
      "pull_request_review_id" : 27703245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759594"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That wouldn't change anything here...?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2017-03-17T22:50:26Z",
      "diff_hunk" : "@@ -0,0 +1,798 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include \"netwatch.h\"\n+\n+#include \"bitcoinunits.h\"\n+#include \"clientmodel.h\"\n+#include \"guiconstants.h\"\n+#include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n+#include \"platformstyle.h\"\n+#include \"networkstyle.h\"\n+\n+#include \"base58.h\"\n+#include \"chain.h\"\n+#include \"chainparams.h\"\n+#include \"primitives/transaction.h\"\n+#include \"pubkey.h\"\n+#include \"script/standard.h\"\n+#include \"sync.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+#include \"validationinterface.h\"\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    GetMainSignals().UpdatedBlockTip.connect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.connect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    GetMainSignals().UpdatedBlockTip.disconnect(boost::bind(&NetWatchLogModel::LogBlock, this, _1));\n+    GetMainSignals().AcceptedTransaction.disconnect(boost::bind(&NetWatchLogModel::LogTransaction, this, _1));\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(CBitcoinAddress(txdest).ToString());\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r106759594",
      "id" : 106759594,
      "in_reply_to_id" : 106677143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjc1OTU5NA==",
      "original_commit_id" : "9019229f08a84bcf8623cb457ed8bee36314c6c8",
      "original_position" : 623,
      "path" : "src/qt/netwatch.cpp",
      "position" : 653,
      "pull_request_review_id" : 27703327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106759594",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I like having this, though we have to be sure that there is *no* performance impact when the monitor is not running, and as little as possible when it is.",
      "created_at" : "2018-03-06T22:54:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-370958712",
      "id" : 370958712,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM3MDk1ODcxMg==",
      "updated_at" : "2018-03-06T22:54:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/370958712",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The code is (already) disabled until the first time it is opened.",
      "created_at" : "2018-03-07T02:46:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-371004084",
      "id" : 371004084,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM3MTAwNDA4NA==",
      "updated_at" : "2018-03-07T02:46:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/371004084",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-10-30T17:18:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434392012",
      "id" : 434392012,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDM5MjAxMg==",
      "updated_at" : "2018-10-30T17:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434392012",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-10-30T18:04:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434408869",
      "id" : 434408869,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDQwODg2OQ==",
      "updated_at" : "2018-10-30T18:04:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434408869",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Oops, had rebased onto 0.17 instead of master. Rebased for real this time.",
      "created_at" : "2018-10-30T20:13:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434452220",
      "id" : 434452220,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDQ1MjIyMA==",
      "updated_at" : "2018-10-30T20:13:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434452220",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229475953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229475953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Might want to use the new connect syntax in this file?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T20:35:55Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    validation_interface(new NetWatchValidationInterface(*this)),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());\n+    const size_t vout_count = CountNonDatacarrierOutputs(block.vtx[0]);\n+    LogAddEntry(LogEntry(GetTime(), *pblockindex), vout_count);\n+}\n+\n+void NetWatchLogModel::LogTransaction(const CTransactionRef& tx)\n+{\n+    const size_t vout_count = CountNonDatacarrierOutputs(tx);\n+    LogAddEntry(LogEntry(GetTime(), tx), vout_count);\n+}\n+\n+void NetWatchLogModel::setClientModel(ClientModel *model)\n+{\n+    if (clientModel) {\n+        disconnect(clientModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n+    }\n+    clientModel = model;\n+    if (model) {\n+        connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229475953",
      "id" : 229475953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTQ3NTk1Mw==",
      "original_commit_id" : "ae96c0d67879d1ede4e44fbacdd787800376fd87",
      "original_position" : 681,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 169987255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229475953",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229509157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229509157"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Let me know if I got it right...",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T22:28:11Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    clientModel(NULL),\n+    validation_interface(new NetWatchValidationInterface(*this)),\n+    logpos(0),\n+    logskip(0),\n+    currentSearch(NULL)\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {\n+        delete currentSearch;\n+    }\n+    currentSearch = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->fCheckAddr || newsearch->fCheckValue) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete currentSearch;\n+    currentSearch = NULL;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!logpos);\n+        log.push_back(le);\n+    }\n+    ++rows_used;\n+    if (rows_used > max_nonweak_txouts) {\n+        LogEntry& old_le = getLogEntryRow(rows_used - max_nonweak_txouts - 1);\n+        if (old_le) {\n+            old_le.makeWeak();\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogAddEntry(const LogEntry& le, size_t vout_count)\n+{\n+    if (vout_count < 1) {\n+        vout_count = 1;\n+    }\n+    const QModelIndex dummy;\n+    LOCK(cs);\n+    size_t rows_to_remove = 0;\n+    if (vout_count >= max_vout_per_tx) {\n+        vout_count = max_vout_per_tx;\n+    }\n+    size_t rows_used = rowCount();\n+    if (rows_used > logsizelimit - vout_count) {\n+        rows_to_remove = (rows_used + vout_count) - logsizelimit;\n+    }\n+    if (rows_to_remove) {\n+        // Don't orphan continuation entries\n+        while (isLogRowContinuation(rows_to_remove)) {\n+            ++rows_to_remove;\n+        }\n+\n+        beginRemoveRows(dummy, 0, rows_to_remove - 1);\n+        logpos = (logpos + rows_to_remove) % log.size();\n+        logskip += rows_to_remove;\n+        endRemoveRows();\n+\n+        rows_used = rowCount();\n+    }\n+\n+    const LogEntry cont_le;\n+    const int first_new_row = rows_used, last_new_row = rows_used + vout_count - 1;\n+    beginInsertRows(dummy, first_new_row, last_new_row);\n+    log_append(le, rows_used);\n+    for (size_t i = 1; i < vout_count; ++i) {\n+        log_append(cont_le, rows_used);\n+    }\n+    endInsertRows();\n+\n+    if (currentSearch) {\n+        QList<int> new_matches;\n+        if (currentSearch->fCheckAddr || currentSearch->fCheckValue) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                if (currentSearch->match(*this, row)) {\n+                    new_matches.append(row);\n+                }\n+            }\n+        } else if (currentSearch->match(*this, first_new_row)) {\n+            for (int row = first_new_row; row <= last_new_row; ++row) {\n+                new_matches.append(row);\n+            }\n+        }\n+        if (!new_matches.isEmpty()) {\n+            Q_EMIT moreSearchResults(new_matches);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::LogBlock(const CBlockIndex* pblockindex)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus())) {\n+        // Indicate error somehow?\n+        return;\n+    }\n+    assert(block.vtx.size());\n+    const size_t vout_count = CountNonDatacarrierOutputs(block.vtx[0]);\n+    LogAddEntry(LogEntry(GetTime(), *pblockindex), vout_count);\n+}\n+\n+void NetWatchLogModel::LogTransaction(const CTransactionRef& tx)\n+{\n+    const size_t vout_count = CountNonDatacarrierOutputs(tx);\n+    LogAddEntry(LogEntry(GetTime(), tx), vout_count);\n+}\n+\n+void NetWatchLogModel::setClientModel(ClientModel *model)\n+{\n+    if (clientModel) {\n+        disconnect(clientModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n+    }\n+    clientModel = model;\n+    if (model) {\n+        connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229509157",
      "id" : 229509157,
      "in_reply_to_id" : 229475953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUwOTE1Nw==",
      "original_commit_id" : "ae96c0d67879d1ede4e44fbacdd787800376fd87",
      "original_position" : 681,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170028006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229509157",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229521971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229521971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could rebase with #14123 to replace these calls with `GUIUtil::bringToFront`.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:27:49Z",
      "diff_hunk" : "@@ -661,6 +676,18 @@ void BitcoinGUI::aboutClicked()\n     dlg.exec();\n }\n \n+void BitcoinGUI::showNetWatch()\n+{\n+    if (!NetWatch) {\n+        NetWatch = new GuiNetWatch(platformStyle, netStyle);\n+        NetWatch->setClientModel(clientModel);\n+    }\n+    NetWatch->showNormal();\n+    NetWatch->show();\n+    NetWatch->raise();\n+    NetWatch->activateWindow();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229521971",
      "id" : 229521971,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMTk3MQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 86,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229521971",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522523"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:30:50Z",
      "diff_hunk" : "@@ -73,7 +74,8 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     m_node(node),\n-    platformStyle(_platformStyle)\n+    platformStyle(_platformStyle),\n+    netStyle(networkStyle)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522523",
      "id" : 229522523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjUyMw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 14,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522523",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522740"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit 2018.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:31:55Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522740",
      "id" : 229522740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjc0MA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 1,
      "path" : "src/qt/netwatch.h",
      "position" : 1,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522740",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, sort.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:32:18Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class PlatformStyle;\n+class NetworkStyle;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522794",
      "id" : 229522794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjc5NA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 26,
      "path" : "src/qt/netwatch.h",
      "position" : 25,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522794",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522918"
         }
      },
      "author_association" : "MEMBER",
      "body" : "move to .cpp? nit, follow code convention.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:33:01Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class PlatformStyle;\n+class NetworkStyle;\n+\n+static const int nLongestAddress = 35;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229522918",
      "id" : 229522918,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMjkxOA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 28,
      "path" : "src/qt/netwatch.h",
      "position" : 28,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229522918",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229523638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229523638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI in #14573 I'm proposing a Window menu.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:37:07Z",
      "diff_hunk" : "@@ -397,6 +404,7 @@ void BitcoinGUI::createMenuBar()\n     settings->addAction(optionsAction);\n \n     QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n+    help->addAction(NetWatchAction);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229523638",
      "id" : 229523638,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyMzYzOA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 48,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229523638",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525155"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `m_show_netwatch_action`.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:45:51Z",
      "diff_hunk" : "@@ -127,6 +128,7 @@ class BitcoinGUI : public QMainWindow\n     QAction* backupWalletAction = nullptr;\n     QAction* changePassphraseAction = nullptr;\n     QAction* aboutQtAction = nullptr;\n+    QAction* NetWatchAction = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525155",
      "id" : 229525155,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTE1NQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 12,
      "path" : "src/qt/bitcoingui.h",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525155",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525358"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525358"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `} // namespace`",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:46:58Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525358",
      "id" : 229525358,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTM1OA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 76,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525358",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525551"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, s/LET/log_entry_type.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:48:00Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525551",
      "id" : 229525551,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTU1MQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 78,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525551",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "const?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:48:25Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525623",
      "id" : 229525623,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTYyMw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 52,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525623",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525695"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, one line `if (...) continue`;",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:48:56Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525695",
      "id" : 229525695,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTY5NQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 53,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525695",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525742"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525742"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same as above.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:49:20Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525742",
      "id" : 229525742,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTc0Mg==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 65,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525742",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same as above.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:49:58Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525862",
      "id" : 229525862,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTg2Mg==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 68,
      "path" : "src/qt/netwatch.cpp",
      "position" : 64,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525862",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525879"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`nullptr`.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:50:05Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525879",
      "id" : 229525879,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTg3OQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 73,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525879",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525965"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, 2018",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-30T23:50:38Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229525965",
      "id" : 229525965,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNTk2NQ==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 1,
      "path" : "src/qt/netwatch.cpp",
      "position" : 1,
      "pull_request_review_id" : 170042728,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229525965",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229527763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229527763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should use/extend `interfaces::Node` instead?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T00:00:40Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return NULL;\n+}\n+\n+}\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType LET)\n+{\n+    switch (LET) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = NULL;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229527763",
      "id" : 229527763,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyNzc2Mw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 265,
      "path" : "src/qt/netwatch.cpp",
      "position" : 261,
      "pull_request_review_id" : 170049486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229527763",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529387"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529387"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's needed...",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T00:11:14Z",
      "diff_hunk" : "@@ -73,7 +74,8 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     m_node(node),\n-    platformStyle(_platformStyle)\n+    platformStyle(_platformStyle),\n+    netStyle(networkStyle)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529387",
      "id" : 229529387,
      "in_reply_to_id" : 229522523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyOTM4Nw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 14,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170051449,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529387",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529437"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2018 is wrong. This code hasn't been substantially changed since 2017.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T00:11:31Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229529437",
      "id" : 229529437,
      "in_reply_to_id" : 229522740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTUyOTQzNw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 1,
      "path" : "src/qt/netwatch.h",
      "position" : 1,
      "pull_request_review_id" : 170051515,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229529437",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229555020"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229555020"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO this one is clearer split out.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T03:38:51Z",
      "diff_hunk" : "@@ -0,0 +1,838 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) {\n+            continue;\n+        }\n+        if (count == txout_index) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229555020",
      "id" : 229555020,
      "in_reply_to_id" : 229525862,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTU1NTAyMA==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 68,
      "path" : "src/qt/netwatch.cpp",
      "position" : 64,
      "pull_request_review_id" : 170082703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229555020",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#13674](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13674.html) (Qt: Fix for bitcoin-qt becoming unresponsive during shutdown (issue #13217) by LeandroRocha84)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-10-31T03:44:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-434550974",
      "id" : 434550974,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNDU1MDk3NA==",
      "updated_at" : "2019-05-08T18:32:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/434550974",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229659095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229659095"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use `nullptr` instead of `NULL`. Applies throughout this PR :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T11:39:27Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() : data(NULL) { }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229659095",
      "id" : 229659095,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTY1OTA5NQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 80,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170207391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229659095",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229693133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229693133"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry, forgot to delete this comment while reviewing..",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T13:32:19Z",
      "diff_hunk" : "@@ -73,7 +74,8 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     m_node(node),\n-    platformStyle(_platformStyle)\n+    platformStyle(_platformStyle),\n+    netStyle(networkStyle)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229693133",
      "id" : 229693133,
      "in_reply_to_id" : 229522523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTY5MzEzMw==",
      "original_commit_id" : "e8ca94c4dc67529e3bb2666c07ed10347a13ff1f",
      "original_position" : 14,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 170251037,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229693133",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229707702"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229707702"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Sort includes :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:07:34Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229707702",
      "id" : 229707702,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcwNzcwMg==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 17,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170269519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229707702",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229708001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229708001"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Make parameter names match between declaration and definition.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:08:17Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() : data(NULL) { }\n+    explicit LogEntry(int32_t relTimestamp, const CBlockIndex&);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionWeakref&, bool weak = true);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionRef&, bool weak = false);\n+    ~LogEntry();\n+\n+    LogEntry& operator=(const LogEntry& other);\n+\n+    explicit operator bool() const;\n+    int32_t getRelTimestamp() const;\n+    uint64_t getTimestamp(uint64_t now) const;\n+    LogEntryType getType() const;\n+\n+    template <typename T> T* get() const {\n+        void *p = data + sizeof(meta_t);\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        return (T*)p;\n+    }\n+\n+    const CBlockIndex& getBlockIndex() const;\n+    CTransactionRef getTransactionRef() const;\n+    bool isWeak() const;\n+    bool expired() const;\n+    void makeWeak();\n+};\n+\n+class NetWatchLogModel;\n+\n+class NetWatchLogSearch {\n+public:\n+    QString query;\n+\n+    bool fCheckType;\n+    bool fCheckId;\n+    bool fCheckAddr;\n+    bool fCheckValue;\n+\n+    NetWatchLogSearch(const QString& query, int displayunit);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229708001",
      "id" : 229708001,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcwODAwMQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 119,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170269875,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229708001",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229709154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229709154"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be `explicit`? :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:10:53Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229709154",
      "id" : 229709154,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcwOTE1NA==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 266,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170271290,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229709154",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229710344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229710344"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: `!block.vtx.empty()` communicates intention more clearly than `block.vtx.size()`?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:13:36Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229710344",
      "id" : 229710344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMDM0NA==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 343,
      "path" : "src/qt/netwatch.cpp",
      "position" : 343,
      "pull_request_review_id" : 170272787,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229710344",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229711281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229711281"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This `if` statement is unnecessary. Deleting a null pointer is a noop.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:16:00Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (clientModel) {\n+                return BitcoinUnits::format(clientModel->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (logpos + row) % log.size();\n+    return log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (clientModel) {\n+                return BitcoinUnits::getAmountColumnTitle(clientModel->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& _query, int displayunit) :\n+    query(_query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    fCheckType = query.length() < 4 && reType.exactMatch(query);\n+    fCheckId = query.length() <= 64 && reHex.exactMatch(query);\n+    fCheckAddr = query.length() <= nLongestAddress;\n+    CAmount val;\n+    fCheckValue = BitcoinUnits::parse(displayunit, query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(query)) {\n+        return true;\n+    } else if (fCheckType && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckId && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckAddr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (fCheckValue && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = clientModel->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    if (currentSearch) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229711281",
      "id" : 229711281,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMTI4MQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 546,
      "path" : "src/qt/netwatch.cpp",
      "position" : null,
      "pull_request_review_id" : 170274029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229711281",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712203"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be made `explicit`?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:18:09Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {\n+        auto pn = reinterpret_cast<std::uintptr_t>(ptr);\n+        auto aligned = (pn + alignment - 1) & -alignment;\n+        auto new_space = space - (aligned - pn);\n+        if (new_space < size) {\n+            return nullptr;\n+        }\n+        space = new_space;\n+        return ptr = reinterpret_cast<void *>(aligned);\n+    }\n+\n+    void init(const LogEntry&);\n+    void init(int32_t relTimestamp, const CBlockIndex&);\n+    void init(int32_t relTimestamp, const CTransactionWeakref&, bool weak);\n+    void clear();\n+\n+public:\n+    enum LogEntryType {\n+        LET_BLOCK,\n+        LET_TX,\n+    };\n+    static const QString LogEntryTypeAbbreviation(LogEntryType);\n+\n+    LogEntry(const LogEntry&);\n+    LogEntry() : data(NULL) { }\n+    explicit LogEntry(int32_t relTimestamp, const CBlockIndex&);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionWeakref&, bool weak = true);\n+    explicit LogEntry(int32_t relTimestamp, const CTransactionRef&, bool weak = false);\n+    ~LogEntry();\n+\n+    LogEntry& operator=(const LogEntry& other);\n+\n+    explicit operator bool() const;\n+    int32_t getRelTimestamp() const;\n+    uint64_t getTimestamp(uint64_t now) const;\n+    LogEntryType getType() const;\n+\n+    template <typename T> T* get() const {\n+        void *p = data + sizeof(meta_t);\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        return (T*)p;\n+    }\n+\n+    const CBlockIndex& getBlockIndex() const;\n+    CTransactionRef getTransactionRef() const;\n+    bool isWeak() const;\n+    bool expired() const;\n+    void makeWeak();\n+};\n+\n+class NetWatchLogModel;\n+\n+class NetWatchLogSearch {\n+public:\n+    QString query;\n+\n+    bool fCheckType;\n+    bool fCheckId;\n+    bool fCheckAddr;\n+    bool fCheckValue;\n+\n+    NetWatchLogSearch(const QString& query, int displayunit);\n+    bool match(const NetWatchLogModel& model, int row) const;\n+};\n+\n+class NetWatchValidationInterface;\n+\n+class NetWatchLogModel : public QAbstractTableModel\n+{\n+    Q_OBJECT\n+\n+private:\n+    QWidget * const widget;\n+    ClientModel *clientModel = nullptr;\n+\n+    NetWatchValidationInterface *validation_interface;\n+\n+    mutable CCriticalSection cs;\n+    std::vector<LogEntry> log;\n+    static const size_t logsizelimit = 0x400;\n+    size_t logpos = 0;\n+    size_t logskip = 0;\n+\n+    static const size_t max_nonweak_txouts = 0x200;\n+    static const size_t max_vout_per_tx = 0x100;\n+\n+    NetWatchLogSearch *currentSearch = nullptr;\n+\n+    const LogEntry& getLogEntryRow(int row) const;\n+    LogEntry& getLogEntryRow(int row);\n+    void log_append(const LogEntry&, size_t& rows_used);\n+\n+public:\n+    static const int NWLMHeaderCount = 5;\n+    enum Header {\n+        NWLMH_TIME,\n+        NWLMH_TYPE,\n+        NWLMH_ID,\n+        NWLMH_ADDR,\n+        NWLMH_VALUE,\n+    };\n+\n+    NetWatchLogModel(QWidget *parent);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712203",
      "id" : 229712203,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjIwMw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 160,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170275230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712203",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712598"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712598"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "created_at" : "2018-10-31T14:19:03Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712598",
      "id" : 229712598,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjU5OA==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 273,
      "path" : "src/qt/netwatch.cpp",
      "position" : 273,
      "pull_request_review_id" : 170275740,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2018-10-31T14:19:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712598",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712853"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:19:39Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712853",
      "id" : 229712853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjg1Mw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 278,
      "path" : "src/qt/netwatch.cpp",
      "position" : 278,
      "pull_request_review_id" : 170276064,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712853",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712885"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712885"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "created_at" : "2018-10-31T14:19:44Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229712885",
      "id" : 229712885,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMjg4NQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 285,
      "path" : "src/qt/netwatch.cpp",
      "position" : 285,
      "pull_request_review_id" : 170276106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2018-10-31T14:19:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229712885",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229713713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229713713"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove extra spaces after `(` and before `)` :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T14:21:39Z",
      "diff_hunk" : "@@ -0,0 +1,228 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Copyright (c) 2011-2013 David Krauss (std::align substitute from c-plus)\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_QT_NETWATCH_H\n+#define BITCOIN_QT_NETWATCH_H\n+\n+#include <primitives/transaction.h>\n+#include <sync.h>\n+#include <validationinterface.h>\n+\n+#include <QAbstractTableModel>\n+#include <QWidget>\n+\n+QT_BEGIN_NAMESPACE\n+class QLineEdit;\n+class QTableView;\n+QT_END_NAMESPACE\n+\n+class CBlock;\n+class CBlockIndex;\n+class ClientModel;\n+class LogEntry;\n+class NetworkStyle;\n+class PlatformStyle;\n+\n+static const int nLongestAddress = 35;\n+\n+class LogEntry {\n+private:\n+    /* data is a uint32_t (meta_t) with the top two bits used for:\n+     *   1: CBlockIndex*\n+     *   2: CTransactionRef\n+     *   3: weak_ptr<const CTransaction>\n+     * The subsequent 30 bits are the timestamp, assumed to be most recent to the current time.\n+     * Following this, and any padding necessary for alignment, the object itself is stored\n+     */\n+    uint8_t *data;\n+\n+    typedef uint32_t meta_t;\n+    typedef std::weak_ptr<const CTransaction> CTransactionWeakref;\n+    static const uint32_t rel_ts_mask = 0x3fffffff;\n+    static const uint64_t rel_ts_mask64 = rel_ts_mask;\n+\n+    template<typename T> static size_t data_sizeof(size_t& offset) {\n+        void *p = (void *)intptr_t(sizeof(meta_t));\n+        size_t dummy_bufsize = sizeof(T) * 2;\n+        p = align(std::alignment_of<T>::value, sizeof(T), p, dummy_bufsize);\n+        assert(p);\n+        offset = size_t(p);\n+        return offset + sizeof(T);\n+    }\n+\n+    // std::align (missing in at least GCC 4.9) substitute from c-plus\n+    static inline void *align( std::size_t alignment, std::size_t size, void *&ptr, std::size_t &space ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229713713",
      "id" : 229713713,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTcxMzcxMw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 56,
      "path" : "src/qt/netwatch.h",
      "position" : null,
      "pull_request_review_id" : 170277164,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229713713",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229830322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229830322"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure. The intent is only to make sure `vtx[0]` below is an acceptable dereference.\r\n\r\nThe actual check for block data is above, with `if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA))`",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:08:05Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229830322",
      "id" : 229830322,
      "in_reply_to_id" : 229710344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzMDMyMg==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 343,
      "path" : "src/qt/netwatch.cpp",
      "position" : 343,
      "pull_request_review_id" : 170424601,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229830322",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229836085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229836085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\nqt/netwatch.cpp:273:70: error: virt-specifiers in ValidationInterfaceUnregistering not allowed outside a class definition\r\n```\r\n\r\nAdding it to only the class def instead...",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:26:52Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229836085",
      "id" : 229836085,
      "in_reply_to_id" : 229712853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzNjA4NQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 278,
      "path" : "src/qt/netwatch.cpp",
      "position" : 278,
      "pull_request_review_id" : 170432166,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229836085",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see -- makes sense :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:31:40Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    widget(parent),\n+    validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (validation_interface) {\n+        UnregisterValidationInterface(validation_interface);\n+        delete validation_interface;\n+        validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete validation_interface;\n+    validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return log.size() - logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837477",
      "id" : 229837477,
      "in_reply_to_id" : 229710344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzNzQ3Nw==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 343,
      "path" : "src/qt/netwatch.cpp",
      "position" : 343,
      "pull_request_review_id" : 170434054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837477",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sounds good. I commented on the wrong line :-)",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-10-31T19:33:11Z",
      "diff_hunk" : "@@ -0,0 +1,829 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/networkstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QWidget>\n+#include <QVBoxLayout>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.data) {\n+        data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(data + alignment_weak, tx);\n+        new (data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering();\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r229837851",
      "id" : 229837851,
      "in_reply_to_id" : 229712853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTgzNzg1MQ==",
      "original_commit_id" : "56bd9fdfc05a64037f027161727402354ba4abdb",
      "original_position" : 278,
      "path" : "src/qt/netwatch.cpp",
      "position" : 278,
      "pull_request_review_id" : 170434583,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229837851",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r230554831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230554831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see this assertion on Windows in testing, haven't take a look at the code.\r\n\r\n![image](https://user-images.githubusercontent.com/11154118/47952673-edfe4380-dfad-11e8-8e40-a667be01659c.png)\r\n",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-11-03T13:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    explicit NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering() override;\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void TransactionAddedToMempool(const CTransactionRef &) override;\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    m_widget(parent),\n+    m_validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(m_validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (m_validation_interface) {\n+        UnregisterValidationInterface(m_validation_interface);\n+        delete m_validation_interface;\n+        m_validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete m_validation_interface;\n+    m_validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return m_log.size() - m_logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (m_client_model) {\n+                return BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return m_widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return m_widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = m_widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (m_client_model) {\n+                return BitcoinUnits::getAmountColumnTitle(m_client_model->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& query, int display_unit) :\n+    m_query(query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    m_check_type = m_query.length() < 4 && reType.exactMatch(m_query);\n+    m_check_id = m_query.length() <= 64 && reHex.exactMatch(m_query);\n+    m_check_addr = m_query.length() <= nLongestAddress;\n+    CAmount val;\n+    m_check_value = BitcoinUnits::parse(display_unit, m_query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(m_query)) {\n+        return true;\n+    } else if (m_check_type && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_id && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_addr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_value && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(m_query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = m_client_model->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->m_check_addr || newsearch->m_check_value) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = nullptr;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (m_logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --m_logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!m_logpos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r230554831",
      "id" : 230554831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDU1NDgzMQ==",
      "original_commit_id" : "654f66d9e0f7a31e3c9b9ac6af30da5f5bdb4fb1",
      "original_position" : 577,
      "path" : "src/qt/netwatch.cpp",
      "position" : 577,
      "pull_request_review_id" : 171327281,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230554831",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r238032221"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238032221"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This could go to window menu, which is added in #14573.",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2018-11-30T23:23:51Z",
      "diff_hunk" : "@@ -397,6 +404,7 @@ void BitcoinGUI::createMenuBar()\n     settings->addAction(optionsAction);\n \n     QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n+    help->addAction(m_show_netwatch_action);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r238032221",
      "id" : 238032221,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzODAzMjIyMQ==",
      "original_commit_id" : "654f66d9e0f7a31e3c9b9ac6af30da5f5bdb4fb1",
      "original_position" : 48,
      "path" : "src/qt/bitcoingui.cpp",
      "position" : null,
      "pull_request_review_id" : 180487486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T16:49:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/238032221",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-12-16T07:13:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#issuecomment-447622632",
      "id" : 447622632,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9849",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NzYyMjYzMg==",
      "updated_at" : "2018-12-16T07:13:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447622632",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256072587"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256072587"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any idea how?>",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2019-02-12T17:51:52Z",
      "diff_hunk" : "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);\n+}\n+\n+class NetWatchValidationInterface final : public CValidationInterface {\n+private:\n+    NetWatchLogModel& model;\n+\n+public:\n+    explicit NetWatchValidationInterface(NetWatchLogModel& model_in) : model(model_in) {}\n+    void ValidationInterfaceUnregistering() override;\n+\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void TransactionAddedToMempool(const CTransactionRef &) override;\n+};\n+\n+void NetWatchValidationInterface::ValidationInterfaceUnregistering()\n+{\n+    model.OrphanedValidationInterface();\n+}\n+\n+void NetWatchValidationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n+{\n+    if (pindexNew != pindexFork) {\n+        model.LogBlock(pindexNew);\n+    }\n+}\n+\n+void NetWatchValidationInterface::TransactionAddedToMempool(const CTransactionRef &ptx)\n+{\n+    model.LogTransaction(ptx);\n+}\n+\n+NetWatchLogModel::NetWatchLogModel(QWidget *parent) :\n+    QAbstractTableModel(parent),\n+    m_widget(parent),\n+    m_validation_interface(new NetWatchValidationInterface(*this))\n+{\n+    RegisterValidationInterface(m_validation_interface);\n+}\n+\n+NetWatchLogModel::~NetWatchLogModel()\n+{\n+    LOCK(cs);\n+    if (m_validation_interface) {\n+        UnregisterValidationInterface(m_validation_interface);\n+        delete m_validation_interface;\n+        m_validation_interface = nullptr;\n+    }\n+}\n+\n+void NetWatchLogModel::OrphanedValidationInterface()\n+{\n+    LOCK(cs);\n+    delete m_validation_interface;\n+    m_validation_interface = nullptr;\n+}\n+\n+int NetWatchLogModel::rowCount(const QModelIndex& parent) const\n+{\n+    LOCK(cs);\n+    return m_log.size() - m_logskip;\n+}\n+\n+int NetWatchLogModel::columnCount(const QModelIndex& parent) const\n+{\n+    return NWLMHeaderCount;\n+}\n+\n+QVariant NetWatchLogModel::data(const CBlockIndex& blockindex, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_BLOCK);\n+        case NWLMH_ID:\n+            return QString::fromStdString(blockindex.GetBlockHash().GetHex());\n+        case NWLMH_ADDR:\n+        case NWLMH_VALUE: {\n+            if (blockindex.nTx == 0 || !(blockindex.nStatus & BLOCK_HAVE_DATA)) {\n+                return QVariant();\n+            }\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, &blockindex, Params().GetConsensus())) {\n+                // Indicate error somehow?\n+                return QVariant();\n+            }\n+            assert(block.vtx.size());\n+            return data(block.vtx[0], txout_index, header);\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+QVariant NetWatchLogModel::data(const CTransactionRef& tx, int txout_index, const Header header) const\n+{\n+    switch (header) {\n+        case NWLMH_TYPE:\n+            return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+        case NWLMH_ID:\n+            return QString::fromStdString(tx->GetHash().GetHex());\n+        case NWLMH_ADDR: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                // Only datacarriers\n+                ptxout = &tx->vout[0];\n+            }\n+            CTxDestination txdest;\n+            if (ptxout->scriptPubKey[0] == OP_RETURN && ptxout->nValue > 0) {\n+                return tr(\"(Burn)\", \"Tx Watch: Provably burned value in transaction\");\n+            } else if (!ExtractDestination(ptxout->scriptPubKey, txdest)) {\n+                return tr(\"(Unknown)\", \"Tx Watch: Unknown transaction output type\");\n+            }\n+            return QString::fromStdString(EncodeDestination(txdest));\n+        }\n+        case NWLMH_VALUE: {\n+            const CTxOut *ptxout = GetNonDatacarrierOutput(tx, txout_index);\n+            if (!ptxout) {\n+                ptxout = &tx->vout[0];\n+            }\n+            if (m_client_model) {\n+                return BitcoinUnits::format(m_client_model->getOptionsModel()->getDisplayUnit(), ptxout->nValue);\n+            } else {\n+                return qlonglong(ptxout->nValue);\n+            }\n+        }\n+        case NWLMH_TIME: ;  // Not valid here\n+    }\n+    return QVariant();\n+}\n+\n+const LogEntry& NetWatchLogModel::getLogEntryRow(int row) const\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+LogEntry& NetWatchLogModel::getLogEntryRow(int row)\n+{\n+    AssertLockHeld(cs);\n+    size_t pos = (m_logpos + row) % m_log.size();\n+    return m_log[pos];\n+}\n+\n+bool NetWatchLogModel::isLogRowContinuation(int row) const\n+{\n+    AssertLockHeld(cs);\n+    return !getLogEntryRow(row);\n+}\n+\n+const LogEntry& NetWatchLogModel::findLogEntry(int row, int& out_entry_row) const\n+{\n+    AssertLockHeld(cs);\n+    out_entry_row = 0;\n+    while (row && isLogRowContinuation(row)) {\n+        --row;\n+        ++out_entry_row;\n+    }\n+    return getLogEntryRow(row);\n+}\n+\n+QVariant NetWatchLogModel::data(const QModelIndex& index, int role) const\n+{\n+    const Header header = Header(index.column());\n+    switch (role) {\n+        case Qt::DisplayRole:\n+            break;\n+        case Qt::BackgroundRole: {\n+            if (!data(index, Qt::DisplayRole).isValid()) {\n+                return m_widget->palette().brush(QPalette::WindowText);\n+            }\n+            LogEntry::LogEntryType type;\n+            {\n+                int entry_row;\n+                LOCK(cs);\n+                const LogEntry& le = findLogEntry(index.row(), entry_row);\n+                type = le.getType();\n+            }\n+            if (type == LogEntry::LET_BLOCK) {\n+                return m_widget->palette().brush(QPalette::AlternateBase);\n+            }\n+            return QVariant();\n+        }\n+        case Qt::ForegroundRole: {\n+            if (index.column() < 3) {\n+                bool iscont;\n+                {\n+                    LOCK(cs);\n+                    iscont = isLogRowContinuation(index.row());\n+                }\n+                if (iscont) {\n+                    QBrush brush = m_widget->palette().brush(QPalette::WindowText);\n+                    QColor color = brush.color();\n+                    color.setAlpha(color.alpha() / 2);\n+                    brush.setColor(color);\n+                    return brush;\n+                }\n+            }\n+            return QVariant();\n+        }\n+        case Qt::TextAlignmentRole:\n+            if (header == NWLMH_VALUE) {\n+                return QVariant(Qt::AlignRight | Qt::AlignVCenter);\n+            }\n+            return QVariant();\n+        case Qt::FontRole:\n+            if (header == NWLMH_ID) {\n+                return GUIUtil::fixedPitchFont();\n+            }\n+            return QVariant();\n+        default:\n+            return QVariant();\n+    }\n+    int entry_row;\n+    LOCK(cs);\n+    const LogEntry& le = findLogEntry(index.row(), entry_row);\n+    if (header == NWLMH_TIME) {\n+        return GUIUtil::dateTimeStr(le.getTimestamp(GetTime()));\n+    }\n+    const LogEntry::LogEntryType type = le.getType();\n+    if (type == LogEntry::LET_BLOCK) {\n+        return data(le.getBlockIndex(), entry_row, header);\n+    }\n+    if (header == NWLMH_TYPE) {\n+        return LogEntry::LogEntryTypeAbbreviation(LogEntry::LET_TX);\n+    }\n+\n+    if (le.expired()) {\n+        return QVariant();\n+    }\n+    return data(le.getTransactionRef(), entry_row, header);\n+}\n+\n+QVariant NetWatchLogModel::headerData(int section, Qt::Orientation orientation, int role) const\n+{\n+    if (orientation != Qt::Horizontal || role != Qt::DisplayRole) {\n+        return QVariant();\n+    }\n+    switch (section) {\n+        case NWLMH_TIME:  return tr(\"Time\"   , \"NetWatch: Time header\");\n+        case NWLMH_TYPE:  return tr(\"Type\"   , \"NetWatch: Type header\");\n+        case NWLMH_ID:    return tr(\"Id\"     , \"NetWatch: Block hash / Txid header\");\n+        case NWLMH_ADDR:  return tr(\"Address\", \"NetWatch: Address header\");\n+        case NWLMH_VALUE:\n+            if (m_client_model) {\n+                return BitcoinUnits::getAmountColumnTitle(m_client_model->getOptionsModel()->getDisplayUnit());\n+            } else {\n+                // Used only for sizing of the column\n+                return BitcoinUnits::getAmountColumnTitle(BitcoinUnits::mBTC);\n+            }\n+    }\n+    return QVariant();\n+}\n+\n+NetWatchLogSearch::NetWatchLogSearch(const QString& query, int display_unit) :\n+    m_query(query)\n+{\n+    const QRegExp reHex(\"^[\\\\da-f]+$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+    const QRegExp reType(\"^(T(xn?)?|B(lk?)?)$\", Qt::CaseInsensitive, QRegExp::RegExp2);\n+\n+    m_check_type = m_query.length() < 4 && reType.exactMatch(m_query);\n+    m_check_id = m_query.length() <= 64 && reHex.exactMatch(m_query);\n+    m_check_addr = m_query.length() <= nLongestAddress;\n+    CAmount val;\n+    m_check_value = BitcoinUnits::parse(display_unit, m_query, &val) && val >= 0 && val <= BitcoinUnits::maxMoney();\n+}\n+\n+bool NetWatchLogSearch::match(const NetWatchLogModel& model, int row) const\n+{\n+    if (model.data(model.index(row, NetWatchLogModel::NWLMH_TIME)).toString().contains(m_query)) {\n+        return true;\n+    } else if (m_check_type && model.data(model.index(row, NetWatchLogModel::NWLMH_TYPE)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_id && model.data(model.index(row, NetWatchLogModel::NWLMH_ID)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_addr && model.data(model.index(row, NetWatchLogModel::NWLMH_ADDR)).toString().contains(m_query, Qt::CaseInsensitive)) {\n+        return true;\n+    } else if (m_check_value && model.data(model.index(row, NetWatchLogModel::NWLMH_VALUE)).toString().contains(m_query)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void NetWatchLogModel::searchRows(const QString& query, QList<int>& results)\n+{\n+    const auto currentUnit = m_client_model->getOptionsModel()->getDisplayUnit();\n+    NetWatchLogSearch *newsearch = new NetWatchLogSearch(query, currentUnit);\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = newsearch;\n+\n+    bool fAdding = false;\n+    const size_t rows_used = rowCount();\n+    for (size_t row = 0; row < rows_used; ++row) {\n+        if (isLogRowContinuation(row) || newsearch->m_check_addr || newsearch->m_check_value) {\n+            // Check for a match\n+            fAdding = newsearch->match(*this, row);\n+        }\n+        if (fAdding) {\n+            results.append(row);\n+        }\n+    }\n+}\n+\n+void NetWatchLogModel::searchDisable() {\n+    LOCK(cs);\n+    delete m_current_search;\n+    m_current_search = nullptr;\n+}\n+\n+void NetWatchLogModel::log_append(const LogEntry& le, size_t& rows_used)\n+{\n+    AssertLockHeld(cs);\n+    if (m_logskip) {\n+        // Replace a deleted row\n+        getLogEntryRow(rows_used) = le;\n+        --m_logskip;\n+    } else {\n+        // Haven't filled up yet, so just push_back\n+        assert(!m_logpos);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256072587",
      "id" : 256072587,
      "in_reply_to_id" : 230554831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NjA3MjU4Nw==",
      "original_commit_id" : "654f66d9e0f7a31e3c9b9ac6af30da5f5bdb4fb1",
      "original_position" : 577,
      "path" : "src/qt/netwatch.cpp",
      "position" : 577,
      "pull_request_review_id" : 202815929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-12T17:51:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256072587",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256345224"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256345224"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Shift overflow?",
      "commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "created_at" : "2019-02-13T11:00:48Z",
      "diff_hunk" : "@@ -0,0 +1,827 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <qt/netwatch.h>\n+\n+#include <qt/bitcoinunits.h>\n+#include <qt/clientmodel.h>\n+#include <qt/guiconstants.h>\n+#include <qt/guiutil.h>\n+#include <qt/networkstyle.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <key_io.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/standard.h>\n+#include <sync.h>\n+#include <util/time.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <memory>\n+#include <type_traits>\n+\n+#include <QAbstractTableModel>\n+#include <QHBoxLayout>\n+#include <QLineEdit>\n+#include <QPushButton>\n+#include <QScrollBar>\n+#include <QVBoxLayout>\n+#include <QWidget>\n+\n+namespace {\n+\n+bool IsDatacarrier(const CTxOut& txout)\n+{\n+    return (txout.scriptPubKey[0] == OP_RETURN && txout.nValue == 0);\n+}\n+\n+size_t CountNonDatacarrierOutputs(const CTransactionRef& tx)\n+{\n+    size_t count = 0;\n+    for (const auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        ++count;\n+    }\n+    return count;\n+}\n+\n+const CTxOut* GetNonDatacarrierOutput(const CTransactionRef& tx, const size_t txout_index)\n+{\n+    size_t count = 0;\n+    for (auto& txout : tx->vout) {\n+        if (IsDatacarrier(txout)) continue;\n+        if (count == txout_index) {\n+            return &txout;\n+        }\n+        ++count;\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+const QString LogEntry::LogEntryTypeAbbreviation(const LogEntryType log_entry_type)\n+{\n+    switch (log_entry_type) {\n+        case LET_BLOCK: return QObject::tr(\"Blk\", \"Tx Watch: Block type abbreviation\");\n+        case LET_TX:    return QObject::tr(\"Txn\", \"Tx Watch: Transaction type abbreviation\");\n+    }\n+    return QString();\n+}\n+\n+void LogEntry::init(const LogEntry& other)\n+{\n+    if (!other.m_data) {\n+        m_data = nullptr;\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)other.m_data;\n+    const int32_t relTimestamp = n & rel_ts_mask;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            init(relTimestamp, other.getBlockIndex());\n+            break;\n+        case 2:  // CTransactionRef\n+        {\n+            CTransactionWeakref ptx(*other.get<CTransactionRef>());\n+            init(relTimestamp, ptx, false);\n+            break;\n+        }\n+        case 3:  // CTransactionWeakref\n+            init(relTimestamp, *other.get<CTransactionWeakref>(), true);\n+            break;\n+    }\n+}\n+\n+LogEntry::LogEntry(const LogEntry& other)\n+{\n+    init(other);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    relTimestamp &= rel_ts_mask;\n+    size_t alignment;\n+    const size_t sz = data_sizeof<CBlockIndex*>(alignment);\n+    m_data = (uint8_t*)::operator new(sz);\n+    *((meta_t*)m_data) = relTimestamp | (1 << 30);\n+    *((const CBlockIndex**)&m_data[alignment]) = &blockindex;\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CBlockIndex& blockindex)\n+{\n+    init(relTimestamp, blockindex);\n+}\n+\n+void LogEntry::init(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    relTimestamp &= rel_ts_mask;\n+\n+    // Allocate enough space for either, so we can convert between them\n+    size_t alignment_shared, alignment_weak;\n+    const size_t sz = std::max(data_sizeof<CTransactionRef>(alignment_shared), data_sizeof<CTransactionWeakref>(alignment_weak));\n+    m_data = (uint8_t*)::operator new(sz);\n+\n+    uint32_t type;\n+    if (weak) {\n+        //std::allocator<std::weak_ptr<CTransaction>>::construct(m_data + alignment_weak, tx);\n+        new (m_data + alignment_weak) CTransactionWeakref(tx);\n+        type = 3;\n+    } else {\n+        new (m_data + alignment_shared) CTransactionRef(tx.lock());\n+        type = 2;\n+    }\n+    *((meta_t*)m_data) = relTimestamp | (type << 30);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionWeakref& tx, bool weak)\n+{\n+    init(relTimestamp, tx, weak);\n+}\n+\n+LogEntry::LogEntry(int32_t relTimestamp, const CTransactionRef& tx, bool weak)\n+{\n+    CTransactionWeakref ptx(tx);\n+    init(relTimestamp, ptx, weak);\n+}\n+\n+void LogEntry::clear()\n+{\n+    if (!m_data) {\n+        return;\n+    }\n+    const meta_t n = *(meta_t*)m_data;\n+    switch (n >> 30) {\n+        case 1:  // CBlockIndex*\n+            break;\n+        case 2:  // CTransactionRef\n+            get<CTransactionRef>()->~CTransactionRef();\n+            break;\n+        case 3:  // CTransactionWeakref\n+            get<CTransactionWeakref>()->~CTransactionWeakref();\n+            break;\n+    }\n+    delete m_data;\n+}\n+\n+LogEntry::~LogEntry()\n+{\n+    clear();\n+}\n+\n+LogEntry& LogEntry::operator=(const LogEntry& other)\n+{\n+    if (this != &other) {\n+        clear();\n+        init(other);\n+    }\n+    return *this;\n+}\n+\n+LogEntry::operator bool() const\n+{\n+    return m_data;\n+}\n+\n+int32_t LogEntry::getRelTimestamp() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return n & rel_ts_mask;\n+}\n+\n+uint64_t LogEntry::getTimestamp(uint64_t now) const\n+{\n+    uint64_t ts = (now & ~rel_ts_mask64) | getRelTimestamp();\n+    if (ts > now) {\n+        ts -= (rel_ts_mask64 + 1);\n+    }\n+    return ts;\n+}\n+\n+LogEntry::LogEntryType LogEntry::getType() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return (n >> 31) ? LET_TX : LET_BLOCK;\n+}\n+\n+const CBlockIndex& LogEntry::getBlockIndex() const\n+{\n+    return **(get<const CBlockIndex*>());\n+}\n+\n+CTransactionRef LogEntry::getTransactionRef() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) & 1) {\n+        return get<CTransactionWeakref>()->lock();\n+    } else {\n+        return *get<CTransactionRef>();\n+    }\n+}\n+\n+bool LogEntry::isWeak() const\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    return ((n >> 30) == 3);\n+}\n+\n+bool LogEntry::expired() const\n+{\n+    if (isWeak()) {\n+        return get<CTransactionWeakref>()->expired();\n+    }\n+    return false;\n+}\n+\n+void LogEntry::makeWeak()\n+{\n+    const meta_t n = *(meta_t*)m_data;\n+    if ((n >> 30) != 2) {\n+        return;\n+    }\n+    CTransactionRef * const ptx_old = get<CTransactionRef>();\n+    CTransactionRef tx = *ptx_old;  // save a copy\n+    ptx_old->~CTransactionRef();\n+    CTransactionWeakref * const ptx_new = get<CTransactionWeakref>();\n+    new (ptx_new) CTransactionWeakref(tx);\n+    *((meta_t*)m_data) |= (3 << 30);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9849#discussion_r256345224",
      "id" : 256345224,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1NjM0NTIyNA==",
      "original_commit_id" : "ba6074b561fce84191bce5f3749f66436473599b",
      "original_position" : 258,
      "path" : "src/qt/netwatch.cpp",
      "position" : 258,
      "pull_request_review_id" : 203146959,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9849",
      "updated_at" : "2019-02-13T11:00:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/256345224",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
