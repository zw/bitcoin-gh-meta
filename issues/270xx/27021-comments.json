[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [achow101](https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1533510937), [furszy](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1417018318), [theStack](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1428805458) |\n| Concept ACK | [glozow](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1326000785) |\n| Stale ACK | [LarryRuane](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1361682595) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2023-02-02T00:25:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1412956940",
      "id" : 1412956940,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UOAMM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1412956940/reactions"
      },
      "updated_at" : "2023-05-16T15:02:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1412956940",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1095658967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095658967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(IIRC we discussed this offline a while ago) We probably want to check here that `to_process_count` doesn't get too large. It's not really feasible to run MiniMiner with a cluster == entire mempool...\r\nPerhaps add a check here so that if we see a cluster size > 1000 (or something), we maybe want to tell the wallet to calculate bump fees in batches, maybe look at fewer UTXOS, or some kind of safe fallback.",
      "commit_id" : "daf023a49ce812417a36ec201e19d4272abc790a",
      "created_at" : "2023-02-03T10:43:45Z",
      "diff_hunk" : "@@ -1140,3 +1153,47 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1095658967",
      "id" : 1095658967,
      "line" : 1185,
      "node_id" : "PRRC_kwDOABII585BTm3X",
      "original_commit_id" : "daf023a49ce812417a36ec201e19d4272abc790a",
      "original_line" : 1185,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 69,
      "pull_request_review_id" : 1282756155,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095658967/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-03T10:47:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095658967",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I wrote a fuzz test for the `MiniMiner` and it crashes on some of the `Assume`s: https://github.com/dergoegge/bitcoin/tree/2023-01-fuzz-mini-miner\r\n\r\n```sh\r\n$ echo \"AQEWCQEBAAEACf//////////////CBwAAgAAlRwB7QEA/wAAAAL7AAEAAAEB7QEA/wAAAAL7AAAA\r\nAAAAXAD//w==\" | base64 -d > mini_miner_crash.input\r\n$ FUZZ=mini_miner ./src/test/fuzz/fuzz ./mini_miner_crash.input\r\n```\r\n\r\nNow that could just mean that my assumptions about what should be passed into the `MiniMiner` are wrong (i.e. my fuzz target is using the `MiniMiner` incorrectly). In that case it might make sense to add documentation that outlines what is expected from a `MiniMiner` user.\r\n\r\nTwo questions:\r\n* Are the assumptions (i.e. `Assume`s in mini_miner.cpp) internal to the `MiniMiner` or do they rely on external assumptions as well? e.g. Does the mini miner expect the mempool it receives in its constructor to only hold transactions that passed out ATMP checks?\r\n* Since this is a \"mini\" version of the `BlockAssembler`, would it be possible to differentially fuzz the two? Or using one as an oracle to test the other? e.g. Checking if transactions bumped with the help of `MiniMiner` make it into the next block constructed by the actual `BlockAssembler`.",
      "created_at" : "2023-02-03T15:41:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416044406",
      "id" : 1416044406,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UZx92",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416044406/reactions"
      },
      "updated_at" : "2023-02-03T15:41:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416044406",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "In what way does the code added here differ from the real block assembly code?",
      "created_at" : "2023-02-03T16:13:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416085883",
      "id" : 1416085883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UZ8F7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416085883/reactions"
      },
      "updated_at" : "2023-02-03T16:13:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416085883",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for fuzzing :100:\r\nIt's fully possible the crashing is due to real bugs, I hit a crash yesterday while testing as well. I think there is something wrong with the way it's handling to-be-replaced outputs.\r\n\r\n> Does the mini miner expect the mempool it receives in its constructor to only hold transactions that passed out ATMP checks?\r\n\r\nActually no. It just uses what's cached in the mempool entries. The fees don't even need to match inputs - outputs, and mini miner definitely doesn't require ATMP checks.\r\n\r\n> Since this is a \"mini\" version of the BlockAssembler, would it be possible to differentially fuzz the two?\r\n\r\nDifferential fuzzing is perfect for this really.`MiniMiner::BuildMockTemplate(target_feerate)` is supposed to do the exact same thing as `BlockAssembler::addPackageTxs` with `blockmintxfee` = target feerate.\r\n\r\n> Checking if transactions bumped with the help of MiniMiner make it into the next block constructed by the actual BlockAssembler.\r\n\r\nThat would also be a really good way of testing the results (after the wallet stuff is added?). Add the bumping tx, mine another block with the target feerate as min feerate, and see that they all get mined.",
      "created_at" : "2023-02-03T16:14:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416087441",
      "id" : 1416087441,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UZ8eR",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416087441/reactions"
      },
      "updated_at" : "2023-02-03T16:14:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416087441",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> In what way does the code added here differ from the real block assembly code?\r\n\r\n- Only operates on the relevant transactions rather than full mempool\r\n- Has the ability to remove transactions that will be replaced so they don't impact their ancestors\r\n- Does not hold mempool lock outside of the constructor, makes copies of the entries it needs instead (though I'm not sure if this has an effect in practice)\r\n- Doesn't do the sanity checks like keeping weight within max block weight and `IsFinalTx()`\r\n- After the block template is built, additionally calculates fees to bump remaining ancestor packages to target feerate",
      "created_at" : "2023-02-03T16:21:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416097704",
      "id" : 1416097704,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UZ--o",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416097704/reactions"
      },
      "updated_at" : "2023-02-03T16:21:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416097704",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Added tests from glozowâs branch",
      "created_at" : "2023-02-03T21:29:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416422200",
      "id" : 1416422200,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UbOM4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416422200/reactions"
      },
      "updated_at" : "2023-02-03T21:29:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416422200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Is there a reason to leave the `CalculateTotalBumpFee` commit out of this PR?",
      "created_at" : "2023-02-06T10:14:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1418834753",
      "id" : 1418834753,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UkbNB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1418834753/reactions"
      },
      "updated_at" : "2023-02-06T10:14:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1418834753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh good point, that just grew organically, but really it could be part of the mini-miner changes. Iâll squash it in there.",
      "created_at" : "2023-02-06T22:26:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1419869444",
      "id" : 1419869444,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585UoX0E",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1419869444/reactions"
      },
      "updated_at" : "2023-02-06T22:26:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1419869444",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve amended this branch to include the `CalculateTotalBumpFee` method from #26152 in the mini-miner code here.",
      "created_at" : "2023-02-08T16:58:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1422942684",
      "id" : 1422942684,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585U0GHc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422942684/reactions"
      },
      "updated_at" : "2023-02-08T16:58:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422942684",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I pushed some changes (with @Xekyo's permission, thanks):\r\n- Capped traversal at 500 items in `CalculateCluster()`. Number is arbitrary, open for commentary\r\n- Fixed up a few things in the MiniMiner implementation, mostly shuffling things around and updating comments\r\n- Dropped the chain interface changes (I think those can go in #26152)\r\n- Expanded unit tests\r\n- Added a fuzzer (expanded from @dergoegge's, thanks)\r\n- Added a fuzzer to differentially test block templates built by `BlockAssembler` and `MiniMiner`. Hopefully this gives reviewers a bit more confidence that they are doing the same thing even if the implementations are difficult to review/compare.",
      "created_at" : "2023-02-16T16:06:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1433329273",
      "id" : 1433329273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585Vbt55",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433329273/reactions"
      },
      "updated_at" : "2023-02-16T16:06:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433329273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Awesome, thanks for the reworking this, @glozow, and the work on the fuzzer, @dergoegge. I've fixed a minor `tidy` issue and Iâll pick the chain interface changes into #26152 and rebase on this shortly.\r\n\r\nReady for review\r\n\r\n",
      "created_at" : "2023-02-16T21:29:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1433738562",
      "id" : 1433738562,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585VdR1C",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433738562/reactions"
      },
      "updated_at" : "2023-02-16T21:29:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433738562",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Pushed again to provide signed commits",
      "created_at" : "2023-02-16T22:26:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1433798783",
      "id" : 1433798783,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585Vdgh_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433798783/reactions"
      },
      "updated_at" : "2023-02-16T22:26:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433798783",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "review-beg-pinging @LarryRuane @josibake @stickies-v who have looked at `MiniMiner` previously",
      "created_at" : "2023-02-17T16:19:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1434870979",
      "id" : 1434870979,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585VhmTD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1434870979/reactions"
      },
      "updated_at" : "2023-02-17T16:19:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1434870979",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "For anyone wanting to review this PR and would like some help with basic mempool concepts, I made a video: https://youtu.be/sQ05azzTp9o -- it mentions 26152 but I think would be helpful for reviewers here as well.",
      "created_at" : "2023-02-17T17:53:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1435034303",
      "id" : 1435034303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585ViOK_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435034303/reactions"
      },
      "updated_at" : "2023-02-17T17:53:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435034303",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-23T21:25:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1442452427",
      "id" : 1442452427,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585V-hPL",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1442452427/reactions"
      },
      "updated_at" : "2023-02-23T21:25:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1442452427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119099044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119099044"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit\r\n```suggestion\r\n        ret.push_back(it.value());\r\n```\r\nThis may help the reader know that `it` is a `std::optional`; at first, I thought `GetIter()` may be returning a pointer. But if you prefer `*`, which is more concise, that's fine too.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-27T17:57:35Z",
      "diff_hunk" : "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> ret;\n+    ret.reserve(txids.size());\n+    for (const auto& txid : txids) {\n+        const auto it{GetIter(txid)};\n+        if (!it) return {};\n+        ret.push_back(*it);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119099044",
      "id" : 1119099044,
      "line" : 910,
      "node_id" : "PRRC_kwDOABII585CtBik",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 910,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 20,
      "pull_request_review_id" : 1316134729,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119099044/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-27T19:35:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119099044",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119107935"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119107935"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\nstd::optional<std::vector<CTxMemPool::txiter>> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const\r\n```\r\nWould this be better than giving a special meaning to an empty vector? I'm unsure, but may be worth considering.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-27T18:05:53Z",
      "diff_hunk" : "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119107935",
      "id" : 1119107935,
      "line" : 902,
      "node_id" : "PRRC_kwDOABII585CtDtf",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 902,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 12,
      "pull_request_review_id" : 1316134729,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119107935/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-27T19:35:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119107935",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119109899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119109899"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\nstd::optional<std::vector<CTxMemPool::txiter>> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-27T18:07:58Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119109899",
      "id" : 1119109899,
      "line" : 1157,
      "node_id" : "PRRC_kwDOABII585CtEML",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1157,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 41,
      "pull_request_review_id" : 1316134729,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119109899/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-27T19:35:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119109899",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119134160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119134160"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should this function return `std::nullopt` instead?",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-27T18:28:45Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119134160",
      "id" : 1119134160,
      "line" : 1164,
      "node_id" : "PRRC_kwDOABII585CtKHQ",
      "original_commit_id" : "aad0c09ab6fb38e6d0a3e4d9eb764d84a2913f15",
      "original_line" : 1164,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 48,
      "pull_request_review_id" : 1316134729,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119134160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-27T19:35:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119134160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119202243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119202243"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm concerned about the possible over-estimation here. In theory, there could be a combinatorial explosion if the DAG is highly interconnected and deep. I would consider removing this code, because vector `push_back()` is highly optimized when growth is needed. Or at least make sure there's a problem before adding this optimization.\r\n\r\nIf you do keep this, consider calling `cluster.shrink_to_fit()` before returning, so at least any high memory usage is temporary.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-27T19:20:02Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119202243",
      "id" : 1119202243,
      "line" : 1170,
      "node_id" : "PRRC_kwDOABII585CtavD",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1170,
      "original_position" : 54,
      "original_start_line" : 1166,
      "path" : "src/txmempool.cpp",
      "position" : 54,
      "pull_request_review_id" : 1316134729,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119202243/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1166,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-27T19:35:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119202243",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120543538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120543538"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n// Copyright (c) 2023 The Bitcoin Core developers\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-28T18:00:17Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120543538",
      "id" : 1120543538,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII585CyiMy",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 1,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120543538/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120543538",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120948639"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120948639"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit, more efficient to not make a copy\r\n```suggestion\r\n                std::vector<COutPoint> outpoints_of_tx({outpoint});\r\n                m_requested_outpoints_by_txid.emplace(outpoint.hash, std::move(outpoints_of_tx));\r\n```\r\nor (I didn't test this, but I'm pretty sure that since the vector argument is an rvalue, the compiler will do a move)\r\n```suggestion\r\n                m_requested_outpoints_by_txid.emplace(outpoint.hash, std::vector<COutPoint>{outpoint});\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-02-28T23:58:17Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120948639",
      "id" : 1120948639,
      "line" : 52,
      "node_id" : "PRRC_kwDOABII585C0FGf",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 52,
      "original_position" : 52,
      "original_start_line" : 51,
      "path" : "src/node/mini_miner.cpp",
      "position" : 52,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120948639/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 51,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120948639",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120964573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120964573"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit, simpler. I don't know if the comment is necessary (the reader is expected to know this about maps), but it may help to document that we're taking advantage of that behavior.\r\n\r\nThe developer notes do [say](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#c-data-structures) not to use the `std::map []` syntax, but only for reading.\r\n```suggestion\r\n            // This creates the map entry if it doesn't already exist.\r\n            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T00:22:44Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120964573",
      "id" : 1120964573,
      "line" : 53,
      "node_id" : "PRRC_kwDOABII585C0I_d",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 53,
      "original_position" : 53,
      "original_start_line" : 47,
      "path" : "src/node/mini_miner.cpp",
      "position" : 53,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120964573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 47,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120964573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120992192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120992192"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not a bug, but I noticed that the only reference to `m_to_be_replaced` outside the constructor is an `Assume` in `SanityCheck()`, I wonder if it's worth `m_to_be_replaced` being a class member. If we give up the `Assume`, which doesn't seem to be doing that much heavy lifting, then `m_to_be_replaced` could be a local variable in the constructor.\r\n\r\nAnother nice thing about making `m_to_be_replaced` a local variable is that its entries can be pointers to transactions, instead of entire txid hashes. I wanted to make sure that would work, so here's a patch that does that and passes the tests. (It includes my other suggestions for the constructor, because I wanted to test all of them.)\r\n\r\n<details>\r\n<summary>patch, click to expand</summary>\r\n\r\n```diff\r\n--- a/src/node/mini_miner.cpp\r\n+++ b/src/node/mini_miner.cpp\r\n@@ -21,6 +21,7 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n {\r\n     LOCK(mempool.cs);\r\n     m_requested_outpoints = outpoints;\r\n+    std::set<const CTransaction*> to_be_replaced;\r\n     // Find which outpoints to calculate bump fees for.\r\n     // Anything that's spent by the mempool is to-be-replaced\r\n     // Anything otherwise unavailable just has a bump fee of 0\r\n@@ -32,25 +33,19 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n             // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\r\n             // removing the to-be-replaced entries. Note that this is only calculating bump fees.\r\n             // RBF fee rules should be handled separately.\r\n-            m_to_be_replaced.insert(ptx->GetHash());\r\n+            to_be_replaced.insert(ptx);\r\n             // Remove descendants because they will be replaced as well. This case should be rare\r\n             // as the wallet won't normally attempt to replace transactions with descendants.\r\n             CTxMemPool::setEntries descendants;\r\n             mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\r\n             for (const auto& desc_txiter : descendants) {\r\n-                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\r\n+                to_be_replaced.insert(&desc_txiter->GetTx());\r\n             }\r\n         }\r\n \r\n         if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\r\n             // This UTXO is unconfirmed and in the mempool.\r\n-            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\r\n-            if (it != m_requested_outpoints_by_txid.end()) {\r\n-                it->second.push_back(outpoint);\r\n-            } else {\r\n-                std::vector<COutPoint> outpoints_of_tx({outpoint});\r\n-                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\r\n-            }\r\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\r\n         } else {\r\n             // This UTXO is either confirmed or not yet submitted to mempool.\r\n             // If it's confirmed, no bump fee is required.\r\n@@ -77,7 +72,7 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n \r\n     // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\r\n     for (const auto& txiter : cluster) {\r\n-        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\r\n+        if (to_be_replaced.find(&txiter->GetTx()) == to_be_replaced.end()) {\r\n             auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\r\n             m_entries.push_back(mapiter);\r\n         } else {\r\n@@ -95,18 +90,19 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n \r\n     // Build the m_descendant_set_by_txid cache.\r\n     for (const auto& txiter : cluster) {\r\n-        const auto& txid = txiter->GetTx().GetHash();\r\n+        const CTransaction& tx{txiter->GetTx()};\r\n+        const auto& txid{tx.GetHash()};\r\n         // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\r\n         // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\r\n         std::vector<MockEntryMap::iterator> cached_descendants;\r\n-        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\r\n+        const bool remove{to_be_replaced.find(&tx) != to_be_replaced.end()};\r\n         CTxMemPool::setEntries descendants;\r\n         mempool.CalculateDescendants(txiter, descendants);\r\n         Assume(descendants.find(txiter) != descendants.end());\r\n         for (const auto& desc_txiter : descendants) {\r\n-            const auto txid_desc = desc_txiter->GetTx().GetHash();\r\n-            const bool remove_desc = m_to_be_replaced.find(txid_desc) != m_to_be_replaced.end();\r\n-            auto desc_it{m_entries_by_txid.find(txid_desc)};\r\n+            const CTransaction& tx_desc{desc_txiter->GetTx()};\r\n+            const bool remove_desc{to_be_replaced.find(&tx_desc) != to_be_replaced.end()};\r\n+            auto desc_it{m_entries_by_txid.find(tx_desc.GetHash())};\r\n             Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\r\n             if (remove) Assume(remove_desc);\r\n             // It's possible that remove=false but remove_desc=true.\r\n@@ -194,9 +190,6 @@ void MiniMiner::SanityCheck() const\r\n     Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\r\n         return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\r\n                entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\r\n-    // None of the entries should be to-be-replaced transactions\r\n-    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\r\n-        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\r\n }\r\n \r\n void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\r\n```\r\n</details>",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T01:05:40Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120992192",
      "id" : 1120992192,
      "line" : 68,
      "node_id" : "PRRC_kwDOABII585C0PvA",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 68,
      "original_position" : 68,
      "original_start_line" : 66,
      "path" : "src/node/mini_miner.h",
      "position" : 68,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120992192/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 66,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120992192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121184614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121184614"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can we remove this code? (I prefer avoiding special cases.) The only effect difference I can see by eliminating this is that, with it, `m_ready_to_calculate` will remain `true`, whereas without it, it will be `false`. Does that matter? I'm unsure of the purpose of `m_ready_to_calculate` (in this PR it's only used by test code, although I understand it may be used in the follow-on PR). Seems like once the constructor runs, it should be ready to calculate, no matter what. There's nothing else that can be done to make it ready to calculate.\r\n\r\nIs `m_ready_to_calculate` an error indication, since it seems it can be `false` only If we hit the DoS limit? If so, how might it used? I think in this case we recover by just not bumping any fees, which is not the end of the world (it's what happens today). The error indication may be useful in tests (to verify that we hit the DoS limit when expected), but then maybe it should have a better name, like `dos_limit_reached`.\r\n\r\nBut it may be better still to just test the actual effect, i.e., that all the bump fees are zero.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T05:52:50Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121184614",
      "id" : 1121184614,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII585C0-tm",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : 62,
      "path" : "src/node/mini_miner.cpp",
      "position" : 63,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121184614/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 62,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121184614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121191113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121191113"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe this 500 can be a `constexpr` in the `MiniMiner` class? I probably wouldn't suggest this if this is the only place it occurs, but the tests specify this value too. It might be nice to be able to change this limit by changing a single line of code.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T06:01:52Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121191113",
      "id" : 1121191113,
      "line" : 1181,
      "node_id" : "PRRC_kwDOABII585C1ATJ",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1181,
      "original_position" : 65,
      "original_start_line" : 1180,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121191113/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1180,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121191113",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121215437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121215437"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This isn't a very efficient data structure, because each entry's key, the txid, is repeated in all of its vector's entries (because a `COutPoint` includes the txid). All you need is the index (`COutPoint::n`) So this could be:\r\n```\r\n    std::map<uint256, std::vector<uint32_t>> m_requested_outpoints_by_txid;\r\n```\r\nalthough the name would be wrong, it's no longer \"requested outpoints\". Elsewhere in the code where you need a `COutPoint` (I think there are only two places), you can construct it from the key (txid) and this index. ",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T06:32:29Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;\n+\n+    // If multiple argument outpoints correspond to the same transaction, cache them together in\n+    // a single entry indexed by txid. Then we can just work with txids since all outpoints from\n+    // the same tx will have the same bumpfee. Excludes non-mempool transactions.\n+    std::map<uint256, std::vector<COutPoint>> m_requested_outpoints_by_txid;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121215437",
      "id" : 1121215437,
      "line" : 73,
      "node_id" : "PRRC_kwDOABII585C1GPN",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 73,
      "original_position" : 73,
      "original_start_line" : 70,
      "path" : "src/node/mini_miner.h",
      "position" : 73,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121215437/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 70,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121215437",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121220463"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121220463"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T06:38:41Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121220463",
      "id" : 1121220463,
      "line" : 80,
      "node_id" : "PRRC_kwDOABII585C1Hdv",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 80,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 80,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121220463/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121220463",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121222211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121222211"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        const bool remove{m_to_be_replaced.count(txid) > 0};\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T06:40:46Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121222211",
      "id" : 1121222211,
      "line" : 102,
      "node_id" : "PRRC_kwDOABII585C1H5D",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 102,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121222211/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121222211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121223393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121223393"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n            const bool remove_desc{to_be_replaced.count(&tx_desc) > 0};\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T06:42:14Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc = m_to_be_replaced.find(txid_desc) != m_to_be_replaced.end();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121223393",
      "id" : 1121223393,
      "line" : 108,
      "node_id" : "PRRC_kwDOABII585C1ILh",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 108,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 108,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121223393/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121223393",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121225418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121225418"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        Assume(descendants.count(txiter) > 0);\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T06:44:43Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121225418",
      "id" : 1121225418,
      "line" : 105,
      "node_id" : "PRRC_kwDOABII585C1IrK",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 105,
      "pull_request_review_id" : 1318211679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121225418/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T06:46:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121225418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121483332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121483332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you explain why using `count` is better?",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T10:27:18Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121483332",
      "id" : 1121483332,
      "in_reply_to_id" : 1121220463,
      "line" : 80,
      "node_id" : "PRRC_kwDOABII585C2HpE",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 80,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 80,
      "pull_request_review_id" : 1319542147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121483332/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T10:38:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121483332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121487831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121487831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree it might just be better to not reserve anything. We have no idea what the cluster size is going to be, so might as well let the stdlib magic do its work.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T10:30:33Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121487831",
      "id" : 1121487831,
      "in_reply_to_id" : 1119202243,
      "line" : 1170,
      "node_id" : "PRRC_kwDOABII585C2IvX",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1170,
      "original_position" : 54,
      "original_start_line" : 1166,
      "path" : "src/txmempool.cpp",
      "position" : 54,
      "pull_request_review_id" : 1319542147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121487831/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1166,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T10:38:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121487831",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121488980"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121488980"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Marking as resolved as this has been implemented",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T10:31:18Z",
      "diff_hunk" : "@@ -1140,3 +1153,47 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121488980",
      "id" : 1121488980,
      "in_reply_to_id" : 1095658967,
      "line" : 1187,
      "node_id" : "PRRC_kwDOABII585C2JBU",
      "original_commit_id" : "daf023a49ce812417a36ec201e19d4272abc790a",
      "original_line" : 1187,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 71,
      "pull_request_review_id" : 1319542147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121488980/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T10:38:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121488980",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121498816"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121498816"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Disagree with txmempool getting this value from mini_miner, as that would create a circular dependency.\r\nThis kind of constant should live in src/kernel/mempool_options.h.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T10:38:37Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121498816",
      "id" : 1121498816,
      "in_reply_to_id" : 1121191113,
      "line" : 1181,
      "node_id" : "PRRC_kwDOABII585C2LbA",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1181,
      "original_position" : 65,
      "original_start_line" : 1180,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 1319542147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121498816/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1180,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T10:38:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121498816",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121528999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121528999"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The `mini_miner` target will always produce a cluster of 500 txs right now, because we always add outputs to `available_coins`. So my suggestion would be to let the fuzzer choose which outputs are added to `available_coins`.\r\n\r\n```suggestion\r\n        for (uint32_t n{0}; n < num_outputs; ++n) {\r\n            if (fuzzed_data_provider.ConsumeBool()) {\r\n                available_coins.push_back(COutPoint{tx->GetHash(), n});\r\n            }\r\n        }\r\n```\r\n ",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T11:02:01Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121528999",
      "id" : 1121528999,
      "line" : 67,
      "node_id" : "PRRC_kwDOABII585C2Syn",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : 61,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 67,
      "pull_request_review_id" : 1319599774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121528999/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 61,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T11:44:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121528999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121540528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121540528"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n            if (fuzzed_data_provider.ConsumeBool()) {\r\n```\r\n\r\nShouldn't really make a difference since the fuzzer picks both bools.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T11:10:25Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);\n+    } else {\n+        const auto bump_fee = mini_miner.CalculateTotalBumpFees(target_feerate);\n+        assert(bump_fee.has_value());\n+    }\n+    assert(!mini_miner.IsReadyToCalculate());\n+}\n+\n+// Test that MiniMiner and BlockAssembler build the same block given the same transactions and constraints.\n+FUZZ_TARGET_INIT(mini_miner_selection, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    // Make a copy to preserve determinism.\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    std::vector<CTransactionRef> transactions;\n+\n+    LOCK2(::cs_main, pool.cs);\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 100)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = 2;\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(2, 5);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+\n+        // First 2 outputs are available to spend. The rest are added to outpoints to calculate bumpfees.\n+        // There is no overlap between spendable coins and outpoints passed to MiniMiner because the\n+        // MiniMiner interprets spent coins as to-be-replaced and excludes them.\n+        for (uint32_t n{0}; n < num_outputs - 1; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool() && fuzzed_data_provider.ConsumeBool()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121540528",
      "id" : 1121540528,
      "line" : 125,
      "node_id" : "PRRC_kwDOABII585C2Vmw",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 125,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 125,
      "pull_request_review_id" : 1319599774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121540528/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-01T11:44:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121540528",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121607436"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121607436"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Alternatively, the `LIMITED_WHILE` condition could be changed.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T12:01:11Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121607436",
      "id" : 1121607436,
      "in_reply_to_id" : 1121528999,
      "line" : 67,
      "node_id" : "PRRC_kwDOABII585C2l8M",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : 61,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 67,
      "pull_request_review_id" : 1319698544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121607436/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 61,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T12:01:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121607436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121611301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121611301"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also, with my suggested modification there is a crash, which I don't think is the modifications fault:\r\n\r\n```\r\n/wCqamFv0GgmkfHCTmPQeMXAul83pioRsGwGcWUbQCYRX/BcVADDAQm0wQAAAAAAAAAAAAAPAAAA\r\nAAAAAA8AAAAAAAAAAAAAAGPQeMXAul83pioRsGwGcWUbKUAGcWUbQCYRX/BcVADDAQm0wQAAAAAA\r\nAAAAAAAPAAAAAAAAAA8AAAAAAAAAAAAAAGPQeMXAul83pioRsGwGcWUbKUAmEV/wVFwAwwG0CQAA\r\nAAAAAAAA//////+mKhGwbAZxZRtAJhFf8FRcAMMBCbTBAAAAAAAAAAAAAA///////////////2Zm\r\nZmZmZmZmZmZmZgAAAAAAAFw=\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-01T12:04:22Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121611301",
      "id" : 1121611301,
      "in_reply_to_id" : 1121528999,
      "line" : 67,
      "node_id" : "PRRC_kwDOABII585C2m4l",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : 61,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 67,
      "pull_request_review_id" : 1319704290,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121611301/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 61,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-01T12:05:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121611301",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122981731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122981731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry ignore my previous review, it was wrong. But this should work:\r\n\r\n```suggestion\r\n            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\r\n                outpoints.push_back(*outpoint);\r\n            }\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-02T11:53:40Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122981731",
      "id" : 1122981731,
      "line" : 77,
      "node_id" : "PRRC_kwDOABII585C71dj",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 77,
      "original_position" : 77,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 77,
      "pull_request_review_id" : 1321674784,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122981731/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-02T12:08:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122981731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122983669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122983669"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This input produces an `outpoints` vector with 2 of the same outpoint, which is what causes it to crash on the line `assert(bump_fees.size() == outpoints.size()`.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-02T11:55:19Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122983669",
      "id" : 1122983669,
      "in_reply_to_id" : 1121528999,
      "line" : 67,
      "node_id" : "PRRC_kwDOABII585C7171",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : 61,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 67,
      "pull_request_review_id" : 1321674784,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122983669/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 61,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-02T12:08:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122983669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122985863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122985863"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Just noticed this was added for `CalculateTotalBumpFees()` - it is redundant with `m_requested_outpoints_by_txid`, so I think you should remove it and have `CalculateTotalBumpFees()` iterate through `m_requested_outpoints_by_txid`'s keys instead.",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-02T11:57:11Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122985863",
      "id" : 1122985863,
      "line" : 23,
      "node_id" : "PRRC_kwDOABII585C72eH",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 23,
      "pull_request_review_id" : 1321674784,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122985863/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-02T12:08:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122985863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123037832"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123037832"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is more precise than making sure the lengths are the same (and would also fix the crash):\r\n```suggestion\r\n        for (const auto& outpoint : outpoints) {\r\n            auto it = bump_fees.find(outpoint);\r\n            assert(it != bump_fees.end());\r\n            assert(it->second >= 0);\r\n        }\r\n```",
      "commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "created_at" : "2023-03-02T12:41:50Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123037832",
      "id" : 1123037832,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII585C8DKI",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : 87,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 88,
      "pull_request_review_id" : 1321745788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123037832/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 87,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-02T12:41:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123037832",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123754749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123754749"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve removed the `reserve(â¦)` call here.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-02T21:48:57Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123754749",
      "id" : 1123754749,
      "in_reply_to_id" : 1119202243,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585C-yL9",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1170,
      "original_position" : 54,
      "original_start_line" : 1166,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123754749/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123754749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123811383"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123811383"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, agreed using an optional would be more explicit, however handling the optional return value would touch a bunch of lines here, and given that the result should never be empty unless something went wrong or the function got called with an empty `txids` input, I feel itâs a bit of a cosmetic improvement here.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-02T22:41:10Z",
      "diff_hunk" : "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123811383",
      "id" : 1123811383,
      "in_reply_to_id" : 1119107935,
      "line" : 902,
      "node_id" : "PRRC_kwDOABII585C_AA3",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 902,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 12,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123811383/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123811383",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123812481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123812481"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâd probably prefer using `.value()` for new code Iâd write, but the asterisk-variant seems prevalent throughout this code.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-02T22:42:39Z",
      "diff_hunk" : "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> ret;\n+    ret.reserve(txids.size());\n+    for (const auto& txid : txids) {\n+        const auto it{GetIter(txid)};\n+        if (!it) return {};\n+        ret.push_back(*it);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123812481",
      "id" : 1123812481,
      "in_reply_to_id" : 1119099044,
      "line" : 910,
      "node_id" : "PRRC_kwDOABII585C_ASB",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 910,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 20,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123812481/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123812481",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123819758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123819758"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "As above with `GetIterVec()`, an empty vector is not a valid outcome for a call, so I tend to leave as is.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-02T22:50:47Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123819758",
      "id" : 1123819758,
      "in_reply_to_id" : 1119109899,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585C_CDu",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1157,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123819758/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123819758",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123823270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123823270"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, will consider, change but feel itâs okay at this time.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-02T22:54:02Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123823270",
      "id" : 1123823270,
      "in_reply_to_id" : 1119134160,
      "line" : 1164,
      "node_id" : "PRRC_kwDOABII585C_C6m",
      "original_commit_id" : "aad0c09ab6fb38e6d0a3e4d9eb764d84a2913f15",
      "original_line" : 1164,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 48,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123823270/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123823270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124907930"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124907930"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâm not sure in how far this needs to be widely visible, since it only affects one function and the corresponding tests.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T19:10:44Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124907930",
      "id" : 1124907930,
      "in_reply_to_id" : 1121191113,
      "line" : 1176,
      "node_id" : "PRRC_kwDOABII585DDLua",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1176,
      "original_position" : 65,
      "original_start_line" : 1180,
      "path" : "src/txmempool.cpp",
      "position" : 60,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124907930/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1175,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124907930",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124908789"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124908789"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T19:11:45Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124908789",
      "id" : 1124908789,
      "in_reply_to_id" : 1120543538,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDL71",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124908789/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124908789",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124938942"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124938942"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Removed `m_requested_outpoints`",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T19:46:09Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124938942",
      "id" : 1124938942,
      "in_reply_to_id" : 1122985863,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDTS-",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124938942/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124938942",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124956187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124956187"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks thatâs much nicer",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T20:05:53Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124956187",
      "id" : 1124956187,
      "in_reply_to_id" : 1120964573,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDXgb",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 53,
      "original_position" : 53,
      "original_start_line" : 47,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124956187/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124956187",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124966759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124966759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems to me that if we donât use the result of `find`, itâs clearer that we just care about whether a key is present instead of where in the sequence it appears",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T20:18:19Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124966759",
      "id" : 1124966759,
      "in_reply_to_id" : 1121220463,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDaFn",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 80,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124966759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124966759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124995387"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995387"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, adopted",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T20:49:39Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124995387",
      "id" : 1124995387,
      "in_reply_to_id" : 1121222211,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDhE7",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995387/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995387",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124995611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995611"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T20:49:46Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124995611",
      "id" : 1124995611,
      "in_reply_to_id" : 1121225418,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDhIb",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995611/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995611",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124997795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124997795"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T20:52:23Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc = m_to_be_replaced.find(txid_desc) != m_to_be_replaced.end();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124997795",
      "id" : 1124997795,
      "in_reply_to_id" : 1121223393,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDhqj",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 108,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124997795/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124997795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124999961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124999961"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "While true, it seems more readable to use the type in the value that I later want than to remember reconstructing it later.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T20:54:54Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;\n+\n+    // If multiple argument outpoints correspond to the same transaction, cache them together in\n+    // a single entry indexed by txid. Then we can just work with txids since all outpoints from\n+    // the same tx will have the same bumpfee. Excludes non-mempool transactions.\n+    std::map<uint256, std::vector<COutPoint>> m_requested_outpoints_by_txid;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124999961",
      "id" : 1124999961,
      "in_reply_to_id" : 1121215437,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII585DDiMZ",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 70,
      "original_position" : 73,
      "original_start_line" : 70,
      "path" : "src/node/mini_miner.h",
      "position" : 70,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124999961/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 67,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124999961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125015732"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125015732"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, I changed it to use outpoints only sometimes depending on the consumed boolean as @dergoegge suggested.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T21:13:53Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125015732",
      "id" : 1125015732,
      "in_reply_to_id" : 1121528999,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDmC0",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 65,
      "original_position" : 67,
      "original_start_line" : 61,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125015732/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125015732",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125018960"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125018960"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, adopted your suggestion.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T21:17:41Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125018960",
      "id" : 1125018960,
      "in_reply_to_id" : 1123037832,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDm1Q",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : 87,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125018960/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125018960",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125019174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125019174"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for finding this!",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T21:17:55Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125019174",
      "id" : 1125019174,
      "in_reply_to_id" : 1122981731,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDm4m",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 77,
      "original_position" : 77,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125019174/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125019174",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125026197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125026197"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Removed second boolean",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T21:25:47Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);\n+    } else {\n+        const auto bump_fee = mini_miner.CalculateTotalBumpFees(target_feerate);\n+        assert(bump_fee.has_value());\n+    }\n+    assert(!mini_miner.IsReadyToCalculate());\n+}\n+\n+// Test that MiniMiner and BlockAssembler build the same block given the same transactions and constraints.\n+FUZZ_TARGET_INIT(mini_miner_selection, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    // Make a copy to preserve determinism.\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    std::vector<CTransactionRef> transactions;\n+\n+    LOCK2(::cs_main, pool.cs);\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 100)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = 2;\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(2, 5);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+\n+        // First 2 outputs are available to spend. The rest are added to outpoints to calculate bumpfees.\n+        // There is no overlap between spendable coins and outpoints passed to MiniMiner because the\n+        // MiniMiner interprets spent coins as to-be-replaced and excludes them.\n+        for (uint32_t n{0}; n < num_outputs - 1; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool() && fuzzed_data_provider.ConsumeBool()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125026197",
      "id" : 1125026197,
      "in_reply_to_id" : 1121540528,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDomV",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 125,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125026197/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125026197",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125071450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071450"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, Iâm not going to interfere here, because outpoints are tiny anyway, and it seems more readable without the move or constructor.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T22:16:27Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125071450",
      "id" : 1125071450,
      "in_reply_to_id" : 1120948639,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DDzpa",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 52,
      "original_position" : 52,
      "original_start_line" : 51,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071450/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125071911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071911"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâll have to revisit this one.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T22:17:00Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125071911",
      "id" : 1125071911,
      "in_reply_to_id" : 1121184614,
      "line" : 57,
      "node_id" : "PRRC_kwDOABII585DDzwn",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 57,
      "original_position" : 63,
      "original_start_line" : 62,
      "path" : "src/node/mini_miner.cpp",
      "position" : 57,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071911/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 56,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125072522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125072522"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the suggestion, going to think about this some more, but donât feel very strongly about it.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-03T22:17:55Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125072522",
      "id" : 1125072522,
      "in_reply_to_id" : 1120992192,
      "line" : 65,
      "node_id" : "PRRC_kwDOABII585DDz6K",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 65,
      "original_position" : 68,
      "original_start_line" : 66,
      "path" : "src/node/mini_miner.h",
      "position" : 65,
      "pull_request_review_id" : 1322708525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125072522/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 63,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-03T22:28:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125072522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126270559"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126270559"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Is m_ready_to_calculate an error indication, since it seems it can be false only If we hit the DoS limit?\r\n\r\nNo it's not just for indicating DoS limit reached, notice that it is also set to false after `BuildMockTemplate` is called. It prevents somebody from constructing a `MiniMiner` and calling `CalculateBumpFees()` or `CalculateTotalBumpFees()` multiple times, which could result in very incorrect results if the target feerate changes.",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-06T11:20:53Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126270559",
      "id" : 1126270559,
      "in_reply_to_id" : 1121184614,
      "line" : 57,
      "node_id" : "PRRC_kwDOABII585DIYZf",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 57,
      "original_position" : 63,
      "original_start_line" : 62,
      "path" : "src/node/mini_miner.cpp",
      "position" : 57,
      "pull_request_review_id" : 1326000785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126270559/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 56,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-06T12:27:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126270559",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126320439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126320439"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: It seems the rename to `GatherClusters` should have been squashed into efeee8b51d, but is in 5ee6f89e40 instead?",
      "commit_id" : "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "created_at" : "2023-03-06T11:59:54Z",
      "diff_hunk" : "@@ -1154,43 +1154,43 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     assert(false);\n }\n \n-std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126320439",
      "id" : 1126320439,
      "line" : 1157,
      "node_id" : "PRRC_kwDOABII585DIkk3",
      "original_commit_id" : "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "original_line" : 1157,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 5,
      "pull_request_review_id" : 1326000785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126320439/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T12:27:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126320439",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126716115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126716115"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit:\r\n```c++\r\nconst txiter& tx_iter = clustered_txs.at(i);\r\nfor (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\r\n     for (const CTxMemPoolEntry& entry : entries) {\r\n          const auto entry_it = mapTx.iterator_to(entry);\r\n          if (!visited(entry_it)) {\r\n              clustered_txs.push_back(entry_it);\r\n              ++to_process_count;  // we still need to process this\r\n           }\r\n     }\r\n}\r\n```",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T16:28:55Z",
      "diff_hunk" : "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }\n+            for (const CTxMemPoolEntry& child_entry : cluster.at(i)->GetMemPoolChildrenConst()) {\n+                const auto child_it = mapTx.iterator_to(child_entry);\n+                if (!visited(child_it)) {\n+                    cluster.push_back(child_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126716115",
      "id" : 1126716115,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DKFLT",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 1187,
      "original_position" : 76,
      "original_start_line" : 1177,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1326682860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126716115/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-06T19:40:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126716115",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126719573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126719573"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: this can just be `cluster.empty()`",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T16:31:02Z",
      "diff_hunk" : "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126719573",
      "id" : 1126719573,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DKGBV",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 1161,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1326682860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126719573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T19:40:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126719573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126727129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126727129"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could add above this line an early return:\r\n```c++\r\nif (txids.size > 500) return {};\r\n```",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T16:35:39Z",
      "diff_hunk" : "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126727129",
      "id" : 1126727129,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DKH3Z",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 1160,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1326682860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126727129/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T19:40:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126727129",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126736075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126736075"
         }
      },
      "author_association" : "MEMBER",
      "body" : "'outpoints' naming shadows the function's arg. Could\r\n```c++\r\nfor (const auto& [txid, _] : m_requested_outpoints_by_txid) {\r\n```",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T16:41:42Z",
      "diff_hunk" : "@@ -0,0 +1,314 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126736075",
      "id" : 1126736075,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DKKDL",
      "original_commit_id" : "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1326682860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126736075/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T19:40:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126736075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126752055"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126752055"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that it would be good to mention the 500 entries DoS limit here, plus the fact that we also return an empty vector if that is limit is breached - since that's something possible future users of this function would want to know about.",
      "commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "created_at" : "2023-03-06T16:51:57Z",
      "diff_hunk" : "@@ -585,6 +592,10 @@ class CTxMemPool\n         const Limits& limits,\n         bool fSearchForParents = true) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    /** Get entire list of connected transactions for all transactions in txids. All txids must\n+     * correspond to transactions in the mempool, otherwise this returns an empty vector. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126752055",
      "id" : 1126752055,
      "line" : 596,
      "node_id" : "PRRC_kwDOABII585DKN83",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 596,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/txmempool.h",
      "position" : 23,
      "pull_request_review_id" : 1326746650,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126752055/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T21:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126752055",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Another crash from the `mini_miner` target:\r\n```\r\nYFxlvAD6+fv7+/8BAADYAAAPZWVlZWVlZV9lZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl\r\nZWVlZWVlZWUgAGVlEWQX7AjobniKnjZtdcp6KPeFnFv/C89XAtDnqxwRFkNlZWVlZWVlZWVlZWVl\r\nZWVlZWVlZWVlZWVlZWVlZWVlZSVlZWVlZWVlY2VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl\r\nZWVlZWVlZWVlZWVlZ2VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWNtZWVlZWXNUm8gQwAAAGVl\r\nZWVlZWVlZWVlZWVlZWVlZWVlZWVclwAAtf//ZWVlAAAAAAY=\r\n```",
      "created_at" : "2023-03-06T17:36:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1456601450",
      "id" : 1456601450,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585W0flq",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 1,
         "laugh" : 0,
         "rocket" : 1,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456601450/reactions"
      },
      "updated_at" : "2023-03-06T17:36:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456601450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126878745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126878745"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, the rename was meant to be in the first commit. Thanks",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T18:44:52Z",
      "diff_hunk" : "@@ -1154,43 +1154,43 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     assert(false);\n }\n \n-std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126878745",
      "id" : 1126878745,
      "in_reply_to_id" : 1126320439,
      "line" : 1157,
      "node_id" : "PRRC_kwDOABII585DKs4Z",
      "original_commit_id" : "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "original_line" : 1157,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 41,
      "pull_request_review_id" : 1326996214,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126878745/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T18:44:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126878745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Moved rename of `GatherClusters(â¦)` to the right commit. Looking into the crash of the fuzzer.",
      "created_at" : "2023-03-06T18:50:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1456759368",
      "id" : 1456759368,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585W1GJI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456759368/reactions"
      },
      "updated_at" : "2023-03-06T18:50:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456759368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127069573"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127069573"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Great, thanks",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T21:49:13Z",
      "diff_hunk" : "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }\n+            for (const CTxMemPoolEntry& child_entry : cluster.at(i)->GetMemPoolChildrenConst()) {\n+                const auto child_it = mapTx.iterator_to(child_entry);\n+                if (!visited(child_it)) {\n+                    cluster.push_back(child_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127069573",
      "id" : 1127069573,
      "in_reply_to_id" : 1126716115,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DLbeF",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 1187,
      "original_position" : 76,
      "original_start_line" : 1177,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1327244857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127069573/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-06T21:49:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127069573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127076941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127076941"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good catch",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T21:56:48Z",
      "diff_hunk" : "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127076941",
      "id" : 1127076941,
      "in_reply_to_id" : 1126719573,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DLdRN",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 1161,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1327256950,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127076941/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:56:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127076941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127077341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127077341"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Okay, added",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T21:57:06Z",
      "diff_hunk" : "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127077341",
      "id" : 1127077341,
      "in_reply_to_id" : 1126727129,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DLdXd",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 1160,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1327257336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127077341/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:57:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127077341",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127079196"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079196"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Youâre right, fixed",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T21:58:45Z",
      "diff_hunk" : "@@ -0,0 +1,314 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127079196",
      "id" : 1127079196,
      "in_reply_to_id" : 1126736075,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DLd0c",
      "original_commit_id" : "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1327259392,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079196/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079196",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127091583"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127091583"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I decided to leave it as is for now.",
      "commit_id" : "e5b382a3db5167c118329f1885660d16e0192d22",
      "created_at" : "2023-03-06T22:13:27Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127091583",
      "id" : 1127091583,
      "in_reply_to_id" : 1120992192,
      "line" : 65,
      "node_id" : "PRRC_kwDOABII585DLg1_",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 65,
      "original_position" : 68,
      "original_start_line" : 66,
      "path" : "src/node/mini_miner.h",
      "position" : 65,
      "pull_request_review_id" : 1327277550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127091583/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 63,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-06T22:13:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127091583",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Changes since https://github.com/bitcoin/bitcoin/commit/32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b:\r\n- Addressed remaining review from @LarryRuane\r\n- Fixed renaming of GatherClusters(â¦) being in the wrong commit\r\n- Fixed crash bug surfaced by @dergoegge\r\n- Addressed review by @furszy ",
      "created_at" : "2023-03-06T22:15:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1457092354",
      "id" : 1457092354,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585W2XcC",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1457092354/reactions"
      },
      "updated_at" : "2023-03-06T22:16:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1457092354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Added myself as co-author to some commits per invitation of @glozow ",
      "created_at" : "2023-03-07T12:20:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1458076661",
      "id" : 1458076661,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585W6Hv1",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1458076661/reactions"
      },
      "updated_at" : "2023-03-07T12:20:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1458076661",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1128592892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128592892"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Indentation is broken, here and below (I initially thought the for loop ended here).",
      "commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "created_at" : "2023-03-07T21:10:11Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1128592892",
      "id" : 1128592892,
      "line" : 182,
      "node_id" : "PRRC_kwDOABII585DRPX8",
      "original_commit_id" : "5eb0158470da233dcc435b6284a2995e75037971",
      "original_line" : 182,
      "original_position" : 182,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 182,
      "pull_request_review_id" : 1326746650,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128592892/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T21:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128592892",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131024834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131024834"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This can be a `CTransactionRef` (aka shared_ptr) and not a plain tx copy. Transaction data never changes.\r\n\r\nJust need to adapt the constructor to call `GetSharedTx` instead.",
      "commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "created_at" : "2023-03-09T13:23:30Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131024834",
      "id" : 1131024834,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585DahHC",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.h",
      "position" : 20,
      "pull_request_review_id" : 1332819517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131024834/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T21:30:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131024834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131070331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131070331"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In a0d54e6b:\r\n\r\n`mempool.CalculateDescendants` returns the base parent transaction. So you could remove this line and add a comment to remember it.\r\n",
      "commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "created_at" : "2023-03-09T14:00:12Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131070331",
      "id" : 1131070331,
      "line" : 34,
      "node_id" : "PRRC_kwDOABII585DasN7",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 34,
      "pull_request_review_id" : 1332819517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131070331/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T21:30:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131070331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131091527"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131091527"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In https://github.com/bitcoin/bitcoin/commit/a0d54e6b8f8afab070de48911f3b11d4cdf289ff:\r\n\r\nnit:\r\nCould prevent extra `GetConflictTx` calls by moving the conflicting tx block of code inside the `mempool.exists` block.\r\ne.g.\r\n\r\n```c++\r\nfor (const auto& outpoint : outpoints) {\r\n     if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\r\n         // This UTXO is either confirmed or not yet submitted to mempool.\r\n         // If it's confirmed, no bump fee is required.\r\n         // If it's not yet submitted, we have no information, so return 0.\r\n         m_bump_fees.emplace(outpoint, 0);\r\n         continue;\r\n     }\r\n\r\n     // UXTO is created by transaction in mempool, add to map.\r\n     // Note: This will either create a missing entry or add the outpoint to an existing entry\r\n     m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\r\n\r\n     if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\r\n         // This outpoint is already being spent by another transaction in the mempool.\r\n         // We assume that the caller wants to replace this transaction (and its descendants).\r\n         // If the outpoint is from a mempool transaction, we still need to calculate its\r\n         // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\r\n         // removing the to-be-replaced entries. Note that this is only calculating bump fees.\r\n         // RBF fee rules should be handled separately.\r\n         \r\n         // Remove conflicting tx and descendants because they will be replaced as well. This case should be rare\r\n         // as the wallet won't normally attempt to replace transactions with descendants.\r\n         CTxMemPool::setEntries descendants;\r\n         mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\r\n         for (const auto& desc_txiter : descendants) {\r\n                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\r\n           }\r\n     }\r\n}\r\n```",
      "commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "created_at" : "2023-03-09T14:17:13Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131091527",
      "id" : 1131091527,
      "line" : 53,
      "node_id" : "PRRC_kwDOABII585DaxZH",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 53,
      "original_position" : 53,
      "original_start_line" : 44,
      "path" : "src/node/mini_miner.cpp",
      "position" : 53,
      "pull_request_review_id" : 1332819517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131091527/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 44,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T21:59:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131091527",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131618449"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131618449"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This has been puzzling me for a while.\r\n\r\nIt is not clear to me why need to calculate the descendants once more if the information is available in the cluster (it is just not accesible because data is unordered).\r\nCouldn't return from `GatherCluster` a map of tx id and its descendants instead? Like first going up into the DAG, starting with the highest parents, and then build the map<tx_id, vector<children>> with a recursive children call.\r\nIt looks like a heavy waste to recalculate the same twice.\r\n\r\nor well.. it is not that heavy because you set the 500 entries limit. hmm.. it still is duplicated work but it has a limit.\r\n\r\nAnother point is why continue traversing the children when the parent was marked to be removed? To double assert that the previous loop worked as expected? (if that is the case, what about decoupling the previous loop into a separate function and adding unit test coverage instead of all the runtime `Assume` calls?).",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-09T21:19:43Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131618449",
      "id" : 1131618449,
      "line" : 100,
      "node_id" : "PRRC_kwDOABII585DcyCR",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 100,
      "original_position" : 100,
      "original_start_line" : 90,
      "path" : "src/node/mini_miner.cpp",
      "position" : 100,
      "pull_request_review_id" : 1332819517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131618449/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 90,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-12T13:39:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131618449",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131782831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131782831"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This may be easier to comprehend:\r\n```\r\n// Compare by min(ancestor feerate, individual feerate), then iterator.\r\n//\r\n// The ancestor feerate of a high-feerate tx should be reduced by its\r\n// low-feerate ancestors, but the ancestor feerate of a low-feerate tx\r\n// should not be increased by its high-feerate ancestors.\r\nstruct AncestorFeerateComparator\r\n{\r\n    template<typename I>\r\n    bool operator()(const I& a, const I& b) const {\r\n        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\r\n            const CAmount afee{e.GetModFeesWithAncestors()};\r\n            const int64_t asize{e.GetSizeWithAncestors()};\r\n            const CAmount fee{e.GetModifiedFee()};\r\n            const int64_t size{e.GetTxSize()};\r\n            // Comparing ancestor feerate with individual feerate:\r\n            //     afee / asize <= fee / size\r\n            // Avoid division and possible loss of precision by\r\n            // multiplying both sides by the sizes:\r\n            return afee * size < fee * asize ?\r\n                       CFeeRate(afee, asize) :\r\n                       CFeeRate(fee, size);\r\n        };\r\n        CFeeRate a_feerate{min_feerate(a->second)};\r\n        CFeeRate b_feerate{min_feerate(b->second)};\r\n        if (a_feerate != b_feerate) {\r\n            return a_feerate > b_feerate;\r\n        }\r\n        // Compare by txid\r\n        return a->first < b->first;\r\n    }\r\n};\r\n```",
      "commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "created_at" : "2023-03-10T00:08:50Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131782831",
      "id" : 1131782831,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585DdaKv",
      "original_commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "original_line" : 146,
      "original_position" : 146,
      "original_start_line" : 125,
      "path" : "src/node/mini_miner.cpp",
      "position" : 146,
      "pull_request_review_id" : 1333993280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131782831/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 125,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-10T00:08:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131782831",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, Iâm just seeing the review comments, I will continue looking into them tomorrow. I just pushed a documentation change for `CalculateBumpFees(â¦)`, after I spent large parts of the day figuring out _why_ the fuzzer had produced a crash and convincing myself that the fix was actually correct.",
      "created_at" : "2023-03-10T02:03:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1463100208",
      "id" : 1463100208,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585XNSMw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1463100208/reactions"
      },
      "updated_at" : "2023-03-10T02:03:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1463100208",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1133185828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133185828"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I was curious about a possible relation between `sum(CalculateBumpFees)` over all outpoints, and `CalculateTotalBumpFees` for the same outpoints / target feerate.\r\nMy naive thought was that taking the sum over `CalculateBumpFees` might overestimate the total bump fee by counting the bumping of some mempool txs twice if there is a shared ancestry, and that the quantities should be equal if there is no shared ancestry. As a result, `CalculateTotalBumpFees` should never be larger than the sum of `CalculateBumpFees`.\r\nBut when I tried to test this hypothesis by changing the fuzz test here to not calculate just one but both quantities in each run (using two mini miners, see https://github.com/mzumsande/bitcoin/commit/e690c11a4c8e1d2d23037cc5439366ce722a9ef2) and then asserting that the above relation holds, it quickly fails - so where did I go wrong? ",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-12T04:40:38Z",
      "diff_hunk" : "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1133185828",
      "id" : 1133185828,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585Diwsk",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 85,
      "pull_request_review_id" : 1335963809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133185828/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-13T20:53:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133185828",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1134606456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1134606456"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, thatâs unexpected. I would also expect that `CalculateTotalBumpFees(â¦)` always is equal or smaller to the sum of individual bump fees. Iâll check it out.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-13T20:55:02Z",
      "diff_hunk" : "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1134606456",
      "id" : 1134606456,
      "in_reply_to_id" : 1133185828,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585DoLh4",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 85,
      "pull_request_review_id" : 1337937335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1134606456/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-13T20:55:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1134606456",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136045597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136045597"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit, it would be more logical for this check to be just after `to_process_count` is incremented below.",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-14T18:51:59Z",
      "diff_hunk" : "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136045597",
      "id" : 1136045597,
      "line" : 1177,
      "node_id" : "PRRC_kwDOABII585Dtq4d",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 1177,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 61,
      "pull_request_review_id" : 1340087246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136045597/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-24T21:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136045597",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136047228"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136047228"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit, I think you could eliminate the `to_process_count` variable, and just use the vector size instead.\r\n```suggestion\r\n        for (size_t i{0}; i < clustered_txs.size(); ++i) {\r\n```",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-14T18:53:42Z",
      "diff_hunk" : "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136047228",
      "id" : 1136047228,
      "line" : 1175,
      "node_id" : "PRRC_kwDOABII585DtrR8",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 1175,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 59,
      "pull_request_review_id" : 1340087246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136047228/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-24T21:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136047228",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136048292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136048292"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit, I think you can remove this code. (It's nice to eliminate special-case code, not only for simplicity, but to reduce testing.)",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-14T18:54:41Z",
      "diff_hunk" : "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136048292",
      "id" : 1136048292,
      "line" : 1166,
      "node_id" : "PRRC_kwDOABII585Dtrik",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 1166,
      "original_position" : 50,
      "original_start_line" : 1162,
      "path" : "src/txmempool.cpp",
      "position" : 50,
      "pull_request_review_id" : 1340087246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136048292/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1162,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T21:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136048292",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136051666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136051666"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's fine, suggestion withdrawn :)",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-14T18:57:40Z",
      "diff_hunk" : "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136051666",
      "id" : 1136051666,
      "in_reply_to_id" : 1121191113,
      "line" : 1177,
      "node_id" : "PRRC_kwDOABII585DtsXS",
      "original_commit_id" : "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "original_line" : 1177,
      "original_position" : 65,
      "original_start_line" : 1180,
      "path" : "src/txmempool.cpp",
      "position" : 61,
      "pull_request_review_id" : 1340087246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136051666/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1176,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T21:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136051666",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136136446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136136446"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The init value should be `CAmount{0}`, not `0` which would convert the summed items to `int`, see [std::accumulate](https://en.cppreference.com/w/cpp/algorithm/accumulate) under \"Common mistakes\". This caused the unexpected fuzzer behavior I saw, because the `int` could overflow.\r\nAlso, for `ancestor_package_size`, the init value should be `int64_t{0}`;",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T20:09:38Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               âââââââââââââââââââ\n+    //               â                 â\n+    //               â   Grandparent   â\n+    //               â    1700 vB      â\n+    //               â    1700 sats    â                    Target feerate: 10    s/vB\n+    //               â       1 s/vB    â    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               â                 â                           P1_ASFR:  9.84â¯s/vB\n+    //               ââââââââ²ââââ²âââââââ                           P2_ASFR:  2.47 s/vB\n+    //                      â   â                                   C_ASFR: 10.27 s/vB\n+    // âââââââââââââââââ    â   â    ââââââââââââââââ\n+    // â               ââââââ   ââââââ¤              â             â C_FR < TFR < C_ASFR\n+    // â   Parent 1    â             â   Parent 2   â\n+    // â    200 vB     â             â    200 vB    â\n+    // â  17000 sats   â             â   3000 sats  â\n+    // â     85 s/vB   â             â     15 s/vB  â\n+    // â               â             â              â\n+    // âââââââââââââ²ââââ             âââââ²âââââââââââ\n+    //             â                     â\n+    //             â    âââââââââââââ    â\n+    //             ââââââ¤           ââââââ\n+    //                  â   Child   â\n+    //                  â  100 vB   â\n+    //                  â  900 sats â\n+    //                  â    9 s/vB â\n+    //                  â           â\n+    //                  âââââââââââââ\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate Ã tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate Ã ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());\n+            const CTransaction& tx = (*iter)->second.GetTx();\n+            for (const auto& input : tx.vin) {\n+                if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                    to_process.insert(parent_it);\n+                    ancestors.insert(parent_it);\n+                }\n+            }\n+            to_process.erase(iter);\n+        }\n+    }\n+    const auto ancestor_package_size = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,\n+        [](int64_t sum, const auto it) {return sum + it->second.GetTxSize();});\n+    const auto ancestor_package_fee = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136136446",
      "id" : 1136136446,
      "line" : 354,
      "node_id" : "PRRC_kwDOABII585DuBD-",
      "original_commit_id" : "82d068ea0e247e7deb3f4dd2c222db3d3eb6d0e4",
      "original_line" : 354,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 354,
      "pull_request_review_id" : 1340199248,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136136446/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T20:25:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136136446",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136146262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136146262"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I commented below for this. After fixing this, the fuzzer doesn't crash anymore (at least not immediately, haven't run it for long). \r\nI wonder if it might make sense to adjust the fuzz test permanently similar to my branch above and assert `sum(CalculateBumpFees) >= CalculateTotalBumpFees()`, if that is really the expectation - in general, I like it if fuzz tests contain asserts that test actual non-trivial high-level expectations we have for the code, and don't just run over the code \"blindly\".",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T20:18:26Z",
      "diff_hunk" : "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136146262",
      "id" : 1136146262,
      "in_reply_to_id" : 1133185828,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585DuDdW",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 85,
      "pull_request_review_id" : 1340211226,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136146262/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T21:47:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136146262",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136182559"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136182559"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think I need to touch five or six different places for this. Is that worth it?",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T20:48:44Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136182559",
      "id" : 1136182559,
      "in_reply_to_id" : 1131024834,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585DuMUf",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.h",
      "position" : 20,
      "pull_request_review_id" : 1340256487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136182559/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T20:48:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136182559",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136214058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136214058"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve updated the comment to mention the 500 entry limit and the resulting empty vector.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T21:14:39Z",
      "diff_hunk" : "@@ -585,6 +592,10 @@ class CTxMemPool\n         const Limits& limits,\n         bool fSearchForParents = true) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    /** Get entire list of connected transactions for all transactions in txids. All txids must\n+     * correspond to transactions in the mempool, otherwise this returns an empty vector. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136214058",
      "id" : 1136214058,
      "in_reply_to_id" : 1126752055,
      "line" : 596,
      "node_id" : "PRRC_kwDOABII585DuUAq",
      "original_commit_id" : "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "original_line" : 596,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/txmempool.h",
      "position" : 23,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136214058/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136214058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136215648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136215648"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good catch. Iâve removed the line and amended the comment to clarify that the transaction is part of the descendants.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T21:16:00Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136215648",
      "id" : 1136215648,
      "in_reply_to_id" : 1131070331,
      "line" : 34,
      "node_id" : "PRRC_kwDOABII585DuUZg",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 34,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136215648/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136215648",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136217858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136217858"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, Iâve adopted your suggestion and moved `!mempool.exists` first.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T21:17:56Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136217858",
      "id" : 1136217858,
      "in_reply_to_id" : 1131091527,
      "line" : 53,
      "node_id" : "PRRC_kwDOABII585DuU8C",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 53,
      "original_position" : 53,
      "original_start_line" : 44,
      "path" : "src/node/mini_miner.cpp",
      "position" : 53,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136217858/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 44,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136217858",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136294354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136294354"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks I took your suggestion with slightly more elaborate variable names.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T22:31:24Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136294354",
      "id" : 1136294354,
      "in_reply_to_id" : 1131782831,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585DunnS",
      "original_commit_id" : "d227d394cdfc377169888dcf1d9f574f02903065",
      "original_line" : 146,
      "original_position" : 146,
      "original_start_line" : 125,
      "path" : "src/node/mini_miner.cpp",
      "position" : 146,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136294354/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 125,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136294354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136299879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136299879"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Uff, great catch, thanks!",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T22:34:01Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               âââââââââââââââââââ\n+    //               â                 â\n+    //               â   Grandparent   â\n+    //               â    1700 vB      â\n+    //               â    1700 sats    â                    Target feerate: 10    s/vB\n+    //               â       1 s/vB    â    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               â                 â                           P1_ASFR:  9.84â¯s/vB\n+    //               ââââââââ²ââââ²âââââââ                           P2_ASFR:  2.47 s/vB\n+    //                      â   â                                   C_ASFR: 10.27 s/vB\n+    // âââââââââââââââââ    â   â    ââââââââââââââââ\n+    // â               ââââââ   ââââââ¤              â             â C_FR < TFR < C_ASFR\n+    // â   Parent 1    â             â   Parent 2   â\n+    // â    200 vB     â             â    200 vB    â\n+    // â  17000 sats   â             â   3000 sats  â\n+    // â     85 s/vB   â             â     15 s/vB  â\n+    // â               â             â              â\n+    // âââââââââââââ²ââââ             âââââ²âââââââââââ\n+    //             â                     â\n+    //             â    âââââââââââââ    â\n+    //             ââââââ¤           ââââââ\n+    //                  â   Child   â\n+    //                  â  100 vB   â\n+    //                  â  900 sats â\n+    //                  â    9 s/vB â\n+    //                  â           â\n+    //                  âââââââââââââ\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate Ã tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate Ã ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());\n+            const CTransaction& tx = (*iter)->second.GetTx();\n+            for (const auto& input : tx.vin) {\n+                if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                    to_process.insert(parent_it);\n+                    ancestors.insert(parent_it);\n+                }\n+            }\n+            to_process.erase(iter);\n+        }\n+    }\n+    const auto ancestor_package_size = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,\n+        [](int64_t sum, const auto it) {return sum + it->second.GetTxSize();});\n+    const auto ancestor_package_fee = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136299879",
      "id" : 1136299879,
      "in_reply_to_id" : 1136136446,
      "line" : 354,
      "node_id" : "PRRC_kwDOABII585Duo9n",
      "original_commit_id" : "82d068ea0e247e7deb3f4dd2c222db3d3eb6d0e4",
      "original_line" : 354,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 354,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136299879/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136299879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136311603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136311603"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, I adopted your suggestion.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T22:42:48Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136311603",
      "id" : 1136311603,
      "in_reply_to_id" : 1131024834,
      "line" : 20,
      "node_id" : "PRRC_kwDOABII585Dur0z",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.h",
      "position" : 20,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136311603/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136311603",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136319884"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136319884"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, this improves the fuzzer. Iâve adopted your suggested change.",
      "commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "created_at" : "2023-03-14T22:52:22Z",
      "diff_hunk" : "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136319884",
      "id" : 1136319884,
      "in_reply_to_id" : 1133185828,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585Dut2M",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : null,
      "path" : "src/test/fuzz/mini_miner.cpp",
      "position" : 85,
      "pull_request_review_id" : 1340290546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136319884/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-14T22:56:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136319884",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136330617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136330617"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I see how this might be a performance improvement, but I donât think this is going to be heavy enough to warrant this level of rewrite at this stage in the PR. Perhaps this could be done in a follow-up.",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-14T23:05:27Z",
      "diff_hunk" : "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136330617",
      "id" : 1136330617,
      "in_reply_to_id" : 1131618449,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585Duwd5",
      "original_commit_id" : "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "original_line" : 101,
      "original_position" : 100,
      "original_start_line" : 90,
      "path" : "src/node/mini_miner.cpp",
      "position" : 101,
      "pull_request_review_id" : 1340411560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136330617/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 91,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-14T23:05:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136330617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve run both of the fuzz targets for 48-CPU-hours last night, and have not seen another crash bug.",
      "created_at" : "2023-03-15T15:17:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1470194229",
      "id" : 1470194229,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585XoWI1",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1470194229/reactions"
      },
      "updated_at" : "2023-03-15T15:17:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1470194229",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@theStack: Thanks for the suggestion. I tried implementing this and found that it does save the six lines here, but it also required special casing two places downstream in my follow-up PR. While the fixes were simple, I feel that it makes the interface slightly worse for the downstream consumer, so Iâm ambivalent on the change.",
      "created_at" : "2023-03-16T20:17:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1472679470",
      "id" : 1472679470,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585Xx04u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1472679470/reactions"
      },
      "updated_at" : "2023-03-16T20:17:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1472679470",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-21T20:30:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1478541182",
      "id" : 1478541182,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585YIL9-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478541182/reactions"
      },
      "updated_at" : "2023-03-21T20:30:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478541182",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145355201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145355201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unimplemented function",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-22T20:09:35Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransactionRef tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetSharedTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return *tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145355201",
      "id" : 1145355201,
      "line" : 43,
      "node_id" : "PRRC_kwDOABII585ERLvB",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 43,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.h",
      "position" : 43,
      "pull_request_review_id" : 1353401668,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145355201/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T21:09:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145355201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145368125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145368125"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Strictly speaking, the descendant size can only be greater than the ancestor size.\r\n\r\n```suggestion\r\n            Assume(descendant->second.vsize_with_ancestors > anc->second.GetTxSize());\r\n```",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-22T20:21:53Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145368125",
      "id" : 1145368125,
      "line" : 173,
      "node_id" : "PRRC_kwDOABII585ERO49",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 173,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 173,
      "pull_request_review_id" : 1353401668,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 1,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145368125/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T21:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145368125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145373839"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145373839"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As the ancestors structure is a set and we are merely looping over it, I don't see how this can realistically happen. Two different iterators pointing to the same object? (if that is the worry, then the problem is with the iterators usage approach)",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-22T20:28:10Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145373839",
      "id" : 1145373839,
      "line" : 173,
      "node_id" : "PRRC_kwDOABII585ERQSP",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 173,
      "original_position" : 173,
      "original_start_line" : 171,
      "path" : "src/node/mini_miner.cpp",
      "position" : 173,
      "pull_request_review_id" : 1353401668,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145373839/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 171,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T21:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145373839",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145394065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145394065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What is the reason behind this separate removal loop? Couldn't we merge it with the loop that is above?\r\n\r\nAre you worry about the `ancestors` set having a parent and a child so if first removes the child then the parent will not find it and then crash?",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-22T20:49:50Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145394065",
      "id" : 1145394065,
      "line" : 189,
      "node_id" : "PRRC_kwDOABII585ERVOR",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 189,
      "original_position" : 189,
      "original_start_line" : 178,
      "path" : "src/node/mini_miner.cpp",
      "position" : 189,
      "pull_request_review_id" : 1353401668,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145394065/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 178,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T21:09:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145394065",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146476492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146476492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit:\r\nisn't this assertion redundant?\r\nIf `iter` would be equal to `end()`, then `to_process.empty()` would be true. Which breaks the loop.",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-23T16:41:45Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               âââââââââââââââââââ\n+    //               â                 â\n+    //               â   Grandparent   â\n+    //               â    1700 vB      â\n+    //               â    1700 sats    â                    Target feerate: 10    s/vB\n+    //               â       1 s/vB    â    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               â                 â                           P1_ASFR:  9.84â¯s/vB\n+    //               ââââââââ²ââââ²âââââââ                           P2_ASFR:  2.47 s/vB\n+    //                      â   â                                   C_ASFR: 10.27 s/vB\n+    // âââââââââââââââââ    â   â    ââââââââââââââââ\n+    // â               ââââââ   ââââââ¤              â             â C_FR < TFR < C_ASFR\n+    // â   Parent 1    â             â   Parent 2   â\n+    // â    200 vB     â             â    200 vB    â\n+    // â  17000 sats   â             â   3000 sats  â\n+    // â     85 s/vB   â             â     15 s/vB  â\n+    // â               â             â              â\n+    // âââââââââââââ²ââââ             âââââ²âââââââââââ\n+    //             â                     â\n+    //             â    âââââââââââââ    â\n+    //             ââââââ¤           ââââââ\n+    //                  â   Child   â\n+    //                  â  100 vB   â\n+    //                  â  900 sats â\n+    //                  â    9 s/vB â\n+    //                  â           â\n+    //                  âââââââââââââ\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate Ã tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate Ã ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146476492",
      "id" : 1146476492,
      "line" : 351,
      "node_id" : "PRRC_kwDOABII585EVdfM",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 351,
      "original_position" : 351,
      "original_start_line" : 349,
      "path" : "src/node/mini_miner.cpp",
      "position" : 351,
      "pull_request_review_id" : 1355048144,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146476492/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 349,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-23T16:45:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146476492",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146927271"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146927271"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: Seems like this pair of curly-braces and the extra-indent is a left-over from earlier code (probably involving a `LOCK`?) and can just be removed.",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-23T22:08:13Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               âââââââââââââââââââ\n+    //               â                 â\n+    //               â   Grandparent   â\n+    //               â    1700 vB      â\n+    //               â    1700 sats    â                    Target feerate: 10    s/vB\n+    //               â       1 s/vB    â    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               â                 â                           P1_ASFR:  9.84â¯s/vB\n+    //               ââââââââ²ââââ²âââââââ                           P2_ASFR:  2.47 s/vB\n+    //                      â   â                                   C_ASFR: 10.27 s/vB\n+    // âââââââââââââââââ    â   â    ââââââââââââââââ\n+    // â               ââââââ   ââââââ¤              â             â C_FR < TFR < C_ASFR\n+    // â   Parent 1    â             â   Parent 2   â\n+    // â    200 vB     â             â    200 vB    â\n+    // â  17000 sats   â             â   3000 sats  â\n+    // â     85 s/vB   â             â     15 s/vB  â\n+    // â               â             â              â\n+    // âââââââââââââ²ââââ             âââââ²âââââââââââ\n+    //             â                     â\n+    //             â    âââââââââââââ    â\n+    //             ââââââ¤           ââââââ\n+    //                  â   Child   â\n+    //                  â  100 vB   â\n+    //                  â  900 sats â\n+    //                  â    9 s/vB â\n+    //                  â           â\n+    //                  âââââââââââââ\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate Ã tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate Ã ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146927271",
      "id" : 1146927271,
      "line" : 338,
      "node_id" : "PRRC_kwDOABII585EXLin",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 338,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 338,
      "pull_request_review_id" : 1355735961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146927271/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-23T22:30:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146927271",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146930797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146930797"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\r\n```\t\r\n",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-23T22:13:35Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146930797",
      "id" : 1146930797,
      "line" : 204,
      "node_id" : "PRRC_kwDOABII585EXMZt",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 204,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 204,
      "pull_request_review_id" : 1355741768,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146930797/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-23T22:13:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146930797",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146941331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146941331"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "minor suggestion: in the unit test's `sanity_check` function, could also check that all (positive) bumpfee entries refer to one of the passed tx's:\r\n```suggestion\r\n    // No negative bumpfees. All positive bumpfees must refer to one of the passed tx's outputs.\r\n    for (const auto& [outpoint, fee] : bumpfees) {\r\n        if (fee < 0) return false;\r\n        if (fee == 0) continue;\r\n        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\r\n        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\r\n            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\r\n        });\r\n        if (!found) return false;\r\n    }\r\n```\r\n(unfortunately a bit ugly with this extra variable needed... C++20 fixes this).",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-23T22:29:51Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146941331",
      "id" : 1146941331,
      "line" : 45,
      "node_id" : "PRRC_kwDOABII585EXO-T",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 45,
      "original_position" : 45,
      "original_start_line" : 42,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 45,
      "pull_request_review_id" : 1355735961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146941331/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 42,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-23T22:30:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146941331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146944495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146944495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is just a nit but I wouldn't call this `tx5_feerate`, it's the `tx5_tx6_package_feerate`.\r\n\r\nAt least in my head, when we talk about certain tx feerate, we talk about the relation between the tx ancestors fee and their size (including the tx itself). Which does not include the descendants (in this case, tx6)",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-23T22:35:30Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146944495",
      "id" : 1146944495,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EXPvv",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 216,
      "original_position" : 203,
      "original_start_line" : 197,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1355761439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146944495/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T16:47:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146944495",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146945075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146945075"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`all_entries` is not used anywhere.",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-23T22:36:35Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146945075",
      "id" : 1146945075,
      "line" : 136,
      "node_id" : "PRRC_kwDOABII585EXP4z",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : 130,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 136,
      "pull_request_review_id" : 1355761439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146945075/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 130,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-23T23:31:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146945075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147030012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147030012"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This else-branch is currently dead code (as can easily be verified by putting an `assert(false)` inside); due to the huge modified fee-rate of tx6, tx5/tx6 are way above all of the tested fee-rate-targets (>1000sats/vbyte) and always get mini-mined, i.e. no fee-bump happens. See also [review comment below](https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147032833).",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-24T01:26:29Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147030012",
      "id" : 1147030012,
      "line" : 209,
      "node_id" : "PRRC_kwDOABII585EXkn8",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 209,
      "original_position" : 209,
      "original_start_line" : 207,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 209,
      "pull_request_review_id" : 1355882419,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147030012/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 207,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T01:52:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147030012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147032833"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147032833"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This fee delta seems excessive (leading to a fee-rate of >1 million sats/vbyte for tx6), I guess just using one of `{high,normal,low}_fee` should also be fine? Then the testing code-path of getting a bumpfee for tx5/tx6 would be hit (see also [comment above](https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147030012)).",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-24T01:32:27Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147032833",
      "id" : 1147032833,
      "line" : 89,
      "node_id" : "PRRC_kwDOABII585EXlUB",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : 87,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 89,
      "pull_request_review_id" : 1355882419,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147032833/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 87,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T01:51:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147032833",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147037874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147037874"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n```\r\nnit: Not that it harms in any way, but wtxid seems not to be relevant for these unit tests, so could remove this.",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-24T01:45:27Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147037874",
      "id" : 1147037874,
      "line" : 28,
      "node_id" : "PRRC_kwDOABII585EXmiy",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : 25,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 28,
      "pull_request_review_id" : 1355882419,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147037874/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 25,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T01:49:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147037874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1148418379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418379"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: unused variable, can be removed\r\n```suggestion\r\n```",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-25T19:06:56Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1148418379",
      "id" : 1148418379,
      "line" : 412,
      "node_id" : "PRRC_kwDOABII585Ec3lL",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 412,
      "original_position" : 412,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 412,
      "pull_request_review_id" : 1357885542,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418379/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-25T19:12:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418379",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1148418808"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418808"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "pedantic-nit:\r\n```suggestion\r\n    // Note that each transaction's ancestor size is 1 or 3, and each descendant size is 1, 2 or 3.\r\n```\r\nThe descendant count of 2 is the rare case here, only applying for parent-txs txp0 and txp49\r\n(for the fun of it, created a functional test for verifying this: https://github.com/theStack/bitcoin/blob/functional_test_mempool_zigzag_playground/test/functional/mempool_zigzag.py).",
      "commit_id" : "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "created_at" : "2023-03-25T19:10:19Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+\n+    // Add chain of size 500\n+    TestMemPoolEntryHelper entry;\n+    std::vector<uint256> chain_txids;\n+    auto& lasttx = m_coinbase_txns[0];\n+    for (auto i{0}; i < 500; ++i) {\n+        const auto tx = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+        pool.addUnchecked(entry.Fee(CENT).FromTx(tx));\n+        chain_txids.push_back(tx->GetHash());\n+        lasttx = tx;\n+    }\n+    const auto cluster_500tx = pool.GatherClusters({lasttx->GetHash()});\n+    CTxMemPool::setEntries cluster_500tx_set{cluster_500tx.begin(), cluster_500tx.end()};\n+    BOOST_CHECK_EQUAL(cluster_500tx.size(), cluster_500tx_set.size());\n+    const auto vec_iters_500 = pool.GetIterVec(chain_txids);\n+    for (const auto& iter : vec_iters_500) BOOST_CHECK(cluster_500tx_set.count(iter));\n+\n+    // GatherClusters stops at 500 transactions.\n+    const auto tx_501 = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(CENT).FromTx(tx_501));\n+    const auto cluster_501 = pool.GatherClusters({tx_501->GetHash()});\n+    BOOST_CHECK_EQUAL(cluster_501.size(), 0);\n+\n+    // Zig Zag cluster:\n+    // txp0     txp1     txp2    ...  txp48  txp49\n+    //    \\    /    \\   /   \\            \\   /\n+    //     txc0     txc1    txc2  ...    txc48\n+    // Note that each transaction's ancestor size is 2 or 3, and each descendant size is 2 or 3.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1148418808",
      "id" : 1148418808,
      "line" : 442,
      "node_id" : "PRRC_kwDOABII585Ec3r4",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 442,
      "original_position" : 442,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 442,
      "pull_request_review_id" : 1357885542,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418808/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-25T19:12:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418808",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149399579"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149399579"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I am not sure I follow. For historical reasons, transactions are included in their own ancestor set and their own descendant set. So while we are iterating over descendants, we could be evaluating a transaction itself that has no ancestors left after they were picked into our âvirtual blockâ. If the evaluated transaction doesnât have ancestors left, and we get its size with ancestors, we are comparing its own size with its own size in this inequality. Therefore, same size must be permitted.\r\n\r\nI tested my expectation that this would cause failures by turning the `Assume` into an `assert` and then running with either `>=` or `>`. The `assert` is triggered for `>`.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T15:10:22Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149399579",
      "id" : 1149399579,
      "in_reply_to_id" : 1145368125,
      "line" : 174,
      "node_id" : "PRRC_kwDOABII585EgnIb",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 174,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 174,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149399579/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149399579",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149422663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149422663"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "See response on prior comment",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T15:26:24Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149422663",
      "id" : 1149422663,
      "in_reply_to_id" : 1145373839,
      "line" : 174,
      "node_id" : "PRRC_kwDOABII585EgsxH",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 174,
      "original_position" : 173,
      "original_start_line" : 171,
      "path" : "src/node/mini_miner.cpp",
      "position" : 174,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149422663/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 172,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149422663",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149445980"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149445980"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, it felt safer to first update everything, then to start deleting things. I did try combining the loops and it did not break anything, though. Still deciding, maybe this could be a follow-up.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T15:42:00Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149445980",
      "id" : 1149445980,
      "in_reply_to_id" : 1145394065,
      "line" : 190,
      "node_id" : "PRRC_kwDOABII585Egydc",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 190,
      "original_position" : 189,
      "original_start_line" : 178,
      "path" : "src/node/mini_miner.cpp",
      "position" : 190,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149445980/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 179,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149445980",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149447519"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149447519"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, removed extraneous curly braces",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T15:43:07Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               âââââââââââââââââââ\n+    //               â                 â\n+    //               â   Grandparent   â\n+    //               â    1700 vB      â\n+    //               â    1700 sats    â                    Target feerate: 10    s/vB\n+    //               â       1 s/vB    â    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               â                 â                           P1_ASFR:  9.84â¯s/vB\n+    //               ââââââââ²ââââ²âââââââ                           P2_ASFR:  2.47 s/vB\n+    //                      â   â                                   C_ASFR: 10.27 s/vB\n+    // âââââââââââââââââ    â   â    ââââââââââââââââ\n+    // â               ââââââ   ââââââ¤              â             â C_FR < TFR < C_ASFR\n+    // â   Parent 1    â             â   Parent 2   â\n+    // â    200 vB     â             â    200 vB    â\n+    // â  17000 sats   â             â   3000 sats  â\n+    // â     85 s/vB   â             â     15 s/vB  â\n+    // â               â             â              â\n+    // âââââââââââââ²ââââ             âââââ²âââââââââââ\n+    //             â                     â\n+    //             â    âââââââââââââ    â\n+    //             ââââââ¤           ââââââ\n+    //                  â   Child   â\n+    //                  â  100 vB   â\n+    //                  â  900 sats â\n+    //                  â    9 s/vB â\n+    //                  â           â\n+    //                  âââââââââââââ\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate Ã tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate Ã ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149447519",
      "id" : 1149447519,
      "in_reply_to_id" : 1146927271,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Egy1f",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 338,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149447519/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149447519",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149653633"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149653633"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, agreed. Gonna remove it",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T18:36:32Z",
      "diff_hunk" : "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               âââââââââââââââââââ\n+    //               â                 â\n+    //               â   Grandparent   â\n+    //               â    1700 vB      â\n+    //               â    1700 sats    â                    Target feerate: 10    s/vB\n+    //               â       1 s/vB    â    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               â                 â                           P1_ASFR:  9.84â¯s/vB\n+    //               ââââââââ²ââââ²âââââââ                           P2_ASFR:  2.47 s/vB\n+    //                      â   â                                   C_ASFR: 10.27 s/vB\n+    // âââââââââââââââââ    â   â    ââââââââââââââââ\n+    // â               ââââââ   ââââââ¤              â             â C_FR < TFR < C_ASFR\n+    // â   Parent 1    â             â   Parent 2   â\n+    // â    200 vB     â             â    200 vB    â\n+    // â  17000 sats   â             â   3000 sats  â\n+    // â     85 s/vB   â             â     15 s/vB  â\n+    // â               â             â              â\n+    // âââââââââââââ²ââââ             âââââ²âââââââââââ\n+    //             â                     â\n+    //             â    âââââââââââââ    â\n+    //             ââââââ¤           ââââââ\n+    //                  â   Child   â\n+    //                  â  100 vB   â\n+    //                  â  900 sats â\n+    //                  â    9 s/vB â\n+    //                  â           â\n+    //                  âââââââââââââ\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate Ã tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate Ã ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149653633",
      "id" : 1149653633,
      "in_reply_to_id" : 1146476492,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EhlKB",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 351,
      "original_position" : 351,
      "original_start_line" : 349,
      "path" : "src/node/mini_miner.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149653633/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149653633",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149659725"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149659725"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Removed unimplemented function",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T18:41:45Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransactionRef tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetSharedTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return *tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149659725",
      "id" : 1149659725,
      "in_reply_to_id" : 1145355201,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EhmpN",
      "original_commit_id" : "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "original_line" : 43,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.h",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149659725/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149659725",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149709427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709427"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Since Iâve removed the special casing that makes us bail if we start with 500 in the first place, I have left it at the start of the loop.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:33:46Z",
      "diff_hunk" : "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149709427",
      "id" : 1149709427,
      "in_reply_to_id" : 1136045597,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Ehyxz",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 1177,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709427/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149709631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709631"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve adopted your suggestion, thanks",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:34:01Z",
      "diff_hunk" : "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149709631",
      "id" : 1149709631,
      "in_reply_to_id" : 1136047228,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Ehy0_",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 1175,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709631/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149712008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149712008"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, if txids is empty, we already return an empty vector anyway, and the 500 limit is already checked at the start of the loop. Sorry, @furszy, I changed my mind about [your prior suggestion to add an early exit](https://github.com/bitcoin/bitcoin/pull/27021/files#diff-c065d4cd2398ad0dbcef393c5dfc53f465bf44723348892395fffd2fb3bac522).",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:36:45Z",
      "diff_hunk" : "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149712008",
      "id" : 1149712008,
      "in_reply_to_id" : 1136048292,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EhzaI",
      "original_commit_id" : "cf1636078f7e97110cab15646110fcc1ce935136",
      "original_line" : 1166,
      "original_position" : 50,
      "original_start_line" : 1162,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149712008/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149712008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149719267"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149719267"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks that sounds like a good idea.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:44:39Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149719267",
      "id" : 1149719267,
      "in_reply_to_id" : 1146941331,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eh1Lj",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 47,
      "original_position" : 45,
      "original_start_line" : 42,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149719267/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149719267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149727812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149727812"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, removed",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:54:21Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149727812",
      "id" : 1149727812,
      "in_reply_to_id" : 1148418379,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eh3RE",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 412,
      "original_position" : 412,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149727812/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149727812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149728848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149728848"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, you are most correct!",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:55:30Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+\n+    // Add chain of size 500\n+    TestMemPoolEntryHelper entry;\n+    std::vector<uint256> chain_txids;\n+    auto& lasttx = m_coinbase_txns[0];\n+    for (auto i{0}; i < 500; ++i) {\n+        const auto tx = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+        pool.addUnchecked(entry.Fee(CENT).FromTx(tx));\n+        chain_txids.push_back(tx->GetHash());\n+        lasttx = tx;\n+    }\n+    const auto cluster_500tx = pool.GatherClusters({lasttx->GetHash()});\n+    CTxMemPool::setEntries cluster_500tx_set{cluster_500tx.begin(), cluster_500tx.end()};\n+    BOOST_CHECK_EQUAL(cluster_500tx.size(), cluster_500tx_set.size());\n+    const auto vec_iters_500 = pool.GetIterVec(chain_txids);\n+    for (const auto& iter : vec_iters_500) BOOST_CHECK(cluster_500tx_set.count(iter));\n+\n+    // GatherClusters stops at 500 transactions.\n+    const auto tx_501 = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(CENT).FromTx(tx_501));\n+    const auto cluster_501 = pool.GatherClusters({tx_501->GetHash()});\n+    BOOST_CHECK_EQUAL(cluster_501.size(), 0);\n+\n+    // Zig Zag cluster:\n+    // txp0     txp1     txp2    ...  txp48  txp49\n+    //    \\    /    \\   /   \\            \\   /\n+    //     txc0     txc1    txc2  ...    txc48\n+    // Note that each transaction's ancestor size is 2 or 3, and each descendant size is 2 or 3.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149728848",
      "id" : 1149728848,
      "in_reply_to_id" : 1148418808,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eh3hQ",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 442,
      "original_position" : 442,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149728848/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149728848",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149730720"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149730720"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for catching that. I amended the above fee and tested that this else-branch now is executed.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:57:40Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149730720",
      "id" : 1149730720,
      "in_reply_to_id" : 1147030012,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eh3-g",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 217,
      "original_position" : 209,
      "original_start_line" : 207,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149730720/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149730720",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149731460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731460"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, Iâve reduced the fee used here and verified that the else branch mentioned below now gets traversed",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:58:31Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149731460",
      "id" : 1149731460,
      "in_reply_to_id" : 1147032833,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eh4KE",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 89,
      "original_position" : 89,
      "original_start_line" : 87,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731460/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731460",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149731957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve removed `all_entries`. Thanks for catching that",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T19:59:07Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149731957",
      "id" : 1149731957,
      "in_reply_to_id" : 1146945075,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eh4R1",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : 130,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731957/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731957",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149782804"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149782804"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Iâve renamed the variable and better explained whatâs going on here.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T20:56:44Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149782804",
      "id" : 1149782804,
      "in_reply_to_id" : 1146944495,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EiEsU",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 216,
      "original_position" : 203,
      "original_start_line" : 197,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149782804/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149782804",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149783183"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149783183"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, Iâve removed the unnecessary definitions here",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-27T20:57:08Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149783183",
      "id" : 1149783183,
      "in_reply_to_id" : 1147037874,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EiEyP",
      "original_commit_id" : "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : 25,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1359286170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149783183/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-27T21:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149783183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Left few more comments.\r\n> \r\n> Plus, while was checking the 1p1c test, couldn't resist myself and made it more friendly [furszy@5dc4b89](https://github.com/furszy/bitcoin-core/commit/5dc4b8957c7a65746666cb5f3e7bd6270b21f8c2). Feel free to take it if you like it.\r\n\r\nSorry, I was just going through the commits one by one and only rediscovered this suggestion this evening. It looks like there is some good stuff there. Iâll aim to incorporate it shortly, but it might not be tonight.",
      "created_at" : "2023-03-27T23:05:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1485975148",
      "id" : 1485975148,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585Yki5s",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1485975148/reactions"
      },
      "updated_at" : "2023-03-27T23:05:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1485975148",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1151002690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151002690"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Just a note to other reviews who also think this looks weird: `it` is a `const` reference being passed to `visited()` so you'd think `it` (or what it points to) can't be modified, so seems like `visited()` must have no effect. Yet we're ignoring its return value. The answer is that `visited()` does modify `it->m_epoch_marker` but that member is `mutable`. To me, it seems like this shouldn't be marked mutable because it does change the state of `*it` in a way that affects behavior, not just caching or locking (the usual use cases for `mutable`). Anyway, nothing wrong with the PR, just wanted to mention it in case others were confused as well.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-28T18:21:39Z",
      "diff_hunk" : "@@ -1140,3 +1153,30 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+    // necessarily mean the entry has been processed.\n+    WITH_FRESH_EPOCH(m_epoch);\n+    for (const auto& it : clustered_txs) {\n+        visited(it);\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1151002690",
      "id" : 1151002690,
      "line" : 1166,
      "node_id" : "PRRC_kwDOABII585EmuhC",
      "original_commit_id" : "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "original_line" : 1166,
      "original_position" : 50,
      "original_start_line" : 1164,
      "path" : "src/txmempool.cpp",
      "position" : 50,
      "pull_request_review_id" : 1361682595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151002690/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 1164,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-29T05:17:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151002690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1151062167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151062167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This comment is for a possible follow-up PR, not suggesting any change here, just wanted to document this thought.\r\n\r\nAs an alternative to this flag, it might be more natural to use \"chained methods\" so you could write something like:\r\n```\r\nstd::map<COutPoint, CAmount> node::MiniMiner(pool, outpoints)\r\n        .BuildMockTemplate(target_feerate)\r\n        .CalculateBumpFees();\r\n```\r\n(This technique is used [here](https://github.com/bitcoin/bitcoin/blob/fdd363ebd917e5916742587608d59023ced513e1/src/blockfilter.cpp#L29) for example, and is common in more modern languages like Rust).\r\n\r\n`BuildMockTemplate()` would `return *this` instead of `void`.\r\n\r\nOf course, `CalculateBumpFees()` and `CalculateTotalBumpFees()` would not call `BuildMockTemplate()` as they currently do. We'd also need `BuildMockTemplate()` to save the feerate in the object for either of the calculate functions to us; we don't want the caller to have to specify the same value twice. The feerate should probably be accessible using a getter.\r\n\r\nA nice property of this approach is that for testing, the results of each \"stage\" could be instantiated into variables, and inspection methods or `SanityCheck()` could be called on them.\r\n\r\nIt should then be possible to make the two calculate methods `const`, which is intuitive -- calculating from an object shouldn't need to mutate it.\r\n\r\nOne other more subtle thing we'd want to do is handle the case where `BuildMockTemplate()` is called more than once -- it would be nice to allow that even if initially only for testing. That is, the caller might do something like:\r\n```\r\nnode::MiniMiner miner(pool, outpoints);\r\nminer.BuildMockTemplate(feerate1);\r\nminer.BuildMockTemplate(feerate2);\r\nresults = miner.CalculateBumpFees();\r\n```\r\nThe effect you'd expect is for the bump fees to be based on `feerate2`. But the first call to `BuildMockTemplate()` would modify the object in such a way that, if nothing special is done, would mess up the second call to `BuildMockTemplate()`.\r\n\r\nI think the best way to deal with this is that when `BuildMockTemplate()` begins, it checks if there's already a feerate set in the object (maybe `m_feerate` is type `std::optional<CFeeRate>`). If so, it resets of the object's state to as it was after the constructor ran. (It shouldn't need to actually re-run the constructor code; that may be a possible design but seems less elegant.)\r\n\r\nOne last thing, what would this do? (Note, `BuildMockTemplate()` isn't called)\r\n```\r\nresults = node::MiniMiner(pool, outpoints).CalculateBumpFees();\r\n```\r\nI think what would be natural here is that all the bump fees would be zero, as if the target feerate is zero. In other words, the \"default\" target feerate is zero; `BuildMockTemplate()` simply modifies the feerate from zero.\r\n\r\nZero bump fees is also what can happen if we hit the cluster-too-large limit. We wouldn't bump any fees, but that's no worse than today. (I think this is what happens with the PR?)",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-28T19:22:50Z",
      "diff_hunk" : "@@ -0,0 +1,121 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransactionRef tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetSharedTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return *tx; }\n+};\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1151062167",
      "id" : 1151062167,
      "line" : 59,
      "node_id" : "PRRC_kwDOABII585Em9CX",
      "original_commit_id" : "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "original_line" : 59,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.h",
      "position" : 59,
      "pull_request_review_id" : 1361682595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151062167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-29T05:17:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151062167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1153139259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153139259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://cirrus-ci.com/task/4526522288046080:\r\n```\r\n/tmp/cirrus-ci-build/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/node/mini_miner.cpp:63:9: error: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop [performance-inefficient-vector-operation,-warnings-as-errors]\r\n        txids_needed.push_back(txid);\r\n```\r\nseems like the tidy job wants you to add this:\r\n```suggestion\r\n    std::vector<uint256> txids_needed;\r\n    txids_needed.reserve(m_requested_outpoints_by_txid.size());\r\n```",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-03-30T11:46:26Z",
      "diff_hunk" : "@@ -0,0 +1,365 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1153139259",
      "id" : 1153139259,
      "line" : 61,
      "node_id" : "PRRC_kwDOABII585Eu4I7",
      "original_commit_id" : "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "original_line" : 61,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/node/mini_miner.cpp",
      "position" : 61,
      "pull_request_review_id" : 1364933315,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 2,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153139259/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-30T11:47:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153139259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Pushed the change to make tidy happy.\r\n\r\n@furszy: I put my take on your suggested changes in https://github.com/Xekyo/bitcoin/commits/furszy-minmintests, but I havenât been able to bring myself to merge it yet, because I was hoping to keep the changes small with the feature freeze on Saturday. Havenât given up the hope completely yet. (^_^)/\r\nIf I have to touch it up a bit more, Iâm thinking to do it, but otherwise maybe in a follow-up?\r\n\r\n----\r\n\r\nEdit: Ah whatever, #27021 doesnât do much without #26152 anyway, so Iâve pushed the changes inspired by furszyâs refactor of the miniminer-tests as well, since I just touched the file to fix the tidy check anyway.\r\n\r\nSo relevant changes are therefore: \r\nhttps://github.com/bitcoin/bitcoin/compare/fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72..b6e4dafa8de15d97927c4d807091c82b0557c104\r\n",
      "created_at" : "2023-03-30T21:26:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1490986943",
      "id" : 1490986943,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585Y3qe_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1490986943/reactions"
      },
      "updated_at" : "2023-03-30T21:36:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1490986943",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Edit: Ah whatever, https://github.com/bitcoin/bitcoin/pull/27021 doesnât do much without https://github.com/bitcoin/bitcoin/pull/26152 anyway\r\n\r\nSeeing as this has missed the feature freeze date, I'm removing both from 25.0 milestone (sorry :cry: )",
      "created_at" : "2023-04-05T10:47:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1497285538",
      "id" : 1497285538,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585ZPsOi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497285538/reactions"
      },
      "updated_at" : "2023-04-05T10:47:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497285538",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed co-authorship attribution to @furszy, no other changes.",
      "created_at" : "2023-04-06T19:09:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1499500913",
      "id" : 1499500913,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585ZYJFx",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499500913/reactions"
      },
      "updated_at" : "2023-04-06T19:09:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499500913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-05-03T18:27:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1533510937",
      "id" : 1533510937,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585bZ4UZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1533510937/reactions"
      },
      "updated_at" : "2023-05-03T18:27:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1533510937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188846506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188846506"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: unused includes\r\n```suggestion\r\n#include <util/check.h>\r\n```",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-05-09T16:20:43Z",
      "diff_hunk" : "@@ -0,0 +1,366 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188846506",
      "id" : 1188846506,
      "line" : 12,
      "node_id" : "PRRC_kwDOABII585G3Fuq",
      "original_commit_id" : "59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "original_line" : 12,
      "original_position" : 12,
      "original_start_line" : 10,
      "path" : "src/node/mini_miner.cpp",
      "position" : 12,
      "pull_request_review_id" : 1419015473,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188846506/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 10,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-05-09T17:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188846506",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188865405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188865405"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: seems odd to sometimes access `MiniMinerMempoolEntry` entrie's ancestor-set information via method (`.GetModFeesWithAncestors(...)`), and sometimes directly by member variable (`.vsize_with_ancestors`). Would suggest to be consistent here and either move the `{fee,vsize}_with_ancestors` fields to the `private:` section (i.e. the getter methods have to be always used) or remove the methods completely and hence always use field access.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-05-09T16:37:45Z",
      "diff_hunk" : "@@ -0,0 +1,366 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet wonât normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    txids_needed.reserve(m_requested_outpoints_by_txid.size());\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entryâs descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188865405",
      "id" : 1188865405,
      "line" : 174,
      "node_id" : "PRRC_kwDOABII585G3KV9",
      "original_commit_id" : "59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : 173,
      "path" : "src/node/mini_miner.cpp",
      "position" : 174,
      "pull_request_review_id" : 1419015473,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188865405/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 173,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-05-09T17:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188865405",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188884884"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188884884"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit, follow-up material:\r\nI think the `{tx5,tx7,tx8}_anc_feerate`s are all off here as they forget to account for their own tx's vsize/fee. Probably it would even make sense to check against the fee-rate calculated with the \"real\" values gathered from CTxMemPool with some checks like this:\r\n```diff\r\n-    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\r\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]);\r\n+    const auto tx4_iter = pool.GetIter(tx4->GetHash());\r\n+    BOOST_CHECK(tx4_anc_feerate == CFeeRate(tx4_iter.value()->GetModFeesWithAncestors(), tx4_iter.value()->GetSizeWithAncestors()));\r\n\r\n```",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-05-09T16:53:53Z",
      "diff_hunk" : "@@ -0,0 +1,477 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+        if (fee == 0) continue;\n+        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\n+        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\n+            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\n+        });\n+        if (!found) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename Key, typename Value>\n+Value Find(const std::map<Key, Value>& map, const Key& key)\n+{\n+    auto it = map.find(key);\n+    BOOST_CHECK_MESSAGE(it != map.end(), strprintf(\"Cannot find %s\", key.ToString()));\n+    return it->second;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), CENT/100);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    struct TxDimensions {\n+        size_t vsize; CAmount mod_fee; CFeeRate feerate;\n+    };\n+    std::map<uint256, TxDimensions> tx_dims;\n+    for (const auto& tx : all_transactions) {\n+        const auto it = pool.GetIter(tx->GetHash()).value();\n+        tx_dims.emplace(tx->GetHash(), TxDimensions{it->GetTxSize(), it->GetModifiedFee(),\n+                                              CFeeRate(it->GetModifiedFee(), it->GetTxSize())});\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(5*CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+\n+        // Check tx1 bumpfee: no other bumper.\n+        const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+        CAmount bumpfee1 = Find(bump_fees, COutPoint{tx1->GetHash(), 1});\n+        if (target_feerate <= tx1_dimensions.feerate) {\n+            BOOST_CHECK_EQUAL(bumpfee1, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(bumpfee1, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+        }\n+\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+        const TxDimensions& tx4_dimensions = tx_dims.find(tx4->GetHash())->second;\n+        const CFeeRate tx3_feerate = CFeeRate(tx3_dimensions.mod_fee + tx4_dimensions.mod_fee, tx3_dimensions.vsize + tx4_dimensions.vsize);\n+        CAmount bumpfee3 = Find(bump_fees, COutPoint{tx3->GetHash(), 1});\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee3, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(bumpfee3, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+        }\n+\n+        // If tx6âs modified fees are sufficient for tx5 and tx6 to be picked\n+        // into the block, our prospective new transaction would not need to\n+        // bump tx5 when using tx5âs second output. If however even tx6âs\n+        // modified fee (which essentially indicates \"effective feerate\") is\n+        // not sufficient to bump tx5, using the second output of tx5 would\n+        // require our transaction to bump tx5 from scratch since we evaluate\n+        // transaction packages per ancestor sets and do not consider multiple\n+        // childrenâs fees.\n+        const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+        const TxDimensions& tx6_dimensions = tx_dims.find(tx6->GetHash())->second;\n+        const CFeeRate tx5_feerate = CFeeRate(tx5_dimensions.mod_fee + tx6_dimensions.mod_fee, tx5_dimensions.vsize + tx6_dimensions.vsize);\n+        CAmount bumpfee5 = Find(bump_fees, COutPoint{tx5->GetHash(), 1});\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee5, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(bumpfee5, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+\n+            // Check tx1 bumpfee: no other bumper.\n+            const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+            CAmount it1_spent = Find(bump_fees, COutPoint{tx1->GetHash(), 0});\n+            if (target_feerate <= tx1_dimensions.feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+            }\n+\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+            const CFeeRate tx3_feerate_unbumped = tx3_dimensions.feerate;\n+            auto it3_spent = Find(bump_fees, COutPoint{tx3->GetHash(), 0});\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+            }\n+\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+            const CFeeRate tx5_feerate_unbumped = tx5_dimensions.feerate;\n+            auto it5_spent = Find(bump_fees, COutPoint{tx5->GetHash(), 0});\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188884884",
      "id" : 1188884884,
      "line" : 334,
      "node_id" : "PRRC_kwDOABII585G3PGU",
      "original_commit_id" : "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "original_line" : 334,
      "original_position" : 334,
      "original_start_line" : 331,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 334,
      "pull_request_review_id" : 1419015473,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188884884/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 331,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-05-09T17:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188884884",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188935619"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188935619"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "For better readability and maintainability, would be nice to start naming the txs with index zero, to avoid the off-by-one relation (`txN <-> tx_vsizes[N-1]`).",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-05-09T17:40:57Z",
      "diff_hunk" : "@@ -0,0 +1,477 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+        if (fee == 0) continue;\n+        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\n+        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\n+            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\n+        });\n+        if (!found) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename Key, typename Value>\n+Value Find(const std::map<Key, Value>& map, const Key& key)\n+{\n+    auto it = map.find(key);\n+    BOOST_CHECK_MESSAGE(it != map.end(), strprintf(\"Cannot find %s\", key.ToString()));\n+    return it->second;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), CENT/100);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    struct TxDimensions {\n+        size_t vsize; CAmount mod_fee; CFeeRate feerate;\n+    };\n+    std::map<uint256, TxDimensions> tx_dims;\n+    for (const auto& tx : all_transactions) {\n+        const auto it = pool.GetIter(tx->GetHash()).value();\n+        tx_dims.emplace(tx->GetHash(), TxDimensions{it->GetTxSize(), it->GetModifiedFee(),\n+                                              CFeeRate(it->GetModifiedFee(), it->GetTxSize())});\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(5*CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+\n+        // Check tx1 bumpfee: no other bumper.\n+        const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+        CAmount bumpfee1 = Find(bump_fees, COutPoint{tx1->GetHash(), 1});\n+        if (target_feerate <= tx1_dimensions.feerate) {\n+            BOOST_CHECK_EQUAL(bumpfee1, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(bumpfee1, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+        }\n+\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+        const TxDimensions& tx4_dimensions = tx_dims.find(tx4->GetHash())->second;\n+        const CFeeRate tx3_feerate = CFeeRate(tx3_dimensions.mod_fee + tx4_dimensions.mod_fee, tx3_dimensions.vsize + tx4_dimensions.vsize);\n+        CAmount bumpfee3 = Find(bump_fees, COutPoint{tx3->GetHash(), 1});\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee3, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(bumpfee3, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+        }\n+\n+        // If tx6âs modified fees are sufficient for tx5 and tx6 to be picked\n+        // into the block, our prospective new transaction would not need to\n+        // bump tx5 when using tx5âs second output. If however even tx6âs\n+        // modified fee (which essentially indicates \"effective feerate\") is\n+        // not sufficient to bump tx5, using the second output of tx5 would\n+        // require our transaction to bump tx5 from scratch since we evaluate\n+        // transaction packages per ancestor sets and do not consider multiple\n+        // childrenâs fees.\n+        const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+        const TxDimensions& tx6_dimensions = tx_dims.find(tx6->GetHash())->second;\n+        const CFeeRate tx5_feerate = CFeeRate(tx5_dimensions.mod_fee + tx6_dimensions.mod_fee, tx5_dimensions.vsize + tx6_dimensions.vsize);\n+        CAmount bumpfee5 = Find(bump_fees, COutPoint{tx5->GetHash(), 1});\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee5, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(bumpfee5, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+\n+            // Check tx1 bumpfee: no other bumper.\n+            const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+            CAmount it1_spent = Find(bump_fees, COutPoint{tx1->GetHash(), 0});\n+            if (target_feerate <= tx1_dimensions.feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+            }\n+\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+            const CFeeRate tx3_feerate_unbumped = tx3_dimensions.feerate;\n+            auto it3_spent = Find(bump_fees, COutPoint{tx3->GetHash(), 0});\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+            }\n+\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+            const CFeeRate tx5_feerate_unbumped = tx5_dimensions.feerate;\n+            auto it5_spent = Find(bump_fees, COutPoint{tx5->GetHash(), 0});\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188935619",
      "id" : 1188935619,
      "line" : 327,
      "node_id" : "PRRC_kwDOABII585G3bfD",
      "original_commit_id" : "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "original_line" : 327,
      "original_position" : 327,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 327,
      "pull_request_review_id" : 1419015473,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188935619/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-09T17:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188935619",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Super, thanks for the review, @theStack. As I already have a follow-up PR with #26152, since this PR has three ACKs now, and all the open comments are nits, I would like to include those changes as a new commit in the follow-up #26152.\r\n\r\nWhat do you think, @glozow?",
      "created_at" : "2023-05-16T23:42:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1550491250",
      "id" : 1550491250,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585cap5y",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1550491250/reactions"
      },
      "updated_at" : "2023-05-17T02:25:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1550491250",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> ACK [6b605b9](https://github.com/bitcoin/bitcoin/commit/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965) modulo `miniminer_overlap` test.\r\n> \r\n> Not really blocking, I'm planning to go deeper later. And probably add some explanatory comments and code simplifications. I think that has a readability barrier that will be a maintenance issue moving forward.\r\n\r\nPerhaps we can address that in #26152 as well",
      "created_at" : "2023-05-17T02:26:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1550595711",
      "id" : 1550595711,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585cbDZ_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1550595711/reactions"
      },
      "updated_at" : "2023-05-17T02:26:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1550595711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> > ACK [6b605b9](https://github.com/bitcoin/bitcoin/commit/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965) modulo `miniminer_overlap` test.\r\n> > Not really blocking, I'm planning to go deeper later. And probably add some explanatory comments and code simplifications. I think that has a readability barrier that will be a maintenance issue moving forward.\r\n> \r\n> Perhaps we can address that in #26152 as well\r\n\r\nAbsolutely. Loved @theStack diagram.",
      "created_at" : "2023-05-17T13:10:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1551366404",
      "id" : 1551366404,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585cd_kE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1551366404/reactions"
      },
      "updated_at" : "2023-05-17T13:10:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1551366404",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5377650?v=4",
         "events_url" : "https://api.github.com/users/furszy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/furszy/followers",
         "following_url" : "https://api.github.com/users/furszy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/furszy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/furszy",
         "id" : 5377650,
         "login" : "furszy",
         "node_id" : "MDQ6VXNlcjUzNzc2NTA=",
         "organizations_url" : "https://api.github.com/users/furszy/orgs",
         "received_events_url" : "https://api.github.com/users/furszy/received_events",
         "repos_url" : "https://api.github.com/users/furszy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/furszy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/furszy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/furszy"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> As I already have a follow-up PR with https://github.com/bitcoin/bitcoin/pull/26152, since this PR has three ACKs now, and all the open comments are nits, I would like to include those changes as a new commit in the follow-up https://github.com/bitcoin/bitcoin/pull/26152.\r\n\r\nYep, I'll look for these in #26152:\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188846506\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188865405\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188884884\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188935619\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1417018318",
      "created_at" : "2023-05-19T14:28:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1554675156",
      "id" : 1554675156,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
      "node_id" : "IC_kwDOABII585cqnXU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1554675156/reactions"
      },
      "updated_at" : "2023-05-19T14:29:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1554675156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1224732592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224732592"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that is a misunderstanding caused by the vector fields being number 0â7 and the txs being numbered 1â8. Iâve got a draft where I change the names of the transactions to start with number 0.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-06-09T20:19:19Z",
      "diff_hunk" : "@@ -0,0 +1,477 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+        if (fee == 0) continue;\n+        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\n+        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\n+            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\n+        });\n+        if (!found) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename Key, typename Value>\n+Value Find(const std::map<Key, Value>& map, const Key& key)\n+{\n+    auto it = map.find(key);\n+    BOOST_CHECK_MESSAGE(it != map.end(), strprintf(\"Cannot find %s\", key.ToString()));\n+    return it->second;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), CENT/100);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    struct TxDimensions {\n+        size_t vsize; CAmount mod_fee; CFeeRate feerate;\n+    };\n+    std::map<uint256, TxDimensions> tx_dims;\n+    for (const auto& tx : all_transactions) {\n+        const auto it = pool.GetIter(tx->GetHash()).value();\n+        tx_dims.emplace(tx->GetHash(), TxDimensions{it->GetTxSize(), it->GetModifiedFee(),\n+                                              CFeeRate(it->GetModifiedFee(), it->GetTxSize())});\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(5*CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+\n+        // Check tx1 bumpfee: no other bumper.\n+        const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+        CAmount bumpfee1 = Find(bump_fees, COutPoint{tx1->GetHash(), 1});\n+        if (target_feerate <= tx1_dimensions.feerate) {\n+            BOOST_CHECK_EQUAL(bumpfee1, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(bumpfee1, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+        }\n+\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+        const TxDimensions& tx4_dimensions = tx_dims.find(tx4->GetHash())->second;\n+        const CFeeRate tx3_feerate = CFeeRate(tx3_dimensions.mod_fee + tx4_dimensions.mod_fee, tx3_dimensions.vsize + tx4_dimensions.vsize);\n+        CAmount bumpfee3 = Find(bump_fees, COutPoint{tx3->GetHash(), 1});\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee3, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(bumpfee3, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+        }\n+\n+        // If tx6âs modified fees are sufficient for tx5 and tx6 to be picked\n+        // into the block, our prospective new transaction would not need to\n+        // bump tx5 when using tx5âs second output. If however even tx6âs\n+        // modified fee (which essentially indicates \"effective feerate\") is\n+        // not sufficient to bump tx5, using the second output of tx5 would\n+        // require our transaction to bump tx5 from scratch since we evaluate\n+        // transaction packages per ancestor sets and do not consider multiple\n+        // childrenâs fees.\n+        const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+        const TxDimensions& tx6_dimensions = tx_dims.find(tx6->GetHash())->second;\n+        const CFeeRate tx5_feerate = CFeeRate(tx5_dimensions.mod_fee + tx6_dimensions.mod_fee, tx5_dimensions.vsize + tx6_dimensions.vsize);\n+        CAmount bumpfee5 = Find(bump_fees, COutPoint{tx5->GetHash(), 1});\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee5, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(bumpfee5, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+\n+            // Check tx1 bumpfee: no other bumper.\n+            const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+            CAmount it1_spent = Find(bump_fees, COutPoint{tx1->GetHash(), 0});\n+            if (target_feerate <= tx1_dimensions.feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+            }\n+\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+            const CFeeRate tx3_feerate_unbumped = tx3_dimensions.feerate;\n+            auto it3_spent = Find(bump_fees, COutPoint{tx3->GetHash(), 0});\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+            }\n+\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+            const CFeeRate tx5_feerate_unbumped = tx5_dimensions.feerate;\n+            auto it5_spent = Find(bump_fees, COutPoint{tx5->GetHash(), 0});\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1224732592",
      "id" : 1224732592,
      "in_reply_to_id" : 1188884884,
      "line" : 334,
      "node_id" : "PRRC_kwDOABII585I_--w",
      "original_commit_id" : "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "original_line" : 334,
      "original_position" : 334,
      "original_start_line" : 331,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 334,
      "pull_request_review_id" : 1473008191,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224732592/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 331,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-06-09T20:19:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224732592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1224732834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224732834"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Great idea, will do.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-06-09T20:19:34Z",
      "diff_hunk" : "@@ -0,0 +1,477 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+        if (fee == 0) continue;\n+        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\n+        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\n+            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\n+        });\n+        if (!found) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename Key, typename Value>\n+Value Find(const std::map<Key, Value>& map, const Key& key)\n+{\n+    auto it = map.find(key);\n+    BOOST_CHECK_MESSAGE(it != map.end(), strprintf(\"Cannot find %s\", key.ToString()));\n+    return it->second;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), CENT/100);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    struct TxDimensions {\n+        size_t vsize; CAmount mod_fee; CFeeRate feerate;\n+    };\n+    std::map<uint256, TxDimensions> tx_dims;\n+    for (const auto& tx : all_transactions) {\n+        const auto it = pool.GetIter(tx->GetHash()).value();\n+        tx_dims.emplace(tx->GetHash(), TxDimensions{it->GetTxSize(), it->GetModifiedFee(),\n+                                              CFeeRate(it->GetModifiedFee(), it->GetTxSize())});\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(5*CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+\n+        // Check tx1 bumpfee: no other bumper.\n+        const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+        CAmount bumpfee1 = Find(bump_fees, COutPoint{tx1->GetHash(), 1});\n+        if (target_feerate <= tx1_dimensions.feerate) {\n+            BOOST_CHECK_EQUAL(bumpfee1, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(bumpfee1, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+        }\n+\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+        const TxDimensions& tx4_dimensions = tx_dims.find(tx4->GetHash())->second;\n+        const CFeeRate tx3_feerate = CFeeRate(tx3_dimensions.mod_fee + tx4_dimensions.mod_fee, tx3_dimensions.vsize + tx4_dimensions.vsize);\n+        CAmount bumpfee3 = Find(bump_fees, COutPoint{tx3->GetHash(), 1});\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee3, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(bumpfee3, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+        }\n+\n+        // If tx6âs modified fees are sufficient for tx5 and tx6 to be picked\n+        // into the block, our prospective new transaction would not need to\n+        // bump tx5 when using tx5âs second output. If however even tx6âs\n+        // modified fee (which essentially indicates \"effective feerate\") is\n+        // not sufficient to bump tx5, using the second output of tx5 would\n+        // require our transaction to bump tx5 from scratch since we evaluate\n+        // transaction packages per ancestor sets and do not consider multiple\n+        // childrenâs fees.\n+        const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+        const TxDimensions& tx6_dimensions = tx_dims.find(tx6->GetHash())->second;\n+        const CFeeRate tx5_feerate = CFeeRate(tx5_dimensions.mod_fee + tx6_dimensions.mod_fee, tx5_dimensions.vsize + tx6_dimensions.vsize);\n+        CAmount bumpfee5 = Find(bump_fees, COutPoint{tx5->GetHash(), 1});\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee5, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(bumpfee5, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+\n+            // Check tx1 bumpfee: no other bumper.\n+            const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+            CAmount it1_spent = Find(bump_fees, COutPoint{tx1->GetHash(), 0});\n+            if (target_feerate <= tx1_dimensions.feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+            }\n+\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+            const CFeeRate tx3_feerate_unbumped = tx3_dimensions.feerate;\n+            auto it3_spent = Find(bump_fees, COutPoint{tx3->GetHash(), 0});\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+            }\n+\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+            const CFeeRate tx5_feerate_unbumped = tx5_dimensions.feerate;\n+            auto it5_spent = Find(bump_fees, COutPoint{tx5->GetHash(), 0});\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1224732834",
      "id" : 1224732834,
      "in_reply_to_id" : 1188935619,
      "line" : 327,
      "node_id" : "PRRC_kwDOABII585I__Ci",
      "original_commit_id" : "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "original_line" : 327,
      "original_position" : 327,
      "original_start_line" : null,
      "path" : "src/test/miniminer_tests.cpp",
      "position" : 327,
      "pull_request_review_id" : 1473008413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224732834/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-06-09T20:19:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224732834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1224733097"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224733097"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I am removing the unused includes.",
      "commit_id" : "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "created_at" : "2023-06-09T20:19:49Z",
      "diff_hunk" : "@@ -0,0 +1,366 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1224733097",
      "id" : 1224733097,
      "in_reply_to_id" : 1188846506,
      "line" : 12,
      "node_id" : "PRRC_kwDOABII585I__Gp",
      "original_commit_id" : "59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "original_line" : 12,
      "original_position" : 12,
      "original_start_line" : 10,
      "path" : "src/node/mini_miner.cpp",
      "position" : 12,
      "pull_request_review_id" : 1473008639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224733097/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 10,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-06-09T20:19:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1224733097",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4060799?v=4",
         "events_url" : "https://api.github.com/users/Xekyo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Xekyo/followers",
         "following_url" : "https://api.github.com/users/Xekyo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Xekyo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Xekyo",
         "id" : 4060799,
         "login" : "Xekyo",
         "node_id" : "MDQ6VXNlcjQwNjA3OTk=",
         "organizations_url" : "https://api.github.com/users/Xekyo/orgs",
         "received_events_url" : "https://api.github.com/users/Xekyo/received_events",
         "repos_url" : "https://api.github.com/users/Xekyo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Xekyo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Xekyo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Xekyo"
      }
   }
]
