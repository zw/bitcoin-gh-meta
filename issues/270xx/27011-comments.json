[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [jamesob](https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1421069505), [dergoegge](https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1427833942) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25325](https://github.com/bitcoin/bitcoin/pull/25325) (Add pool based memory resource by martinus)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-01-31T23:12:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1411201803",
      "id" : 1411201803,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585UHTsL",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411201803/reactions"
      },
      "updated_at" : "2023-02-13T12:08:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411201803",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1092893327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092893327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Could replace those four lines with just `LIMITED_WHILE`?",
      "commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "created_at" : "2023-02-01T08:24:06Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1092893327",
      "id" : 1092893327,
      "line" : 243,
      "node_id" : "PRRC_kwDOABII585BJDqP",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 243,
      "original_position" : 243,
      "original_start_line" : 240,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 243,
      "pull_request_review_id" : 1278620441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092893327/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 240,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-01T08:34:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092893327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1092893857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092893857"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: If you do switch to FuzzedDataProvider, could use CallOneOf?",
      "commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "created_at" : "2023-02-01T08:24:38Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;\n+\n+        // Every operation (except \"Decrement height\") moves current height forward,\n+        // so it functions as a kind of epoch.\n+        ++current_height;\n+        // Make sure there is always at least one CCoinsViewCache.\n+        if (caches.empty()) {\n+            caches.emplace_back(new CCoinsViewCache(&bottom));\n+            sim_caches[caches.size()].Wipe();\n+        }\n+\n+        unsigned cmd = (*(it++)) % 17U;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1092893857",
      "id" : 1092893857,
      "line" : 254,
      "node_id" : "PRRC_kwDOABII585BJDyh",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 254,
      "original_position" : 254,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 254,
      "pull_request_review_id" : 1278620441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092893857/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T08:34:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092893857",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1092896650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092896650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: If you do switch to FuzzedDataProvider, could use the `<uint8_t>` int getter? Alternatively, maybe write a lambda: `const auto get_uint8_t{[](auto& it) { return it == buffer.end() ? 0 : *(it++); }}` and use it in all places with \r\n```suggestion\r\n            uint32_t outpointidx{get_uint8_t(it)};\r\n```",
      "commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "created_at" : "2023-02-01T08:27:25Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;\n+\n+        // Every operation (except \"Decrement height\") moves current height forward,\n+        // so it functions as a kind of epoch.\n+        ++current_height;\n+        // Make sure there is always at least one CCoinsViewCache.\n+        if (caches.empty()) {\n+            caches.emplace_back(new CCoinsViewCache(&bottom));\n+            sim_caches[caches.size()].Wipe();\n+        }\n+\n+        unsigned cmd = (*(it++)) % 17U;\n+        switch (cmd) {\n+\n+        case 0: { // GetCoin\n+            uint32_t outpointidx = (it == buffer.end()) ? 0 : *(it++);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1092896650",
      "id" : 1092896650,
      "line" : 258,
      "node_id" : "PRRC_kwDOABII585BJEeK",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 258,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 258,
      "pull_request_review_id" : 1278620441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092896650/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T08:34:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1092896650",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093089636"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093089636"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    static const PrecomputedData data;\r\n```\r\n\r\n`PrecomputedData` is generated deterministically, right? Given that and it being const, there should be no need to generate it on each iteration.",
      "commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "created_at" : "2023-02-01T11:20:55Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093089636",
      "id" : 1093089636,
      "line" : 194,
      "node_id" : "PRRC_kwDOABII585BJzlk",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 194,
      "pull_request_review_id" : 1278920127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093089636/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T11:52:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093089636",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093103190"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093103190"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why not consume until the buffer is empty?\r\n\r\nInput sizes are limited by the fuzzing engines anyway (e.g. libFuzzer's default is 4096 bytes when starting from an empty corpus), so the max. number of ops is capped by that.",
      "commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "created_at" : "2023-02-01T11:35:07Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093103190",
      "id" : 1093103190,
      "in_reply_to_id" : 1092893327,
      "line" : 243,
      "node_id" : "PRRC_kwDOABII585BJ25W",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 243,
      "original_position" : 243,
      "original_start_line" : 240,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 243,
      "pull_request_review_id" : 1278920127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093103190/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 240,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-01T11:52:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093103190",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093127024"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093127024"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> libFuzzer's default is 4096 bytes\r\n\r\nWe use more fuzz engines than libFuzzer on default settings ;)\r\n\r\n\r\nYou can look up the history of LIMITED_WHILE to get an idea of how much is broken if the macro is removed.",
      "commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "created_at" : "2023-02-01T12:00:19Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093127024",
      "id" : 1093127024,
      "in_reply_to_id" : 1092893327,
      "line" : 243,
      "node_id" : "PRRC_kwDOABII585BJ8tw",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 243,
      "original_position" : 243,
      "original_start_line" : 240,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 243,
      "pull_request_review_id" : 1278974622,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 1,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093127024/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 240,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-01T12:00:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093127024",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093197929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093197929"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Confused by this comment - `2**8` doesn't seem to be able to fit `2**256-1`. Did you mean to write `NUM_COINS - 1`?",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T13:10:36Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093197929",
      "id" : 1093197929,
      "line" : 26,
      "node_id" : "PRRC_kwDOABII585BKOBp",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 26,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 26,
      "pull_request_review_id" : 1279079556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093197929/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:21:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093197929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093271860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093271860"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> nit: Could replace those four lines with just `LIMITED_WHILE`?\r\n\r\nDone.\r\n\r\n> Why not consume until the buffer is empty?\r\n\r\nIt does, by the way (in addition to having an upper limit).\r\n\r\n",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:07:05Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093271860",
      "id" : 1093271860,
      "in_reply_to_id" : 1092893327,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585BKgE0",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 243,
      "original_position" : 243,
      "original_start_line" : 240,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : null,
      "pull_request_review_id" : 1279186506,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093271860/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-01T14:07:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093271860",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093272100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093272100"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:07:14Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;\n+\n+        // Every operation (except \"Decrement height\") moves current height forward,\n+        // so it functions as a kind of epoch.\n+        ++current_height;\n+        // Make sure there is always at least one CCoinsViewCache.\n+        if (caches.empty()) {\n+            caches.emplace_back(new CCoinsViewCache(&bottom));\n+            sim_caches[caches.size()].Wipe();\n+        }\n+\n+        unsigned cmd = (*(it++)) % 17U;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093272100",
      "id" : 1093272100,
      "in_reply_to_id" : 1092893857,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585BKgIk",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 254,
      "original_position" : 254,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : null,
      "pull_request_review_id" : 1279186783,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093272100/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:07:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093272100",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093273592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093273592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, switched `provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);`, which makes it not strongly tied to the range of a `uint8_t`.",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:08:05Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    auto it = buffer.begin();\n+    unsigned iters = 0;\n+    while (it != buffer.end()) {\n+        // Upper limit on number of operations.\n+        if (++iters == 10000U) break;\n+\n+        // Every operation (except \"Decrement height\") moves current height forward,\n+        // so it functions as a kind of epoch.\n+        ++current_height;\n+        // Make sure there is always at least one CCoinsViewCache.\n+        if (caches.empty()) {\n+            caches.emplace_back(new CCoinsViewCache(&bottom));\n+            sim_caches[caches.size()].Wipe();\n+        }\n+\n+        unsigned cmd = (*(it++)) % 17U;\n+        switch (cmd) {\n+\n+        case 0: { // GetCoin\n+            uint32_t outpointidx = (it == buffer.end()) ? 0 : *(it++);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093273592",
      "id" : 1093273592,
      "in_reply_to_id" : 1092896650,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585BKgf4",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 258,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : null,
      "pull_request_review_id" : 1279188433,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093273592/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:08:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093273592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093274782"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093274782"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, good catch. Made it `static`, which makes fuzzing several times faster.",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:08:48Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    const PrecomputedData data;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093274782",
      "id" : 1093274782,
      "in_reply_to_id" : 1093089636,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585BKgye",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : null,
      "pull_request_review_id" : 1279189779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093274782/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:08:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093274782",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093282327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093282327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hm. Can't you emulate `Sync()` by adding an `erase` parameter to `flush()` that just doesn't set the cache entry to `EntryType::NONE`? If you don't do this, won't the contents of the simulation cache differ from the real caches?",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:13:49Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/util.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    static const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    LIMITED_WHILE(provider.remaining_bytes(), 10000) {\n+        // Every operation (except \"Change height\") moves current height forward,\n+        // so it functions as a kind of epoch.\n+        ++current_height;\n+        // Make sure there is always at least one CCoinsViewCache.\n+        if (caches.empty()) {\n+            caches.emplace_back(new CCoinsViewCache(&bottom));\n+            sim_caches[caches.size()].Wipe();\n+        }\n+\n+        // Execute command.\n+        CallOneOf(\n+            provider,\n+\n+            [&]() { // GetCoin\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data.\n+                auto sim = lookup(outpointidx);\n+                // Look up in real caches.\n+                Coin realcoin;\n+                auto real = caches.back()->GetCoin(data.outpoints[outpointidx], realcoin);\n+                // Compare results.\n+                if (!sim.has_value()) {\n+                    assert(!real);\n+                } else {\n+                    assert(!realcoin.IsSpent());\n+                    const auto& simcoin = data.coins[sim->first];\n+                    assert(realcoin.out == simcoin.out);\n+                    assert(realcoin.fCoinBase == simcoin.fCoinBase);\n+                    assert(realcoin.nHeight == sim->second);\n+                }\n+            },\n+\n+            [&]() { // HaveCoin\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data.\n+                auto sim = lookup(outpointidx);\n+                // Look up in real caches.\n+                auto real = caches.back()->HaveCoin(data.outpoints[outpointidx]);\n+                // Compare results.\n+                assert(sim.has_value() == real);\n+            },\n+\n+            [&]() { // HaveCoinInCache\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Invoke on real cache (there is no equivalent in simulation, so nothing to compare result with).\n+                (void)caches.back()->HaveCoinInCache(data.outpoints[outpointidx]);\n+            },\n+\n+            [&]() { // AccessCoin\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data.\n+                auto sim = lookup(outpointidx);\n+                // Look up in real caches.\n+                const auto& realcoin = caches.back()->AccessCoin(data.outpoints[outpointidx]);\n+                // Compare results.\n+                if (!sim.has_value()) {\n+                    assert(realcoin.IsSpent());\n+                } else {\n+                    assert(!realcoin.IsSpent());\n+                    const auto& simcoin = data.coins[sim->first];\n+                    assert(simcoin.out == realcoin.out);\n+                    assert(simcoin.fCoinBase == realcoin.fCoinBase);\n+                    assert(realcoin.nHeight == sim->second);\n+                }\n+            },\n+\n+            [&]() { // AddCoin (only possible_overwrite if necessary)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                uint32_t coinidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_COINS - 1);\n+                // Look up in simulation data (to know whether we must set possible_overwrite or not).\n+                auto sim = lookup(outpointidx);\n+                // Invoke on real caches.\n+                Coin coin = data.coins[coinidx];\n+                coin.nHeight = current_height;\n+                caches.back()->AddCoin(data.outpoints[outpointidx], std::move(coin), sim.has_value());\n+                // Apply to simulation data.\n+                auto& entry = sim_caches[caches.size()].entry[outpointidx];\n+                entry.entrytype = EntryType::UNSPENT;\n+                entry.coinidx = coinidx;\n+                entry.height = current_height;\n+            },\n+\n+            [&]() { // AddCoin (always possible_overwrite)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                uint32_t coinidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_COINS - 1);\n+                // Invoke on real caches.\n+                Coin coin = data.coins[coinidx];\n+                coin.nHeight = current_height;\n+                caches.back()->AddCoin(data.outpoints[outpointidx], std::move(coin), true);\n+                // Apply to simulation data.\n+                auto& entry = sim_caches[caches.size()].entry[outpointidx];\n+                entry.entrytype = EntryType::UNSPENT;\n+                entry.coinidx = coinidx;\n+                entry.height = current_height;\n+            },\n+\n+            [&]() { // SpendCoin (moveto = nullptr)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Invoke on real caches.\n+                caches.back()->SpendCoin(data.outpoints[outpointidx], nullptr);\n+                // Apply to simulation data.\n+                sim_caches[caches.size()].entry[outpointidx].entrytype = EntryType::SPENT;\n+            },\n+\n+            [&]() { // SpendCoin (with moveto)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data (to compare the returned *moveto with).\n+                auto sim = lookup(outpointidx);\n+                // Invoke on real caches.\n+                Coin realcoin;\n+                caches.back()->SpendCoin(data.outpoints[outpointidx], &realcoin);\n+                // Apply to simulation data.\n+                sim_caches[caches.size()].entry[outpointidx].entrytype = EntryType::SPENT;\n+                // Compare *moveto with the value expected based on simulation data.\n+                if (!sim.has_value()) {\n+                    assert(realcoin.IsSpent());\n+                } else {\n+                    assert(!realcoin.IsSpent());\n+                    const auto& simcoin = data.coins[sim->first];\n+                    assert(simcoin.out == realcoin.out);\n+                    assert(simcoin.fCoinBase == realcoin.fCoinBase);\n+                    assert(realcoin.nHeight == sim->second);\n+                }\n+            },\n+\n+            [&]() { // Uncache\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Apply to real caches (there is no equivalent in our simulation).\n+                caches.back()->Uncache(data.outpoints[outpointidx]);\n+            },\n+\n+            [&]() { // Add a cache level (if not already at the max).\n+                if (caches.size() != MAX_CACHES) {\n+                    // Apply to real caches.\n+                    caches.emplace_back(new CCoinsViewCache(&*caches.back()));\n+                    // Apply to simulation data.\n+                    sim_caches[caches.size()].Wipe();\n+                }\n+            },\n+\n+            [&]() { // Remove a cache level.\n+                // Apply to real caches (this reduces caches.size(), implicitly doing the same on the simulation data).\n+                caches.back()->SanityCheck();\n+                caches.pop_back();\n+            },\n+\n+            [&]() { // Flush.\n+                // Apply to simulation data.\n+                flush();\n+                // Apply to real caches.\n+                caches.back()->Flush();\n+            },\n+\n+            [&]() { // Sync.\n+                // Apply to simulation data (note that in our simulation, syncing and flushing is the same thing).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093282327",
      "id" : 1093282327,
      "line" : 396,
      "node_id" : "PRRC_kwDOABII585BKioX",
      "original_commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "original_line" : 396,
      "original_position" : 396,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 396,
      "pull_request_review_id" : 1279079556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093282327/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:21:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093282327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093300662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093300662"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed!",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:28:29Z",
      "diff_hunk" : "@@ -0,0 +1,487 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093300662",
      "id" : 1093300662,
      "in_reply_to_id" : 1093197929,
      "line" : 26,
      "node_id" : "PRRC_kwDOABII585BKnG2",
      "original_commit_id" : "f87382af7ab95c4a77ff6c22a4fba2be6974fdc6",
      "original_line" : 26,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 26,
      "pull_request_review_id" : 1279227071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093300662/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:28:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093300662",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093303443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093303443"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Semantically, Flush() and Sync() have the same effect: they push the changes made in this cache to the parent coinsview. Whether or not entries stay in a cache is an implementation aspect that's not observable (except through CacheSize() etc).\n\nThe NONE entry in the simulated cache is also different from \"missing\" in the real cache, in that lookups in the simulated cache never pull in entries from parent caches, so you can't really compare the actual cache entrytype with anything the real caches do. They're wholly different implementations, but their observable behavior should be identical.\n\nYou're right that I could choose to not reset things to NONE in the simulated cache, but that'd in effect be extending the test to test the behavior of the simulation: resetting to NONE is just a non-observable optimization too there.",
      "commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "created_at" : "2023-02-01T14:30:31Z",
      "diff_hunk" : "@@ -0,0 +1,467 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/util.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold 2^NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkey */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);\n+                } else {\n+                    auto it2 = m_data.find(it->first);\n+                    assert(it2 != m_data.end());\n+                    assert(it->second.coin.out == it2->second.out);\n+                    assert(it->second.coin.fCoinBase == it2->second.fCoinBase);\n+                    assert(it->second.coin.nHeight == it2->second.nHeight);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(coinscache_sim)\n+{\n+    /** Precomputed COutPoint and CCoins values. */\n+    static const PrecomputedData data;\n+\n+    /** Dummy coinsview instance (base of the hierarchy). */\n+    CoinsViewBottom bottom;\n+    /** Real CCoinsViewCache objects. */\n+    std::vector<std::unique_ptr<CCoinsViewCache>> caches;\n+    /** Simulated cache data (sim_caches[0] matches bottom, sim_caches[i+1] matches caches[i]). */\n+    CacheLevel sim_caches[MAX_CACHES + 1];\n+    /** Current height in the simulation. */\n+    uint32_t current_height = 1U;\n+\n+    // Initialize bottom simulated cache.\n+    sim_caches[0].Wipe();\n+\n+    /** Helper lookup function in the simulated cache stack. */\n+    auto lookup = [&](uint32_t outpointidx, int sim_idx = -1) -> std::optional<std::pair<coinidx_type, uint32_t>> {\n+        uint32_t cache_idx = sim_idx == -1 ? caches.size() : sim_idx;\n+        while (true) {\n+            const auto& entry = sim_caches[cache_idx].entry[outpointidx];\n+            if (entry.entrytype == EntryType::UNSPENT) {\n+                return {{entry.coinidx, entry.height}};\n+            } else if (entry.entrytype == EntryType::SPENT) {\n+                return std::nullopt;\n+            };\n+            if (cache_idx == 0) break;\n+            --cache_idx;\n+        }\n+        return std::nullopt;\n+    };\n+\n+    /** Flush changes in top cache to the one below. */\n+    auto flush = [&]() {\n+        assert(caches.size() >= 1);\n+        auto& cache = sim_caches[caches.size()];\n+        auto& prev_cache = sim_caches[caches.size() - 1];\n+        for (uint32_t outpointidx = 0; outpointidx < NUM_OUTPOINTS; ++outpointidx) {\n+            if (cache.entry[outpointidx].entrytype != EntryType::NONE) {\n+                prev_cache.entry[outpointidx] = cache.entry[outpointidx];\n+                cache.entry[outpointidx].entrytype = EntryType::NONE;\n+            }\n+        }\n+    };\n+\n+    // Main simulation loop: read commands from the fuzzer input, and apply them\n+    // to both the real cache stack and the simulation.\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+    LIMITED_WHILE(provider.remaining_bytes(), 10000) {\n+        // Every operation (except \"Change height\") moves current height forward,\n+        // so it functions as a kind of epoch.\n+        ++current_height;\n+        // Make sure there is always at least one CCoinsViewCache.\n+        if (caches.empty()) {\n+            caches.emplace_back(new CCoinsViewCache(&bottom));\n+            sim_caches[caches.size()].Wipe();\n+        }\n+\n+        // Execute command.\n+        CallOneOf(\n+            provider,\n+\n+            [&]() { // GetCoin\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data.\n+                auto sim = lookup(outpointidx);\n+                // Look up in real caches.\n+                Coin realcoin;\n+                auto real = caches.back()->GetCoin(data.outpoints[outpointidx], realcoin);\n+                // Compare results.\n+                if (!sim.has_value()) {\n+                    assert(!real);\n+                } else {\n+                    assert(!realcoin.IsSpent());\n+                    const auto& simcoin = data.coins[sim->first];\n+                    assert(realcoin.out == simcoin.out);\n+                    assert(realcoin.fCoinBase == simcoin.fCoinBase);\n+                    assert(realcoin.nHeight == sim->second);\n+                }\n+            },\n+\n+            [&]() { // HaveCoin\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data.\n+                auto sim = lookup(outpointidx);\n+                // Look up in real caches.\n+                auto real = caches.back()->HaveCoin(data.outpoints[outpointidx]);\n+                // Compare results.\n+                assert(sim.has_value() == real);\n+            },\n+\n+            [&]() { // HaveCoinInCache\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Invoke on real cache (there is no equivalent in simulation, so nothing to compare result with).\n+                (void)caches.back()->HaveCoinInCache(data.outpoints[outpointidx]);\n+            },\n+\n+            [&]() { // AccessCoin\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data.\n+                auto sim = lookup(outpointidx);\n+                // Look up in real caches.\n+                const auto& realcoin = caches.back()->AccessCoin(data.outpoints[outpointidx]);\n+                // Compare results.\n+                if (!sim.has_value()) {\n+                    assert(realcoin.IsSpent());\n+                } else {\n+                    assert(!realcoin.IsSpent());\n+                    const auto& simcoin = data.coins[sim->first];\n+                    assert(simcoin.out == realcoin.out);\n+                    assert(simcoin.fCoinBase == realcoin.fCoinBase);\n+                    assert(realcoin.nHeight == sim->second);\n+                }\n+            },\n+\n+            [&]() { // AddCoin (only possible_overwrite if necessary)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                uint32_t coinidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_COINS - 1);\n+                // Look up in simulation data (to know whether we must set possible_overwrite or not).\n+                auto sim = lookup(outpointidx);\n+                // Invoke on real caches.\n+                Coin coin = data.coins[coinidx];\n+                coin.nHeight = current_height;\n+                caches.back()->AddCoin(data.outpoints[outpointidx], std::move(coin), sim.has_value());\n+                // Apply to simulation data.\n+                auto& entry = sim_caches[caches.size()].entry[outpointidx];\n+                entry.entrytype = EntryType::UNSPENT;\n+                entry.coinidx = coinidx;\n+                entry.height = current_height;\n+            },\n+\n+            [&]() { // AddCoin (always possible_overwrite)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                uint32_t coinidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_COINS - 1);\n+                // Invoke on real caches.\n+                Coin coin = data.coins[coinidx];\n+                coin.nHeight = current_height;\n+                caches.back()->AddCoin(data.outpoints[outpointidx], std::move(coin), true);\n+                // Apply to simulation data.\n+                auto& entry = sim_caches[caches.size()].entry[outpointidx];\n+                entry.entrytype = EntryType::UNSPENT;\n+                entry.coinidx = coinidx;\n+                entry.height = current_height;\n+            },\n+\n+            [&]() { // SpendCoin (moveto = nullptr)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Invoke on real caches.\n+                caches.back()->SpendCoin(data.outpoints[outpointidx], nullptr);\n+                // Apply to simulation data.\n+                sim_caches[caches.size()].entry[outpointidx].entrytype = EntryType::SPENT;\n+            },\n+\n+            [&]() { // SpendCoin (with moveto)\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Look up in simulation data (to compare the returned *moveto with).\n+                auto sim = lookup(outpointidx);\n+                // Invoke on real caches.\n+                Coin realcoin;\n+                caches.back()->SpendCoin(data.outpoints[outpointidx], &realcoin);\n+                // Apply to simulation data.\n+                sim_caches[caches.size()].entry[outpointidx].entrytype = EntryType::SPENT;\n+                // Compare *moveto with the value expected based on simulation data.\n+                if (!sim.has_value()) {\n+                    assert(realcoin.IsSpent());\n+                } else {\n+                    assert(!realcoin.IsSpent());\n+                    const auto& simcoin = data.coins[sim->first];\n+                    assert(simcoin.out == realcoin.out);\n+                    assert(simcoin.fCoinBase == realcoin.fCoinBase);\n+                    assert(realcoin.nHeight == sim->second);\n+                }\n+            },\n+\n+            [&]() { // Uncache\n+                uint32_t outpointidx = provider.ConsumeIntegralInRange<uint32_t>(0, NUM_OUTPOINTS - 1);\n+                // Apply to real caches (there is no equivalent in our simulation).\n+                caches.back()->Uncache(data.outpoints[outpointidx]);\n+            },\n+\n+            [&]() { // Add a cache level (if not already at the max).\n+                if (caches.size() != MAX_CACHES) {\n+                    // Apply to real caches.\n+                    caches.emplace_back(new CCoinsViewCache(&*caches.back()));\n+                    // Apply to simulation data.\n+                    sim_caches[caches.size()].Wipe();\n+                }\n+            },\n+\n+            [&]() { // Remove a cache level.\n+                // Apply to real caches (this reduces caches.size(), implicitly doing the same on the simulation data).\n+                caches.back()->SanityCheck();\n+                caches.pop_back();\n+            },\n+\n+            [&]() { // Flush.\n+                // Apply to simulation data.\n+                flush();\n+                // Apply to real caches.\n+                caches.back()->Flush();\n+            },\n+\n+            [&]() { // Sync.\n+                // Apply to simulation data (note that in our simulation, syncing and flushing is the same thing).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093303443",
      "id" : 1093303443,
      "in_reply_to_id" : 1093282327,
      "line" : 396,
      "node_id" : "PRRC_kwDOABII585BKnyT",
      "original_commit_id" : "c7d20096b6808b11aadda7a652273298b3dd98a8",
      "original_line" : 396,
      "original_position" : 396,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 396,
      "pull_request_review_id" : 1279231079,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093303443/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-01T14:35:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093303443",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093861209"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093861209"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not sure about 0, 1, 2 etc. used here:\r\n\r\nReadability: Instead of using numbers, meaningful names for the different coin attributes could be used. This makes the code easier to understand and maintain.\r\n",
      "commit_id" : "b95982b3f976b85ceaa1db079df8dc41d4f45fa9",
      "created_at" : "2023-02-01T23:53:53Z",
      "diff_hunk" : "@@ -314,6 +314,23 @@ void CCoinsViewCache::ReallocateCache()\n     ::new (&cacheCoins) CCoinsMap();\n }\n \n+void CCoinsViewCache::SanityCheck() const\n+{\n+    size_t recomputed_usage = 0;\n+    for (const auto& [_, entry] : cacheCoins) {\n+        unsigned attr = 0;\n+        if (entry.flags & CCoinsCacheEntry::DIRTY) attr |= 1;\n+        if (entry.flags & CCoinsCacheEntry::FRESH) attr |= 2;\n+        if (entry.coin.IsSpent()) attr |= 4;\n+        // Only 5 combinations are possible.\n+        assert(attr != 2 && attr != 4 && attr != 7);\n+\n+        // Recompute cachedCoinsUsage.\n+        recomputed_usage += entry.coin.DynamicMemoryUsage();\n+    }\n+    assert(recomputed_usage == cachedCoinsUsage);\n+}\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093861209",
      "id" : 1093861209,
      "line" : 335,
      "node_id" : "PRRC_kwDOABII585BMv9Z",
      "original_commit_id" : "bc2cc7243fe8063217b719b6cdf05373d161b706",
      "original_line" : 335,
      "original_position" : 20,
      "original_start_line" : 317,
      "path" : "src/coins.cpp",
      "position" : 31,
      "pull_request_review_id" : 1280056566,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093861209/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 319,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-01T23:53:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093861209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/94559964?v=4",
         "events_url" : "https://api.github.com/users/1440000bytes/events{/privacy}",
         "followers_url" : "https://api.github.com/users/1440000bytes/followers",
         "following_url" : "https://api.github.com/users/1440000bytes/following{/other_user}",
         "gists_url" : "https://api.github.com/users/1440000bytes/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/1440000bytes",
         "id" : 94559964,
         "login" : "1440000bytes",
         "node_id" : "U_kgDOBaLe3A",
         "organizations_url" : "https://api.github.com/users/1440000bytes/orgs",
         "received_events_url" : "https://api.github.com/users/1440000bytes/received_events",
         "repos_url" : "https://api.github.com/users/1440000bytes/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/1440000bytes/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/1440000bytes/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/1440000bytes"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093863917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093863917"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There really is no meaning at all; they're arbitrary bits assigned to certain properties.",
      "commit_id" : "b95982b3f976b85ceaa1db079df8dc41d4f45fa9",
      "created_at" : "2023-02-01T23:59:19Z",
      "diff_hunk" : "@@ -314,6 +314,23 @@ void CCoinsViewCache::ReallocateCache()\n     ::new (&cacheCoins) CCoinsMap();\n }\n \n+void CCoinsViewCache::SanityCheck() const\n+{\n+    size_t recomputed_usage = 0;\n+    for (const auto& [_, entry] : cacheCoins) {\n+        unsigned attr = 0;\n+        if (entry.flags & CCoinsCacheEntry::DIRTY) attr |= 1;\n+        if (entry.flags & CCoinsCacheEntry::FRESH) attr |= 2;\n+        if (entry.coin.IsSpent()) attr |= 4;\n+        // Only 5 combinations are possible.\n+        assert(attr != 2 && attr != 4 && attr != 7);\n+\n+        // Recompute cachedCoinsUsage.\n+        recomputed_usage += entry.coin.DynamicMemoryUsage();\n+    }\n+    assert(recomputed_usage == cachedCoinsUsage);\n+}\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1093863917",
      "id" : 1093863917,
      "in_reply_to_id" : 1093861209,
      "line" : 335,
      "node_id" : "PRRC_kwDOABII585BMwnt",
      "original_commit_id" : "bc2cc7243fe8063217b719b6cdf05373d161b706",
      "original_line" : 335,
      "original_position" : 20,
      "original_start_line" : 317,
      "path" : "src/coins.cpp",
      "position" : 31,
      "pull_request_review_id" : 1280060151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093863917/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 319,
      "start_side" : "RIGHT",
      "updated_at" : "2023-02-01T23:59:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1093863917",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1094389462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1094389462"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think currently the determinism is lost when `ReallocateCache` is called, because we call the constructor there without the deterministic `SaltedOutpointHasher`.\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/883c2c8258fb10cfd5ab5e60735284b274fb1158/src/coins.cpp#L311-L317",
      "commit_id" : "883c2c8258fb10cfd5ab5e60735284b274fb1158",
      "created_at" : "2023-02-02T11:21:46Z",
      "diff_hunk" : "@@ -32,7 +32,9 @@ bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock,\n std::unique_ptr<CCoinsViewCursor> CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn) : CCoinsViewBacked(baseIn) {}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn, bool deterministic) :\n+    CCoinsViewBacked(baseIn), cacheCoins(0, SaltedOutpointHasher(deterministic))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1094389462",
      "id" : 1094389462,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII585BOw7W",
      "original_commit_id" : "883c2c8258fb10cfd5ab5e60735284b274fb1158",
      "original_line" : 36,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/coins.cpp",
      "position" : 6,
      "pull_request_review_id" : 1280848061,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1094389462/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-02T11:21:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1094389462",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1094643941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1094643941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed, I think.",
      "commit_id" : "59e6828bb5b56a2354a80059d3f660f551f3e207",
      "created_at" : "2023-02-02T14:58:52Z",
      "diff_hunk" : "@@ -32,7 +32,9 @@ bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock,\n std::unique_ptr<CCoinsViewCursor> CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn) : CCoinsViewBacked(baseIn) {}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView* baseIn, bool deterministic) :\n+    CCoinsViewBacked(baseIn), cacheCoins(0, SaltedOutpointHasher(deterministic))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1094643941",
      "id" : 1094643941,
      "in_reply_to_id" : 1094389462,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585BPvDl",
      "original_commit_id" : "883c2c8258fb10cfd5ab5e60735284b274fb1158",
      "original_line" : 36,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/coins.cpp",
      "position" : null,
      "pull_request_review_id" : 1281230016,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1094643941/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-02T14:58:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1094643941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "https://drahtbot.space/host_reports/DrahtBot/reports/coverage_fuzz/monotree/59e6828bb5b56a23/fuzz.coverage/index.html",
      "created_at" : "2023-02-02T21:48:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1414420147",
      "id" : 1414420147,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585UTlaz",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414420147/reactions"
      },
      "updated_at" : "2023-02-02T21:48:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414420147",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1095119955"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095119955"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Looks like this isn't covered https://drahtbot.space/host_reports/DrahtBot/reports/coverage_fuzz/monotree/59e6828bb5b56a23/fuzz.coverage/src/test/fuzz/coinscache_sim.cpp.gcov.html#177",
      "commit_id" : "59e6828bb5b56a2354a80059d3f660f551f3e207",
      "created_at" : "2023-02-02T21:51:11Z",
      "diff_hunk" : "@@ -0,0 +1,468 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/util.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkeys (of different lengths, so SanityCheck's cached memory\n+             * usage check has a chance to detect mismatches). */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1095119955",
      "id" : 1095119955,
      "line" : 177,
      "node_id" : "PRRC_kwDOABII585BRjRT",
      "original_commit_id" : "59e6828bb5b56a2354a80059d3f660f551f3e207",
      "original_line" : 177,
      "original_position" : 177,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 177,
      "pull_request_review_id" : 1281960526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095119955/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-02T21:51:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095119955",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1095130020"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095130020"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's not what I would have expected when I wrote it, but it makes sense; it's related to how line 55 of coins.cpp (https://drahtbot.space/host_reports/DrahtBot/reports/coverage_fuzz/monotree/59e6828bb5b56a23/fuzz.coverage/src/coins.cpp.gcov.html) isn't covered either.\r\n\r\nWhen a coin is looked up in a child cache, and the parent reports it doesn't exist, the child does not cache that absence (this is in contrast to a successful lookup, which does get copied into the child). As a result, we never actually exercise the case where non-`DIRTY` `IsSpent()` appear in the caches.\r\n\r\nI don't think this is a problem. This fuzz test is designed to simulate a relatively realistic scenario of cache creations/deletions/flushes/syncs/additions/spends/lookups, and I believe the above just means that a lack of non-DIRTY spent coins also doesn't appear in actual block processing.",
      "commit_id" : "59e6828bb5b56a2354a80059d3f660f551f3e207",
      "created_at" : "2023-02-02T22:00:23Z",
      "diff_hunk" : "@@ -0,0 +1,468 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <coins.h>\n+#include <crypto/sha256.h>\n+#include <primitives/transaction.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/util.h>\n+\n+#include <assert.h>\n+#include <optional>\n+#include <memory>\n+#include <stdint.h>\n+#include <vector>\n+\n+namespace {\n+\n+/** Number of distinct COutPoint values used in this test. */\n+constexpr uint32_t NUM_OUTPOINTS = 256;\n+/** Number of distinct Coin values used in this test (ignoring nHeight). */\n+constexpr uint32_t NUM_COINS = 256;\n+/** Maximum number CCoinsViewCache objects used in this test. */\n+constexpr uint32_t MAX_CACHES = 4;\n+/** Data type large enough to hold NUM_COINS-1. */\n+using coinidx_type = uint8_t;\n+\n+struct PrecomputedData\n+{\n+    //! Randomly generated COutPoint values.\n+    COutPoint outpoints[NUM_OUTPOINTS];\n+\n+    //! Randomly generated Coin values.\n+    Coin coins[NUM_COINS];\n+\n+    PrecomputedData()\n+    {\n+        static const uint8_t PREFIX_O[1] = {'o'}; /** Hash prefix for outpoint hashes. */\n+        static const uint8_t PREFIX_S[1] = {'s'}; /** Hash prefix for coins scriptPubKeys. */\n+        static const uint8_t PREFIX_M[1] = {'m'}; /** Hash prefix for coins nValue/fCoinBase. */\n+\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            uint32_t idx = (i * 1200U) >> 12; /* Map 3 or 4 entries to same txid. */\n+            const uint8_t ser[4] = {uint8_t(idx), uint8_t(idx >> 8), uint8_t(idx >> 16), uint8_t(idx >> 24)};\n+            CSHA256().Write(PREFIX_O, 1).Write(ser, sizeof(ser)).Finalize(outpoints[i].hash.begin());\n+            outpoints[i].n = i;\n+        }\n+\n+        for (uint32_t i = 0; i < NUM_COINS; ++i) {\n+            const uint8_t ser[4] = {uint8_t(i), uint8_t(i >> 8), uint8_t(i >> 16), uint8_t(i >> 24)};\n+            uint256 hash;\n+            CSHA256().Write(PREFIX_S, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            /* Convert hash to scriptPubkeys (of different lengths, so SanityCheck's cached memory\n+             * usage check has a chance to detect mismatches). */\n+            switch (i % 5U) {\n+            case 0: /* P2PKH */\n+                coins[i].out.scriptPubKey.resize(25);\n+                coins[i].out.scriptPubKey[0] = OP_DUP;\n+                coins[i].out.scriptPubKey[1] = OP_HASH160;\n+                coins[i].out.scriptPubKey[2] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 3);\n+                coins[i].out.scriptPubKey[23] = OP_EQUALVERIFY;\n+                coins[i].out.scriptPubKey[24] = OP_CHECKSIG;\n+                break;\n+            case 1: /* P2SH */\n+                coins[i].out.scriptPubKey.resize(23);\n+                coins[i].out.scriptPubKey[0] = OP_HASH160;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                coins[i].out.scriptPubKey[12] = OP_EQUAL;\n+                break;\n+            case 2: /* P2WPKH */\n+                coins[i].out.scriptPubKey.resize(22);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 20;\n+                std::copy(hash.begin(), hash.begin() + 20, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 3: /* P2WSH */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_0;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            case 4: /* P2TR */\n+                coins[i].out.scriptPubKey.resize(34);\n+                coins[i].out.scriptPubKey[0] = OP_1;\n+                coins[i].out.scriptPubKey[1] = 32;\n+                std::copy(hash.begin(), hash.begin() + 32, coins[i].out.scriptPubKey.begin() + 2);\n+                break;\n+            }\n+            /* Hash again to construct nValue and fCoinBase. */\n+            CSHA256().Write(PREFIX_M, 1).Write(ser, sizeof(ser)).Finalize(hash.begin());\n+            coins[i].out.nValue = CAmount(hash.GetUint64(0) % MAX_MONEY);\n+            coins[i].fCoinBase = (hash.GetUint64(1) & 7) == 0;\n+            coins[i].nHeight = 0; /* Real nHeight used in simulation is set dynamically. */\n+        }\n+    }\n+};\n+\n+enum class EntryType : uint8_t\n+{\n+    /* This entry in the cache does not exist (so we'd have to look in the parent cache). */\n+    NONE,\n+\n+    /* This entry in the cache corresponds to an unspent coin. */\n+    UNSPENT,\n+\n+    /* This entry in the cache corresponds to a spent coin. */\n+    SPENT,\n+};\n+\n+struct CacheEntry\n+{\n+    /* Type of entry. */\n+    EntryType entrytype;\n+\n+    /* Index in the coins array this entry corresponds to (only if entrytype == UNSPENT). */\n+    coinidx_type coinidx;\n+\n+    /* nHeight value for this entry (so the coins[coinidx].nHeight value is ignored; only if entrytype == UNSPENT). */\n+    uint32_t height;\n+};\n+\n+struct CacheLevel\n+{\n+    CacheEntry entry[NUM_OUTPOINTS];\n+\n+    void Wipe() {\n+        for (uint32_t i = 0; i < NUM_OUTPOINTS; ++i) {\n+            entry[i].entrytype = EntryType::NONE;\n+        }\n+    }\n+};\n+\n+/** Class for the base of the hierarchy (roughly simulating a memory-backed CCoinsViewDB). */\n+class CoinsViewBottom final : public CCoinsView\n+{\n+    std::map<COutPoint, Coin> m_data;\n+\n+public:\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const final\n+    {\n+        auto it = m_data.find(outpoint);\n+        if (it == m_data.end()) {\n+            return false;\n+        } else {\n+            coin = it->second;\n+            return true;\n+        }\n+    }\n+\n+    bool HaveCoin(const COutPoint& outpoint) const final\n+    {\n+        return m_data.count(outpoint);\n+    }\n+\n+    uint256 GetBestBlock() const final { return {}; }\n+    std::vector<uint256> GetHeadBlocks() const final { return {}; }\n+    std::unique_ptr<CCoinsViewCursor> Cursor() const final { return {}; }\n+    size_t EstimateSize() const final { return m_data.size(); }\n+\n+    bool BatchWrite(CCoinsMap& data, const uint256&, bool erase) final\n+    {\n+        for (auto it = data.begin(); it != data.end(); it = erase ? data.erase(it) : std::next(it)) {\n+            if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+                if (it->second.coin.IsSpent()) {\n+                    m_data.erase(it->first);\n+                } else if (erase) {\n+                    m_data[it->first] = std::move(it->second.coin);\n+                } else {\n+                    m_data[it->first] = it->second.coin;\n+                }\n+            } else {\n+                /* For non-dirty entries being written, compare them with what we have. */\n+                if (it->second.coin.IsSpent()) {\n+                    assert(m_data.count(it->first) == 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#discussion_r1095130020",
      "id" : 1095130020,
      "in_reply_to_id" : 1095119955,
      "line" : 177,
      "node_id" : "PRRC_kwDOABII585BRluk",
      "original_commit_id" : "59e6828bb5b56a2354a80059d3f660f551f3e207",
      "original_line" : 177,
      "original_position" : 177,
      "original_start_line" : null,
      "path" : "src/test/fuzz/coinscache_sim.cpp",
      "position" : 177,
      "pull_request_review_id" : 1281976969,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27011",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095130020/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-02T22:01:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095130020",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK https://github.com/bitcoin/bitcoin/pull/27011/commits/561848aaf2d67791e92754f3d11813bc53959a8f\r\n\r\n",
      "created_at" : "2023-02-07T16:34:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1421069505",
      "id" : 1421069505,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585Us8zB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1421069505/reactions"
      },
      "updated_at" : "2023-02-07T16:34:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1421069505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I ran the fuzzer using the latest corpus for about an hour and it didn't find any crashes, so that's nice.",
      "created_at" : "2023-02-08T14:32:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1422690771",
      "id" : 1422690771,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585UzInT",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422690771/reactions"
      },
      "updated_at" : "2023-02-08T14:32:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422690771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The seeds I've added to qa-assets for this fuzzer (https://github.com/bitcoin-core/qa-assets/pull/103) are the result of a few months of CPU time, FWIW.",
      "created_at" : "2023-02-08T14:44:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1422709281",
      "id" : 1422709281,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585UzNIh",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422709281/reactions"
      },
      "updated_at" : "2023-02-10T15:41:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422709281",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code review ACK 561848aaf2d67791e92754f3d11813bc53959a8f",
      "created_at" : "2023-02-13T12:08:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1427833942",
      "id" : 1427833942,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585VGwRW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1427833942/reactions"
      },
      "updated_at" : "2023-02-13T12:08:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1427833942",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sipa While rebasing #25325 I saw that the fuzzer in `coins_view.cpp` still uses `CCoinsMap coins_map;` and doesn't use the deterministic seeds, shouldn't this fuzzer do that as well?\r\n\r\nI can add it while rebasing, I'm touching that line anyways. Unless you want to do this separately",
      "created_at" : "2023-02-14T06:40:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27011#issuecomment-1429201435",
      "id" : 1429201435,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27011",
      "node_id" : "IC_kwDOABII585VL-Ib",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429201435/reactions"
      },
      "updated_at" : "2023-02-14T06:40:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429201435",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   }
]
