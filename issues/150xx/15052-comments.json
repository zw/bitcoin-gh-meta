[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503109"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Drop all these empty lines surrounding single code lines. Applies throughout this PR :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T16:59:10Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503109",
      "id" : 244503109,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzEwOQ==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 48,
      "path" : "src/test/timedata_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503109",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503202"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be unsigned to match what `CMedianFilter` expects?\r\n\r\nApplies for all `int capacity` in this file.",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:00:33Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    int capacity = 20; //  can store up to 20 samples",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503202",
      "id" : 244503202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzIwMg==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 68,
      "path" : "src/test/timedata_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503202",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503273"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make the implicit conversion from `unsigned int` to `unsigned char` explicit here.\r\n\r\nApplies for all `CNetAddr addr = UtilBuildAddress(Ã¢ÂÂ¦, sample);` in this file.",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:01:31Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503273",
      "id" : 244503273,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzI3Mw==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 75,
      "path" : "src/test/timedata_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503273",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503644"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂsupportsÃ¢ÂÂ :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:06:47Z",
      "diff_hunk" : "@@ -290,25 +290,52 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart function within the wallet reads the current time using the GetAdjustedTime function in timedata.\n+    //\n+    // This function computes the time based on the system time (which suports mocking)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503644",
      "id" : 244503644,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzY0NA==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 34,
      "path" : "src/wallet/test/wallet_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503644",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503656"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂprecedingÃ¢ÂÂ :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:07:12Z",
      "diff_hunk" : "@@ -290,25 +290,52 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart function within the wallet reads the current time using the GetAdjustedTime function in timedata.\n+    //\n+    // This function computes the time based on the system time (which suports mocking)\n+    // and the time offset, which is not necessarily zero (and does not support mocking)\n+    //\n+    // Tests have to be executed in order, because the individual cases are stateful\n+\n+\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n+    SetMockTime(10);\n+    int64_t clockTime = GetAdjustedTime(); // time + time offset (unfortunately, from a statefull data structure)\n+    int64_t blockTime = clockTime + 5;\n+\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, blockTime), clockTime); // clocktime shall be used\n \n     // Test that updating existing transaction does not change smart time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 200, 220), 100);\n+    SetMockTime(20);\n+    int64_t newBlockTime = GetAdjustedTime() + 10;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, newBlockTime), clockTime); // time has not changed from the preceeding transaction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503656",
      "id" : 244503656,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzY1Ng==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 52,
      "path" : "src/wallet/test/wallet_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503656",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503664"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503664"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂprecedingÃ¢ÂÂ :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:07:33Z",
      "diff_hunk" : "@@ -290,25 +290,52 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart function within the wallet reads the current time using the GetAdjustedTime function in timedata.\n+    //\n+    // This function computes the time based on the system time (which suports mocking)\n+    // and the time offset, which is not necessarily zero (and does not support mocking)\n+    //\n+    // Tests have to be executed in order, because the individual cases are stateful\n+\n+\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n+    SetMockTime(10);\n+    int64_t clockTime = GetAdjustedTime(); // time + time offset (unfortunately, from a statefull data structure)\n+    int64_t blockTime = clockTime + 5;\n+\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, blockTime), clockTime); // clocktime shall be used\n \n     // Test that updating existing transaction does not change smart time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 200, 220), 100);\n+    SetMockTime(20);\n+    int64_t newBlockTime = GetAdjustedTime() + 10;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, newBlockTime), clockTime); // time has not changed from the preceeding transaction\n+\n \n     // New transaction should use clock time if there's no block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, 300, 0), 300);\n+    SetMockTime(30);\n+    clockTime = GetAdjustedTime();\n+    blockTime = 0;                                               // block time is not set\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 2, blockTime), clockTime); // clocktime used, because blocktime was not set (zero)\n \n     // New transaction should use block time if lower than clock time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, 420, 400), 400);\n+    SetMockTime(40);\n+    clockTime = GetAdjustedTime();\n+    blockTime = clockTime - 2;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 3, blockTime), blockTime); // blocktime shall be used\n \n     // New transaction should use latest entry time if higher than\n     // min(block time, clock time).\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, 500, 390), 400);\n+    SetMockTime(5);\n+    newBlockTime = blockTime - 5;\n+    BOOST_CHECK_EQUAL(AddTx(m_wallet, 4, newBlockTime), blockTime); // using the blocktime of the preceeding transaction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503664",
      "id" : 244503664,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzY2NA==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 74,
      "path" : "src/wallet/test/wallet_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503664",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503683"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unused. Drop this :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:08:10Z",
      "diff_hunk" : "@@ -44,20 +44,36 @@ static int64_t abs64(int64_t n)\n \n #define BITCOIN_TIMEDATA_MAX_SAMPLES 200\n \n+\n+static std::set<CNetAddr> setKnown;\n+\n+static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n+\n+int CountOffsetSamples()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503683",
      "id" : 244503683,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzY4Mw==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 9,
      "path" : "src/timedata.cpp",
      "position" : 9,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503683",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unused :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:08:20Z",
      "diff_hunk" : "@@ -75,4 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to isolate the contract in AddTimeData */\n+int CountOffsetSamples();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503688",
      "id" : 244503688,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzY4OA==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 13,
      "path" : "src/timedata.h",
      "position" : 13,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503688",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503754"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂstatefulÃ¢ÂÂ :-)",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:08:57Z",
      "diff_hunk" : "@@ -290,25 +290,52 @@ static int64_t AddTx(CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64\n // expanded to cover more corner cases of smart time logic.\n BOOST_AUTO_TEST_CASE(ComputeTimeSmart)\n {\n+    // The ComputeTimeSmart function within the wallet reads the current time using the GetAdjustedTime function in timedata.\n+    //\n+    // This function computes the time based on the system time (which suports mocking)\n+    // and the time offset, which is not necessarily zero (and does not support mocking)\n+    //\n+    // Tests have to be executed in order, because the individual cases are stateful\n+\n+\n     // New transaction should use clock time if lower than block time.\n-    BOOST_CHECK_EQUAL(AddTx(m_wallet, 1, 100, 120), 100);\n+    SetMockTime(10);\n+    int64_t clockTime = GetAdjustedTime(); // time + time offset (unfortunately, from a statefull data structure)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503754",
      "id" : 244503754,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzc1NA==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 43,
      "path" : "src/wallet/test/wallet_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503754",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503775"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503775"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂsampleÃ¢ÂÂ?",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:09:20Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset\n+\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset != offset);                    // ...and new offset was computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 7 samples. (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 9); // next sample will be the 10th (even) and will *not* trigger a new computation of the offset\n+\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset == offset);                    // ...but new offset was not computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWithMedianWithinBounds)\n+{\n+    int capacity = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init samplee: 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503775",
      "id" : 244503775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzc3NQ==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 125,
      "path" : "src/test/timedata_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503775",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503826"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503826"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why `assert(Ã¢ÂÂ¦)` and not `BOOST_CHECK(Ã¢ÂÂ¦)`? Applies throughout this PR.",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:11:29Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503826",
      "id" : 244503826,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzgyNg==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 81,
      "path" : "src/test/timedata_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503826",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503838"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503838"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Drop one of the newlines. Applies for all double newlines in this PR.",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:11:56Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset\n+\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset != offset);                    // ...and new offset was computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 7 samples. (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 9); // next sample will be the 10th (even) and will *not* trigger a new computation of the offset\n+\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503838",
      "id" : 244503838,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzgzOA==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 110,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 97,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503838",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503861"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503861"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Drop empty line at end of block.",
      "commit_id" : "477db9e4dd61159eabfec47e3804454cc3e43a7b",
      "created_at" : "2018-12-29T17:12:45Z",
      "diff_hunk" : "@@ -34,4 +35,223 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+/* Utility function to build a CNetAddr object.\n+\n+   Using memcpy to build sockaddr_in because compat.h does not support inet_pton with current #define _WIN32_WINNT 0x0501\n+*/\n+CNetAddr UtilBuildAddress(unsigned char ip1, unsigned char ip2, unsigned char ip3, unsigned char ip4)\n+{\n+    unsigned char ip[] = {ip1, ip2, ip3, ip4};\n+\n+    struct sockaddr_in sa;\n+    memset(&sa, 0, sizeof(sockaddr_in)); // initialize the memory block\n+    memcpy(&(sa.sin_addr), &ip, sizeof(ip));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_UtilBuildAddress)\n+{\n+    CNetAddr cn1 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    CNetAddr cn2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D2); // 1.1.1.210\n+\n+    bool eq = (cn1 == cn2);\n+\n+    BOOST_CHECK(eq);\n+\n+    CNetAddr cn3 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0D3); // 1.1.1.211\n+\n+    bool neq = !(cn1 == cn3);\n+\n+    BOOST_CHECK(neq);\n+\n+    neq = !(cn2 == cn3);\n+\n+    BOOST_CHECK(neq);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWhenNewSampleCountIsGreaterEqualFiveAndUneven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 10; sample++) { // precondition: at least 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 10); // next sample will be the 11th (uneven) and will trigger a new computation of the offset\n+\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset != offset);                    // ...and new offset was computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmDoNotComputeOffsetWhenNewSampleCountIsGreaterEqualFiveButEven)\n+{\n+    int capacity = 20; //  can store up to 20 samples\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 20 , init sample: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 9; sample++) { // precondition: at least 7 samples. (including the init sample : 0\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK(offset != 0); // offset has changed from the initial value\n+\n+    assert(offsetFilter.size() == 9); // next sample will be the 10th (even) and will *not* trigger a new computation of the offset\n+\n+\n+    int samples = offsetFilter.size();\n+    int64_t oldOffset = offset;\n+    CNetAddr addr2 = UtilBuildAddress(0x001, 0x001, 0x001, 0x0010);\n+    AddTimeDataAlgorithm(addr2, 111, knownSet, offsetFilter, offset); // 1.1.1.16 , offsetSample = 111\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), samples + 1); // sample was added...\n+    BOOST_CHECK(oldOffset == offset);                    // ...but new offset was not computed\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmComputeOffsetWithMedianWithinBounds)\n+{\n+    int capacity = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init samplee: 0\n+\n+\n+    for (unsigned int sample = 1; sample < 4; sample++) { // precondition: 4 samples. (including the init sample : 0)\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);\n+        AddTimeDataAlgorithm(addr, sample, knownSet, offsetFilter, offset); // 1.1.1.[1,2,3],  offsetSample = [1,2,3]\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(UtilBuildAddress(0x001, 0x001, 0x001, 0x0C8), 200, knownSet, offsetFilter, offset); // 1.1.1.200 , offsetSample = 200\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmOffsetFlipsToZeroIfMedianIsOutsideBounds)\n+{\n+    int capacity = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(capacity, 0); // max size : 10 , init sample: 0\n+\n+    for (int sample = 1; sample < 4; sample++) {                                                     // precondition: 4 samples, all outside bounds\n+        CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, sample);                               // 1.1.1.[1,2,3]\n+        AddTimeDataAlgorithm(addr, 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // offsetSample  = 2 * DEFAULT_MAX_TIME_ADJUSTMENT (out of bounds)\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15052#discussion_r244503861",
      "id" : 244503861,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0NDUwMzg2MQ==",
      "original_commit_id" : "a92d201a5db95bac243b1b86ef36580015735d8d",
      "original_position" : 152,
      "path" : "src/test/timedata_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 188416711,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15052",
      "updated_at" : "2018-12-30T16:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/244503861",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
