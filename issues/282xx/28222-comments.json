[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28222#pullrequestreview-1565029167), [vasild](https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1677719961) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#28248](https://github.com/bitcoin/bitcoin/pull/28248) (p2p: bugfixes, logic and logging improvements by jonatack)\n* [#28196](https://github.com/bitcoin/bitcoin/pull/28196) (BIP324 connection support by sipa)\n* [#28165](https://github.com/bitcoin/bitcoin/pull/28165) (net: transport abstraction by sipa)\n* [#28155](https://github.com/bitcoin/bitcoin/pull/28155) (Improves addnode / m_added_nodes logic by sr-gi)\n* [#28016](https://github.com/bitcoin/bitcoin/pull/28016) (p2p: gives seednode priority over dnsseed if both are provided by sr-gi)\n* [#27981](https://github.com/bitcoin/bitcoin/pull/27981) (Fix potential network stalling bug by sipa)\n* [#27600](https://github.com/bitcoin/bitcoin/pull/27600) (net: Add new permission `forceinbound` to evict a random unprotected connection if all slots are otherwise full by pinheadmz)\n* [#27114](https://github.com/bitcoin/bitcoin/pull/27114) (p2p: Allow whitelisting outgoing connections by brunoerg)\n* [#27071](https://github.com/bitcoin/bitcoin/pull/27071) (Handle CJDNS from LookupSubNet() by vasild)\n* [#26938](https://github.com/bitcoin/bitcoin/pull/26938) ([WIP] p2p: asmap, avoid inbound connections from a specific AS by brunoerg)\n* [#26621](https://github.com/bitcoin/bitcoin/pull/26621) (refactor: Continue moving application data from CNode to Peer by dergoegge)\n* [#21878](https://github.com/bitcoin/bitcoin/pull/21878) (Make all networking code mockable by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2023-08-05T09:45:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1666456560",
      "id" : 1666456560,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jVBvw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666456560/reactions"
      },
      "updated_at" : "2023-08-17T06:06:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666456560",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Also see #10738",
      "created_at" : "2023-08-05T13:35:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1666508138",
      "id" : 1666508138,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jVOVq",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666508138/reactions"
      },
      "updated_at" : "2023-08-05T13:35:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666508138",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Also see #10738\r\n\r\nThanks, I hadn't seen this one before. Will take a look tonight\r\n\r\nEdit: Really like the last commit. Will see if I can also drop a few locks too..",
      "created_at" : "2023-08-05T14:14:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1666517688",
      "id" : 1666517688,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jVQq4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666517688/reactions"
      },
      "updated_at" : "2023-08-05T20:52:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666517688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-08-06T17:46:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1666931527",
      "id" : 1666931527,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jW1tH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666931527/reactions"
      },
      "updated_at" : "2023-08-06T17:46:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1666931527",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Also see #10738\r\n\r\n:+1: \r\n\r\nI guess it must be possible to do that without \"reinventing the wheel aka introducing custom smart pointer types\", like mentioned in the last comment.",
      "created_at" : "2023-08-07T06:42:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1667275661",
      "id" : 1667275661,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jYJuN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1667275661/reactions"
      },
      "updated_at" : "2023-08-07T06:42:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1667275661",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285681548"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285681548"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a reason why we need to use the shared_ptr type in net processing?",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-08-07T10:24:54Z",
      "diff_hunk" : "@@ -502,7 +502,7 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Implement NetEventsInterface */\n     void InitializeNode(CNode& node, ServiceFlags our_services) override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex);\n-    void FinalizeNode(const CNode& node) override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, !m_headers_presync_mutex);\n+    void FinalizeNode(const CNodeRef node) override EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, !m_headers_presync_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285681548",
      "id" : 1285681548,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MofGM",
      "original_commit_id" : "499f267050d076a9065342c58338d5f2da791053",
      "original_line" : 505,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 1565029167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285681548/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-07T12:00:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285681548",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285682361"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285682361"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(I know this will get push back but)\r\n\r\nnit: Could we call this `ConnectionRef`? After all the connection manager is managing... connections.",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-08-07T10:25:46Z",
      "diff_hunk" : "@@ -651,6 +633,8 @@ class CNode\n     std::unique_ptr<i2p::sam::Session> m_i2p_sam_session GUARDED_BY(m_sock_mutex);\n };\n \n+typedef std::shared_ptr<CNode> CNodeRef;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285682361",
      "id" : 1285682361,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MofS5",
      "original_commit_id" : "499f267050d076a9065342c58338d5f2da791053",
      "original_line" : 636,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1565029167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 1,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285682361/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-07T12:00:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285682361",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285683763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285683763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It would also seem more modern to use `using` here",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-08-07T10:27:16Z",
      "diff_hunk" : "@@ -651,6 +633,8 @@ class CNode\n     std::unique_ptr<i2p::sam::Session> m_i2p_sam_session GUARDED_BY(m_sock_mutex);\n };\n \n+typedef std::shared_ptr<CNode> CNodeRef;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285683763",
      "id" : 1285683763,
      "in_reply_to_id" : 1285682361,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Mofoz",
      "original_commit_id" : "499f267050d076a9065342c58338d5f2da791053",
      "original_line" : 636,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1565029167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285683763/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-07T12:00:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285683763",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285689978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285689978"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In a way this is worse than the custom ref counting because it is harder to assert that we actually don't take new references after this check.",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-08-07T10:33:50Z",
      "diff_hunk" : "@@ -1138,23 +1135,23 @@ void CConnman::DisconnectNodes()\n                 // close socket and cleanup\n                 pnode->CloseSocketDisconnect();\n \n-                // hold in disconnected pool until all refs are released\n-                pnode->Release();\n+                // move to m_nodes_disconnected until all refs are released\n                 m_nodes_disconnected.push_back(pnode);\n             }\n         }\n     }\n     {\n         // Delete disconnected nodes\n-        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;\n-        for (CNode* pnode : nodes_disconnected_copy)\n-        {\n-            // Destroy the object only after other threads have stopped using it.\n-            if (pnode->GetRefCount() <= 0) {\n-                m_nodes_disconnected.remove(pnode);\n-                DeleteNode(pnode);\n+        std::vector<CNodeRef> disconnected_still_in_use;\n+        for (auto& pnode : m_nodes_disconnected) {\n+            // Finalize when we have the final reference inside this block\n+            if (pnode.use_count() == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1285689978",
      "id" : 1285689978,
      "line" : 1148,
      "node_id" : "PRRC_kwDOABII585MohJ6",
      "original_commit_id" : "499f267050d076a9065342c58338d5f2da791053",
      "original_line" : 1148,
      "original_position" : 239,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 274,
      "pull_request_review_id" : 1565029167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285689978/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-07T12:00:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1285689978",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @theuni (just in case you are interested in chiming in)",
      "created_at" : "2023-08-07T12:01:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1667726251",
      "id" : 1667726251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jZ3ur",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1667726251/reactions"
      },
      "updated_at" : "2023-08-07T12:01:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1667726251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the conceptual review @dergoegge.\r\n\r\nI've forced push a relatively different approach here, trying to take into consideration your review points, and #10738, but trying not to require introducing the decaying pointers. This has resulted in the following conceptual changes:\r\n\r\n1. Taking the idea of @theuni's `GetnodesCopy()` in `m_nodes` iterations by re-purposing and upgrading `NodesSnapshot()` a bit, allowing removal of many instances of `m_nodes_mutex` in the code, as he achieved.\r\n2. Made `CNode` a friend of `CConnman`. This allows us to call back to `DeleteNode()` automagically ðª  on CNode destruction when the final reference is dropped. Then we can just worry about dropping all references, which seems easier to reason about for me. I think it might be possible to modify `DeleteNode()` further to assert no `shared_ptr`s remain for it --ensuring that nobody can accidently re-introduce unsafe deletion in the codebase in the future --, but I haven't looked at this yet.\r\n\r\n> In a way this is worse than the custom ref counting because it is harder to assert that we actually don't take new references after this check.\r\n\r\n3. I re-worked this part of `DisconnectNodes()` in general, but IMO this is safe-enough to drop from `m_nodes_disconnected` outright, as the only users of `m_nodes_disconnected` are `StopNodes()` and `DisconnectNodes()`. To belt-and-suspenders this anyway, I added a final optional commit which adds an `m_nodes_disconnected_mutex` to ensure no new references can be created while we are dropping from `m_nodes_disconnected`.\r\n\r\nThe commits need tidying up, rewording etc. still, but otherwise would be curious to know if this new approach looked better to you? ",
      "created_at" : "2023-08-09T10:49:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1671097648",
      "id" : 1671097648,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jmu0w",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671097648/reactions"
      },
      "updated_at" : "2023-08-09T10:49:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671097648",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1288400379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1288400379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Having the managed objects have a reference to the manager leads to absolute spaghetti code, so leaning towards NACK on that.",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-08-09T12:23:25Z",
      "diff_hunk" : "@@ -665,8 +650,11 @@ class CNode\n      * Otherwise this unique_ptr is empty.\n      */\n     std::unique_ptr<i2p::sam::Session> m_i2p_sam_session GUARDED_BY(m_sock_mutex);\n+    CConnman* m_connman;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1288400379",
      "id" : 1288400379,
      "line" : 653,
      "node_id" : "PRRC_kwDOABII585My237",
      "original_commit_id" : "82dc400170414129aedf4b32870b2ade2a5cd71c",
      "original_line" : 653,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 63,
      "pull_request_review_id" : 1569429475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1288400379/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-09T14:47:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1288400379",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1288527915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1288527915"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can just get rid of NodesSnapshot entirely now, it was only needed as a RAII helper for the manual ref counting.",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-08-09T13:57:39Z",
      "diff_hunk" : "@@ -1219,43 +1206,48 @@ class CConnman\n     static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n \n     /**\n-     * RAII helper to atomically create a copy of `m_nodes` and add a reference\n-     * to each of the nodes. The nodes are released when this object is destroyed.\n+     * RAII helper to atomically create a copy of `m_nodes` with shared pointers and manual reference counting.\n      */\n     class NodesSnapshot\n     {\n     public:\n-        explicit NodesSnapshot(const CConnman& connman, bool shuffle)\n+        explicit NodesSnapshot(const CConnman& connman, bool shuffle = false)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1288527915",
      "id" : 1288527915,
      "line" : 1214,
      "node_id" : "PRRC_kwDOABII585MzWAr",
      "original_commit_id" : "36c6fe59b21999c0ea904d310bcc794d0736628d",
      "original_line" : 1214,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 175,
      "pull_request_review_id" : 1569429475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1288527915/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-09T14:47:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1288527915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@dergoegge Thanks for the ping.\r\n\r\n> makes operations such as deleting them from multiple threads difficult \r\n\r\nWhy is this a goal?\r\n\r\nI'm quite nervous about these changes. I've spoken with @dergoegge about this a few times now, but I'm afraid my information and opinions on the code involved are quite dated at this point (2017 to be exact :), so I haven't had much to contribute. \r\n\r\nI'll say though, any changes or refactors for future changes to the threading model should be very well justified upfront imo. I remember even being uneasy about #10738 at the time, in fact I might have even talked myself out of rebasing it for merge.",
      "created_at" : "2023-08-09T14:04:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1671392361",
      "id" : 1671392361,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jn2xp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671392361/reactions"
      },
      "updated_at" : "2023-08-09T14:04:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671392361",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">>  makes operations such as deleting them from multiple threads difficult\r\n>\r\n> Why is this a goal?\r\n\r\nI missed this in the OP and think that this should not be a goal or should be well justified.\r\n\r\nI like getting rid of the custom ref counting for other reasons. Mainly, because it's annoying and bug prone.\r\n\r\nSomething I have been working on is hiding CNode from the public net interface and turning the connection manager into a NodeId based manager, e.g. `CConnman::PushMessage(CNode*, CSerializedNetMsg&&)` becomes  `CConnman::PushMessage(NodeId, CSerializedNetMsg&&)`. This leads to situations where the CConnman needs to hold `m_nodes_mutex` while acquiring the right CNode to call `AddRef` and then later `Release` (once finished with the CNode). While that avoids holding `m_nodes_mutex` the entire time, it is pretty messy/bug-prone while we are using the custom ref-counting and smart pointers would be a good improvement there.",
      "created_at" : "2023-08-09T15:05:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1671589152",
      "id" : 1671589152,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jom0g",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671589152/reactions"
      },
      "updated_at" : "2023-08-09T15:05:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671589152",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> @dergoegge Thanks for the ping.\r\n> \r\n> > makes operations such as deleting them from multiple threads difficult\r\n> \r\n> Why is this a goal?\r\n> \r\n> I'm quite nervous about these changes. I've spoken with @dergoegge about this a few times now, but I'm afraid my information and opinions on the code involved are quite dated at this point (2017 to be exact :), so I haven't had much to contribute.\r\n> \r\n> I'll say though, any changes or refactors for future changes to the threading model should be very well justified upfront imo. I remember even being uneasy about #10738 at the time, in fact I might have even talked myself out of rebasing it for merge.\r\n\r\nThanks, and I agree that after working on this I'm not sure this will ever extend to being  threadsafe (todo: update PR description here). For context https://github.com/bitcoin/bitcoin/pull/27912 is how I came to be looking at this.\r\n\r\nI feel like the model as (intended to be) implemented here is easier to reason about as refcounting is taken care of for us via the smart pointers and node cleanup only happens (automatically) once we have a single final reference in `m_nodes_disconnected` and we drop it: once moved from `m_nodes` the node won't be included in any future iterations of that container and it waits to be gracefully dropped from `m_nodes_disconnected` and cleaned up when appropriate.\r\n\r\n@dergoegge also left some comments on the current implementation of the approach while I was replying here, which I will consider and reply to seperately :)",
      "created_at" : "2023-08-09T15:09:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1671595104",
      "id" : 1671595104,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jooRg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671595104/reactions"
      },
      "updated_at" : "2023-08-09T15:09:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1671595104",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Seeing these failures locally:\r\n\r\n```\r\n$ ./src/test/test_bitcoin -t denialofservice_tests\r\nRunning 5 test cases...\r\nAssertion failed: lock m_nodes_mutex not held in net.cpp:1598; locks held:\r\n'cs_main' in net_processing.cpp:5203 (in thread 'test')\r\nunknown location:0: fatal error: in \"denialofservice_tests/stale_tip_peer_management\": signal: SIGABRT (application abort requested)\r\ntest/denialofservice_tests.cpp:182: last checkpoint\r\nAssertion failed: (ret.second), function AddArg, file args.cpp, line 577.\r\nunknown location:0: fatal error: in \"denialofservice_tests/block_relay_only_eviction\": signal: SIGABRT (application abort requested)\r\ntest/denialofservice_tests.cpp:243: last checkpoint: \"block_relay_only_eviction\" fixture ctor\r\nAssertion failed: (ret.second), function AddArg, file args.cpp, line 577.\r\nunknown location:0: fatal error: in \"denialofservice_tests/peer_discouragement\": signal: SIGABRT (application abort requested)\r\ntest/denialofservice_tests.cpp:304: last checkpoint: \"peer_discouragement\" fixture ctor\r\nAssertion failed: (ret.second), function AddArg, file args.cpp, line 577.\r\nunknown location:0: fatal error: in \"denialofservice_tests/DoS_bantime\": signal: SIGABRT (application abort requested)\r\ntest/denialofservice_tests.cpp:409: last checkpoint: \"DoS_bantime\" fixture ctor\r\n\r\n*** 4 failures are detected in the test module \"Bitcoin Core Test Suite\"\r\nAssertion failed: (m_worker_threads.empty()), function ~CCheckQueue, file checkqueue.h, line 198.\r\nzsh: abort      ./src/test/test_bitcoin -t denialofservice_tests```\r\n```\r\n\r\n```\r\n$ FUZZ=process_message ./src/test/fuzz/fuzz\r\n\r\n...a few seconds later...\r\n\r\nin Peer::SetTxRelay() net_processing.cpp:305\r\nnet_processing.cpp:307 SetTxRelay: Assertion `!m_tx_relay' failed.\r\n```",
      "created_at" : "2023-08-09T23:09:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1672297168",
      "id" : 1672297168,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585jrTrQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1672297168/reactions"
      },
      "updated_at" : "2023-08-09T23:09:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1672297168",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "What about calling `FinalizeNode()` from the destructor of `CNode`? This ensures it will be called exactly once by some thread after no other threads are referencing it. Is this not what we want?\r\n\r\n<details>\r\n<summary>[patch] FinalizeNode() from ~CNode()</summary>\r\n\r\n```diff\r\ndiff --git i/src/net.h w/src/net.h\r\nindex 1ea0ad868a..587d907c3a 100644\r\n--- i/src/net.h\r\n+++ w/src/net.h\r\n@@ -412,13 +412,12 @@ public:\r\n     /** fSuccessfullyConnected is set to true on receiving VERACK from the peer. */\r\n     std::atomic_bool fSuccessfullyConnected{false};\r\n     // Setting fDisconnect to true will cause the node to be disconnected the\r\n     // next time DisconnectNodes() runs\r\n     std::atomic_bool fDisconnect{false};\r\n     CSemaphoreGrant grantOutbound;\r\n-    std::atomic<int> nRefCount{0};\r\n \r\n     const uint64_t nKeyedNetGroup;\r\n     std::atomic_bool fPauseRecv{false};\r\n     std::atomic_bool fPauseSend{false};\r\n \r\n     const ConnectionType m_conn_type;\r\n@@ -566,30 +565,27 @@ public:\r\n           uint64_t nKeyedNetGroupIn,\r\n           uint64_t nLocalHostNonceIn,\r\n           const CAddress& addrBindIn,\r\n           const std::string& addrNameIn,\r\n           ConnectionType conn_type_in,\r\n           bool inbound_onion,\r\n+          std::function<void(CNode&)> destruct_cb = {},\r\n           CNodeOptions&& node_opts = {});\r\n     CNode(const CNode&) = delete;\r\n     CNode& operator=(const CNode&) = delete;\r\n \r\n+    ~CNode();\r\n+\r\n     NodeId GetId() const {\r\n         return id;\r\n     }\r\n \r\n     uint64_t GetLocalNonce() const {\r\n         return nLocalHostNonce;\r\n     }\r\n \r\n-    int GetRefCount() const\r\n-    {\r\n-        assert(nRefCount >= 0);\r\n-        return nRefCount;\r\n-    }\r\n-\r\n     /**\r\n      * Receive bytes from the buffer and deserialize them into messages.\r\n      *\r\n      * @param[in]   msg_bytes   The raw data\r\n      * @param[out]  complete    Set True if at least one message has been\r\n      *                          deserialized and is ready to be processed\r\n@@ -609,23 +605,12 @@ public:\r\n     }\r\n \r\n     CService GetAddrLocal() const EXCLUSIVE_LOCKS_REQUIRED(!m_addr_local_mutex);\r\n     //! May not be called more than once\r\n     void SetAddrLocal(const CService& addrLocalIn) EXCLUSIVE_LOCKS_REQUIRED(!m_addr_local_mutex);\r\n \r\n-    CNode* AddRef()\r\n-    {\r\n-        nRefCount++;\r\n-        return this;\r\n-    }\r\n-\r\n-    void Release()\r\n-    {\r\n-        nRefCount--;\r\n-    }\r\n-\r\n     void CloseSocketDisconnect() EXCLUSIVE_LOCKS_REQUIRED(!m_sock_mutex);\r\n \r\n     void CopyStats(CNodeStats& stats) EXCLUSIVE_LOCKS_REQUIRED(!m_subver_mutex, !m_addr_local_mutex, !cs_vSend, !cs_vRecv);\r\n \r\n     std::string ConnectionTypeAsString() const { return ::ConnectionTypeAsString(m_conn_type); }\r\n \r\n@@ -662,12 +647,17 @@ private:\r\n      * the data socket is closed, the control socket is not going to be used anymore\r\n      * and is just taking up resources. So better close it as soon as `m_sock` is\r\n      * closed.\r\n      * Otherwise this unique_ptr is empty.\r\n      */\r\n     std::unique_ptr<i2p::sam::Session> m_i2p_sam_session GUARDED_BY(m_sock_mutex);\r\n+\r\n+    /**\r\n+     * A function to be called just before this object is destroyed.\r\n+     */\r\n+    std::function<void(CNode&)> m_destruct_cb;\r\n };\r\n \r\n /**\r\n  * Interface for message handling\r\n  */\r\n class NetEventsInterface\r\n@@ -802,23 +792,23 @@ public:\r\n \r\n     using NodeFn = std::function<void(CNode*)>;\r\n     void ForEachNode(const NodeFn& func)\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n         for (auto&& node : m_nodes) {\r\n-            if (NodeFullyConnected(node))\r\n-                func(node);\r\n+            if (NodeFullyConnected(*node))\r\n+                func(node.get());\r\n         }\r\n     };\r\n \r\n     void ForEachNode(const NodeFn& func) const\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n         for (auto&& node : m_nodes) {\r\n-            if (NodeFullyConnected(node))\r\n-                func(node);\r\n+            if (NodeFullyConnected(*node))\r\n+                func(node.get());\r\n         }\r\n     };\r\n \r\n     // Addrman functions\r\n     /**\r\n      * Return all or many randomly selected addresses, optionally by network.\r\n@@ -964,25 +954,25 @@ private:\r\n \r\n     /**\r\n      * Generate a collection of sockets to check for IO readiness.\r\n      * @param[in] nodes Select from these nodes' sockets.\r\n      * @return sockets to check for readiness\r\n      */\r\n-    Sock::EventsPerSock GenerateWaitSockets(Span<CNode* const> nodes);\r\n+    Sock::EventsPerSock GenerateWaitSockets(const std::vector<std::shared_ptr<CNode>>& nodes);\r\n \r\n     /**\r\n      * Check connected and listening sockets for IO readiness and process them accordingly.\r\n      */\r\n     void SocketHandler() EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex, !mutexMsgProc);\r\n \r\n     /**\r\n      * Do the read/write for connected sockets that are ready for IO.\r\n      * @param[in] nodes Nodes to process. The socket of each node is checked against `what`.\r\n      * @param[in] events_per_sock Sockets that are ready for IO.\r\n      */\r\n-    void SocketHandlerConnected(const std::vector<CNode*>& nodes,\r\n+    void SocketHandlerConnected(const std::vector<std::shared_ptr<CNode>>& nodes,\r\n                                 const Sock::EventsPerSock& events_per_sock)\r\n         EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex, !mutexMsgProc);\r\n \r\n     /**\r\n      * Accept incoming connections, one from each read-ready listening socket.\r\n      * @param[in] events_per_sock Sockets that are ready for IO.\r\n@@ -991,25 +981,25 @@ private:\r\n \r\n     void ThreadSocketHandler() EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex, !mutexMsgProc);\r\n     void ThreadDNSAddressSeed() EXCLUSIVE_LOCKS_REQUIRED(!m_addr_fetches_mutex, !m_nodes_mutex);\r\n \r\n     uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\r\n \r\n-    CNode* FindNode(const CNetAddr& ip);\r\n-    CNode* FindNode(const CSubNet& subNet);\r\n-    CNode* FindNode(const std::string& addrName);\r\n-    CNode* FindNode(const CService& addr);\r\n+    std::shared_ptr<CNode> FindNode(const CNetAddr& ip);\r\n+    std::shared_ptr<CNode> FindNode(const CSubNet& subNet);\r\n+    std::shared_ptr<CNode> FindNode(const std::string& addrName);\r\n+    std::shared_ptr<CNode> FindNode(const CService& addr);\r\n \r\n     /**\r\n      * Determine whether we're already connected to a given address, in order to\r\n      * avoid initiating duplicate connections.\r\n      */\r\n     bool AlreadyConnectedToAddress(const CAddress& addr);\r\n \r\n     bool AttemptToEvictConnection();\r\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type) EXCLUSIVE_LOCKS_REQUIRED(!m_unused_i2p_sessions_mutex);\r\n+    std::shared_ptr<CNode> ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type) EXCLUSIVE_LOCKS_REQUIRED(!m_unused_i2p_sessions_mutex);\r\n     void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\r\n \r\n     void DeleteNode(CNode* pnode);\r\n \r\n     NodeId GetNewNodeId();\r\n \r\n@@ -1041,13 +1031,13 @@ private:\r\n      *\r\n      * @return           bool        Whether a preferred network was found.\r\n      */\r\n     bool MaybePickPreferredNetwork(std::optional<Network>& network);\r\n \r\n     // Whether the node should be passed out in ForEach* callbacks\r\n-    static bool NodeFullyConnected(const CNode* pnode);\r\n+    static bool NodeFullyConnected(const CNode& node);\r\n \r\n     // Network usage totals\r\n     mutable Mutex m_total_bytes_sent_mutex;\r\n     std::atomic<uint64_t> nTotalBytesRecv{0};\r\n     uint64_t nTotalBytesSent GUARDED_BY(m_total_bytes_sent_mutex) {0};\r\n \r\n@@ -1072,14 +1062,13 @@ private:\r\n     AddrMan& addrman;\r\n     const NetGroupManager& m_netgroupman;\r\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\r\n     Mutex m_addr_fetches_mutex;\r\n     std::vector<std::string> m_added_nodes GUARDED_BY(m_added_nodes_mutex);\r\n     mutable Mutex m_added_nodes_mutex;\r\n-    std::vector<CNode*> m_nodes GUARDED_BY(m_nodes_mutex);\r\n-    std::list<CNode*> m_nodes_disconnected;\r\n+    std::vector<std::shared_ptr<CNode>> m_nodes GUARDED_BY(m_nodes_mutex);\r\n     mutable RecursiveMutex m_nodes_mutex;\r\n     std::atomic<NodeId> nLastNodeId{0};\r\n     unsigned int nPrevNodeCount{0};\r\n \r\n     // Stores number of full-tx connections (outbound and manual) per network\r\n     std::array<unsigned int, Network::NET_MAX> m_network_conn_counts GUARDED_BY(m_nodes_mutex) = {};\r\n@@ -1227,35 +1216,25 @@ private:\r\n     public:\r\n         explicit NodesSnapshot(const CConnman& connman, bool shuffle)\r\n         {\r\n             {\r\n                 LOCK(connman.m_nodes_mutex);\r\n                 m_nodes_copy = connman.m_nodes;\r\n-                for (auto& node : m_nodes_copy) {\r\n-                    node->AddRef();\r\n-                }\r\n             }\r\n             if (shuffle) {\r\n                 Shuffle(m_nodes_copy.begin(), m_nodes_copy.end(), FastRandomContext{});\r\n             }\r\n         }\r\n \r\n-        ~NodesSnapshot()\r\n-        {\r\n-            for (auto& node : m_nodes_copy) {\r\n-                node->Release();\r\n-            }\r\n-        }\r\n-\r\n-        const std::vector<CNode*>& Nodes() const\r\n+        const std::vector<std::shared_ptr<CNode>>& Nodes() const\r\n         {\r\n             return m_nodes_copy;\r\n         }\r\n \r\n     private:\r\n-        std::vector<CNode*> m_nodes_copy;\r\n+        std::vector<std::shared_ptr<CNode>> m_nodes_copy;\r\n     };\r\n \r\n     friend struct ConnmanTestMsg;\r\n };\r\n \r\n /** Dump binary message to file, with timestamp */\r\ndiff --git i/src/net.cpp w/src/net.cpp\r\nindex b51043ba27..c1ad1166f3 100644\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -359,49 +359,49 @@ bool SeenLocal(const CService& addr)\r\n bool IsLocal(const CService& addr)\r\n {\r\n     LOCK(g_maplocalhost_mutex);\r\n     return mapLocalHost.count(addr) > 0;\r\n }\r\n \r\n-CNode* CConnman::FindNode(const CNetAddr& ip)\r\n+std::shared_ptr<CNode> CConnman::FindNode(const CNetAddr& ip)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (auto& pnode : m_nodes) {\r\n       if (static_cast<CNetAddr>(pnode->addr) == ip) {\r\n             return pnode;\r\n         }\r\n     }\r\n     return nullptr;\r\n }\r\n \r\n-CNode* CConnman::FindNode(const CSubNet& subNet)\r\n+std::shared_ptr<CNode> CConnman::FindNode(const CSubNet& subNet)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (auto& pnode : m_nodes) {\r\n         if (subNet.Match(static_cast<CNetAddr>(pnode->addr))) {\r\n             return pnode;\r\n         }\r\n     }\r\n     return nullptr;\r\n }\r\n \r\n-CNode* CConnman::FindNode(const std::string& addrName)\r\n+std::shared_ptr<CNode> CConnman::FindNode(const std::string& addrName)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (auto& pnode : m_nodes) {\r\n         if (pnode->m_addr_name == addrName) {\r\n             return pnode;\r\n         }\r\n     }\r\n     return nullptr;\r\n }\r\n \r\n-CNode* CConnman::FindNode(const CService& addr)\r\n+std::shared_ptr<CNode> CConnman::FindNode(const CService& addr)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (auto& pnode : m_nodes) {\r\n         if (static_cast<CService>(pnode->addr) == addr) {\r\n             return pnode;\r\n         }\r\n     }\r\n     return nullptr;\r\n }\r\n@@ -411,13 +411,13 @@ bool CConnman::AlreadyConnectedToAddress(const CAddress& addr)\r\n     return FindNode(static_cast<CNetAddr>(addr)) || FindNode(addr.ToStringAddrPort());\r\n }\r\n \r\n bool CConnman::CheckIncomingNonce(uint64_t nonce)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    for (const CNode* pnode : m_nodes) {\r\n+    for (const auto& pnode : m_nodes) {\r\n         if (!pnode->fSuccessfullyConnected && !pnode->IsInboundConn() && pnode->GetLocalNonce() == nonce)\r\n             return false;\r\n     }\r\n     return true;\r\n }\r\n \r\n@@ -434,25 +434,23 @@ static CAddress GetBindAddress(const Sock& sock)\r\n             LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\r\n         }\r\n     }\r\n     return addr_bind;\r\n }\r\n \r\n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type)\r\n+std::shared_ptr<CNode> CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type)\r\n {\r\n     AssertLockNotHeld(m_unused_i2p_sessions_mutex);\r\n     assert(conn_type != ConnectionType::INBOUND);\r\n \r\n     if (pszDest == nullptr) {\r\n         if (IsLocal(addrConnect))\r\n             return nullptr;\r\n \r\n         // Look for an existing connection\r\n-        CNode* pnode = FindNode(static_cast<CService>(addrConnect));\r\n-        if (pnode)\r\n-        {\r\n+        if (FindNode(static_cast<CService>(addrConnect))) {\r\n             LogPrintf(\"Failed to open new connection, already connected\\n\");\r\n             return nullptr;\r\n         }\r\n     }\r\n \r\n     LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"trying connection %s lastseen=%.1fhrs\\n\",\r\n@@ -471,14 +469,13 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\r\n                 LogPrint(BCLog::NET, \"Resolver returned invalid address %s for %s\\n\", addrConnect.ToStringAddrPort(), pszDest);\r\n                 return nullptr;\r\n             }\r\n             // It is possible that we already have a connection to the IP/port pszDest resolved to.\r\n             // In that case, drop the connection that was just created.\r\n             LOCK(m_nodes_mutex);\r\n-            CNode* pnode = FindNode(static_cast<CService>(addrConnect));\r\n-            if (pnode) {\r\n+            if (FindNode(static_cast<CService>(addrConnect))) {\r\n                 LogPrintf(\"Failed to open new connection, already connected\\n\");\r\n                 return nullptr;\r\n             }\r\n         }\r\n     }\r\n \r\n@@ -563,26 +560,26 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\r\n     // Add node\r\n     NodeId id = GetNewNodeId();\r\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\r\n     if (!addr_bind.IsValid()) {\r\n         addr_bind = GetBindAddress(*sock);\r\n     }\r\n-    CNode* pnode = new CNode(id,\r\n+    auto pnode = std::make_shared<CNode>(id,\r\n                              std::move(sock),\r\n                              addrConnect,\r\n                              CalculateKeyedNetGroup(addrConnect),\r\n                              nonce,\r\n                              addr_bind,\r\n                              pszDest ? pszDest : \"\",\r\n                              conn_type,\r\n                              /*inbound_onion=*/false,\r\n+                             [this](CNode& node) {m_msgproc->FinalizeNode(node);},\r\n                              CNodeOptions{\r\n                                  .i2p_sam_session = std::move(i2p_transient_session),\r\n                                  .recv_flood_size = nReceiveFloodSize,\r\n                              });\r\n-    pnode->AddRef();\r\n \r\n     // We're making a new connection, harvest entropy from the time (and our peer count)\r\n     RandAddEvent((uint32_t)id);\r\n \r\n     return pnode;\r\n }\r\n@@ -902,13 +899,13 @@ size_t CConnman::SocketSendData(CNode& node) const\r\n bool CConnman::AttemptToEvictConnection()\r\n {\r\n     std::vector<NodeEvictionCandidate> vEvictionCandidates;\r\n     {\r\n \r\n         LOCK(m_nodes_mutex);\r\n-        for (const CNode* node : m_nodes) {\r\n+        for (const auto& node : m_nodes) {\r\n             if (node->fDisconnect)\r\n                 continue;\r\n             NodeEvictionCandidate candidate{\r\n                 .id = node->GetId(),\r\n                 .m_connected = node->m_connected,\r\n                 .m_min_ping_time = node->m_min_ping_time,\r\n@@ -929,13 +926,13 @@ bool CConnman::AttemptToEvictConnection()\r\n     }\r\n     const std::optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));\r\n     if (!node_id_to_evict) {\r\n         return false;\r\n     }\r\n     LOCK(m_nodes_mutex);\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (const auto& pnode : m_nodes) {\r\n         if (pnode->GetId() == *node_id_to_evict) {\r\n             LogPrint(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());\r\n             pnode->fDisconnect = true;\r\n             return true;\r\n         }\r\n     }\r\n@@ -986,13 +983,13 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\r\n         NetPermissions::AddFlag(permission_flags, NetPermissionFlags::Mempool);\r\n         NetPermissions::AddFlag(permission_flags, NetPermissionFlags::NoBan);\r\n     }\r\n \r\n     {\r\n         LOCK(m_nodes_mutex);\r\n-        for (const CNode* pnode : m_nodes) {\r\n+        for (const auto& pnode : m_nodes) {\r\n             if (pnode->IsInboundConn()) nInbound++;\r\n         }\r\n     }\r\n \r\n     if (!fNetworkActive) {\r\n         LogPrint(BCLog::NET, \"connection from %s dropped: not accepting new connections\\n\", addr.ToStringAddrPort());\r\n@@ -1043,27 +1040,27 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\r\n     ServiceFlags nodeServices = nLocalServices;\r\n     if (NetPermissions::HasFlag(permission_flags, NetPermissionFlags::BloomFilter)) {\r\n         nodeServices = static_cast<ServiceFlags>(nodeServices | NODE_BLOOM);\r\n     }\r\n \r\n     const bool inbound_onion = std::find(m_onion_binds.begin(), m_onion_binds.end(), addr_bind) != m_onion_binds.end();\r\n-    CNode* pnode = new CNode(id,\r\n+    auto pnode = std::make_shared<CNode>(id,\r\n                              std::move(sock),\r\n                              addr,\r\n                              CalculateKeyedNetGroup(addr),\r\n                              nonce,\r\n                              addr_bind,\r\n                              /*addrNameIn=*/\"\",\r\n                              ConnectionType::INBOUND,\r\n                              inbound_onion,\r\n+                             [this](CNode& node) {m_msgproc->FinalizeNode(node);},\r\n                              CNodeOptions{\r\n                                  .permission_flags = permission_flags,\r\n                                  .prefer_evict = discouraged,\r\n                                  .recv_flood_size = nReceiveFloodSize,\r\n                              });\r\n-    pnode->AddRef();\r\n     m_msgproc->InitializeNode(*pnode, nodeServices);\r\n \r\n     LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToStringAddrPort());\r\n \r\n     {\r\n         LOCK(m_nodes_mutex);\r\n@@ -1095,13 +1092,13 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\r\n     case ConnectionType::FEELER:\r\n         break;\r\n     } // no default case, so the compiler can warn about missing cases\r\n \r\n     // Count existing connections\r\n     int existing_connections = WITH_LOCK(m_nodes_mutex,\r\n-                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](CNode* node) { return node->m_conn_type == conn_type; }););\r\n+                                         return std::count_if(m_nodes.begin(), m_nodes.end(), [conn_type](std::shared_ptr<CNode> node) { return node->m_conn_type == conn_type; }););\r\n \r\n     // Max connections of specified type already exist\r\n     if (max_connections != std::nullopt && existing_connections >= max_connections) return false;\r\n \r\n     // Max total outbound connections already exist\r\n     CSemaphoreGrant grant(*semOutbound, true);\r\n@@ -1110,58 +1107,50 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\r\n     OpenNetworkConnection(CAddress(), false, &grant, address.c_str(), conn_type);\r\n     return true;\r\n }\r\n \r\n void CConnman::DisconnectNodes()\r\n {\r\n+    std::vector<std::shared_ptr<CNode>> disconnected_nodes;\r\n+\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n \r\n         if (!fNetworkActive) {\r\n             // Disconnect any connected nodes\r\n-            for (CNode* pnode : m_nodes) {\r\n+            for (const auto& pnode : m_nodes) {\r\n                 if (!pnode->fDisconnect) {\r\n                     LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\r\n                     pnode->fDisconnect = true;\r\n                 }\r\n             }\r\n         }\r\n \r\n         // Disconnect unused nodes\r\n-        std::vector<CNode*> nodes_copy = m_nodes;\r\n-        for (CNode* pnode : nodes_copy)\r\n-        {\r\n-            if (pnode->fDisconnect)\r\n-            {\r\n+        for (auto it = m_nodes.begin(); it != m_nodes.end();) {\r\n+            auto node = *it;\r\n+            if (node->fDisconnect) {\r\n                 // remove from m_nodes\r\n-                m_nodes.erase(remove(m_nodes.begin(), m_nodes.end(), pnode), m_nodes.end());\r\n+                it = m_nodes.erase(it);\r\n+\r\n+                // Keep a reference to this CNode object to delay its destruction until\r\n+                // after m_nodes_mutex has been released. Destructing a node involves\r\n+                // calling m_msgproc->FinalizeNode() which acquires cs_main. Lock order\r\n+                // should be cs_main, m_nodes_mutex.\r\n+                disconnected_nodes.push_back(node);\r\n \r\n                 // release outbound grant (if any)\r\n-                pnode->grantOutbound.Release();\r\n+                node->grantOutbound.Release();\r\n \r\n                 // close socket and cleanup\r\n-                pnode->CloseSocketDisconnect();\r\n+                node->CloseSocketDisconnect();\r\n \r\n                 // update connection count by network\r\n-                if (pnode->IsManualOrFullOutboundConn()) --m_network_conn_counts[pnode->addr.GetNetwork()];\r\n-\r\n-                // hold in disconnected pool until all refs are released\r\n-                pnode->Release();\r\n-                m_nodes_disconnected.push_back(pnode);\r\n-            }\r\n-        }\r\n-    }\r\n-    {\r\n-        // Delete disconnected nodes\r\n-        std::list<CNode*> nodes_disconnected_copy = m_nodes_disconnected;\r\n-        for (CNode* pnode : nodes_disconnected_copy)\r\n-        {\r\n-            // Destroy the object only after other threads have stopped using it.\r\n-            if (pnode->GetRefCount() <= 0) {\r\n-                m_nodes_disconnected.remove(pnode);\r\n-                DeleteNode(pnode);\r\n+                if (node->IsManualOrFullOutboundConn()) --m_network_conn_counts[node->addr.GetNetwork()];\r\n+            } else {\r\n+                ++it;\r\n             }\r\n         }\r\n     }\r\n }\r\n \r\n void CConnman::NotifyNumConnectionsChanged()\r\n@@ -1214,21 +1203,21 @@ bool CConnman::InactivityCheck(const CNode& node) const\r\n         return true;\r\n     }\r\n \r\n     return false;\r\n }\r\n \r\n-Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\r\n+Sock::EventsPerSock CConnman::GenerateWaitSockets(const std::vector<std::shared_ptr<CNode>>& nodes)\r\n {\r\n     Sock::EventsPerSock events_per_sock;\r\n \r\n     for (const ListenSocket& hListenSocket : vhListenSocket) {\r\n         events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV});\r\n     }\r\n \r\n-    for (CNode* pnode : nodes) {\r\n+    for (auto& pnode : nodes) {\r\n         // Implement the following logic:\r\n         // * If there is data to send, select() for sending data. As this only\r\n         //   happens when optimistic write failed, we choose to first drain the\r\n         //   write buffer in this case before receiving more. This avoids\r\n         //   needlessly queueing received data, if the remote peer is not themselves\r\n         //   receiving data. This means properly utilizing TCP flow control signalling.\r\n@@ -1287,18 +1276,18 @@ void CConnman::SocketHandler()\r\n     }\r\n \r\n     // Accept new connections from listening sockets.\r\n     SocketHandlerListening(events_per_sock);\r\n }\r\n \r\n-void CConnman::SocketHandlerConnected(const std::vector<CNode*>& nodes,\r\n+void CConnman::SocketHandlerConnected(const std::vector<std::shared_ptr<CNode>>& nodes,\r\n                                       const Sock::EventsPerSock& events_per_sock)\r\n {\r\n     AssertLockNotHeld(m_total_bytes_sent_mutex);\r\n \r\n-    for (CNode* pnode : nodes) {\r\n+    for (auto& pnode : nodes) {\r\n         if (interruptNet)\r\n             return;\r\n \r\n         //\r\n         // Receive\r\n         //\r\n@@ -1454,13 +1443,13 @@ void CConnman::ThreadDNSAddressSeed()\r\n                     if (!interruptNet.sleep_for(w)) return;\r\n                     to_wait -= w;\r\n \r\n                     int nRelevant = 0;\r\n                     {\r\n                         LOCK(m_nodes_mutex);\r\n-                        for (const CNode* pnode : m_nodes) {\r\n+                        for (const auto& pnode : m_nodes) {\r\n                             if (pnode->fSuccessfullyConnected && pnode->IsFullOutboundConn()) ++nRelevant;\r\n                         }\r\n                     }\r\n                     if (nRelevant >= 2) {\r\n                         if (found > 0) {\r\n                             LogPrintf(\"%d addresses found from DNS seeds\\n\", found);\r\n@@ -1572,13 +1561,13 @@ void CConnman::StartExtraBlockRelayPeers()\r\n // evict some peer that has finished the handshake)\r\n int CConnman::GetExtraFullOutboundCount() const\r\n {\r\n     int full_outbound_peers = 0;\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n-        for (const CNode* pnode : m_nodes) {\r\n+        for (const auto& pnode : m_nodes) {\r\n             if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsFullOutboundConn()) {\r\n                 ++full_outbound_peers;\r\n             }\r\n         }\r\n     }\r\n     return std::max(full_outbound_peers - m_max_outbound_full_relay, 0);\r\n@@ -1586,13 +1575,13 @@ int CConnman::GetExtraFullOutboundCount() const\r\n \r\n int CConnman::GetExtraBlockRelayCount() const\r\n {\r\n     int block_relay_peers = 0;\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n-        for (const CNode* pnode : m_nodes) {\r\n+        for (const auto& pnode : m_nodes) {\r\n             if (pnode->fSuccessfullyConnected && !pnode->fDisconnect && pnode->IsBlockOnlyConn()) {\r\n                 ++block_relay_peers;\r\n             }\r\n         }\r\n     }\r\n     return std::max(block_relay_peers - m_max_outbound_block_relay, 0);\r\n@@ -1734,13 +1723,13 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\r\n         int nOutboundBlockRelay = 0;\r\n         int outbound_privacy_network_peers = 0;\r\n         std::set<std::vector<unsigned char>> outbound_ipv46_peer_netgroups;\r\n \r\n         {\r\n             LOCK(m_nodes_mutex);\r\n-            for (const CNode* pnode : m_nodes) {\r\n+            for (const auto& pnode : m_nodes) {\r\n                 if (pnode->IsFullOutboundConn()) nOutboundFullRelay++;\r\n                 if (pnode->IsBlockOnlyConn()) nOutboundBlockRelay++;\r\n \r\n                 // Make sure our persistent outbound slots to ipv4/ipv6 peers belong to different netgroups.\r\n                 switch (pnode->m_conn_type) {\r\n                     // We currently don't take inbound connections into account. Since they are\r\n@@ -1954,13 +1943,13 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\r\n }\r\n \r\n std::vector<CAddress> CConnman::GetCurrentBlockRelayOnlyConns() const\r\n {\r\n     std::vector<CAddress> ret;\r\n     LOCK(m_nodes_mutex);\r\n-    for (const CNode* pnode : m_nodes) {\r\n+    for (const auto& pnode : m_nodes) {\r\n         if (pnode->IsBlockOnlyConn()) {\r\n             ret.push_back(pnode->addr);\r\n         }\r\n     }\r\n \r\n     return ret;\r\n@@ -1980,13 +1969,13 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const\r\n \r\n     // Build a map of all already connected addresses (by IP:port and by name) to inbound/outbound and resolved CService\r\n     std::map<CService, bool> mapConnected;\r\n     std::map<std::string, std::pair<bool, CService>> mapConnectedByName;\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n-        for (const CNode* pnode : m_nodes) {\r\n+        for (const auto& pnode : m_nodes) {\r\n             if (pnode->addr.IsValid()) {\r\n                 mapConnected[pnode->addr] = pnode->IsInboundConn();\r\n             }\r\n             std::string addrName{pnode->m_addr_name};\r\n             if (!addrName.empty()) {\r\n                 mapConnectedByName[std::move(addrName)] = std::make_pair(pnode->IsInboundConn(), static_cast<const CService&>(pnode->addr));\r\n@@ -2068,13 +2057,13 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\r\n         if (IsLocal(addrConnect) || banned_or_discouraged || AlreadyConnectedToAddress(addrConnect)) {\r\n             return;\r\n         }\r\n     } else if (FindNode(std::string(pszDest)))\r\n         return;\r\n \r\n-    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type);\r\n+    auto pnode = ConnectNode(addrConnect, pszDest, fCountFailure, conn_type);\r\n \r\n     if (!pnode)\r\n         return;\r\n     if (grantOutbound)\r\n         grantOutbound->MoveTo(pnode->grantOutbound);\r\n \r\n@@ -2101,23 +2090,23 @@ void CConnman::ThreadMessageHandler()\r\n         {\r\n             // Randomize the order in which we process messages from/to our peers.\r\n             // This prevents attacks in which an attacker exploits having multiple\r\n             // consecutive connections in the m_nodes list.\r\n             const NodesSnapshot snap{*this, /*shuffle=*/true};\r\n \r\n-            for (CNode* pnode : snap.Nodes()) {\r\n+            for (auto& pnode : snap.Nodes()) {\r\n                 if (pnode->fDisconnect)\r\n                     continue;\r\n \r\n                 // Receive messages\r\n-                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\r\n+                bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode.get(), flagInterruptMsgProc);\r\n                 fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\r\n                 if (flagInterruptMsgProc)\r\n                     return;\r\n                 // Send messages\r\n-                m_msgproc->SendMessages(pnode);\r\n+                m_msgproc->SendMessages(pnode.get());\r\n \r\n                 if (flagInterruptMsgProc)\r\n                     return;\r\n             }\r\n         }\r\n \r\n@@ -2531,35 +2520,24 @@ void CConnman::StopNodes()\r\n             }\r\n             DumpAnchors(gArgs.GetDataDirNet() / ANCHORS_DATABASE_FILENAME, anchors_to_dump);\r\n         }\r\n     }\r\n \r\n     // Delete peer connections.\r\n-    std::vector<CNode*> nodes;\r\n+    std::vector<std::shared_ptr<CNode>> nodes;\r\n     WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));\r\n-    for (CNode* pnode : nodes) {\r\n-        pnode->CloseSocketDisconnect();\r\n-        DeleteNode(pnode);\r\n+    for (auto& node : nodes) {\r\n+        node->CloseSocketDisconnect();\r\n     }\r\n+    nodes.clear();\r\n \r\n-    for (CNode* pnode : m_nodes_disconnected) {\r\n-        DeleteNode(pnode);\r\n-    }\r\n-    m_nodes_disconnected.clear();\r\n     vhListenSocket.clear();\r\n     semOutbound.reset();\r\n     semAddnode.reset();\r\n }\r\n \r\n-void CConnman::DeleteNode(CNode* pnode)\r\n-{\r\n-    assert(pnode);\r\n-    m_msgproc->FinalizeNode(*pnode);\r\n-    delete pnode;\r\n-}\r\n-\r\n CConnman::~CConnman()\r\n {\r\n     Interrupt();\r\n     Stop();\r\n }\r\n \r\n@@ -2664,35 +2642,35 @@ uint32_t CConnman::GetMappedAS(const CNetAddr& addr) const\r\n \r\n void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\r\n {\r\n     vstats.clear();\r\n     LOCK(m_nodes_mutex);\r\n     vstats.reserve(m_nodes.size());\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (const auto& pnode : m_nodes) {\r\n         vstats.emplace_back();\r\n         pnode->CopyStats(vstats.back());\r\n         vstats.back().m_mapped_as = GetMappedAS(pnode->addr);\r\n     }\r\n }\r\n \r\n bool CConnman::DisconnectNode(const std::string& strNode)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    if (CNode* pnode = FindNode(strNode)) {\r\n+    if (auto pnode = FindNode(strNode)) {\r\n         LogPrint(BCLog::NET, \"disconnect by address%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", strNode) : \"\"), pnode->GetId());\r\n         pnode->fDisconnect = true;\r\n         return true;\r\n     }\r\n     return false;\r\n }\r\n \r\n bool CConnman::DisconnectNode(const CSubNet& subnet)\r\n {\r\n     bool disconnected = false;\r\n     LOCK(m_nodes_mutex);\r\n-    for (CNode* pnode : m_nodes) {\r\n+    for (auto& pnode : m_nodes) {\r\n         if (subnet.Match(pnode->addr)) {\r\n             LogPrint(BCLog::NET, \"disconnect by subnet%s matched peer=%d; disconnecting\\n\", (fLogIPs ? strprintf(\"=%s\", subnet.ToString()) : \"\"), pnode->GetId());\r\n             pnode->fDisconnect = true;\r\n             disconnected = true;\r\n         }\r\n     }\r\n@@ -2704,13 +2682,13 @@ bool CConnman::DisconnectNode(const CNetAddr& addr)\r\n     return DisconnectNode(CSubNet(addr));\r\n }\r\n \r\n bool CConnman::DisconnectNode(NodeId id)\r\n {\r\n     LOCK(m_nodes_mutex);\r\n-    for(CNode* pnode : m_nodes) {\r\n+    for(auto& pnode : m_nodes) {\r\n         if (id == pnode->GetId()) {\r\n             LogPrint(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());\r\n             pnode->fDisconnect = true;\r\n             return true;\r\n         }\r\n     }\r\n@@ -2828,12 +2806,13 @@ CNode::CNode(NodeId idIn,\r\n              uint64_t nKeyedNetGroupIn,\r\n              uint64_t nLocalHostNonceIn,\r\n              const CAddress& addrBindIn,\r\n              const std::string& addrNameIn,\r\n              ConnectionType conn_type_in,\r\n              bool inbound_onion,\r\n+             std::function<void(CNode&)> destruct_cb,\r\n              CNodeOptions&& node_opts)\r\n     : m_deserializer{std::make_unique<V1TransportDeserializer>(V1TransportDeserializer(Params(), idIn, SER_NETWORK, INIT_PROTO_VERSION))},\r\n       m_serializer{std::make_unique<V1TransportSerializer>(V1TransportSerializer())},\r\n       m_permission_flags{node_opts.permission_flags},\r\n       m_sock{sock},\r\n       m_connected{GetTime<std::chrono::seconds>()},\r\n@@ -2844,13 +2823,14 @@ CNode::CNode(NodeId idIn,\r\n       m_prefer_evict{node_opts.prefer_evict},\r\n       nKeyedNetGroup{nKeyedNetGroupIn},\r\n       m_conn_type{conn_type_in},\r\n       id{idIn},\r\n       nLocalHostNonce{nLocalHostNonceIn},\r\n       m_recv_flood_size{node_opts.recv_flood_size},\r\n-      m_i2p_sam_session{std::move(node_opts.i2p_sam_session)}\r\n+      m_i2p_sam_session{std::move(node_opts.i2p_sam_session)},\r\n+      m_destruct_cb{destruct_cb}\r\n {\r\n     if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);\r\n \r\n     for (const std::string &msg : getAllNetMessageTypes())\r\n         mapRecvBytesPerMsgType[msg] = 0;\r\n     mapRecvBytesPerMsgType[NET_MESSAGE_TYPE_OTHER] = 0;\r\n@@ -2859,12 +2839,19 @@ CNode::CNode(NodeId idIn,\r\n         LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);\r\n     } else {\r\n         LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\r\n     }\r\n }\r\n \r\n+CNode::~CNode()\r\n+{\r\n+    if (m_destruct_cb) {\r\n+        m_destruct_cb(*this);\r\n+    }\r\n+}\r\n+\r\n void CNode::MarkReceivedMsgsForProcessing()\r\n {\r\n     AssertLockNotHeld(m_msg_process_queue_mutex);\r\n \r\n     size_t nSizeAdded = 0;\r\n     for (const auto& msg : vRecvMsg) {\r\n@@ -2890,15 +2877,15 @@ std::optional<std::pair<CNetMessage, bool>> CNode::PollMessage()\r\n     m_msg_process_queue_size -= msgs.front().m_raw_message_size;\r\n     fPauseRecv = m_msg_process_queue_size > m_recv_flood_size;\r\n \r\n     return std::make_pair(std::move(msgs.front()), !m_msg_process_queue.empty());\r\n }\r\n \r\n-bool CConnman::NodeFullyConnected(const CNode* pnode)\r\n+bool CConnman::NodeFullyConnected(const CNode& node)\r\n {\r\n-    return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;\r\n+    return node.fSuccessfullyConnected && !node.fDisconnect;\r\n }\r\n \r\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\r\n {\r\n     AssertLockNotHeld(m_total_bytes_sent_mutex);\r\n     size_t nMessageSize = msg.data.size();\r\n@@ -2939,21 +2926,19 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\r\n     }\r\n     if (nBytesSent) RecordBytesSent(nBytesSent);\r\n }\r\n \r\n bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\r\n {\r\n-    CNode* found = nullptr;\r\n     LOCK(m_nodes_mutex);\r\n     for (auto&& pnode : m_nodes) {\r\n         if(pnode->GetId() == id) {\r\n-            found = pnode;\r\n-            break;\r\n+            return NodeFullyConnected(*pnode) && func(pnode.get());\r\n         }\r\n     }\r\n-    return found != nullptr && NodeFullyConnected(found) && func(found);\r\n+    return false;\r\n }\r\n \r\n CSipHasher CConnman::GetDeterministicRandomizer(uint64_t id) const\r\n {\r\n     return CSipHasher(nSeed0, nSeed1).Write(id);\r\n }\r\ndiff --git i/src/test/fuzz/net.cpp w/src/test/fuzz/net.cpp\r\nindex ddf919f2e6..19db2c7c50 100644\r\n--- i/src/test/fuzz/net.cpp\r\n+++ w/src/test/fuzz/net.cpp\r\n@@ -40,21 +40,12 @@ FUZZ_TARGET(net, .init = initialize_net)\r\n                 node.CloseSocketDisconnect();\r\n             },\r\n             [&] {\r\n                 CNodeStats stats;\r\n                 node.CopyStats(stats);\r\n             },\r\n-            [&] {\r\n-                const CNode* add_ref_node = node.AddRef();\r\n-                assert(add_ref_node == &node);\r\n-            },\r\n-            [&] {\r\n-                if (node.GetRefCount() > 0) {\r\n-                    node.Release();\r\n-                }\r\n-            },\r\n             [&] {\r\n                 const std::optional<CService> service_opt = ConsumeDeserializable<CService>(fuzzed_data_provider);\r\n                 if (!service_opt) {\r\n                     return;\r\n                 }\r\n                 node.SetAddrLocal(*service_opt);\r\n@@ -66,14 +57,12 @@ FUZZ_TARGET(net, .init = initialize_net)\r\n             });\r\n     }\r\n \r\n     (void)node.GetAddrLocal();\r\n     (void)node.GetId();\r\n     (void)node.GetLocalNonce();\r\n-    const int ref_count = node.GetRefCount();\r\n-    assert(ref_count >= 0);\r\n     (void)node.GetCommonVersion();\r\n \r\n     const NetPermissionFlags net_permission_flags = ConsumeWeakEnum(fuzzed_data_provider, ALL_NET_PERMISSION_FLAGS);\r\n     (void)node.HasPermission(net_permission_flags);\r\n     (void)node.ConnectedThroughNetwork();\r\n }\r\ndiff --git i/src/test/fuzz/util/net.h w/src/test/fuzz/util/net.h\r\nindex 47e4a2fac0..bc68018cdb 100644\r\n--- i/src/test/fuzz/util/net.h\r\n+++ w/src/test/fuzz/util/net.h\r\n@@ -117,23 +117,25 @@ auto ConsumeNode(FuzzedDataProvider& fuzzed_data_provider, const std::optional<N\r\n                                        keyed_net_group,\r\n                                        local_host_nonce,\r\n                                        addr_bind,\r\n                                        addr_name,\r\n                                        conn_type,\r\n                                        inbound_onion,\r\n+                                       [](CNode&){},\r\n                                        CNodeOptions{ .permission_flags = permission_flags });\r\n     } else {\r\n         return CNode{node_id,\r\n                      sock,\r\n                      address,\r\n                      keyed_net_group,\r\n                      local_host_nonce,\r\n                      addr_bind,\r\n                      addr_name,\r\n                      conn_type,\r\n                      inbound_onion,\r\n+                     {},\r\n                      CNodeOptions{ .permission_flags = permission_flags }};\r\n     }\r\n }\r\n inline std::unique_ptr<CNode> ConsumeNodeAsUniquePtr(FuzzedDataProvider& fdp, const std::optional<NodeId>& node_id_in = std::nullopt) { return ConsumeNode<true>(fdp, node_id_in); }\r\n \r\n void FillNode(FuzzedDataProvider& fuzzed_data_provider, ConnmanTestMsg& connman, CNode& node) noexcept EXCLUSIVE_LOCKS_REQUIRED(NetEventsInterface::g_msgproc_mutex);\r\ndiff --git i/src/test/util/net.h w/src/test/util/net.h\r\nindex b2f6ebb163..e90e3d8401 100644\r\n--- i/src/test/util/net.h\r\n+++ w/src/test/util/net.h\r\n@@ -25,23 +25,20 @@ struct ConnmanTestMsg : public CConnman {\r\n         m_peer_connect_timeout = timeout;\r\n     }\r\n \r\n     void AddTestNode(CNode& node)\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n-        m_nodes.push_back(&node);\r\n+        m_nodes.push_back(std::shared_ptr<CNode>(&node));\r\n \r\n         if (node.IsManualOrFullOutboundConn()) ++m_network_conn_counts[node.addr.GetNetwork()];\r\n     }\r\n \r\n     void ClearTestNodes()\r\n     {\r\n         LOCK(m_nodes_mutex);\r\n-        for (CNode* node : m_nodes) {\r\n-            delete node;\r\n-        }\r\n         m_nodes.clear();\r\n     }\r\n \r\n     void Handshake(CNode& node,\r\n                    bool successfully_connected,\r\n                    ServiceFlags remote_services,\r\n```\r\n</details>",
      "created_at" : "2023-08-14T17:05:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1677719961",
      "id" : 1677719961,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585j__mZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1677719961/reactions"
      },
      "updated_at" : "2023-08-14T17:05:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1677719961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-08-17T13:49:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1682322817",
      "id" : 1682322817,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585kRjWB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1682322817/reactions"
      },
      "updated_at" : "2023-08-17T13:49:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1682322817",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1314264417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1314264417"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't think this makes sense in general? If you have a shared_ptr, you should normally just pass the reference to the object (`CNode&`) if you've checked it's not null, or the pointer itself (`CNode*`).\r\n\r\ncf http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-smart",
      "commit_id" : "095482204591c9a2d149dd4e00dbb77d94e0b017",
      "created_at" : "2023-09-03T14:01:00Z",
      "diff_hunk" : "@@ -798,11 +798,11 @@ class CConnman\n     // alias for thread safety annotations only, not defined\n     RecursiveMutex& GetNodesMutex() const LOCK_RETURNED(m_nodes_mutex);\n \n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+    bool ForNode(NodeId id, std::function<bool(CNodeRef pnode)> func);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1314264417",
      "id" : 1314264417,
      "line" : 787,
      "node_id" : "PRRC_kwDOABII585OVhVh",
      "original_commit_id" : "1f612cded86dd8e0406d7c7feaef065bfbeb6f4b",
      "original_line" : 801,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 76,
      "pull_request_review_id" : 1608532082,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1314264417/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-03T14:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1314264417",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Are you still working on this?",
      "created_at" : "2023-11-13T16:09:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1808469111",
      "id" : 1808469111,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585rywx3",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1808469111/reactions"
      },
      "updated_at" : "2023-11-13T16:09:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1808469111",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--13523179cfe9479db18ec6c5d236f789-->\nâ There hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? â¡ï¸ Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? â¡ï¸ Please close.\n* Did the author lose interest or time to work on this? â¡ï¸ Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
      "created_at" : "2024-02-11T01:20:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28222#issuecomment-1937382299",
      "id" : 1937382299,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28222",
      "node_id" : "IC_kwDOABII585zehub",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1937382299/reactions"
      },
      "updated_at" : "2024-02-11T01:20:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1937382299",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
