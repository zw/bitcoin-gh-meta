[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
      "created_at" : "2023-03-06T19:47:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1456857488",
      "id" : 1456857488,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
      "node_id" : "IC_kwDOABII585W1eGQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456857488/reactions"
      },
      "updated_at" : "2023-03-06T19:47:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456857488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127073061"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit (for 9bf078f66c8f286e1ab5e34b8eeed7d80290a897):\r\n```cpp\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex ec5b0213b..f608d60f0 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -722,15 +722,13 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\r\n     if (newOnly && nNew == 0) return {};\r\n \r\n     // Decide if we are going to search the new or tried table\r\n-    bool search_tried;\r\n+    bool search_tried{false};\r\n \r\n     // Use a 50% chance for choosing between tried and new table entries.\r\n     if (!newOnly &&\r\n        (nTried > 0 &&\r\n         (nNew == 0 || insecure_rand.randbool() == 0))) {\r\n         search_tried = true;\r\n-    } else {\r\n-        search_tried = false;\r\n     }\r\n \r\n     if (search_tried) {\r\n```",
      "commit_id" : "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "created_at" : "2023-03-06T21:53:24Z",
      "diff_hunk" : "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127073061",
      "id" : 1127073061,
      "line" : 740,
      "node_id" : "PRRC_kwDOABII585DLcUl",
      "original_commit_id" : "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "original_line" : 725,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 8,
      "pull_request_review_id" : 1327252882,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:53:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127079909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "perhaps rename `newOnly` to `new_only`?",
      "commit_id" : "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "created_at" : "2023-03-06T21:59:21Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127079909",
      "id" : 1127079909,
      "line" : 735,
      "node_id" : "PRRC_kwDOABII585DLd_l",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 735,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 24,
      "pull_request_review_id" : 1327260528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T21:59:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127083746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Suggestion:\r\n```diff\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex 8c36af13f..66d54d2b4 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -746,8 +746,7 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optiona\r\n         search_tried = insecure_rand.randbool();\r\n     }\r\n \r\n-    int bucket_count;\r\n-    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\r\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n     //  Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n```",
      "commit_id" : "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "created_at" : "2023-03-06T22:03:42Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n \n     // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n     bool search_tried;\n-    int bucket_count;\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 &&\n-        (nNew == 0 || insecure_rand.randbool() == 0))) {\n+    if (newOnly || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n         search_tried = true;\n-        bucket_count = ADDRMAN_TRIED_BUCKET_COUNT;\n     } else {\n-        search_tried = false;\n-        bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\n+        search_tried = insecure_rand.randbool();\n     }\n \n+    int bucket_count;\n+    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127083746",
      "id" : 1127083746,
      "line" : 750,
      "node_id" : "PRRC_kwDOABII585DLe7i",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 750,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 48,
      "pull_request_review_id" : 1327266458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-06T22:03:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127282542"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "hm, this suggestion makes sense within the context of the first commit. however, the `search_tried` logic gets updated over the commits so it would be expanded anyways. \r\n\r\nit would be possible to rework the end state to be a bit more nifty like this, but since this logic is pretty crucial to the function working as intended, I'm more inclined to leave the explicit assignment of new vs tried. ",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T02:42:20Z",
      "diff_hunk" : "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127282542",
      "id" : 1127282542,
      "in_reply_to_id" : 1127073061,
      "line" : 740,
      "node_id" : "PRRC_kwDOABII585DMPdu",
      "original_commit_id" : "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "original_line" : 725,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 72,
      "pull_request_review_id" : 1327548731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T02:43:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice, done",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T03:02:01Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n \n     // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n     bool search_tried;\n-    int bucket_count;\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 &&\n-        (nNew == 0 || insecure_rand.randbool() == 0))) {\n+    if (newOnly || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n         search_tried = true;\n-        bucket_count = ADDRMAN_TRIED_BUCKET_COUNT;\n     } else {\n-        search_tried = false;\n-        bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\n+        search_tried = insecure_rand.randbool();\n     }\n \n+    int bucket_count;\n+    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291828",
      "id" : 1127291828,
      "in_reply_to_id" : 1127083746,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DMRu0",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 750,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1327561910,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T03:02:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T03:02:11Z",
      "diff_hunk" : "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291922",
      "id" : 1127291922,
      "in_reply_to_id" : 1127079909,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DMRwS",
      "original_commit_id" : "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "original_line" : 735,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1327562027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T03:02:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127730689"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n        const auto& address = addrman.Select(/*new_only=*/false, NET_I2P);\r\n```",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T11:39:44Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*newOnly*/false, NET_I2P);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127730689",
      "id" : 1127730689,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII585DN84B",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 145,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 65,
      "pull_request_review_id" : 1328202519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T11:41:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127731998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, can leave this way. This suggestion I made while reviewing the first commit but considering the whole context, you can leave it.",
      "commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "created_at" : "2023-03-07T11:41:00Z",
      "diff_hunk" : "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127731998",
      "id" : 1127731998,
      "in_reply_to_id" : 1127073061,
      "line" : 740,
      "node_id" : "PRRC_kwDOABII585DN9Me",
      "original_commit_id" : "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "original_line" : 725,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 72,
      "pull_request_review_id" : 1328205378,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T11:41:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128258413"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Interesting, perhaps #26261 would be a good fit :)",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-07T17:21:30Z",
      "diff_hunk" : "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128258413",
      "id" : 1128258413,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585DP9tt",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 82,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 19,
      "pull_request_review_id" : 1329133202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T17:21:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128704427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ah, it looks like those changes would remove the need for this helper? ",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-07T22:52:34Z",
      "diff_hunk" : "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128704427",
      "id" : 1128704427,
      "in_reply_to_id" : 1128258413,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585DRqmr",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 82,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 19,
      "pull_request_review_id" : 1329678832,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T22:52:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128705089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good catch, updated. also realized there were stale comments in the addrman unit test, so updated those too.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-07T22:53:17Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*newOnly*/false, NET_I2P);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128705089",
      "id" : 1128705089,
      "in_reply_to_id" : 1127730689,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DRqxB",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 145,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1329679553,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-07T22:53:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129220513"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, if it makes sense for you I'd appreciate your review there btw.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T10:16:15Z",
      "diff_hunk" : "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129220513",
      "id" : 1129220513,
      "in_reply_to_id" : 1128258413,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585DTomh",
      "original_commit_id" : "3a93327688aad526f9a81d214aed6e3f38415274",
      "original_line" : 82,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 19,
      "pull_request_review_id" : 1330318402,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-08T10:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129434505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `Addrman` in the method name is redundant. Maybe `AddrManImpl::LookupEntry()` or even `AddrManImpl::Lookup()` or `AddrManImpl::Get()`.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T13:32:30Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129434505",
      "id" : 1129434505,
      "line" : 798,
      "node_id" : "PRRC_kwDOABII585DUc2J",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 155,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129439158"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be good to have an assert that checks there is no out-of-bounds access. This method itself does not know what the callers will use for arguments or how they will be derived so better check.\r\n\r\nMaybe change the arrays to `std::array` and use `.at()` here.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T13:36:01Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129439158",
      "id" : 1129439158,
      "line" : 806,
      "node_id" : "PRRC_kwDOABII585DUd-2",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 806,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : 163,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 802,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129442167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: I know it was using `int` to index the array, but those should be `size_t`. Now looks like a good time to fix that:\r\n```suggestion\r\nint AddrManImpl::LookupAddrmanEntry(bool use_tried, size_t bucket, size_t position) const\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T13:38:17Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129442167",
      "id" : 1129442167,
      "line" : 798,
      "node_id" : "PRRC_kwDOABII585DUet3",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 155,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129522848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`std::string` will do heap allocation. It is an overkill in this case.\r\n\r\n```suggestion\r\n            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), search_tried ? \"tried\" : \"new\");\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:26:56Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129522848",
      "id" : 1129522848,
      "line" : 789,
      "node_id" : "PRRC_kwDOABII585DUyag",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 789,
      "original_position" : 146,
      "original_start_line" : 787,
      "path" : "src/addrman.cpp",
      "position" : 146,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 787,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129539099"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: use `std::nullopt` instead of `{}` which I believe is more readable and consistent with the comment that says \"nullopt = all\". Like here:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/8d12127a9c19cb218d661a88ab9b6871c9d853b9/src/addrman.h#L109",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:37:16Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] network  Select only addresses of this network (nullopt = all)\n      * @return    CAddress The record for the selected peer.\n      *            seconds  The last time we attempted to connect to that peer.\n      */\n-    std::pair<CAddress, NodeSeconds> Select(bool newOnly = false) const;\n+    std::pair<CAddress, NodeSeconds> Select(bool new_only = false, std::optional<Network> network = {}) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129539099",
      "id" : 1129539099,
      "line" : 154,
      "node_id" : "PRRC_kwDOABII585DU2Yb",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 154,
      "original_position" : 11,
      "original_start_line" : 150,
      "path" : "src/addrman.h",
      "position" : 11,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 150,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129547711"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: I think it is good to be explicit and use `network.has_value()` here. Otherwise it can get confusing, especially with booleans (`network` is not boolean, but anyway). For example:\r\n\r\n```cpp\r\nstd::optional<bool> is_odd\r\n...\r\nif (is_odd) { // did the author mean is_odd.has_value() or *is_odd?\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:42:40Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129547711",
      "id" : 1129547711,
      "line" : 726,
      "node_id" : "PRRC_kwDOABII585DU4e_",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 726,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 58,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129552332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n\r\n```suggestion\r\n    if (new_count + tried_count == 0) return {};\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:45:28Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129552332",
      "id" : 1129552332,
      "line" : 736,
      "node_id" : "PRRC_kwDOABII585DU5nM",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 736,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 68,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129566625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This maybe warrants a better description:\r\n\r\n```suggestion\r\n     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` guarantees either an address from the new table or an invalid return value. Passing `false` requests 50% chance of new or tried, it does not guarantee an entry from the tried table.\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:53:56Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129566625",
      "id" : 1129566625,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII585DU9Gh",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 149,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : 5,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129568636"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n    // Loop through the addrman table until we find an appropriate entry\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:55:10Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129568636",
      "id" : 1129568636,
      "line" : 751,
      "node_id" : "PRRC_kwDOABII585DU9l8",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 751,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 106,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129569710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: same as elsewhere: consider `network.has_value()`.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T14:55:51Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129569710",
      "id" : 1129569710,
      "line" : 765,
      "node_id" : "PRRC_kwDOABII585DU92u",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 765,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : 120,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129577204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: the code below has an assert after `find()`, good to have it here too:\r\n\r\n```suggestion\r\n                    const auto it{mapInfo.find(node_id)};\r\n                    assert(it != mapInfo.end());\r\n                    const auto info{it->second};\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-08T15:00:36Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129577204",
      "id" : 1129577204,
      "line" : 767,
      "node_id" : "PRRC_kwDOABII585DU_r0",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 767,
      "original_position" : 122,
      "original_start_line" : 766,
      "path" : "src/addrman.cpp",
      "position" : 122,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 766,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130661248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: in the commit message of `tests: add addrman_select_by_network test`: `s/newOnly/new_only` since it was already renamed before that commit",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T08:46:27Z",
      "diff_hunk" : "@@ -127,45 +127,47 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130661248",
      "id" : 1130661248,
      "line" : 128,
      "node_id" : "PRRC_kwDOABII585DZIWA",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 128,
      "original_position" : 2,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 2,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130664213"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: that should be `/*new_only=*/` for clang-tidy to check it and for consistency with the rest of the code base (here and elsewhere).",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T08:49:03Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130664213",
      "id" : 1130664213,
      "line" : 200,
      "node_id" : "PRRC_kwDOABII585DZJEV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 200,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 80,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130668333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be better to check that the returned result is `!IsValid()` and not rely on how an invalid address would be represented by `ToStringAddrPort()` (maybe even that method should assert that the object is valid).\r\n\r\n```suggestion\r\n    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV4).first.IsValid());\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T08:52:40Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130668333",
      "id" : 1130668333,
      "line" : 201,
      "node_id" : "PRRC_kwDOABII585DZKEt",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 201,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 81,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:25:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130699029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `250.1.1.1` is duplicated here and above. Maybe put it in a variable or avoid comparing through strings altogether (here and elsewhere):\r\n\r\n```suggestion\r\n    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_IPV4).first == addr1);\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:18:09Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130699029",
      "id" : 1130699029,
      "line" : 208,
      "node_id" : "PRRC_kwDOABII585DZRkV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 208,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 88,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"new_only=true, some_nonexistent_network\" seems untested:\r\n\r\n```cpp\r\nBOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:23:41Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627",
      "id" : 1130705627,
      "line" : 226,
      "node_id" : "PRRC_kwDOABII585DZTLb",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 106,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130712887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If this is changed to:\r\n```cpp\r\nCAddress i2p_addr;\r\n```\r\nand the rest of the code left as it is, then it will still work, but then `CAddress(i2p_addr, NODE_NONE)` which is duplicated below can be replaced with `i2p_addr`.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:29:46Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130712887",
      "id" : 1130712887,
      "line" : 217,
      "node_id" : "PRRC_kwDOABII585DZU83",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 217,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 97,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130731456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This test will fail sporadically.\r\n\r\nAlso, if you are only going to check the size, then a counter suffices. If you are going to collect the strings, then you may as well check that they are as expected (`i2p_addr` and `i2p_addr2`).\r\n\r\nConsider this:\r\n\r\n```cpp\r\n    CAddress i2p_addr2;\r\n...\r\n    // ensure that both new and tried table are selected from\r\n    bool new_selected{false};\r\n    bool tried_selected{false};\r\n    while (!new_selected || !tried_selected) { \r\n        const CAddress selected{addrman->Select(/*new_only=*/false, NET_I2P).first};\r\n        BOOST_REQUIRE(selected == i2p_addr || selected == i2p_addr2);\r\n        if (selected == i2p_addr) {\r\n            tried_selected = true;\r\n        } else {\r\n            new_selected = true;\r\n        }\r\n    }  \r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T09:45:08Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130731456",
      "id" : 1130731456,
      "line" : 246,
      "node_id" : "PRRC_kwDOABII585DZZfA",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 246,
      "original_position" : 126,
      "original_start_line" : 241,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 126,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 241,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130754068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "For this test to be meaningful there must be some address also in the tried table. Otherwise:\r\n\r\n```\r\n740     bool search_tried;\r\n741     if (new_only || tried_count == 0) {\r\n742         search_tried = false;\r\n743     } else if (new_count == 0) {\r\n744         search_tried = true;\r\n745     } else {\r\n746         search_tried = insecure_rand.randbool();\r\n747     }\r\n```\r\n\r\nit will always go to the new table via line 742 because `tried_count == 0` and it will never execute line 746 which I guess is the purpose of this test.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T10:03:39Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130754068",
      "id" : 1130754068,
      "line" : 262,
      "node_id" : "PRRC_kwDOABII585DZfAU",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 142,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 259,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130835999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "String comparison is very non-effective and surely has an impact of performance in such a tight-loop cases. This may better be:\r\n\r\n```suggestion\r\n        const auto address = addrman.Select(/*new_only*/false, NET_I2P).first;\r\n        assert(address == i2p_address);\r\n```\r\n\r\nI think that this also does not need to check the result - now it is mixing bench + correctness test in such a way that the correctness check may skew the benchmark. We have the unit tests to ensure correctness. Thus, this may as well be:\r\n\r\n```suggestion\r\n        (void)addrman.Select(/*new_only*/false, NET_I2P);\r\n```\r\n\r\nto reduce the amount of noise.",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T11:05:42Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\n+        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130835999",
      "id" : 1130835999,
      "line" : 146,
      "node_id" : "PRRC_kwDOABII585DZzAf",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 146,
      "original_position" : 66,
      "original_start_line" : 145,
      "path" : "src/bench/addrman.cpp",
      "position" : 66,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 145,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130840488"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is checking the port an indirect way to check that `Select()` returned a valid result? You can check that the returned value `IsValid()` for that. But same as for the other bench, this may as well be just `(void)addrman.Select();` to reduce the noise (and leave correctness checks to the unit tests).",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T11:10:13Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130840488",
      "id" : 1130840488,
      "line" : 126,
      "node_id" : "PRRC_kwDOABII585DZ0Go",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 126,
      "original_position" : 46,
      "original_start_line" : 125,
      "path" : "src/bench/addrman.cpp",
      "position" : 46,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 125,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-09T11:22:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130844842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It is excellent to see benchmark tests added! My only concern with this PR is that it will iterate through a lot of entries in addrman before finding one from the requested network. This in theory is `O(addrman size)`. And the benchmarks will help us assess that. So, it would be nice to compare, on the same, full addrman (e.g. 70k addresses):\r\n\r\n1. the speed of a regular `Select()`\r\n2. the speed of a `Select(network)` where the searched for address is ~near the end~ rare. In other words, worst case scenario, when ~70k addresses are iterated before finding the result.\r\n\r\nSomehow I don't see that from the added benchmarks. I will play with them to see if that's possible (~how to put an address \"at the end\"?~, that is nonsense, [there is no end](https://bitcoin-irc.chaincode.com/bitcoin-core-dev/2023-03-09#903165;)).\r\n\r\nBtw the results are unstable:\r\n```\r\n:wavy_dash: `AddrManSelectByNetwork` (Unstable with ~1.2 iters. Increase `minEpochIterations` to e.g. 12)\r\n```",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-09T11:14:39Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130844842",
      "id" : 1130844842,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585DZ1Kq",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 130,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 50,
      "pull_request_review_id" : 1330675864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-10T12:20:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Let me elaborate why I think comparing 1. and 2. above is important (the benchmarks in this PR don't do that):\r\n\r\n* Right now, on `master`, when we pick a peer to connect to 1. happens.\r\n* With #27213 when we pick a peer to connect to 2. happens.\r\n* I assume most of the addrmans out there are full (tens of thousands of addresses, max 80k), thus testing on an empty addrman is not representative.\r\n\r\nSo, we will add security at the cost of making it a bit slower. To assess how much slower I tweaked the benchmark as this:\r\n\r\n<details>\r\n<summary>benchmark tweaks</summary>\r\n\r\n```diff\r\ndiff --git i/src/bench/addrman.cpp w/src/bench/addrman.cpp\r\nindex 9fe50f4ec2..d1def9e520 100644\r\n--- i/src/bench/addrman.cpp\r\n+++ w/src/bench/addrman.cpp\r\n@@ -12,13 +12,13 @@\r\n \r\n #include <optional>\r\n #include <vector>\r\n \r\n /* A \"source\" is a source address from which we have received a bunch of other addresses. */\r\n \r\n-static constexpr size_t NUM_SOURCES = 64;\r\n+static constexpr size_t NUM_SOURCES = 512; // fills addrman with ~55k addresses, instead of ~15k\r\n static constexpr size_t NUM_ADDRESSES_PER_SOURCE = 256;\r\n \r\n static NetGroupManager EMPTY_NETGROUPMAN{std::vector<bool>()};\r\n static constexpr uint32_t ADDRMAN_CONSISTENCY_CHECK_RATIO{0};\r\n \r\n static std::vector<CAddress> g_sources;\r\n@@ -137,16 +137,20 @@ static void AddrManSelectByNetwork(benchmark::Bench& bench)\r\n     CAddress i2p_address(i2p_service, NODE_NONE);\r\n     i2p_address.nTime = Now<NodeSeconds>();\r\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\r\n     addrman.Add({i2p_address}, source);\r\n \r\n     FillAddrMan(addrman);\r\n-\r\n-    bench.run([&] {\r\n-        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\r\n-        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\r\n+    fprintf(stderr, \"addrman size: %zu\\n\", addrman.Size());\r\n+\r\n+    bench.minEpochIterations(300).run([&] {\r\n+#if 0\r\n+        addrman.Select(/*new_only=*/false);\r\n+#else\r\n+        addrman.Select(/*new_only=*/false, NET_I2P);\r\n+#endif\r\n     });\r\n }\r\n \r\n static void AddrManGetAddr(benchmark::Bench& bench)\r\n {\r\n     AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n```\r\n</details>\r\n\r\nThe results are:\r\n\r\n1. `Select()` takes 0.18 microseconds\r\n2. `Select(network)` takes 6000 microseconds\r\n\r\nNow, this is a big difference, but maybe that is ok. We don't `Select()` in a tight loop. However, it can be improved relatively easy. I observed that in 2. we visit between ~100 and ~600k bucket positions before finding a match. Given that there are 80k in addrman it means that we visit some multiple times, which is a waste of resources. This is avoided if we don't visit already visited buckets (but still visit buckets in random order). The patch below does that (on top of this PR):\r\n\r\n<details>\r\n<summary>don't visit already visited buckets</summary>\r\n\r\n```diff\r\ndiff --git i/src/addrman.cpp w/src/addrman.cpp\r\nindex 1023c3cbdb..0e196050b9 100644\r\n--- i/src/addrman.cpp\r\n+++ w/src/addrman.cpp\r\n@@ -16,12 +16,13 @@\r\n #include <streams.h>\r\n #include <tinyformat.h>\r\n #include <uint256.h>\r\n #include <util/check.h>\r\n #include <util/time.h>\r\n \r\n+#include <array>\r\n #include <cmath>\r\n #include <optional>\r\n \r\n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\r\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\r\n /** Over how many buckets entries with new addresses originating from a single group are spread */\r\n@@ -745,17 +746,39 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n     } else {\r\n         search_tried = insecure_rand.randbool();\r\n     }\r\n \r\n     const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n+    // We want to search buckets in random order and also prefer visiting a\r\n+    // bucket that we have not visited before instead of visiting an already\r\n+    // visited bucket. Thus shuffle the buckets and visit that shuffled list\r\n+    // in order.\r\n+\r\n+    std::array<uint16_t, std::max(ADDRMAN_TRIED_BUCKET_COUNT, ADDRMAN_NEW_BUCKET_COUNT)>\r\n+        shuffled_bucket_indexes;\r\n+    for (uint16_t i = 0; i < bucket_count; ++i) {\r\n+        shuffled_bucket_indexes[i] = i;\r\n+    }\r\n+    Shuffle(shuffled_bucket_indexes.begin(),\r\n+            shuffled_bucket_indexes.begin() + bucket_count,\r\n+            insecure_rand);\r\n+    // If we visit a bucket and find 0 matching addresses in it, mark it with\r\n+    // this and never visit it again.\r\n+    static constexpr uint16_t ALREADY_VISITED_AND_BORING{std::numeric_limits<uint16_t>::max()};\r\n+\r\n+    static_assert(ADDRMAN_TRIED_BUCKET_COUNT < ALREADY_VISITED_AND_BORING);\r\n+    static_assert(ADDRMAN_NEW_BUCKET_COUNT < ALREADY_VISITED_AND_BORING);\r\n+\r\n     //  Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n-    while (1) {\r\n-        // Pick a bucket, and an initial position in that bucket.\r\n-        int bucket = insecure_rand.randrange(bucket_count);\r\n+    for (uint16_t b = 0;; b = (b + 1) % bucket_count) {\r\n+        if (shuffled_bucket_indexes[b] == ALREADY_VISITED_AND_BORING) {\r\n+            continue;\r\n+        }\r\n+        const size_t bucket{shuffled_bucket_indexes[b]};\r\n         int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n         int i;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n@@ -769,14 +792,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n                 } else {\r\n                     break;\r\n                 }\r\n             }\r\n         }\r\n \r\n-        // If the bucket is entirely empty, start over with a (likely) different one.\r\n-        if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n+        // Start over with a different bucket if this one is entirely empty or\r\n+        // specific network was requested and it does not contain any addresses\r\n+        // from that network.\r\n+        if (i == ADDRMAN_BUCKET_SIZE) {\r\n+            shuffled_bucket_indexes[b] = ALREADY_VISITED_AND_BORING;\r\n+            continue;\r\n+        }\r\n \r\n         // Find the entry to return.\r\n         int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n         int nId = LookupAddrmanEntry(search_tried, bucket, position);\r\n         const auto it_found{mapInfo.find(nId)};\r\n         assert(it_found != mapInfo.end());\r\n```\r\n</details>\r\n\r\nIt changes `Select(network)` to about 3000 microseconds (down from 6000), but that result from the benchmark is averaged between executions that take anything between 100 and 600k iterations. What is more important is that with the change above it never takes more than ~60k iterations, that is - anything between 100 and 60k. Worst case lowered ~10 times.\r\n\r\nThe optimization brings some complexity but IMO it is worth it.\r\n",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-10T17:02:33Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513",
      "id" : 1132629513,
      "in_reply_to_id" : 1130844842,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585Dgo4J",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 130,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 50,
      "pull_request_review_id" : 1335246024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-10T17:02:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132740863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This looks like a nice speedup in the case where we only have a few addresses - however, due to the constant overhead of building the shuffled list of buckets in the beginning I'd expect performance to go down a bit for the case where we have many addresses to choose from. Do you see this in your benchmark?\r\nWhy does this need `ALREADY_VISITED_AND_BORING`? If we do a for-loop through a pre-shuffled list of buckets instead of a while loop, doesn't that already guarantee that we visit each bucket at most once?",
      "commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "created_at" : "2023-03-10T18:37:32Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132740863",
      "id" : 1132740863,
      "in_reply_to_id" : 1130844842,
      "line" : 130,
      "node_id" : "PRRC_kwDOABII585DhED_",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 130,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 50,
      "pull_request_review_id" : 1335415244,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-10T18:37:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132837417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good point about checking bounds. one way to do that is with simple checks like `assert(bucket <= ADDRMAN_TRIED_BUCKET_COUNT)` etc. \r\n\r\n> Maybe change the arrays to std::array and use .at() here.\r\n\r\nbut I'd like to understand this option better. right now `vvTried` and `vvNew` are declared as C-style arrays. is your recommendation to change those `AddrManImpl` declarations so that we can utilize the bounds checking of the `.at()` function? ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-10T20:20:42Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132837417",
      "id" : 1132837417,
      "in_reply_to_id" : 1129439158,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585Dhbop",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 805,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : 162,
      "pull_request_review_id" : 1335559840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 801,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-10T20:20:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132968822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "oh interesting, I thought that the compiler optimizes away these sort of named-variables-used-shortly-after patterns, but maybe it's different for `std::string`? I took it to compiler explorer to see if I could observe the allocation- https://godbolt.org/z/GG78zv3KT. are the calls to `std::allocator<char>` what you are referring to? ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-10T23:29:52Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132968822",
      "id" : 1132968822,
      "in_reply_to_id" : 1129522848,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dh7t2",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 789,
      "original_position" : 146,
      "original_start_line" : 787,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335744428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-10T23:29:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133106788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "this test is actually covering the `tried_count == 0` logic. if it were to hit line 746, it would sometimes select the tried table and sometimes the new table, which means it should fail 50% of the time. this coverage is ensuring that the `tried_count` has the proper interactions with `network`, which gets assigned earlier in the function-\r\n\r\n```\r\n    if (network.has_value()) {\r\n        auto it = m_network_counts.find(*network);\r\n        if (it == m_network_counts.end()) return {};\r\n\r\n        auto counts = it->second;\r\n        new_count = counts.n_new;\r\n        tried_count = counts.n_tried;\r\n    }\r\n``` \r\n\r\nlmk if that makes sense ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T15:29:08Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133106788",
      "id" : 1133106788,
      "in_reply_to_id" : 1130754068,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DidZk",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335898315,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T15:29:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133112932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "if I am understanding this thread properly, it seems like there are two concepts being discussed:\r\n1. changes to the bench tests\r\n2. optimization to `AddrManImpl::Select_`\r\n\r\nRE 1, I'm slightly confused as to the desired coverage. Without the network parameter, I would expect the worst case of the current `Select_` function to happen when addrman is practically empty, which is why we introduced `AddrManSelectFromAlmostEmpty`. On mainnet, this case would be unlikely, which is represented by `AddrManSelect`. With the network parameter, I would expect worst case to be represented by `AddrManSelectByNetwork` where theres just 1 I2P address on an addrman filled with other addresses. @vasild can you clarify what feels absent or misrepresentative?\r\n\r\nalso happy to discuss 2 further, but a question there - does it feel relevant to these patches to improve performance, or is it an orthogonal improvement (since we see similar worst cases right now)?  ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T15:58:51Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133112932",
      "id" : 1133112932,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585Die5k",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1335901245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T15:58:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good point, updated to `GetEntry` to match the naming style of `GetAddr`",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:31:04Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131333",
      "id" : 1133131333,
      "in_reply_to_id" : 1129434505,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijZF",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:31:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "updated, my understanding is that `size_t` is unsigned and better optimizes for different platforms. does that track?",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:32:14Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131478",
      "id" : 1133131478,
      "in_reply_to_id" : 1129442167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijbW",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920290,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:32:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "updated",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:32:45Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131507",
      "id" : 1133131507,
      "in_reply_to_id" : 1129522848,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijbz",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 789,
      "original_position" : 146,
      "original_start_line" : 787,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:32:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:33:05Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] network  Select only addresses of this network (nullopt = all)\n      * @return    CAddress The record for the selected peer.\n      *            seconds  The last time we attempted to connect to that peer.\n      */\n-    std::pair<CAddress, NodeSeconds> Select(bool newOnly = false) const;\n+    std::pair<CAddress, NodeSeconds> Select(bool new_only = false, std::optional<Network> network = {}) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131556",
      "id" : 1133131556,
      "in_reply_to_id" : 1129539099,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijck",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 154,
      "original_position" : 11,
      "original_start_line" : 150,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 1335920364,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:33:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131581"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:33:20Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131581",
      "id" : 1133131581,
      "in_reply_to_id" : 1129547711,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijc9",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 726,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920380,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:33:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:33:30Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131605",
      "id" : 1133131605,
      "in_reply_to_id" : 1129552332,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijdV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 736,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:33:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "updated but worded it a bit differently - the 50% is only true if there are matches in both tables (with network interactions). lmk if the new language seems reasonable to you",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:34:16Z",
      "diff_hunk" : "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131667",
      "id" : 1133131667,
      "in_reply_to_id" : 1129566625,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijeT",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 149,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/addrman.h",
      "position" : null,
      "pull_request_review_id" : 1335920465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:34:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:34:25Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131673",
      "id" : 1133131673,
      "in_reply_to_id" : 1129568636,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijeZ",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 751,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:34:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:34:48Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131714",
      "id" : 1133131714,
      "in_reply_to_id" : 1129569710,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijfC",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 765,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:34:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:02Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131741",
      "id" : 1133131741,
      "in_reply_to_id" : 1129577204,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijfd",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 768,
      "original_position" : 122,
      "original_start_line" : 766,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920533,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:09Z",
      "diff_hunk" : "@@ -127,45 +127,47 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131754",
      "id" : 1133131754,
      "in_reply_to_id" : 1130661248,
      "line" : 128,
      "node_id" : "PRRC_kwDOABII585Dijfq",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 128,
      "original_position" : 2,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : 2,
      "pull_request_review_id" : 1335920546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ah, thanks. updated lots of comments, I think I caught them all?",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:33Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131791",
      "id" : 1133131791,
      "in_reply_to_id" : 1130664213,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijgP",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 200,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks, updated this in lots of places",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:35:48Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131815",
      "id" : 1133131815,
      "in_reply_to_id" : 1130668333,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijgn",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 201,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:35:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "incorporated this in many places in the tests I touched. definitely reads better",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:11Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131847",
      "id" : 1133131847,
      "in_reply_to_id" : 1130699029,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijhH",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 208,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "added",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:17Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131864",
      "id" : 1133131864,
      "in_reply_to_id" : 1130705627,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijhY",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:26Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131874",
      "id" : 1133131874,
      "in_reply_to_id" : 1130712887,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dijhi",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 217,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920656,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "great idea ! updated to use this while loop. also added you as co-author for this commit btw, thanks for the in depth review :)",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:36:58Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131929",
      "id" : 1133131929,
      "in_reply_to_id" : 1130731456,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijiZ",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 246,
      "original_position" : 126,
      "original_start_line" : 241,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:36:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "that makes sense, updated to remove correctness tests",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:37:28Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\n+        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131961",
      "id" : 1133131961,
      "in_reply_to_id" : 1130835999,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Diji5",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 146,
      "original_position" : 66,
      "original_start_line" : 145,
      "path" : "src/bench/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:37:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131985"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yeah it was, but updated to remove that assertion. ",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-11T18:37:41Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131985",
      "id" : 1133131985,
      "in_reply_to_id" : 1130840488,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DijjR",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 126,
      "original_position" : 46,
      "original_start_line" : 125,
      "path" : "src/bench/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1335920779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-11T18:37:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136853031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@mzumsande,\r\n\r\n> I'd expect performance to go down a bit for the case where we have many addresses to choose from. Do you see this in your benchmark?\r\n\r\nYes, that slows down a bit the fast `Select()` (any network is ok). I observed that and think it is ok because it is still super fast with or without the shuffling.\r\n\r\n> Why does this need `ALREADY_VISITED_AND_BORING`?\r\n\r\nThe `for` loop could still repeat the whole array from the start if some address was found but was skipped. `ALREADY_VISITED_AND_BORING` is a further optimization to completely skip that bucket on the second and further passes through the array.\r\n\r\n@amitiuttarwar, you are right that I modified the newly added `AddrManSelectByNetwork()` so that, in general, it tests the same thing as `AddrManSelect()` which already exists in `master`. I did that in order to be sure that everything else is _identical_: the way addrman is filled, `minEpochIterations(300)` and the `GetPort()` call. Way too many times I have been bitten by chasing noise in benchmarks, so I wanted to be sure that this is the only difference in the two things I am comparing:\r\n\r\n```cpp\r\n#if 0 // flip to 1 to test the other case\r\n        addrman.Select(/*new_only=*/false);\r\n#else\r\n        addrman.Select(/*new_only=*/false, NET_I2P);\r\n#endif\r\n```\r\n\r\n> also happy to discuss 2 further, but a question there - does it feel relevant to these patches to improve performance, or is it an orthogonal improvement\r\n\r\nI think the performance improvement would be a nice addition to the work done by this PR (or maybe even a \"must have\"?)\r\n\r\n> (since we see similar worst cases right now)?\r\n\r\nHmm? Now on `master` on mainnet it takes 0.18 microseconds and with this PR on mainnet it will take 6000 microseconds. That is the average case (averaged by the benchmark executing `Select` about 3500 times). The difference in the worst case is even more pronounced.",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T10:40:18Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136853031",
      "id" : 1136853031,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585DwwAn",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1341141202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T10:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136869429"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, but I am not saying to do it (use `std::array` and `.at()`). It is just an option, in case you have not considered it. Up to you.\r\n\r\nBtw, a difference between an `assert()` and `.at()` is that the former will call `abort()` and will inevitably cause the program to exit. OTOH `.at()` will throw `std::out_of_range` which the caller can catch and continue the execution. I don't have a strong opinion which one is more preferable to use here. Maybe either one is ok. Usually on such \"programmer error\" we want to really stop the whole program, OTOH `.at()` is much more elegant to write :) and if the exception is unhandled then it will also cause the program to exit.",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T10:54:20Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136869429",
      "id" : 1136869429,
      "in_reply_to_id" : 1129439158,
      "line" : 805,
      "node_id" : "PRRC_kwDOABII585Dw0A1",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 805,
      "original_position" : 163,
      "original_start_line" : 802,
      "path" : "src/addrman.cpp",
      "position" : 162,
      "pull_request_review_id" : 1341177551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 801,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-15T10:54:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136880077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh, yes, now it makes sense! I was confused. I should have read the comment like:\r\n\"ensure that the new table gets selected even if new_only is false _(because the tried table is empty)_\"",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T11:03:24Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136880077",
      "id" : 1136880077,
      "in_reply_to_id" : 1130754068,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dw2nN",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1341203111,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-15T11:03:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136890366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes. Also std methods that take such \"indexes\" are usually `size_t`, e.g. https://en.cppreference.com/w/cpp/container/array/operator_at",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T11:12:37Z",
      "diff_hunk" : "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136890366",
      "id" : 1136890366,
      "in_reply_to_id" : 1129442167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Dw5H-",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 798,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/addrman.cpp",
      "position" : null,
      "pull_request_review_id" : 1341228747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T11:12:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137099484"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Where?",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T13:46:01Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137099484",
      "id" : 1137099484,
      "in_reply_to_id" : 1130705627,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DxsLc",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 226,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1341539035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T13:46:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137181909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think so, thanks!",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T14:32:05Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137181909",
      "id" : 1137181909,
      "in_reply_to_id" : 1130664213,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585DyATV",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 200,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1341641215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T14:32:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137526957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Hmm? Now on master on mainnet it takes 0.18 microseconds and with this PR on mainnet it will take 6000 microseconds. That is the average case (averaged by the benchmark executing Select about 3500 times). The difference in the worst case is even more pronounced.\r\n\r\nWe might be using slightly different terminology here: With \"worst case\", I mean the edge case where we have just one entry in AddrMan of the kind of address that we want. This is the benchmark `AddrManSelectFromAlmostEmpty` for unspecific selection and `AddrManSelectByNetwork` for network-specific selection. \r\n>#if 0 // flip to 1 to test the other case\r\n        addrman.Select(/*new_only=*/false);\r\n#else\r\n        addrman.Select(/*new_only=*/false, NET_I2P);\r\n#endif\r\n\r\nThis is not a meaningful comparison, because the first case is picking from an almost full AddrMan (\"best case\"), and the second case is the \"worst case\". If you replace `NET_I2P` by `NET_IPV4` in that example, I'd expect the network-specific performance to be basically identical to that of unspecific `Select()`, because AddrMan contains a single I2P address and ~50k IPV4 addresses in your setup.\r\n\r\nFluctuations due to RNG randomness within a given benchmark shouldn't be called \"worst case\" in my opinion, especially because there is no lower limit with the way `Select_()` currently works: for a given RNG seed, we might not visit the required bucket \"forever\" even if the probability for that will go to zero so quickly that it will never happen - there just is no distinct lower bound we could call \"worst case\" because it's probabilistic).\r\n\r\n> Yes, that slows down a bit the fast `Select()` (any network is ok).\r\n\r\nThe crucial question is by how much, because situations close to the \"worst case\" should be rather infrequent, while situations where we have multiple addresses to choose from should me much more common. With all the different methods of getting addresses, after a while of running your node you should at least know a couple dozens of addresses for each reachable network (even for CJDNS?!).\r\nSo there is the possibility that we might be optimizing for an edge case that is encountered very infrequently in the wild, while slightly slowing down the frequently encountered case at the same time. In this case, the change could be detrimental for performance overall!\r\n\r\nI'm not saying this would be the case here, but I want to do some more in-depth benchmarking myself later this week to convince myself a bit more that this would really be a clear performance improvement overall.",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-15T17:48:50Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137526957",
      "id" : 1137526957,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585DzUit",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1342072709,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-15T18:07:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1138102842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yeah, just to clarify- the tried table doesn't have to be empty, it just needs to have no matches for the specific network. I tried to capture that in the beginning of the comment: \"since the only ipv4 address is on the new table\", but let me know if there's something else that would help make that more clear",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-16T04:29:45Z",
      "diff_hunk" : "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1138102842",
      "id" : 1138102842,
      "in_reply_to_id" : 1130754068,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585D1hI6",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 262,
      "original_position" : 142,
      "original_start_line" : 259,
      "path" : "src/test/addrman_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1342882508,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-16T04:29:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140727315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I compared the performance of the PR branch with @vasild's [suggested optimization](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513) (\"VD\") a bit more closely:\r\n\r\n**Test 1**: Reasonably full addrman (15k addresses): `./bench_bitcoin -filter=AddrManSelect -min-time=5000`\r\n=> The PR is much faster, since VD has a constant overhead due to the shuffling.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              142.41 |        7,021,818.47 |    0.2% |      5.50 | `AddrManSelect`    \r\n|              145.75 |        6,860,921.17 |    0.4% |      5.63 | `AddrManSelect`\r\n|              145.91 |        6,853,404.83 |    1.4% |      5.55 | `AddrManSelect`\r\n|              149.78 |        6,676,385.78 |    3.7% |      5.63 | `AddrManSelect`\r\n|              144.37 |        6,926,771.77 |    0.3% |      5.49 | `AddrManSelect`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           12,716.43 |           78,638.44 |    0.1% |      5.49 | `AddrManSelect`\r\n|           12,790.84 |           78,180.95 |    0.8% |      5.36 | `AddrManSelect`\r\n|           12,884.37 |           77,613.41 |    0.7% |      5.53 | `AddrManSelect`\r\n|           12,815.30 |           78,031.72 |    0.9% |      5.52 | `AddrManSelect`\r\n|           12,961.91 |           77,149.10 |    1.3% |      5.55 | `AddrManSelect`\r\n</details>\r\n\r\n\r\n<br />\r\n\r\n**Test 2**: A single address in AddrMan:  \r\n`bench_bitcoin -filter=AddrManSelectFromAlmostEmpty -min-time=5000`\r\n=> VD is faster by  a factor of 1.8\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           93,286.28 |           10,719.69 |    2.2% |      5.42 | `AddrManSelectFromAlmostEmpty`\r\n|           90,781.42 |           11,015.47 |    1.0% |      5.52 | `AddrManSelectFromAlmostEmpty`\r\n|           92,758.06 |           10,780.73 |    1.2% |      5.57 | `AddrManSelectFromAlmostEmpty`\r\n|           90,026.20 |           11,107.88 |    0.7% |      5.52 | `AddrManSelectFromAlmostEmpty`\r\n|           91,946.89 |           10,875.84 |    1.1% |      5.47 | `AddrManSelectFromAlmostEmpty`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           55,306.93 |           18,080.92 |    0.7% |      5.50 | `AddrManSelectFromAlmostEmpty`\r\n|           55,209.86 |           18,112.71 |    0.4% |      5.48 | `AddrManSelectFromAlmostEmpty`\r\n|           54,989.61 |           18,185.25 |    0.5% |      5.51 | `AddrManSelectFromAlmostEmpty`\r\n|           56,727.70 |           17,628.07 |    2.1% |      5.57 | `AddrManSelectFromAlmostEmpty`\r\n|           55,732.54 |           17,942.84 |    0.5% |      5.50 | `AddrManSelectFromAlmostEmpty`\r\n</details>\r\n\r\n**Test 3**: Three addresses in AddrMan:  set `NUM_SOURCES = 3`, `NUM_ADDRESSES_PER_SOURCE=1` then run \r\n`./bench_bitcoin -filter=AddrManSelect -min-time=5000`\r\n=> PR is slightly faster.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           30,034.99 |           33,294.50 |    0.7% |      5.51 | `AddrManSelect`\r\n|           30,370.28 |           32,926.92 |    1.1% |      5.17 | `AddrManSelect`\r\n|           30,574.52 |           32,706.98 |    2.1% |      5.20 | `AddrManSelect`\r\n|           29,883.53 |           33,463.25 |    0.7% |      5.52 | `AddrManSelect`\r\n|           29,944.31 |           33,395.33 |    0.5% |      5.52 | `AddrManSelect`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           34,126.18 |           29,303.02 |    0.7% |      5.30 | `AddrManSelect`\r\n|           34,660.26 |           28,851.49 |    0.9% |      5.32 | `AddrManSelect`\r\n|           34,075.81 |           29,346.33 |    0.7% |      5.30 | `AddrManSelect`\r\n|           34,628.06 |           28,878.31 |    1.3% |      5.36 | `AddrManSelect`\r\n|           34,300.57 |           29,154.03 |    0.6% |      5.31 | `AddrManSelect`\r\n</details>\r\n\r\n**Test 4**:\r\nQuery for a single network-specific address in an AddrMan filled with 15k IPV4 addresses we don't want\r\n`./bench_bitcoin -filter=AddrManSelectByNetwork -min-time=500`\r\n=> VD is faster by a factor of ~2.1.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|        1,256,860.84 |              795.63 |    4.4% |      5.40 | `AddrManSelectByNetwork`\r\n|        1,269,322.70 |              787.82 |    2.6% |      5.50 | `AddrManSelectByNetwork`\r\n|        1,242,639.25 |              804.74 |    1.9% |      5.56 | `AddrManSelectByNetwork`\r\n|        1,246,311.65 |              802.37 |    2.9% |      5.69 | `AddrManSelectByNetwork`\r\n|        1,265,535.68 |              790.18 |    3.4% |      5.59 | `AddrManSelectByNetwork`\r\n\r\nVD\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          560,818.30 |            1,783.11 |    1.0% |      5.56 | `AddrManSelectByNetwork`\r\n|          558,351.91 |            1,790.99 |    0.9% |      5.53 | `AddrManSelectByNetwork`\r\n|          600,536.33 |            1,665.18 |    4.8% |      5.38 | `AddrManSelectByNetwork`\r\n|          569,208.08 |            1,756.83 |    1.7% |      5.45 | `AddrManSelectByNetwork`\r\n|          581,860.03 |            1,718.63 |    2.3% |      5.47 | `AddrManSelectByNetwork`\r\n</details>\r\n\r\n**Test 5**:\r\nQuery for 20 network-specific address in an AddrMan filled with 15k IPV4 addresses we don't want (changing the code a bit)\r\n`./bench_bitcoin -filter=AddrManSelectByNetwork -min-time=500`\r\n=> Performance is approximately the same.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          109,388.10 |            9,141.76 |    1.6% |      5.40 | `AddrManSelectByNetwork`\r\n|          108,804.63 |            9,190.79 |    2.1% |      5.56 | `AddrManSelectByNetwork`\r\n|          111,333.16 |            8,982.05 |    2.0% |      5.61 | `AddrManSelectByNetwork`\r\n|          110,827.61 |            9,023.02 |    1.4% |      5.55 | `AddrManSelectByNetwork`\r\n|          122,518.06 |            8,162.06 |    1.4% |      5.47 | `AddrManSelectByNetwork`\r\n\r\nVD\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          106,806.78 |            9,362.70 |    2.5% |      5.51 | `AddrManSelectByNetwork`\r\n|          109,221.66 |            9,155.69 |    3.1% |      5.59 | `AddrManSelectByNetwork`\r\n|          107,870.77 |            9,270.35 |    3.8% |      5.41 | `AddrManSelectByNetwork`\r\n|          105,131.17 |            9,511.93 |    0.5% |      5.47 | `AddrManSelectByNetwork`\r\n|          106,080.47 |            9,426.81 |    1.2% |      5.48 | `AddrManSelectByNetwork`\r\n\r\n</details>\r\n\r\nIn conclusion, my results indicate that the suggested optimization is only faster in some specific scenarios because the pre-shuffling of the buckets adds a constant overhead that is not neglible:\r\nIn the case of non-network specific queries (which should be the bulk even after #27213 ), the PR is already faster when `AddrMan` has more than 3 addresses (which should virtually always be the case!)\r\nIn the case of network-specific queries, the tipping point is (because of the additional cost of looking up addrs in buckets that we can't use) at ~20 network-specific addresses (with 15k IPV4 addresses). This is a bit higher, but I would imagine that we should get more than 20 addresses of most alternative networks rather quickly.\r\nTo summarize, my results indicate that adding pre-shuffling AddrMan buckets to prevent repeated visits appears to be no clear performance improvement - in most cases, performance would go down.\r\n\r\n@vasild: Do you see similar numbers?\r\n",
      "commit_id" : "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "created_at" : "2023-03-17T21:30:32Z",
      "diff_hunk" : "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140727315",
      "id" : 1140727315,
      "in_reply_to_id" : 1130844842,
      "line" : 129,
      "node_id" : "PRRC_kwDOABII585D_h4T",
      "original_commit_id" : "25a64a20749f10ce84060f3570ad76d1a4776948",
      "original_line" : 129,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/bench/addrman.cpp",
      "position" : 49,
      "pull_request_review_id" : 1346757351,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-17T22:31:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   }
]
