[
   {
      "author_association" : "MEMBER",
      "body" : "I've dropped the amalgamation file",
      "created_at" : "2020-05-27T03:19:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-634403350",
      "id" : 634403350,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNDQwMzM1MA==",
      "updated_at" : "2020-05-27T03:19:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/634403350",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Pretty amazing work! Thanks for doing this.\r\nFor testing purposes, would it make sense to add logdb (#5686, simple implementation) in order to test and benchmark?\r\n\r\nConcept ACK on a BDB replacement for descriptor wallets.\r\nStill unsure wether sqlite or an internal format should be chosen. Maybe a comparison(-matrix) of internal vs. sqlite could be done?\r\n\r\nAs for concrete implementation steps, maybe it would make sense to PR the DB flexibility first, then additional storage engines later.",
      "created_at" : "2020-05-27T15:54:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-634758099",
      "id" : 634758099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNDc1ODA5OQ==",
      "updated_at" : "2020-05-27T15:55:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/634758099",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> For testing purposes, would it make sense to add logdb (#5686, simple implementation) in order to test and benchmark?\r\n\r\nI don't think it really makes sense to add a database system that we aren't going to use.\r\n\r\n> Still unsure wether sqlite or an internal format should be chosen. Maybe a comparison(-matrix) of internal vs. sqlite could be done?\r\n\r\nI think there's two primary reasons to choose sqlite over an internal format.\r\n\r\n1. Review and implementation are much simpler The library already exists so implementation just means correctly using the API. Reviewers won't have to review a file format implementation and convince themselves that that format won't corrupt and is robust.\r\n\r\n2. Better guarantees of consistency and non-corruption. SQLite is very well tested and very widely used. I think they are able better guarantee that data will get written, won't get lost, and won't get corrupted, than we would be able to with an internal format.\r\n\r\n> As for concrete implementation steps, maybe it would make sense to PR the DB flexibility first, then additional storage engines later.\r\n\r\n#18971 does the DB class stuff that gives us this flexibility. This PR is adding in the storage engine and the logic for CWallet to choose which storage to use.",
      "created_at" : "2020-05-27T16:25:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-634780861",
      "id" : 634780861,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNDc4MDg2MQ==",
      "updated_at" : "2020-05-27T16:25:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/634780861",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nNice work! Very readable code!",
      "created_at" : "2020-05-27T19:21:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-634887122",
      "id" : 634887122,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNDg4NzEyMg==",
      "updated_at" : "2020-05-27T19:21:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/634887122",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19558 (build: split pthread flags out of ldflags and dont use when building libconsensus by fanquake)\n* #19502 (Bugfix: Wallet: Soft-fail exceptions within ListWalletDir file checks by luke-jr)\n* #19425 (refactor: Get rid of more redundant chain methods by ryanofsky)\n* #19419 (wallet: let Listwalletdir do not iterate trough our blocksdata. by Saibato)\n* #19245 ([WIP DONOTMERGE] Replace boost::filesystem with std::filesystem (in c++17) by kiminuo)\n* #19137 (wallettool: Add dump and createfromdump commands by achow101)\n* #19101 (refactor: remove ::vpwallets and related global variables by ryanofsky)\n* #18904 (Don't call lsn_reset in periodic flush by bvbfan)\n* #18836 (wallet: upgradewallet fixes and additional tests by achow101)\n* #18608 (refactor: Remove CAddressBookData::destdata by ryanofsky)\n* #18095 (Fix crashes and infinite loop in ListWalletDir() by uhliksk)\n* #18077 (net: Add NAT-PMP port forwarding support by hebasto)\n* #16546 (External signer support - Wallet Box edition by Sjors)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-05-27T19:50:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-634903672",
      "id" : 634903672,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNDkwMzY3Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-04T04:07:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/634903672",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "CONCEPT ACK\r\n :tada: :partying_face: :tada: \r\nVery happy to move on from BerkeleyDB and I've always liked sqlite as a versatile but still minimalistic replacement.",
      "created_at" : "2020-05-28T10:41:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-635262568",
      "id" : 635262568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNTI2MjU2OA==",
      "updated_at" : "2020-05-28T10:42:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/635262568",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. I'm able to build and run the test suite (including `feature_backwards_compatibility.py`) on macOS 10.15.4 with Homebrew `brew install sqlite3` (don't forget to add). I'm also able to build with `/depends`. I'm able to load an existing descriptor wallet (bdb) and create a new one.\r\n\r\nIs there a particular reason to stick to `.dat` as the file extension, rather than `.sqlite`? If you do the latter, `listwalletdir` and the Open Wallet GUI need a trivial change.\r\n\r\nWould it make sense to switch some of the records over to a format that's more easy to inspect with a SQLite viewer? As well as use tables like \"transactions\"? Or would that make this PR far too complicated?",
      "created_at" : "2020-06-01T15:28:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-636923373",
      "id" : 636923373,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNjkyMzM3Mw==",
      "updated_at" : "2020-06-01T15:29:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/636923373",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Is there a particular reason to stick to `.dat` as the file extension, rather than `.sqlite`? If you do the latter, `listwalletdir` and the Open Wallet GUI need a trivial change.\r\n\r\nThere are 2 reasons. The first is that it's easier on review on implementation to stick to one filename. As you mentioned, if I make it `.sqlite`, `listwalletdir` and other places need to be changed. There are several places throughout the codebase where we specifically look for `wallet.dat` and not changing those to also use `wallet.sqlite` could be very bad. Additionally, some of those places may need to know whether they are looking for `wallet.dat` or `wallet.sqlite` so they would need access to whether a wallet is a descriptor wallet. They may need to know what kind of storage to look for which exposes more information than we currently already do. It's much simpler to just keep it `wallet.dat`. This avoids issues where the wrong filename could be used and makes review simpler.\r\n\r\nThe second reason is that there are already lots of tooling, documentation, and discussion that use `wallet.dat`. Things like backup scripts or instructions telling people how to backup their wallet won't be invalidated as we keep the same naming. For the most part, the end user doesn't care about how the data is being stored within the file, they just need to know to preserve the `wallet.dat` file. So by keeping the naming, all of these things stay the same and make it less likely for people to lose their money.\r\n\r\nThere are, of course, a few cases where tooling does need to be updated because of the format change. But this tooling is all for manual inspection of the wallet.dat file and most users aren't using that tooling.\r\n\r\n> Would it make sense to switch some of the records over to a format that's more easy to inspect with a SQLite viewer? As well as use tables like \"transactions\"? Or would that make this PR far too complicated?\r\n\r\nI would like to do that in the future. But I think that is too complicated for right now.",
      "created_at" : "2020-06-01T15:58:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-636939984",
      "id" : 636939984,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNjkzOTk4NA==",
      "updated_at" : "2020-06-01T15:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/636939984",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I don't think it really makes sense to add a database system that we aren't going to use.\r\n\r\nMaybe it's time to use logdb.\r\n\r\n>Review and implementation are much simpler\r\n\r\nRealistically, this should be phrased \"review and implementation are behind closed doors by another team, and non-transparent\".\r\n\r\nWhile SQLite has a free license, it is not open development. I'm not sure if their review standards are even documented.\r\n\r\n> I've always liked sqlite as a versatile but still minimalistic\r\n\r\nNot sure SQLite counts as minimalistic... :p",
      "created_at" : "2020-06-03T18:03:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-638366578",
      "id" : 638366578,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzODM2NjU3OA==",
      "updated_at" : "2020-06-03T18:03:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/638366578",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. Awesome.",
      "created_at" : "2020-06-11T20:33:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-642914167",
      "id" : 642914167,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MjkxNDE2Nw==",
      "updated_at" : "2020-06-11T20:33:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/642914167",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Since #19334 has been merged, this is now ready for review.",
      "created_at" : "2020-07-23T03:50:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-662805756",
      "id" : 662805756,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MjgwNTc1Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-23T03:50:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/662805756",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460269271"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460269271"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Change WalletLocation::Exists to check for wallet file existence\" (6e7ef52e359e55bc82a30207a701995f0ca255d7)\r\n\r\nMinor: I can't really figure out what this commit and also the previous commit \"wallet: Don't Verify if database location doesn't exist\" (b64e40310742e3975ae704a801ccafa73d8617bf) are doing. Changes seem harmless, but they are making code more complicated. It would be good if commit messages mentioned motivations in commits like these where the motivations aren't obvious.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:20:16Z",
      "diff_hunk" : "@@ -101,9 +101,23 @@ WalletLocation::WalletLocation(const std::string& name)\n bool WalletLocation::Exists() const\n {\n     fs::path path = m_path;\n-    // For the default wallet, check specifically for the wallet.dat file\n-    if (m_name.empty()) {\n+\n+    fs::file_type path_type = fs::symlink_status(path).type();\n+    // Short circuit if it just doesn't exist\n+    if (path_type == fs::file_not_found) {\n+        return false;\n+    }\n+\n+    // If it's a file, it exists (duh)\n+    if (path_type == fs::regular_file) {\n+        return true;\n+    }\n+\n+    // If it's a directory, check specifically for the wallet.dat files\n+    if (path_type == fs::directory_file || (path_type == fs::symlink_file && fs::is_directory(path))) {\n         path = fs::absolute(\"wallet.dat\", m_path);\n+        return fs::symlink_status(path).type() != fs::file_not_found;\n     }\n-    return fs::symlink_status(path).type() != fs::file_not_found;\n+    // Something exists here but we don't know what it is... Just say something exists so an error can be caught later",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460269271",
      "id" : 460269271,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2OTI3MQ==",
      "original_commit_id" : "6e7ef52e359e55bc82a30207a701995f0ca255d7",
      "original_line" : 138,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "src/wallet/walletutil.cpp",
      "position" : null,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460269271",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460275191"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460275191"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add libsqlite3\" (31243f5482bb1c8a71affbe7ced6653a09bd6829)\r\n\r\nWould suggest splitting this commit and other build and depends and travis related commits into a separate build PR so it can get feedback from bitcoin build aficionados (and so this PR can more approachable for regular and wallet reviewers).\r\n\r\nI think probably build reviewers will want a `--with-sqlite` configure option to allow sqlite to be disabled in the build even if it is present in the system. They might also want the sqlite location to be determined through pkgconfig instead of assumed to be in the system include directory.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:34:37Z",
      "diff_hunk" : "@@ -1138,6 +1138,9 @@ fi\n if test x$enable_wallet != xno; then\n     dnl Check for libdb_cxx only if wallet enabled\n     BITCOIN_FIND_BDB48\n+\n+    dnl Check for sqlite3\n+    AC_CHECK_HEADERS([sqlite3.h], [AC_CHECK_LIB([sqlite3], [sqlite3_open], [SQLITE_LIBS=-lsqlite3], [AC_MSG_ERROR(sqlite3_open missing from libsqlite3)], [-pthread -lpthread])], [AC_MSG_ERROR(sqlite3.h headers missing)])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460275191",
      "id" : 460275191,
      "line" : 1180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NTE5MQ==",
      "original_commit_id" : "31243f5482bb1c8a71affbe7ced6653a09bd6829",
      "original_line" : 1180,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "configure.ac",
      "position" : 6,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460275191",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460276199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460276199"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Constructors, destructors, and relevant private fields for SQLiteDatabase/Batch\" (08847ca4de58c112da4b6455230f7b454afa543c)\r\n\r\nMinor: Suggest `sqlite3* m_db{nullptr};` or `sqlite3* m_db = nullptr;` here to be sure this is safe without looking and even if someone adds another constructor.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:37:14Z",
      "diff_hunk" : "@@ -83,6 +92,8 @@ class SQLiteDatabase : public WalletDatabase\n \n     /** Make a SQLiteBatch connected to this database */\n     std::unique_ptr<DatabaseBatch> MakeBatch(const char* mode = \"r+\", bool flush_on_close = true) override;\n+\n+    sqlite3* m_db;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460276199",
      "id" : 460276199,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NjE5OQ==",
      "original_commit_id" : "08847ca4de58c112da4b6455230f7b454afa543c",
      "original_line" : 96,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : null,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460276199",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460278213"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460278213"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Introduce g_file_paths\" (d038d04a4e3e0522a51cf0d39110749f8395f61a)\r\n\r\nMinor: Pretty sure we can get rid of these globals with more sane loading code in the wallet, but in any case could consider switching RecursiveMutex to Mutex if possible and switching `cs_sqlite` to `g_sqlite_mutex` to follow newer conventions",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:41:46Z",
      "diff_hunk" : "@@ -5,12 +5,20 @@\n #include <wallet/sqlite.h>\n \n #include <logging.h>\n+#include <sync.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n #include <wallet/db.h>\n \n #include <sqlite3.h>\n #include <stdint.h>\n+#include <unordered_set>\n+\n+namespace {\n+    RecursiveMutex cs_sqlite;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460278213",
      "id" : 460278213,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3ODIxMw==",
      "original_commit_id" : "d038d04a4e3e0522a51cf0d39110749f8395f61a",
      "original_line" : 18,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460278213",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460279135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460279135"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement SQLiteDatabaseVersion\" (b2f2e7171861fe2998f2c27af44b65b0e1f558aa)\r\n\r\nMinor: SQLiteLibraryVersion might be a more descriptive name",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:43:50Z",
      "diff_hunk" : "@@ -124,3 +125,8 @@ bool SQLiteBatch::TxnAbort()\n {\n     return false;\n }\n+\n+std::string SQLiteDatabaseVersion()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460279135",
      "id" : 460279135,
      "line" : 580,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3OTEzNQ==",
      "original_commit_id" : "b2f2e7171861fe2998f2c27af44b65b0e1f558aa",
      "original_line" : 580,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 580,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460279135",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460280638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460280638"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Initialize and Shutdown sqlite3 globals\" (5c78c9094a0158e4d466b696a3bbbcbd35b51b15)\r\n\r\nMinor: Would add comment saying this is a no-op if it is already called. Another option would be to only call it when g_file_paths is empty.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:47:36Z",
      "diff_hunk" : "@@ -34,6 +34,10 @@ SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_pa\n     LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n     LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n \n+    int ret = sqlite3_initialize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460280638",
      "id" : 460280638,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4MDYzOA==",
      "original_commit_id" : "5c78c9094a0158e4d466b696a3bbbcbd35b51b15",
      "original_line" : 37,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460280638",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460281099"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460281099"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Initialize and Shutdown sqlite3 globals\" (5c78c9094a0158e4d466b696a3bbbcbd35b51b15)\r\n\r\nReturn value isn't checked here. Would suggest at least logging an error so we know if something has gone wrong.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T20:48:46Z",
      "diff_hunk" : "@@ -44,6 +48,9 @@ SQLiteDatabase::~SQLiteDatabase()\n     Close();\n     LOCK(cs_sqlite);\n     g_file_paths.erase(m_file_path);\n+    if (g_file_paths.empty()) {\n+        sqlite3_shutdown();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460281099",
      "id" : 460281099,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4MTA5OQ==",
      "original_commit_id" : "5c78c9094a0158e4d466b696a3bbbcbd35b51b15",
      "original_line" : 52,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 455162194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460281099",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> If it's available, I'd be curious to see a diff of the additional changes that switch `wallet.dat` to `wallet.sqlite` and how complicated they are.\r\n\r\nhttps://github.com/achow101/bitcoin/tree/sqlite-wallet-w-rename is a copy of the original branch with the rename. It's a bit outdated, but it should give you an idea of what was needed for renaming.\r\n\r\n  > Do we know how current & previous versions of bitcoins react if they load a `wallet.dat` file that doesn't contain berkeley db data? Hopefully they show a sensible error instead of crashing obscurely or doing something worse like modifying the file.\r\n\r\nThe wallets won't be listed by `listwalletdir` as the bdb magic is checked in that function. BDB itself will error with `Not a Berkeley DB` (or something like that) when it tries to open the sqlite file and that error makes it's way to the user.",
      "created_at" : "2020-07-24T21:17:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-663738278",
      "id" : 663738278,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MzczODI3OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-24T21:17:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/663738278",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460293438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460293438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The motivation is so that we check the wallet file itself as part of the db type checking later on. IIRC there were some issues with where the wrong file type was being used that necessitated these changes.\r\n\r\nI'll try to expand the commit message ",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-24T21:20:52Z",
      "diff_hunk" : "@@ -101,9 +101,23 @@ WalletLocation::WalletLocation(const std::string& name)\n bool WalletLocation::Exists() const\n {\n     fs::path path = m_path;\n-    // For the default wallet, check specifically for the wallet.dat file\n-    if (m_name.empty()) {\n+\n+    fs::file_type path_type = fs::symlink_status(path).type();\n+    // Short circuit if it just doesn't exist\n+    if (path_type == fs::file_not_found) {\n+        return false;\n+    }\n+\n+    // If it's a file, it exists (duh)\n+    if (path_type == fs::regular_file) {\n+        return true;\n+    }\n+\n+    // If it's a directory, check specifically for the wallet.dat files\n+    if (path_type == fs::directory_file || (path_type == fs::symlink_file && fs::is_directory(path))) {\n         path = fs::absolute(\"wallet.dat\", m_path);\n+        return fs::symlink_status(path).type() != fs::file_not_found;\n     }\n-    return fs::symlink_status(path).type() != fs::file_not_found;\n+    // Something exists here but we don't know what it is... Just say something exists so an error can be caught later",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460293438",
      "id" : 460293438,
      "in_reply_to_id" : 460269271,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5MzQzOA==",
      "original_commit_id" : "6e7ef52e359e55bc82a30207a701995f0ca255d7",
      "original_line" : 138,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "src/wallet/walletutil.cpp",
      "position" : null,
      "pull_request_review_id" : 455192029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460293438",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596136"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-27T00:47:32Z",
      "diff_hunk" : "@@ -83,6 +92,8 @@ class SQLiteDatabase : public WalletDatabase\n \n     /** Make a SQLiteBatch connected to this database */\n     std::unique_ptr<DatabaseBatch> MakeBatch(const char* mode = \"r+\", bool flush_on_close = true) override;\n+\n+    sqlite3* m_db;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596136",
      "id" : 460596136,
      "in_reply_to_id" : 460276199,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU5NjEzNg==",
      "original_commit_id" : "08847ca4de58c112da4b6455230f7b454afa543c",
      "original_line" : 96,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : null,
      "pull_request_review_id" : 455413175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596136",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596148"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596148"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-27T00:47:39Z",
      "diff_hunk" : "@@ -5,12 +5,20 @@\n #include <wallet/sqlite.h>\n \n #include <logging.h>\n+#include <sync.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n #include <wallet/db.h>\n \n #include <sqlite3.h>\n #include <stdint.h>\n+#include <unordered_set>\n+\n+namespace {\n+    RecursiveMutex cs_sqlite;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596148",
      "id" : 460596148,
      "in_reply_to_id" : 460278213,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU5NjE0OA==",
      "original_commit_id" : "d038d04a4e3e0522a51cf0d39110749f8395f61a",
      "original_line" : 18,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 455413190,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596148",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Probably, but I'm also following the convention set by `BerkeleyDatabaseVersion`.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-27T00:48:16Z",
      "diff_hunk" : "@@ -124,3 +125,8 @@ bool SQLiteBatch::TxnAbort()\n {\n     return false;\n }\n+\n+std::string SQLiteDatabaseVersion()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596211",
      "id" : 460596211,
      "in_reply_to_id" : 460279135,
      "line" : 580,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU5NjIxMQ==",
      "original_commit_id" : "b2f2e7171861fe2998f2c27af44b65b0e1f558aa",
      "original_line" : 580,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 580,
      "pull_request_review_id" : 455413266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596211",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596216"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596216"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-27T00:48:21Z",
      "diff_hunk" : "@@ -34,6 +34,10 @@ SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_pa\n     LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n     LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n \n+    int ret = sqlite3_initialize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596216",
      "id" : 460596216,
      "in_reply_to_id" : 460280638,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU5NjIxNg==",
      "original_commit_id" : "5c78c9094a0158e4d466b696a3bbbcbd35b51b15",
      "original_line" : 37,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 455413284,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596216",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596231"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-07-27T00:48:27Z",
      "diff_hunk" : "@@ -44,6 +48,9 @@ SQLiteDatabase::~SQLiteDatabase()\n     Close();\n     LOCK(cs_sqlite);\n     g_file_paths.erase(m_file_path);\n+    if (g_file_paths.empty()) {\n+        sqlite3_shutdown();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r460596231",
      "id" : 460596231,
      "in_reply_to_id" : 460281099,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU5NjIzMQ==",
      "original_commit_id" : "5c78c9094a0158e4d466b696a3bbbcbd35b51b15",
      "original_line" : 52,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 455413296,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460596231",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-07-27T01:04:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-664067917",
      "id" : 664067917,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NDA2NzkxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-27T01:04:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/664067917",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r464085954"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/464085954"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A couple of comments here:\r\n\r\n- file at path is opened twice.\r\n- nit, in `DetermineStorageType` you check `IsSQLiteFile` first, maybe change there for now as most is BDB.\r\n- maybe follow up, this could use `DetermineStorageType`.\r\n",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-08-02T14:41:06Z",
      "diff_hunk" : "@@ -40,18 +42,7 @@ static bool IsBerkeleyBtree(const fs::path& path)\n     if (ec) LogPrintf(\"%s: %s %s\\n\", __func__, ec.message(), path.string());\n     if (size < 4096) return false;\n \n-    fsbridge::ifstream file(path, std::ios::binary);\n-    if (!file.is_open()) return false;\n-\n-    file.seekg(12, std::ios::beg); // Magic bytes start at offset 12\n-    uint32_t data = 0;\n-    file.read((char*) &data, sizeof(data)); // Read 4 bytes of file to compare against magic\n-\n-    // Berkeley DB Btree magic bytes, from:\n-    //  https://github.com/file/file/blob/5824af38469ec1ca9ac3ffd251e7afe9dc11e227/magic/Magdir/database#L74-L75\n-    //  - big endian systems - 00 05 31 62\n-    //  - little endian systems - 62 31 05 00\n-    return data == 0x00053162 || data == 0x62310500;\n+    return IsBDBFile(path) || IsSQLiteFile(path);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r464085954",
      "id" : 464085954,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4NTk1NA==",
      "original_commit_id" : "e68484878b539692be5030b8941fd3fe81d79870",
      "original_line" : 45,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/wallet/walletutil.cpp",
      "position" : null,
      "pull_request_review_id" : 459654361,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/464085954",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r465347410"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/465347410"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> file at path is opened twice.\r\n\r\nIt is?\r\n\r\nDone the other 2 suggestions.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-08-04T21:43:46Z",
      "diff_hunk" : "@@ -40,18 +42,7 @@ static bool IsBerkeleyBtree(const fs::path& path)\n     if (ec) LogPrintf(\"%s: %s %s\\n\", __func__, ec.message(), path.string());\n     if (size < 4096) return false;\n \n-    fsbridge::ifstream file(path, std::ios::binary);\n-    if (!file.is_open()) return false;\n-\n-    file.seekg(12, std::ios::beg); // Magic bytes start at offset 12\n-    uint32_t data = 0;\n-    file.read((char*) &data, sizeof(data)); // Read 4 bytes of file to compare against magic\n-\n-    // Berkeley DB Btree magic bytes, from:\n-    //  https://github.com/file/file/blob/5824af38469ec1ca9ac3ffd251e7afe9dc11e227/magic/Magdir/database#L74-L75\n-    //  - big endian systems - 00 05 31 62\n-    //  - little endian systems - 62 31 05 00\n-    return data == 0x00053162 || data == 0x62310500;\n+    return IsBDBFile(path) || IsSQLiteFile(path);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r465347410",
      "id" : 465347410,
      "in_reply_to_id" : 464085954,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NzQxMA==",
      "original_commit_id" : "e68484878b539692be5030b8941fd3fe81d79870",
      "original_line" : 45,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/wallet/walletutil.cpp",
      "position" : null,
      "pull_request_review_id" : 461195815,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/465347410",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r465348577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/465348577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "At worst case it is.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-08-04T21:46:23Z",
      "diff_hunk" : "@@ -40,18 +42,7 @@ static bool IsBerkeleyBtree(const fs::path& path)\n     if (ec) LogPrintf(\"%s: %s %s\\n\", __func__, ec.message(), path.string());\n     if (size < 4096) return false;\n \n-    fsbridge::ifstream file(path, std::ios::binary);\n-    if (!file.is_open()) return false;\n-\n-    file.seekg(12, std::ios::beg); // Magic bytes start at offset 12\n-    uint32_t data = 0;\n-    file.read((char*) &data, sizeof(data)); // Read 4 bytes of file to compare against magic\n-\n-    // Berkeley DB Btree magic bytes, from:\n-    //  https://github.com/file/file/blob/5824af38469ec1ca9ac3ffd251e7afe9dc11e227/magic/Magdir/database#L74-L75\n-    //  - big endian systems - 00 05 31 62\n-    //  - little endian systems - 62 31 05 00\n-    return data == 0x00053162 || data == 0x62310500;\n+    return IsBDBFile(path) || IsSQLiteFile(path);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r465348577",
      "id" : 465348577,
      "in_reply_to_id" : 464085954,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0ODU3Nw==",
      "original_commit_id" : "e68484878b539692be5030b8941fd3fe81d79870",
      "original_line" : 45,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/wallet/walletutil.cpp",
      "position" : null,
      "pull_request_review_id" : 461197201,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/465348577",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-05T12:10:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-669156764",
      "id" : 669156764,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2OTE1Njc2NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-05T12:10:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/669156764",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r467193743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467193743"
         }
      },
      "author_association" : "MEMBER",
      "body" : "787047133d22f014bea2646d3b23cd18801f19c2: you can drop the `else if (fs::is_directory(location.GetPath()` branch from `rpcwallet.cpp`",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-08-07T18:09:06Z",
      "diff_hunk" : "@@ -269,7 +269,7 @@ def wallet_file(name):\n \n         # Fail to load if a directory is specified that doesn't contain a wallet\n         os.mkdir(wallet_dir('empty_wallet_dir'))\n-        assert_raises_rpc_error(-18, \"Directory empty_wallet_dir does not contain a wallet.dat file\", self.nodes[0].loadwallet, 'empty_wallet_dir')\n+        assert_raises_rpc_error(-18, \"Wallet empty_wallet_dir not found.\", self.nodes[0].loadwallet, 'empty_wallet_dir')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r467193743",
      "id" : 467193743,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5Mzc0Mw==",
      "original_commit_id" : "787047133d22f014bea2646d3b23cd18801f19c2",
      "original_line" : 272,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/wallet_multiwallet.py",
      "position" : null,
      "pull_request_review_id" : 463507539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467193743",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r467304981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467304981"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add/Remove m_file_path to/from g_file_paths in con/destructor\" (316002da052cad68c54a48e918d1d5f2ca58c0d0)\r\n\r\nMinor: Developer notes and current clang-format config don't indent namespace contents\r\n\r\nAlso, I wonder if these variables are even necessary. If sqlite supports opening databases in an exclusive mode, there should be no need for our code to maintain this additional list of database files.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-08-07T22:02:29Z",
      "diff_hunk" : "@@ -5,12 +5,20 @@\n #include <wallet/sqlite.h>\n \n #include <logging.h>\n+#include <sync.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n #include <wallet/db.h>\n \n #include <sqlite3.h>\n #include <stdint.h>\n+#include <unordered_set>\n+\n+namespace {\n+    Mutex g_sqlite_mutex;\n+    //! Set of wallet file paths in use\n+    std::unordered_set<std::string> g_file_paths GUARDED_BY(g_sqlite_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r467304981",
      "id" : 467304981,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwNDk4MQ==",
      "original_commit_id" : "fe790158c8a6c2019ebcb97b6637e1c069b76ed6",
      "original_line" : 22,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 463662644,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467304981",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've taken @ryanofsky's rebase and made a few changes. Notably I removed the filename change and the related tests. Also I made a slight change to CreateWallet` so that the GUI would also make sqlite wallets for descriptor wallets.",
      "created_at" : "2020-08-10T22:11:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-671615437",
      "id" : 671615437,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3MTYxNTQzNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-10T22:11:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/671615437",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r468239295"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/468239295"
         }
      },
      "author_association" : "MEMBER",
      "body" : "sqlite does have a way to open databases in an exclusive mode but we don't use it. But we also do that ourselves with the `.walletlock` file. So I think this is just unnecessary anyways and thus I've removed it.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-08-10T23:24:53Z",
      "diff_hunk" : "@@ -5,12 +5,20 @@\n #include <wallet/sqlite.h>\n \n #include <logging.h>\n+#include <sync.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n #include <wallet/db.h>\n \n #include <sqlite3.h>\n #include <stdint.h>\n+#include <unordered_set>\n+\n+namespace {\n+    Mutex g_sqlite_mutex;\n+    //! Set of wallet file paths in use\n+    std::unordered_set<std::string> g_file_paths GUARDED_BY(g_sqlite_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r468239295",
      "id" : 468239295,
      "in_reply_to_id" : 467304981,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzOTI5NQ==",
      "original_commit_id" : "fe790158c8a6c2019ebcb97b6637e1c069b76ed6",
      "original_line" : 22,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : null,
      "pull_request_review_id" : 464651826,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/468239295",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-14T15:03:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-674117920",
      "id" : 674117920,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDExNzkyMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T15:03:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674117920",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-31T10:17:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-683693307",
      "id" : 683693307,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MzY5MzMwNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-31T10:17:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/683693307",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-09-03T17:35:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-686643954",
      "id" : 686643954,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4NjY0Mzk1NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-03T17:35:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/686643954",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This can now be rebased after #19619 merge ",
      "created_at" : "2020-09-06T23:48:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-687936981",
      "id" : 687936981,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4NzkzNjk4MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-06T23:48:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/687936981",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/meshcollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/meshcollider/followers",
         "following_url" : "https://api.github.com/users/meshcollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/meshcollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/meshcollider",
         "id" : 3211283,
         "login" : "meshcollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/meshcollider/orgs",
         "received_events_url" : "https://api.github.com/users/meshcollider/received_events",
         "repos_url" : "https://api.github.com/users/meshcollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/meshcollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/meshcollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2020-09-06T23:55:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-687938563",
      "id" : 687938563,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4NzkzODU2Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-06T23:55:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/687938563",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Should probably be setting the application_id pragma to something constant and random.\r\n\r\nIt's also important that fullfsync be set because Mac OS X is a liar.\r\n\r\nCould also be setting user_version, which is a way of versioning the schema.",
      "created_at" : "2020-09-07T17:18:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-688444710",
      "id" : 688444710,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4ODQ0NDcxMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-07T17:18:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/688444710",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Should probably be setting the application_id pragma to something constant and random.\r\n\r\nCould just set it to the network magic bytes? I think that might even let us deal with #12805 by ensuring that we only open a wallet that was created with the correct network magic as the application_id.\r\n\r\n> Could also be setting user_version, which is a way of versioning the schema.\r\n\r\nWould it be useful to set it to the wallet version number or should this just be a new schema version number?",
      "created_at" : "2020-09-07T22:05:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-688523403",
      "id" : 688523403,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4ODUyMzQwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-07T22:05:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/688523403",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Added application_id as the network magic. Also added user_version.",
      "created_at" : "2020-09-10T00:23:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-689894349",
      "id" : 689894349,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4OTg5NDM0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-10T00:23:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/689894349",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-09-15T11:39:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#issuecomment-692659595",
      "id" : 692659595,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MjY1OTU5NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-15T11:39:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/692659595",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491332879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491332879"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "1) I suppose the locking is done in the calling code. Do I understand correctly that it's managed by `cs_wallet`? \r\n\r\n2) nit: I believe it's better to have all members private. Why not make `SQLiteBatch` a friend class or just pass the statement handlers when we construct `SQLiteBatch` object.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-19T08:37:16Z",
      "diff_hunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_SQLITE_H\n+#define BITCOIN_WALLET_SQLITE_H\n+\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+\n+struct bilingual_str;\n+class SQLiteDatabase;\n+\n+/** RAII class that provides access to a WalletDatabase */\n+class SQLiteBatch : public DatabaseBatch\n+{\n+private:\n+    SQLiteDatabase& m_database;\n+\n+    bool m_read_only = false;\n+    bool m_cursor_init = false;\n+\n+    bool ReadKey(CDataStream&& key, CDataStream& value) override;\n+    bool WriteKey(CDataStream&& key, CDataStream&& value, bool overwrite=true) override;\n+    bool EraseKey(CDataStream&& key) override;\n+    bool HasKey(CDataStream&& key) override;\n+\n+public:\n+    explicit SQLiteBatch(SQLiteDatabase& database, const char* mode);\n+    ~SQLiteBatch() override { Close(); }\n+\n+    void Flush() override;\n+    void Close() override;\n+\n+    bool StartCursor() override;\n+    bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) override;\n+    void CloseCursor() override;\n+    bool TxnBegin() override;\n+    bool TxnCommit() override;\n+    bool TxnAbort() override;\n+};\n+\n+/** An instance of this class represents one SQLite3 database.\n+ **/\n+class SQLiteDatabase : public WalletDatabase\n+{\n+private:\n+    bool m_mock = false;\n+\n+    const std::string m_dir_path;\n+\n+    const std::string m_file_path;\n+\n+    bool PrepareDirectory() const;\n+\n+    void SetupSQLStatements();\n+\n+public:\n+    SQLiteDatabase() = delete;\n+\n+    /** Create DB handle to real database */\n+    SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock=false);\n+\n+    ~SQLiteDatabase();\n+\n+    bool Verify(bilingual_str& error);\n+\n+    /** Open the database if it is not already opened */\n+    void Open(const char* mode) override;\n+\n+    /** Close the database */\n+    void Close() override;\n+\n+    /** Indicate the a new database user has began using the database. Increments m_refcount */\n+    void AddRef() override;\n+    /** Indicate that database user has stopped using the database. Decrement m_refcount */\n+    void RemoveRef() override;\n+\n+    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n+     */\n+    bool Rewrite(const char* skip=nullptr) override;\n+\n+    /** Back up the entire database to a file.\n+     */\n+    bool Backup(const std::string& dest) const override;\n+\n+    /** Make sure all changes are flushed to disk.\n+     */\n+    void Flush() override;\n+    /* flush the wallet passively (TRY_LOCK)\n+       ideal to be called periodically */\n+    bool PeriodicFlush() override;\n+\n+    void IncrementUpdateCounter() override { ++nUpdateCounter; }\n+\n+    void ReloadDbEnv() override;\n+\n+    std::string Filename() override { return m_file_path; };\n+\n+    /** Make a SQLiteBatch connected to this database */\n+    std::unique_ptr<DatabaseBatch> MakeBatch(const char* mode = \"r+\", bool flush_on_close = true) override;\n+\n+    sqlite3* m_db{nullptr};\n+\n+    sqlite3_stmt* m_read_stmt = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491332879",
      "id" : 491332879,
      "line" : 106,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzMjg3OQ==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 106,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 106,
      "pull_request_review_id" : 491982796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491332879",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491354812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491354812"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I double pstratem's comment regarding `fullsync` and `checkpoint_fullsync`",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-19T09:45:04Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491354812",
      "id" : 491354812,
      "line" : 126,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM1NDgxMg==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 126,
      "original_position" : 126,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 126,
      "pull_request_review_id" : 491982796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491354812",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491360876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491360876"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What if we create read-only batch first and then a read-write batch? Looks like it's going to fail since the connection will remain read-only.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-19T10:03:19Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491360876",
      "id" : 491360876,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MDg3Ng==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 227,
      "pull_request_review_id" : 491982796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491360876",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491362245"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491362245"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: IIUC we need to close db handler even in the case of an error.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-19T10:06:55Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {\n+        sqlite3* db = nullptr;\n+        int ret = sqlite3_open_v2(m_file_path.c_str(), &db, flags, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to open database: %s\\n\", sqlite3_errstr(ret)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491362245",
      "id" : 491362245,
      "line" : 231,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM2MjI0NQ==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 231,
      "original_position" : 231,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 231,
      "pull_request_review_id" : 491982796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491362245",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491651973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491651973"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: why not verify `m_cursor_init` just in case?",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-20T04:46:01Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {\n+        sqlite3* db = nullptr;\n+        int ret = sqlite3_open_v2(m_file_path.c_str(), &db, flags, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to open database: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+        // TODO: Maybe(?) Check the file wasn't copied and a duplicate opened\n+\n+        if (create) {\n+            bool table_exists;\n+            // Check that the main table exists\n+            sqlite3_stmt* check_main_stmt;\n+            std::string check_main = \"SELECT name FROM sqlite_master WHERE type='table' AND name='main'\";\n+            ret = sqlite3_prepare_v2(db, check_main.c_str(), -1, &check_main_stmt, nullptr);\n+            if (ret != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to prepare statement to check table existence: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+            ret = sqlite3_step(check_main_stmt);\n+            if (sqlite3_finalize(check_main_stmt) != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to finalize statement checking table existence: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+            if (ret == SQLITE_DONE) {\n+                table_exists = false;\n+            } else if (ret == SQLITE_ROW) {\n+                table_exists = true;\n+            } else {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to execute statement to check table existence: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+\n+            if (!table_exists) {\n+                // Make the table for our key-value pairs\n+                std::string create_stmt = \"CREATE TABLE main(key BLOB PRIMARY KEY, value BLOB)\";\n+                ret = sqlite3_exec(db, create_stmt.c_str(), nullptr, nullptr, nullptr);\n+                if (ret != SQLITE_OK) {\n+                    throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to create new database: %s\\n\", sqlite3_errstr(ret)));\n+                }\n+            }\n+\n+            // Set the application id\n+            uint32_t app_id = ReadBE32(Params().MessageStart());\n+            std::string set_app_id = strprintf(\"PRAGMA application_id = %d\", (int32_t)app_id);\n+            ret = sqlite3_exec(db, set_app_id.c_str(), nullptr, nullptr, nullptr);\n+            if (ret != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to set the application id: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+\n+            // Set the user version\n+            std::string set_user_ver = strprintf(\"PRAGMA user_version = %d\", WALLET_SCHEMA_VERSION);\n+            ret = sqlite3_exec(db, set_user_ver.c_str(), nullptr, nullptr, nullptr);\n+            if (ret != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to set the wallet schema version: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+        }\n+\n+        m_db = db;\n+    }\n+    SetupSQLStatements();\n+}\n+\n+bool SQLiteDatabase::Rewrite(const char* skip)\n+{\n+    while (true) {\n+        if (m_refcount == 0) {\n+            break;\n+        }\n+        UninterruptibleSleep(std::chrono::milliseconds{100});\n+    }\n+\n+    // Rewrite the database using the VACUUM command: https://sqlite.org/lang_vacuum.html\n+    int ret = sqlite3_exec(m_db, \"VACUUM\", nullptr, nullptr, nullptr);\n+    return ret == SQLITE_OK;\n+}\n+\n+bool SQLiteDatabase::PeriodicFlush()\n+{\n+    return true;\n+}\n+\n+bool SQLiteDatabase::Backup(const std::string& dest) const\n+{\n+    sqlite3* db_copy;\n+    int res = sqlite3_open(dest.c_str(), &db_copy);\n+    if (res != SQLITE_OK) {\n+        sqlite3_close(db_copy);\n+        return false;\n+    }\n+    sqlite3_backup* backup = sqlite3_backup_init(db_copy, \"main\", m_db, \"main\");\n+    if (!backup) {\n+        sqlite3_backup_finish(backup);\n+        sqlite3_close(db_copy);\n+        return false;\n+    }\n+    // Copy all of the pages using -1\n+    res = sqlite3_backup_step(backup, -1);\n+    if (res != SQLITE_DONE) {\n+        sqlite3_backup_finish(backup);\n+        sqlite3_close(db_copy);\n+        return false;\n+    }\n+    res = sqlite3_backup_finish(backup);\n+    sqlite3_close(db_copy);\n+    return res == SQLITE_OK;\n+}\n+\n+void SQLiteDatabase::Close()\n+{\n+    if (!m_db) return;\n+\n+    assert(m_refcount == 0);\n+\n+    // Free all of the prepared statements\n+    sqlite3_finalize(m_read_stmt);\n+    sqlite3_finalize(m_insert_stmt);\n+    sqlite3_finalize(m_overwrite_stmt);\n+    sqlite3_finalize(m_delete_stmt);\n+    sqlite3_finalize(m_cursor_stmt);\n+\n+    int res = sqlite3_close(m_db);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to close database: %s\\n\", sqlite3_errstr(res)));\n+    }\n+    m_db = nullptr;\n+\n+    UnlockDirectory(m_dir_path, \".walletlock\");\n+}\n+\n+void SQLiteDatabase::Flush() {}\n+\n+void SQLiteDatabase::ReloadDbEnv() {}\n+\n+void SQLiteDatabase::RemoveRef()\n+{\n+    m_refcount--;\n+}\n+\n+void SQLiteDatabase::AddRef()\n+{\n+    m_refcount++;\n+}\n+\n+std::unique_ptr<DatabaseBatch> SQLiteDatabase::MakeBatch(const char* mode, bool flush_on_close)\n+{\n+    // We ignore flush_on_close because we don't do manual flushing for SQLite\n+    return MakeUnique<SQLiteBatch>(*this, mode);\n+}\n+\n+SQLiteBatch::SQLiteBatch(SQLiteDatabase& database, const char* mode)\n+    : m_database(database)\n+{\n+    m_read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+    m_database.AddRef();\n+    m_database.Open(mode);\n+}\n+\n+void SQLiteBatch::Flush() {}\n+\n+void SQLiteBatch::Close()\n+{\n+    if (m_database.m_db && sqlite3_get_autocommit(m_database.m_db) == 0) {\n+        TxnAbort();\n+    }\n+    m_database.RemoveRef();\n+}\n+\n+bool SQLiteBatch::ReadKey(CDataStream&& key, CDataStream& value)\n+{\n+    if (!m_database.m_db) return false;\n+    assert(m_database.m_read_stmt);\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    int res = sqlite3_bind_blob(m_database.m_read_stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(m_database.m_read_stmt);\n+        sqlite3_reset(m_database.m_read_stmt);\n+        return false;\n+    }\n+    res = sqlite3_step(m_database.m_read_stmt);\n+    if (res != SQLITE_ROW) {\n+        sqlite3_clear_bindings(m_database.m_read_stmt);\n+        sqlite3_reset(m_database.m_read_stmt);\n+        return false;\n+    }\n+    // Leftmost column in result is index 0\n+    const char* data = (const char*)sqlite3_column_blob(m_database.m_read_stmt, 0);\n+    int data_size = sqlite3_column_bytes(m_database.m_read_stmt, 0);\n+    value.write(data, data_size);\n+\n+    sqlite3_clear_bindings(m_database.m_read_stmt);\n+    sqlite3_reset(m_database.m_read_stmt);\n+    return true;\n+}\n+\n+bool SQLiteBatch::WriteKey(CDataStream&& key, CDataStream&& value, bool overwrite)\n+{\n+    if (!m_database.m_db) return false;\n+    if (m_read_only) assert(!\"Write called on database in read-only mode\");\n+    assert(m_database.m_insert_stmt && m_database.m_overwrite_stmt);\n+\n+    sqlite3_stmt* stmt;\n+    if (overwrite) {\n+        stmt = m_database.m_overwrite_stmt;\n+    } else {\n+        stmt = m_database.m_insert_stmt;\n+    }\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    // Insert index 1 is key, 2 is value\n+    int res = sqlite3_bind_blob(stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(stmt);\n+        sqlite3_reset(stmt);\n+        return false;\n+    }\n+    res = sqlite3_bind_blob(stmt, 2, value.data(), value.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(stmt);\n+        sqlite3_reset(stmt);\n+        return false;\n+    }\n+\n+    // Execute\n+    res = sqlite3_step(stmt);\n+    sqlite3_clear_bindings(stmt);\n+    sqlite3_reset(stmt);\n+    return res == SQLITE_DONE;\n+}\n+\n+bool SQLiteBatch::EraseKey(CDataStream&& key)\n+{\n+    if (!m_database.m_db) return false;\n+    if (m_read_only) assert(!\"Erase called on database in read-only mode\");\n+    assert(m_database.m_delete_stmt);\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    int res = sqlite3_bind_blob(m_database.m_delete_stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(m_database.m_delete_stmt);\n+        sqlite3_reset(m_database.m_delete_stmt);\n+        return false;\n+    }\n+\n+    // Execute\n+    res = sqlite3_step(m_database.m_delete_stmt);\n+    sqlite3_clear_bindings(m_database.m_delete_stmt);\n+    sqlite3_reset(m_database.m_delete_stmt);\n+    return res == SQLITE_DONE;\n+}\n+\n+bool SQLiteBatch::HasKey(CDataStream&& key)\n+{\n+    if (!m_database.m_db) return false;\n+    assert(m_database.m_read_stmt);\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    bool ret = false;\n+    int res = sqlite3_bind_blob(m_database.m_read_stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res == SQLITE_OK) {\n+        res = sqlite3_step(m_database.m_read_stmt);\n+        if (res == SQLITE_ROW) {\n+            ret = true;\n+        }\n+    }\n+\n+    sqlite3_clear_bindings(m_database.m_read_stmt);\n+    sqlite3_reset(m_database.m_read_stmt);\n+    return ret;\n+}\n+\n+bool SQLiteBatch::StartCursor()\n+{\n+    assert(!m_cursor_init);\n+    if (!m_database.m_db) return false;\n+    m_cursor_init = true;\n+    return true;\n+}\n+\n+bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& complete)\n+{\n+    complete = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491651973",
      "id" : 491651973,
      "line" : 514,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY1MTk3Mw==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 514,
      "original_position" : 505,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 514,
      "pull_request_review_id" : 491982796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491651973",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491662874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491662874"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: maybe add an upper limit to avoid hanging the thread in case something went wrong?",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-20T07:22:39Z",
      "diff_hunk" : "@@ -170,7 +170,16 @@ void SQLiteDatabase::Open(const char* mode)\n \n bool SQLiteDatabase::Rewrite(const char* skip)\n {\n-    return false;\n+    while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r491662874",
      "id" : 491662874,
      "line" : 297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY2Mjg3NA==",
      "original_commit_id" : "ceac790fb2be0bcd5a1e20b275612c3b75df7786",
      "original_line" : 297,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 297,
      "pull_request_review_id" : 491982796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491662874",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492397526"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492397526"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> I suppose the locking is done in the calling code. Do I understand correctly that it's managed by `cs_wallet`?\r\n\r\nFor the most part, yes. Sometimes we do need to handle concurrency withing `SQLiteDatabase` but those should already be handled by `m_refcount` and sqlite itself.\r\n\r\n> nit: I believe it's better to have all members private. Why not make `SQLiteBatch` a friend class or just pass the statement handlers when we construct `SQLiteBatch` object.\r\n\r\nI suppose now we could pass them in. In a previous revision, I don't think that was possible.\r\n\r\nBut it's easier to just let them be public members. It would be 6 extra arguments to pass them in and we are already giving the `SQLiteDatabase` container.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-21T23:14:48Z",
      "diff_hunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_SQLITE_H\n+#define BITCOIN_WALLET_SQLITE_H\n+\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+\n+struct bilingual_str;\n+class SQLiteDatabase;\n+\n+/** RAII class that provides access to a WalletDatabase */\n+class SQLiteBatch : public DatabaseBatch\n+{\n+private:\n+    SQLiteDatabase& m_database;\n+\n+    bool m_read_only = false;\n+    bool m_cursor_init = false;\n+\n+    bool ReadKey(CDataStream&& key, CDataStream& value) override;\n+    bool WriteKey(CDataStream&& key, CDataStream&& value, bool overwrite=true) override;\n+    bool EraseKey(CDataStream&& key) override;\n+    bool HasKey(CDataStream&& key) override;\n+\n+public:\n+    explicit SQLiteBatch(SQLiteDatabase& database, const char* mode);\n+    ~SQLiteBatch() override { Close(); }\n+\n+    void Flush() override;\n+    void Close() override;\n+\n+    bool StartCursor() override;\n+    bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) override;\n+    void CloseCursor() override;\n+    bool TxnBegin() override;\n+    bool TxnCommit() override;\n+    bool TxnAbort() override;\n+};\n+\n+/** An instance of this class represents one SQLite3 database.\n+ **/\n+class SQLiteDatabase : public WalletDatabase\n+{\n+private:\n+    bool m_mock = false;\n+\n+    const std::string m_dir_path;\n+\n+    const std::string m_file_path;\n+\n+    bool PrepareDirectory() const;\n+\n+    void SetupSQLStatements();\n+\n+public:\n+    SQLiteDatabase() = delete;\n+\n+    /** Create DB handle to real database */\n+    SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock=false);\n+\n+    ~SQLiteDatabase();\n+\n+    bool Verify(bilingual_str& error);\n+\n+    /** Open the database if it is not already opened */\n+    void Open(const char* mode) override;\n+\n+    /** Close the database */\n+    void Close() override;\n+\n+    /** Indicate the a new database user has began using the database. Increments m_refcount */\n+    void AddRef() override;\n+    /** Indicate that database user has stopped using the database. Decrement m_refcount */\n+    void RemoveRef() override;\n+\n+    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n+     */\n+    bool Rewrite(const char* skip=nullptr) override;\n+\n+    /** Back up the entire database to a file.\n+     */\n+    bool Backup(const std::string& dest) const override;\n+\n+    /** Make sure all changes are flushed to disk.\n+     */\n+    void Flush() override;\n+    /* flush the wallet passively (TRY_LOCK)\n+       ideal to be called periodically */\n+    bool PeriodicFlush() override;\n+\n+    void IncrementUpdateCounter() override { ++nUpdateCounter; }\n+\n+    void ReloadDbEnv() override;\n+\n+    std::string Filename() override { return m_file_path; };\n+\n+    /** Make a SQLiteBatch connected to this database */\n+    std::unique_ptr<DatabaseBatch> MakeBatch(const char* mode = \"r+\", bool flush_on_close = true) override;\n+\n+    sqlite3* m_db{nullptr};\n+\n+    sqlite3_stmt* m_read_stmt = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492397526",
      "id" : 492397526,
      "in_reply_to_id" : 491332879,
      "line" : 106,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NzUyNg==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 106,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 106,
      "pull_request_review_id" : 493042692,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492397526",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492417032"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492417032"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think we always open in read-write mode first so that doesn't have any effect. But I suppose we should still have a check for that.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T00:25:12Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492417032",
      "id" : 492417032,
      "in_reply_to_id" : 491360876,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzAzMg==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 227,
      "pull_request_review_id" : 493064287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492417032",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492417585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492417585"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It will be closed when the `SQLiteDatabase` is destructed.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T00:27:30Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {\n+        sqlite3* db = nullptr;\n+        int ret = sqlite3_open_v2(m_file_path.c_str(), &db, flags, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to open database: %s\\n\", sqlite3_errstr(ret)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492417585",
      "id" : 492417585,
      "in_reply_to_id" : 491362245,
      "line" : 231,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxNzU4NQ==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 231,
      "original_position" : 231,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 231,
      "pull_request_review_id" : 493064873,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492417585",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492418121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492418121"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it's fine",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T00:29:49Z",
      "diff_hunk" : "@@ -170,7 +170,16 @@ void SQLiteDatabase::Open(const char* mode)\n \n bool SQLiteDatabase::Rewrite(const char* skip)\n {\n-    return false;\n+    while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492418121",
      "id" : 492418121,
      "in_reply_to_id" : 491662874,
      "line" : 297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQxODEyMQ==",
      "original_commit_id" : "ceac790fb2be0bcd5a1e20b275612c3b75df7786",
      "original_line" : 297,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 297,
      "pull_request_review_id" : 493065456,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492418121",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492428340"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492428340"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added `fullfsync` enabling. `checkpoint_fullsync` is not needed as we don't use WAL mode.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T01:13:56Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492428340",
      "id" : 492428340,
      "in_reply_to_id" : 491354812,
      "line" : 126,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyODM0MA==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 126,
      "original_position" : 126,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 126,
      "pull_request_review_id" : 493076274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:13:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492428340",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492428354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492428354"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T01:14:02Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {\n+        sqlite3* db = nullptr;\n+        int ret = sqlite3_open_v2(m_file_path.c_str(), &db, flags, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to open database: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+        // TODO: Maybe(?) Check the file wasn't copied and a duplicate opened\n+\n+        if (create) {\n+            bool table_exists;\n+            // Check that the main table exists\n+            sqlite3_stmt* check_main_stmt;\n+            std::string check_main = \"SELECT name FROM sqlite_master WHERE type='table' AND name='main'\";\n+            ret = sqlite3_prepare_v2(db, check_main.c_str(), -1, &check_main_stmt, nullptr);\n+            if (ret != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to prepare statement to check table existence: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+            ret = sqlite3_step(check_main_stmt);\n+            if (sqlite3_finalize(check_main_stmt) != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to finalize statement checking table existence: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+            if (ret == SQLITE_DONE) {\n+                table_exists = false;\n+            } else if (ret == SQLITE_ROW) {\n+                table_exists = true;\n+            } else {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to execute statement to check table existence: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+\n+            if (!table_exists) {\n+                // Make the table for our key-value pairs\n+                std::string create_stmt = \"CREATE TABLE main(key BLOB PRIMARY KEY, value BLOB)\";\n+                ret = sqlite3_exec(db, create_stmt.c_str(), nullptr, nullptr, nullptr);\n+                if (ret != SQLITE_OK) {\n+                    throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to create new database: %s\\n\", sqlite3_errstr(ret)));\n+                }\n+            }\n+\n+            // Set the application id\n+            uint32_t app_id = ReadBE32(Params().MessageStart());\n+            std::string set_app_id = strprintf(\"PRAGMA application_id = %d\", (int32_t)app_id);\n+            ret = sqlite3_exec(db, set_app_id.c_str(), nullptr, nullptr, nullptr);\n+            if (ret != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to set the application id: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+\n+            // Set the user version\n+            std::string set_user_ver = strprintf(\"PRAGMA user_version = %d\", WALLET_SCHEMA_VERSION);\n+            ret = sqlite3_exec(db, set_user_ver.c_str(), nullptr, nullptr, nullptr);\n+            if (ret != SQLITE_OK) {\n+                throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to set the wallet schema version: %s\\n\", sqlite3_errstr(ret)));\n+            }\n+        }\n+\n+        m_db = db;\n+    }\n+    SetupSQLStatements();\n+}\n+\n+bool SQLiteDatabase::Rewrite(const char* skip)\n+{\n+    while (true) {\n+        if (m_refcount == 0) {\n+            break;\n+        }\n+        UninterruptibleSleep(std::chrono::milliseconds{100});\n+    }\n+\n+    // Rewrite the database using the VACUUM command: https://sqlite.org/lang_vacuum.html\n+    int ret = sqlite3_exec(m_db, \"VACUUM\", nullptr, nullptr, nullptr);\n+    return ret == SQLITE_OK;\n+}\n+\n+bool SQLiteDatabase::PeriodicFlush()\n+{\n+    return true;\n+}\n+\n+bool SQLiteDatabase::Backup(const std::string& dest) const\n+{\n+    sqlite3* db_copy;\n+    int res = sqlite3_open(dest.c_str(), &db_copy);\n+    if (res != SQLITE_OK) {\n+        sqlite3_close(db_copy);\n+        return false;\n+    }\n+    sqlite3_backup* backup = sqlite3_backup_init(db_copy, \"main\", m_db, \"main\");\n+    if (!backup) {\n+        sqlite3_backup_finish(backup);\n+        sqlite3_close(db_copy);\n+        return false;\n+    }\n+    // Copy all of the pages using -1\n+    res = sqlite3_backup_step(backup, -1);\n+    if (res != SQLITE_DONE) {\n+        sqlite3_backup_finish(backup);\n+        sqlite3_close(db_copy);\n+        return false;\n+    }\n+    res = sqlite3_backup_finish(backup);\n+    sqlite3_close(db_copy);\n+    return res == SQLITE_OK;\n+}\n+\n+void SQLiteDatabase::Close()\n+{\n+    if (!m_db) return;\n+\n+    assert(m_refcount == 0);\n+\n+    // Free all of the prepared statements\n+    sqlite3_finalize(m_read_stmt);\n+    sqlite3_finalize(m_insert_stmt);\n+    sqlite3_finalize(m_overwrite_stmt);\n+    sqlite3_finalize(m_delete_stmt);\n+    sqlite3_finalize(m_cursor_stmt);\n+\n+    int res = sqlite3_close(m_db);\n+    if (res != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to close database: %s\\n\", sqlite3_errstr(res)));\n+    }\n+    m_db = nullptr;\n+\n+    UnlockDirectory(m_dir_path, \".walletlock\");\n+}\n+\n+void SQLiteDatabase::Flush() {}\n+\n+void SQLiteDatabase::ReloadDbEnv() {}\n+\n+void SQLiteDatabase::RemoveRef()\n+{\n+    m_refcount--;\n+}\n+\n+void SQLiteDatabase::AddRef()\n+{\n+    m_refcount++;\n+}\n+\n+std::unique_ptr<DatabaseBatch> SQLiteDatabase::MakeBatch(const char* mode, bool flush_on_close)\n+{\n+    // We ignore flush_on_close because we don't do manual flushing for SQLite\n+    return MakeUnique<SQLiteBatch>(*this, mode);\n+}\n+\n+SQLiteBatch::SQLiteBatch(SQLiteDatabase& database, const char* mode)\n+    : m_database(database)\n+{\n+    m_read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+    m_database.AddRef();\n+    m_database.Open(mode);\n+}\n+\n+void SQLiteBatch::Flush() {}\n+\n+void SQLiteBatch::Close()\n+{\n+    if (m_database.m_db && sqlite3_get_autocommit(m_database.m_db) == 0) {\n+        TxnAbort();\n+    }\n+    m_database.RemoveRef();\n+}\n+\n+bool SQLiteBatch::ReadKey(CDataStream&& key, CDataStream& value)\n+{\n+    if (!m_database.m_db) return false;\n+    assert(m_database.m_read_stmt);\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    int res = sqlite3_bind_blob(m_database.m_read_stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(m_database.m_read_stmt);\n+        sqlite3_reset(m_database.m_read_stmt);\n+        return false;\n+    }\n+    res = sqlite3_step(m_database.m_read_stmt);\n+    if (res != SQLITE_ROW) {\n+        sqlite3_clear_bindings(m_database.m_read_stmt);\n+        sqlite3_reset(m_database.m_read_stmt);\n+        return false;\n+    }\n+    // Leftmost column in result is index 0\n+    const char* data = (const char*)sqlite3_column_blob(m_database.m_read_stmt, 0);\n+    int data_size = sqlite3_column_bytes(m_database.m_read_stmt, 0);\n+    value.write(data, data_size);\n+\n+    sqlite3_clear_bindings(m_database.m_read_stmt);\n+    sqlite3_reset(m_database.m_read_stmt);\n+    return true;\n+}\n+\n+bool SQLiteBatch::WriteKey(CDataStream&& key, CDataStream&& value, bool overwrite)\n+{\n+    if (!m_database.m_db) return false;\n+    if (m_read_only) assert(!\"Write called on database in read-only mode\");\n+    assert(m_database.m_insert_stmt && m_database.m_overwrite_stmt);\n+\n+    sqlite3_stmt* stmt;\n+    if (overwrite) {\n+        stmt = m_database.m_overwrite_stmt;\n+    } else {\n+        stmt = m_database.m_insert_stmt;\n+    }\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    // Insert index 1 is key, 2 is value\n+    int res = sqlite3_bind_blob(stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(stmt);\n+        sqlite3_reset(stmt);\n+        return false;\n+    }\n+    res = sqlite3_bind_blob(stmt, 2, value.data(), value.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(stmt);\n+        sqlite3_reset(stmt);\n+        return false;\n+    }\n+\n+    // Execute\n+    res = sqlite3_step(stmt);\n+    sqlite3_clear_bindings(stmt);\n+    sqlite3_reset(stmt);\n+    return res == SQLITE_DONE;\n+}\n+\n+bool SQLiteBatch::EraseKey(CDataStream&& key)\n+{\n+    if (!m_database.m_db) return false;\n+    if (m_read_only) assert(!\"Erase called on database in read-only mode\");\n+    assert(m_database.m_delete_stmt);\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    int res = sqlite3_bind_blob(m_database.m_delete_stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res != SQLITE_OK) {\n+        sqlite3_clear_bindings(m_database.m_delete_stmt);\n+        sqlite3_reset(m_database.m_delete_stmt);\n+        return false;\n+    }\n+\n+    // Execute\n+    res = sqlite3_step(m_database.m_delete_stmt);\n+    sqlite3_clear_bindings(m_database.m_delete_stmt);\n+    sqlite3_reset(m_database.m_delete_stmt);\n+    return res == SQLITE_DONE;\n+}\n+\n+bool SQLiteBatch::HasKey(CDataStream&& key)\n+{\n+    if (!m_database.m_db) return false;\n+    assert(m_database.m_read_stmt);\n+\n+    // Bind: leftmost parameter in statement is index 1\n+    bool ret = false;\n+    int res = sqlite3_bind_blob(m_database.m_read_stmt, 1, key.data(), key.size(), SQLITE_STATIC);\n+    if (res == SQLITE_OK) {\n+        res = sqlite3_step(m_database.m_read_stmt);\n+        if (res == SQLITE_ROW) {\n+            ret = true;\n+        }\n+    }\n+\n+    sqlite3_clear_bindings(m_database.m_read_stmt);\n+    sqlite3_reset(m_database.m_read_stmt);\n+    return ret;\n+}\n+\n+bool SQLiteBatch::StartCursor()\n+{\n+    assert(!m_cursor_init);\n+    if (!m_database.m_db) return false;\n+    m_cursor_init = true;\n+    return true;\n+}\n+\n+bool SQLiteBatch::ReadAtCursor(CDataStream& key, CDataStream& value, bool& complete)\n+{\n+    complete = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492428354",
      "id" : 492428354,
      "in_reply_to_id" : 491651973,
      "line" : 514,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyODM1NA==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 514,
      "original_position" : 505,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 514,
      "pull_request_review_id" : 493076299,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:14:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492428354",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492428410"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492428410"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T01:14:14Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492428410",
      "id" : 492428410,
      "in_reply_to_id" : 491360876,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyODQxMA==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 227,
      "pull_request_review_id" : 493076352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T01:14:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492428410",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492663400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492663400"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> For the most part, yes. Sometimes we do need to handle concurrency withing SQLiteDatabase but those should already be handled by m_refcount and sqlite itself.\r\n\r\nCould you please elaborate on this part? It looks like there are indeed places when we access `WalletDatabase` instance from another thread without acquiring lock first. For example `CWallet::chainStateFlushed`. From my understanding of sqlite it's safe to use by multiple threads, but they should be using different connections. Which is not the case in this example. And I'm not sure how `m_refcount` will help with that.\r\n\r\nI guess in BDB this was handled by `cs_db` within `BerkeleyDatabase::Open`",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T11:35:09Z",
      "diff_hunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_SQLITE_H\n+#define BITCOIN_WALLET_SQLITE_H\n+\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+\n+struct bilingual_str;\n+class SQLiteDatabase;\n+\n+/** RAII class that provides access to a WalletDatabase */\n+class SQLiteBatch : public DatabaseBatch\n+{\n+private:\n+    SQLiteDatabase& m_database;\n+\n+    bool m_read_only = false;\n+    bool m_cursor_init = false;\n+\n+    bool ReadKey(CDataStream&& key, CDataStream& value) override;\n+    bool WriteKey(CDataStream&& key, CDataStream&& value, bool overwrite=true) override;\n+    bool EraseKey(CDataStream&& key) override;\n+    bool HasKey(CDataStream&& key) override;\n+\n+public:\n+    explicit SQLiteBatch(SQLiteDatabase& database, const char* mode);\n+    ~SQLiteBatch() override { Close(); }\n+\n+    void Flush() override;\n+    void Close() override;\n+\n+    bool StartCursor() override;\n+    bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) override;\n+    void CloseCursor() override;\n+    bool TxnBegin() override;\n+    bool TxnCommit() override;\n+    bool TxnAbort() override;\n+};\n+\n+/** An instance of this class represents one SQLite3 database.\n+ **/\n+class SQLiteDatabase : public WalletDatabase\n+{\n+private:\n+    bool m_mock = false;\n+\n+    const std::string m_dir_path;\n+\n+    const std::string m_file_path;\n+\n+    bool PrepareDirectory() const;\n+\n+    void SetupSQLStatements();\n+\n+public:\n+    SQLiteDatabase() = delete;\n+\n+    /** Create DB handle to real database */\n+    SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock=false);\n+\n+    ~SQLiteDatabase();\n+\n+    bool Verify(bilingual_str& error);\n+\n+    /** Open the database if it is not already opened */\n+    void Open(const char* mode) override;\n+\n+    /** Close the database */\n+    void Close() override;\n+\n+    /** Indicate the a new database user has began using the database. Increments m_refcount */\n+    void AddRef() override;\n+    /** Indicate that database user has stopped using the database. Decrement m_refcount */\n+    void RemoveRef() override;\n+\n+    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n+     */\n+    bool Rewrite(const char* skip=nullptr) override;\n+\n+    /** Back up the entire database to a file.\n+     */\n+    bool Backup(const std::string& dest) const override;\n+\n+    /** Make sure all changes are flushed to disk.\n+     */\n+    void Flush() override;\n+    /* flush the wallet passively (TRY_LOCK)\n+       ideal to be called periodically */\n+    bool PeriodicFlush() override;\n+\n+    void IncrementUpdateCounter() override { ++nUpdateCounter; }\n+\n+    void ReloadDbEnv() override;\n+\n+    std::string Filename() override { return m_file_path; };\n+\n+    /** Make a SQLiteBatch connected to this database */\n+    std::unique_ptr<DatabaseBatch> MakeBatch(const char* mode = \"r+\", bool flush_on_close = true) override;\n+\n+    sqlite3* m_db{nullptr};\n+\n+    sqlite3_stmt* m_read_stmt = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492663400",
      "id" : 492663400,
      "in_reply_to_id" : 491332879,
      "line" : 106,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY2MzQwMA==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 106,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 106,
      "pull_request_review_id" : 493367050,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T11:35:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492663400",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492671660"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492671660"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Actually, I couldn't find a single place when we create read-only batch at all. Maybe I'm missing something. Do you know what was the original purpose to add read-only mode?",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T11:51:14Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492671660",
      "id" : 492671660,
      "in_reply_to_id" : 491360876,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY3MTY2MA==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 227,
      "pull_request_review_id" : 493378039,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T11:51:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492671660",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1466284?v=4",
         "events_url" : "https://api.github.com/users/S3RK/events{/privacy}",
         "followers_url" : "https://api.github.com/users/S3RK/followers",
         "following_url" : "https://api.github.com/users/S3RK/following{/other_user}",
         "gists_url" : "https://api.github.com/users/S3RK/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/S3RK",
         "id" : 1466284,
         "login" : "S3RK",
         "node_id" : "MDQ6VXNlcjE0NjYyODQ=",
         "organizations_url" : "https://api.github.com/users/S3RK/orgs",
         "received_events_url" : "https://api.github.com/users/S3RK/received_events",
         "repos_url" : "https://api.github.com/users/S3RK/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/S3RK/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/S3RK/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/S3RK"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492889600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492889600"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's pretty much just a leftover from BDB. The single place a readonly batch is used is in `BerkeleyDatabase::Rewrite`. Maybe we should just remove the readonly stuff, but that could be done in a followup.",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T16:53:14Z",
      "diff_hunk" : "@@ -0,0 +1,606 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/sqlite.h>\n+\n+#include <chainparams.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <util/memory.h>\n+#include <util/strencodings.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+#include <stdint.h>\n+\n+static const char* DATABASE_FILENAME = \"wallet.dat\";\n+\n+static const int32_t WALLET_SCHEMA_VERSION = 0;\n+\n+std::atomic<int> g_dbs_open{0};\n+\n+static void ErrorLogCallback(void* arg, int code, const char* msg)\n+{\n+    assert(arg == nullptr); // That's what we tell it to do during the setup\n+    LogPrintf(\"SQLite Error. Code: %d. Message: %s\\n\", code, msg);\n+}\n+\n+SQLiteDatabase::SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock) :\n+    WalletDatabase(), m_mock(mock), m_dir_path(dir_path.string()), m_file_path(file_path.string())\n+{\n+    LogPrintf(\"Using SQLite Version %s\\n\", SQLiteDatabaseVersion());\n+    LogPrintf(\"Using wallet %s\\n\", m_dir_path);\n+\n+    if (g_dbs_open.fetch_add(1) == 0) {\n+        // Setup logging\n+        int ret = sqlite3_config(SQLITE_CONFIG_LOG, ErrorLogCallback, nullptr);\n+        if (ret != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup error log: %s\\n\", sqlite3_errstr(ret)));\n+        }\n+    }\n+    int ret = sqlite3_initialize(); // This is a no-op if sqlite3 is already initialized\n+    if (ret != SQLITE_OK) {\n+        throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to initialize SQLite: %s\\n\", sqlite3_errstr(ret)));\n+    }\n+}\n+\n+bool SQLiteDatabase::PrepareDirectory() const\n+{\n+    if (m_mock) return true;\n+    // Try to create the directory containing the wallet file and lock it\n+    TryCreateDirectories(m_dir_path);\n+    if (!LockDirectory(m_dir_path, \".walletlock\")) {\n+        LogPrintf(\"Cannot obtain a lock on wallet directory %s. Another instance of bitcoin may be using it.\\n\", m_dir_path);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void SQLiteDatabase::SetupSQLStatements()\n+{\n+    std::string read_sql = \"SELECT value FROM main WHERE key = ?\";\n+    std::string insert_sql = \"INSERT INTO main VALUES(?, ?)\";\n+    std::string overwrite_sql = \"INSERT OR REPLACE INTO main VALUES(?, ?)\";\n+    std::string delete_sql = \"DELETE FROM main WHERE key = ?\";\n+    std::string cursor_sql = \"SELECT key, value FROM main\";\n+\n+    int res;\n+    if (!m_read_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, read_sql.c_str(), -1, &m_read_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_insert_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, insert_sql.c_str(), -1, &m_insert_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_overwrite_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, overwrite_sql.c_str(), -1, &m_overwrite_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_delete_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, delete_sql.c_str(), -1, &m_delete_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements: %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+    if (!m_cursor_stmt) {\n+        if ((res = sqlite3_prepare_v2(m_db, cursor_sql.c_str(), -1, &m_cursor_stmt, nullptr)) != SQLITE_OK) {\n+            throw std::runtime_error(strprintf(\"SQLiteDatabase: Failed to setup SQL statements : %s\\n\", sqlite3_errstr(res)));\n+        }\n+    }\n+}\n+\n+SQLiteDatabase::~SQLiteDatabase()\n+{\n+    Close();\n+    if (g_dbs_open.fetch_sub(1) == 1) {\n+        int ret = sqlite3_shutdown();\n+        if (ret != SQLITE_OK) {\n+            LogPrintf(\"SQLiteDatabase: Failed to shutdown SQLite: %s\\n\", sqlite3_errstr(ret));\n+        }\n+    }\n+}\n+\n+bool SQLiteDatabase::Verify(bilingual_str& error)\n+{\n+    if (!PrepareDirectory()) return false;\n+\n+    sqlite3* db = nullptr;\n+    int ret = sqlite3_open_v2(m_file_path.c_str(), &db, SQLITE_OPEN_READONLY, nullptr);\n+    if (ret == SQLITE_NOTFOUND) {\n+        sqlite3_close(db);\n+        return true; // Return true if the file doesn't exist\n+    } else if (ret != SQLITE_OK) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+\n+    // Check the application ID matches our network magic\n+    sqlite3_stmt* app_id_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA application_id\", -1, &app_id_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(app_id_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(app_id_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch the application id: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    uint32_t app_id = (uint32_t)sqlite3_column_int(app_id_stmt, 0);\n+    sqlite3_finalize(app_id_stmt);\n+    uint32_t net_magic = ReadBE32(Params().MessageStart());\n+    if (app_id != net_magic) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unexpected application id. Expected %u, got %u\"), net_magic, app_id);\n+        return false;\n+    }\n+\n+    // Check our schema version\n+    sqlite3_stmt* user_ver_stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &user_ver_stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to prepare the statement to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    ret = sqlite3_step(user_ver_stmt);\n+    if (ret != SQLITE_ROW) {\n+        sqlite3_finalize(user_ver_stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to fetch sqlite wallet schema version: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    int32_t user_ver = sqlite3_column_int(user_ver_stmt, 0);\n+    sqlite3_finalize(user_ver_stmt);\n+    if (user_ver != WALLET_SCHEMA_VERSION) {\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Unknown sqlite wallet schema version %d. Only version %d is supported\"), user_ver, WALLET_SCHEMA_VERSION);\n+        return false;\n+    }\n+\n+    sqlite3_stmt* stmt;\n+    ret = sqlite3_prepare_v2(db, \"PRAGMA integrity_check\", -1, &stmt, nullptr);\n+    if (ret != SQLITE_OK) {\n+        sqlite3_finalize(stmt);\n+        sqlite3_close(db);\n+        error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+        return false;\n+    }\n+    while (true) {\n+        ret = sqlite3_step(stmt);\n+        if (ret == SQLITE_DONE) {\n+            break;\n+        } else if (ret != SQLITE_ROW) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        const char* msg = (const char*)sqlite3_column_text(stmt, 0);\n+        if (!msg) {\n+            error = strprintf(_(\"SQLiteDatabase: Failed to verify database: %s\"), sqlite3_errstr(ret));\n+            break;\n+        }\n+        std::string str_msg(msg);\n+        if (str_msg == \"ok\") {\n+            continue;\n+        }\n+        error += Untranslated(\"\\n\" + str_msg);\n+    }\n+    sqlite3_finalize(stmt);\n+    sqlite3_close(db);\n+    return error.original.empty();\n+}\n+\n+void SQLiteDatabase::Open(const char* mode)\n+{\n+    if (!PrepareDirectory()) {\n+        throw std::runtime_error(\"Cannot obtain a lock on wallet directory\");\n+    }\n+\n+    bool read_only = (!strchr(mode, '+') && !strchr(mode, 'w'));\n+\n+    bool create = strchr(mode, 'c') != nullptr;\n+    int flags;\n+    if (read_only) {\n+        flags = SQLITE_OPEN_READONLY;\n+    } else {\n+        flags = SQLITE_OPEN_READWRITE;\n+    }\n+    if (create) {\n+        flags |= SQLITE_OPEN_CREATE;\n+    }\n+    if (m_mock) {\n+        flags |= SQLITE_OPEN_MEMORY; // In memory database for mock db\n+    }\n+\n+    if (m_db == nullptr) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492889600",
      "id" : 492889600,
      "in_reply_to_id" : 491360876,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg4OTYwMA==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 227,
      "original_position" : 227,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.cpp",
      "position" : 227,
      "pull_request_review_id" : 493663647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T16:53:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492889600",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492892531"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492892531"
         }
      },
      "author_association" : "MEMBER",
      "body" : "According to https://sqlite.org/threadsafe.html, the default multithreading mode is serialized which means that a single database connection can be used from multiple threads safely. So no locking is needed with that.\r\n\r\nI suppose we should enforce that when opening by setting `SQLITE_OPEN_FULLMUTEX`?",
      "commit_id" : "dbb91176356c18a8ffb73ddd4475f96357d83234",
      "created_at" : "2020-09-22T16:57:47Z",
      "diff_hunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_SQLITE_H\n+#define BITCOIN_WALLET_SQLITE_H\n+\n+#include <wallet/db.h>\n+\n+#include <sqlite3.h>\n+\n+struct bilingual_str;\n+class SQLiteDatabase;\n+\n+/** RAII class that provides access to a WalletDatabase */\n+class SQLiteBatch : public DatabaseBatch\n+{\n+private:\n+    SQLiteDatabase& m_database;\n+\n+    bool m_read_only = false;\n+    bool m_cursor_init = false;\n+\n+    bool ReadKey(CDataStream&& key, CDataStream& value) override;\n+    bool WriteKey(CDataStream&& key, CDataStream&& value, bool overwrite=true) override;\n+    bool EraseKey(CDataStream&& key) override;\n+    bool HasKey(CDataStream&& key) override;\n+\n+public:\n+    explicit SQLiteBatch(SQLiteDatabase& database, const char* mode);\n+    ~SQLiteBatch() override { Close(); }\n+\n+    void Flush() override;\n+    void Close() override;\n+\n+    bool StartCursor() override;\n+    bool ReadAtCursor(CDataStream& ssKey, CDataStream& ssValue, bool& complete) override;\n+    void CloseCursor() override;\n+    bool TxnBegin() override;\n+    bool TxnCommit() override;\n+    bool TxnAbort() override;\n+};\n+\n+/** An instance of this class represents one SQLite3 database.\n+ **/\n+class SQLiteDatabase : public WalletDatabase\n+{\n+private:\n+    bool m_mock = false;\n+\n+    const std::string m_dir_path;\n+\n+    const std::string m_file_path;\n+\n+    bool PrepareDirectory() const;\n+\n+    void SetupSQLStatements();\n+\n+public:\n+    SQLiteDatabase() = delete;\n+\n+    /** Create DB handle to real database */\n+    SQLiteDatabase(const fs::path& dir_path, const fs::path& file_path, bool mock=false);\n+\n+    ~SQLiteDatabase();\n+\n+    bool Verify(bilingual_str& error);\n+\n+    /** Open the database if it is not already opened */\n+    void Open(const char* mode) override;\n+\n+    /** Close the database */\n+    void Close() override;\n+\n+    /** Indicate the a new database user has began using the database. Increments m_refcount */\n+    void AddRef() override;\n+    /** Indicate that database user has stopped using the database. Decrement m_refcount */\n+    void RemoveRef() override;\n+\n+    /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n+     */\n+    bool Rewrite(const char* skip=nullptr) override;\n+\n+    /** Back up the entire database to a file.\n+     */\n+    bool Backup(const std::string& dest) const override;\n+\n+    /** Make sure all changes are flushed to disk.\n+     */\n+    void Flush() override;\n+    /* flush the wallet passively (TRY_LOCK)\n+       ideal to be called periodically */\n+    bool PeriodicFlush() override;\n+\n+    void IncrementUpdateCounter() override { ++nUpdateCounter; }\n+\n+    void ReloadDbEnv() override;\n+\n+    std::string Filename() override { return m_file_path; };\n+\n+    /** Make a SQLiteBatch connected to this database */\n+    std::unique_ptr<DatabaseBatch> MakeBatch(const char* mode = \"r+\", bool flush_on_close = true) override;\n+\n+    sqlite3* m_db{nullptr};\n+\n+    sqlite3_stmt* m_read_stmt = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19077#discussion_r492892531",
      "id" : 492892531,
      "in_reply_to_id" : 491332879,
      "line" : 106,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5MjUzMQ==",
      "original_commit_id" : "69f7321f8d3e8cd8b3901dee8b08b948dabe5465",
      "original_line" : 106,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/wallet/sqlite.h",
      "position" : 106,
      "pull_request_review_id" : 493667274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19077",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-22T16:59:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492892531",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
