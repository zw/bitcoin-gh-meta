[
   {
      "body" : "I like the concept of being able to listen for events through http, however I think this is severely limited by having server-side state, limiting the number of listeners to only one.\r\n\r\nWhat I'd personally prefer is, instead of longpolling, to subscribe to a 'stream' of events (e.g. websocket or just chunked encoding), where the set of events to listen to is in the request. This avoids having to store any client-state in the server - at least for longer than the request lasts.",
      "created_at" : "2016-04-26T15:40:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-214786965",
      "id" : 214786965,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2016-04-26T15:41:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214786965",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : ">[... ] having server-side state, limiting the number of listeners to only one\r\n\r\nRight. The current implementation limits to only one listener. Extending this PR so it would support a client chosen UUID would not be very complicated (a set of queues and a set of registered notification types). Clients could register notification types along with a client-chosen UUID.\r\nI might extend this PR to support multiple listeners.",
      "created_at" : "2016-04-26T15:45:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-214789068",
      "id" : 214789068,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2016-04-26T15:45:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214789068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Added a commit that allows multiple clients at the same time.\r\n\r\nThe new RPC commands require now a `clientUUID` parameter (a per client unique string, ideally a UUID after RFC 4122). Bitcoind keeps a queue, sequence numbers and registered types per client.\r\n\r\nThere is currently not max client limit and no way to remove clients (though you can unregister all notification types but not empty the current queue).",
      "created_at" : "2016-04-26T17:45:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-214824842",
      "id" : 214824842,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2016-04-29T11:33:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214824842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased.\r\nWould be nice to get some concept NACKs/ACKs.",
      "created_at" : "2016-05-06T09:53:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-217400507",
      "id" : 217400507,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2016-05-06T09:53:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/217400507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r62311355"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62311355"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: python3\n",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2016-05-06T10:10:47Z",
      "diff_hunk" : "@@ -0,0 +1,64 @@\n+#!/usr/bin/env python2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r62311355",
      "id" : 62311355,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzExMzU1",
      "original_commit_id" : "90b28e41a45ec96a0a11b6f30249438b47762541",
      "original_position" : 1,
      "path" : "qa/rpc-tests/rpcsignals.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-10-23T01:32:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62311355",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r62313033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62313033"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.\n",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2016-05-06T10:29:06Z",
      "diff_hunk" : "@@ -0,0 +1,64 @@\n+#!/usr/bin/env python2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r62313033",
      "id" : 62313033,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzEzMDMz",
      "original_commit_id" : "90b28e41a45ec96a0a11b6f30249438b47762541",
      "original_position" : 1,
      "path" : "qa/rpc-tests/rpcsignals.py",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-10-23T01:32:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62313033",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased.",
      "created_at" : "2016-05-12T10:54:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-218724368",
      "id" : 218724368,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2016-05-12T10:54:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/218724368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Gah we need to take a look at this again after 0.14 is released.",
      "created_at" : "2017-01-11T13:09:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-271864278",
      "id" : 271864278,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2017-01-11T13:09:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271864278",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Yes. Sure. I'll try to re-base and overhaul this soon.",
      "created_at" : "2017-01-11T13:27:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-271867853",
      "id" : 271867853,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2017-01-11T13:27:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/271867853",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Plan on rebasing this, or should just be closed?",
      "created_at" : "2017-09-28T16:47:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-332896020",
      "id" : 332896020,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2017-09-28T16:47:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/332896020",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm currently rewriting this... will be ready soon.",
      "created_at" : "2017-09-28T16:57:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-332898896",
      "id" : 332898896,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2017-09-28T16:57:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/332898896",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Overhauled and rebased.\r\n\r\nThis is still server based (server keeps track of what the client has) queue max size is currently 1024^2 and does only contain hashes of blocks or transactions.\r\nEach notification comes with a sequence number to detect lost transactions (which then should trigger a \"full-client-sync\").",
      "created_at" : "2017-10-20T06:02:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-338113926",
      "id" : 338113926,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2017-10-20T06:02:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/338113926",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149155028"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149155028"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ugh, can we not use more BOOST_FOREACH garbage? Should be really easy to rewrite this without, no?",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T17:59:29Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;\n+\n+    NotificationQueue* getQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    NotificationQueue* addQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        m_map_sequence_numbers[clientid] = new NotificationQueue();\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    void NotifyTransaction(const CTransactionRef& ptx)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        for (auto& queueEntry : m_map_sequence_numbers) {\n+            if (!queueEntry.second->isTypeRegistered(NotificationType::Tx)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Tx;\n+            entry.m_notification.setStr(ptx->GetHash().GetHex());\n+            queueEntry.second->addToQueue(entry);\n+        }\n+    }\n+\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction added in the block\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction removed in block disconnection\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockIndex* pindexFork, bool fInitialDownload) override\n+    {\n+        LOCK(m_cs_queue_manager);\n+        BOOST_FOREACH (NotificationQueue* queue, m_map_sequence_numbers | boost::adaptors::map_values) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149155028",
      "id" : 149155028,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE1NTAyOA==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 218,
      "path" : "src/rpc/notifications.cpp",
      "position" : 218,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149155028",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149155354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149155354"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I dont think this is the notification we want  here - dont we want to use BlockConnected/Disconnected to notify clients of all connected blocks, not just new tips after reorgs which potentially connect multiple blocks?",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T18:00:45Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;\n+\n+    NotificationQueue* getQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    NotificationQueue* addQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        m_map_sequence_numbers[clientid] = new NotificationQueue();\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    void NotifyTransaction(const CTransactionRef& ptx)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        for (auto& queueEntry : m_map_sequence_numbers) {\n+            if (!queueEntry.second->isTypeRegistered(NotificationType::Tx)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Tx;\n+            entry.m_notification.setStr(ptx->GetHash().GetHex());\n+            queueEntry.second->addToQueue(entry);\n+        }\n+    }\n+\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction added in the block\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction removed in block disconnection\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockIndex* pindexFork, bool fInitialDownload) override",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149155354",
      "id" : 149155354,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE1NTM1NA==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 215,
      "path" : "src/rpc/notifications.cpp",
      "position" : 215,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149155354",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149155844"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149155844"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I generally prefer 64 bit ints here - sure, its unlikely you'd overflow 32 bits, but if you're online for 3 or 4 years you may start getting closeish.",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T18:02:48Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149155844",
      "id" : 149155844,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE1NTg0NA==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 55,
      "path" : "src/rpc/notifications.cpp",
      "position" : 55,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149155844",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149158599"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149158599"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'd be somwhat worried we'd fill someone's drive with debug log entries in case they forget to deregister a listener, here.",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T18:15:14Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149158599",
      "id" : 149158599,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE1ODU5OQ==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 152,
      "path" : "src/rpc/notifications.cpp",
      "position" : 152,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149158599",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149162289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149162289"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It'd be great if we could de-duplicate the queues here - no need to have a queue per client, just have a global queue and keep track of how far delayed all the clients are in terms of the sequence number and just clean things up to the furthest-back client.",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T18:29:11Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149162289",
      "id" : 149162289,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE2MjI4OQ==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 171,
      "path" : "src/rpc/notifications.cpp",
      "position" : 171,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149162289",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149163276"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149163276"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Also, please use unique_ptr here instead of manual management and maybe remove the queue when there are no registered types (and, I suppose, the client is caught up) instead of keeping around a null queue.",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T18:33:06Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149163276",
      "id" : 149163276,
      "in_reply_to_id" : 149162289,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE2MzI3Ng==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 171,
      "path" : "src/rpc/notifications.cpp",
      "position" : 171,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149163276",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149163720"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149163720"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should probably use a CV and a way for Interrupt to interrupt it instead of calling ShutdownRequested in a 500ms loop.",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2017-11-06T18:34:53Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;\n+\n+    NotificationQueue* getQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    NotificationQueue* addQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        m_map_sequence_numbers[clientid] = new NotificationQueue();\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    void NotifyTransaction(const CTransactionRef& ptx)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        for (auto& queueEntry : m_map_sequence_numbers) {\n+            if (!queueEntry.second->isTypeRegistered(NotificationType::Tx)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Tx;\n+            entry.m_notification.setStr(ptx->GetHash().GetHex());\n+            queueEntry.second->addToQueue(entry);\n+        }\n+    }\n+\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction added in the block\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction removed in block disconnection\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockIndex* pindexFork, bool fInitialDownload) override\n+    {\n+        LOCK(m_cs_queue_manager);\n+        BOOST_FOREACH (NotificationQueue* queue, m_map_sequence_numbers | boost::adaptors::map_values) {\n+            if (!queue->isTypeRegistered(NotificationType::Block)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Block;\n+            entry.m_notification.setStr(pindexNew->GetBlockHash().GetHex());\n+            queue->addToQueue(entry);\n+        }\n+    }\n+\n+    void TransactionAddedToMempool(const CTransactionRef& ptx) override\n+    {\n+        NotifyTransaction(ptx);\n+    }\n+};\n+\n+CCriticalSection cs_queueManagerSharedInstance;\n+static NotificationQueueManager* queueManagerSharedInstance = NULL;\n+\n+NotificationQueue* getQueue(const std::string& clientID, bool createIfNotExists)\n+{\n+    LOCK(cs_queueManagerSharedInstance);\n+    NotificationQueue* clientQueue = queueManagerSharedInstance->getQueue(clientID);\n+    if (!clientQueue && !createIfNotExists)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Client UUID not found.\");\n+    if (!clientQueue)\n+        clientQueue = queueManagerSharedInstance->addQueue(clientID);\n+    return clientQueue;\n+}\n+\n+UniValue setregisterednotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 2)\n+        throw std::runtime_error(\n+            \"setregisterednotifications <uuid> [<type>, <type>, ...]\\n\"\n+            \"Register for rpc notification(s).\\n\"\n+            \"Notifications can be polled by calling pollnotifications.\"\n+            \"The client UUID must be unique per client application and will define the used queue.\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"2. \\\"type\\\"         (string, required) The notification type to register for (\\\"hashblock\\\", \\\"hashtx\\\")\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nRegister for block and transaction notifications\\n\" +\n+            HelpExampleCli(\"setregisterednotifications\", \"\\\"[\\\"hashblock\\\", \\\"hashtx\\\"]\\\" \\\"\") +\n+            \"register for transaction and block signals\\n\");\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VARR), true);\n+\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), true);\n+\n+    /* remove all current registered types */\n+    clientQueue->unregisterAllTypes();\n+\n+    UniValue types = request.params[1].get_array();\n+    BOOST_FOREACH (const UniValue& newType, types.getValues()) {\n+        if (!newType.isStr())\n+            continue;\n+\n+        NotificationType type = clientQueue->stringToType(newType.get_str());\n+        if (type == NotificationType::Unknown) {\n+            /* don't register only for a subset of the requested notifications */\n+            clientQueue->unregisterAllTypes();\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Notification type not found\");\n+        }\n+\n+        clientQueue->registerType(type);\n+    }\n+\n+    return NullUniValue;\n+}\n+\n+UniValue getregisterednotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"getregisterednotifications <uuid>\\n\"\n+            \"\\nReturns the currently registered RPC notification types for the given uuid.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"[\\\"\\n\"\n+            \"\\\"  \\\"<signal>\\\"             (string) The registered signal\\n\"\n+            \"\\\"  ,...\\n\"\n+            \"\\\"]\\\"\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate a transaction\\n\" +\n+            HelpExampleCli(\"getregisterednotifications\", \"\") +\n+            \"Get the registered notification types\\n\" + HelpExampleRpc(\"getregisterednotifications\", \"\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR), true);\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), false);\n+\n+    UniValue result = UniValue(UniValue::VARR);\n+    BOOST_FOREACH (NotificationType type, clientQueue->m_registered_notification_types)\n+        result.push_back(clientQueue->typeToString(type));\n+\n+    return result;\n+}\n+\n+UniValue pollnotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"pollnotifications <uuid> <timeout>\\n\"\n+            \"\\nLong poll function to get all available notifications for a given uuid (see setregisterednotifications for how to register for notifications).\\n\"\n+            \"The RPC thread will idle for the via <timeout> defined amount of seconds and/or will immediately response if new notifications are available\\n\"\n+            \"Arguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"2. \\\"timeout\\\"      (numeric, optional) The timeout \\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"[ notification, ... ]\\\"             (object) The notification object\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nPoll notifications for client a8098c1a...\\n\" +\n+            HelpExampleCli(\"pollnotifications\", \"\\\"a8098c1a-f86e-11da-bd1a-00112444be1e\\\" 500\") +\n+            \"Long poll notification (max. 500 seconds)\\n\" + HelpExampleRpc(\"pollnotifications\", \"\\\"a8098c1a-f86e-11da-bd1a-00112444be1e\\\" 500\"));\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM), false);\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), false);\n+\n+    int64_t timeOut = DEFAULT_POLL_TIMEOUT;\n+    if (request.params.size() == 2)\n+        timeOut = request.params[1].get_int64();\n+\n+    int64_t startTime = GetTime();\n+\n+    UniValue result = UniValue(UniValue::VARR);\n+    // allow long polling\n+    while (!ShutdownRequested()) {\n+        if (clientQueue->elementsAvailable()) {\n+            clientQueue->dequeueElements(result);\n+            break;\n+        }\n+        if (startTime + timeOut + (500 / 1000.0) < GetTime())\n+            break;\n+        MilliSleep(500);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r149163720",
      "id" : 149163720,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0OTE2MzcyMA==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 352,
      "path" : "src/rpc/notifications.cpp",
      "position" : 352,
      "pull_request_review_id" : 74505301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2017-11-06T18:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/149163720",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Also, looks like the test is failing.",
      "created_at" : "2017-11-06T18:51:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-342247619",
      "id" : 342247619,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2017-11-06T18:51:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/342247619",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Strong Concept ACK for this one ! \r\n@jonasschnelli any idea if you will bring this one from the dead?",
      "created_at" : "2018-01-10T16:10:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-356650229",
      "id" : 356650229,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2018-01-10T16:10:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356650229",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/3020646?v=4",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@NicolasDorier \r\nI think there is no consensus about an additional push channel... also, @sipa brought up the idea of having a push channel (could be long poll) that acts similar then `listsinceblock` where the server doesn't need to keep track of clients (keep a queue).\r\nI haven't looked closer at this approach.",
      "created_at" : "2018-01-10T18:50:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-356699212",
      "id" : 356699212,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2018-01-10T18:50:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356699212",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I implemented a similar solution in NBXplorer. Basically there is a `GetUTXOs(xPub)` call, this call replay all the transactions of the xpub in topological order to create the current utxo for this xpub. While playing the transactions, it hashes them along the way (the hash after each transaction is effectively the equivalent of a `bookmark`). Then the bookmark + the UTXO is sent back to the client.\r\n\r\nThe client process the result, then call again `GetUTXOs(xPub, bookmark)`. The server does the same operation, replaying all transactions while calculating bookmarks along the way, when it reaches the bookmark passed by the client, it knows that what is after is a differential to the previous bookmark. If there is no differential, it just long poll. If there is a differential, it sends it back to the client.\r\n\r\nIf the bookmark in parameter was not reached, then the full UTXO is sent back again to the client, with a flag indicating it is not a differential.\r\n\r\nThis solution does not involve server side state.",
      "created_at" : "2018-01-14T19:15:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#issuecomment-357534439",
      "id" : 357534439,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7949",
      "updated_at" : "2018-01-14T19:18:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357534439",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/3020646?v=4",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r214549319"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549319"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: becase",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2018-09-02T18:37:16Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r214549319",
      "id" : 214549319,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTMxOQ==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 28,
      "path" : "src/rpc/notifications.cpp",
      "position" : 28,
      "pull_request_review_id" : 151629370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2018-09-02T18:37:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549319",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r214549340"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549340"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: successfull",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2018-09-02T18:37:40Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r214549340",
      "id" : 214549340,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTM0MA==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 86,
      "path" : "src/rpc/notifications.cpp",
      "position" : 86,
      "pull_request_review_id" : 151629390,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2018-09-02T18:37:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549340",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r231934058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231934058"
         }
      },
      "author_association" : "MEMBER",
      "body" : " ",
      "commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "created_at" : "2018-11-08T15:28:28Z",
      "diff_hunk" : "@@ -0,0 +1,381 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"init.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"rpc/server.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+#include \"validationinterface.h\"\n+\n+#include <univalue.h>\n+\n+#include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/range/adaptors.hpp>\n+\n+#include <deque>\n+#include <exception>\n+#include <stdint.h>\n+\n+static const char* MSG_HASHBLOCK = \"hashblock\";\n+static const char* MSG_HASHTX = \"hashtx\";\n+\n+/* keep the max queue size large becase we don't\n+   auto-register for notification on startup */\n+static const size_t MAX_QUEUE_SIZE = 1024 * 1024;\n+static const int DEFAULT_POLL_TIMEOUT = 30;\n+\n+enum class NotificationType {\n+    Unknown,\n+    Block,\n+    Tx\n+};\n+\n+typedef std::pair<size_t, size_t> queueRange_t;\n+typedef std::string clientUUID_t;\n+\n+// class that represents a notification\n+class NotificationEntry\n+{\n+public:\n+    NotificationType m_type;\n+    int32_t m_sequence_number;\n+    UniValue m_notification;\n+};\n+\n+class NotificationQueue\n+{\n+public:\n+    std::deque<NotificationEntry> m_queue;\n+    std::map<NotificationType, int32_t> m_map_sequence_numbers;\n+    std::set<NotificationType> m_registered_notification_types;\n+\n+    CCriticalSection m_cs_notification_queue;\n+\n+    const std::string typeToString(NotificationType type) const\n+    {\n+        switch (type) {\n+        case NotificationType::Block:\n+            return MSG_HASHBLOCK;\n+            break;\n+        case NotificationType::Tx:\n+            return MSG_HASHTX;\n+            break;\n+        default:\n+            return \"unknown\";\n+        }\n+    }\n+\n+    NotificationType stringToType(const std::string& strType) const\n+    {\n+        if (strType == MSG_HASHBLOCK)\n+            return NotificationType::Block;\n+        else if (strType == MSG_HASHTX)\n+            return NotificationType::Tx;\n+        else\n+            return NotificationType::Unknown;\n+    }\n+\n+    // populates a json object with all notifications in the queue\n+    // returns a range to allow removing the elements from the queue\n+    // after successfull transmitting\n+    queueRange_t weakDequeueNotifications(UniValue& result)\n+    {\n+        size_t firstElement = 0;\n+        size_t elementCount = 0;\n+\n+        LOCK(m_cs_notification_queue);\n+        for (const NotificationEntry& entry : m_queue) {\n+            UniValue obj = UniValue(UniValue::VOBJ);\n+            obj.pushKV(\"type\", typeToString(entry.m_type));\n+            obj.pushKV(\"seq\", entry.m_sequence_number);\n+            obj.pushKV(\"obj\", entry.m_notification);\n+            result.push_back(obj);\n+            elementCount++;\n+        }\n+        return std::make_pair(firstElement, elementCount);\n+    }\n+\n+    // removes notifications in the given range from the queue\n+    void eraseRangeFromQueue(const queueRange_t range)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_queue.erase(m_queue.begin() + range.first, m_queue.begin() + range.first + range.second);\n+    }\n+\n+    // dequeues all notifications from the queue\n+    void dequeueElements(UniValue& result)\n+    {\n+        queueRange_t range = weakDequeueNotifications(result);\n+        eraseRangeFromQueue(range);\n+    }\n+\n+    bool elementsAvailable()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return m_queue.size() > 0;\n+    }\n+\n+    void registerType(NotificationType type)\n+    {\n+        if (type == NotificationType::Unknown)\n+            return;\n+\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.insert(type);\n+    }\n+\n+    void unregisterType(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.erase(type);\n+    }\n+\n+    void unregisterAllTypes()\n+    {\n+        LOCK(m_cs_notification_queue);\n+        m_registered_notification_types.clear();\n+    }\n+\n+    void addToQueue(NotificationEntry entry)\n+    {\n+        LOCK(m_cs_notification_queue);\n+\n+        size_t queueSize = m_queue.size();\n+        if (queueSize > MAX_QUEUE_SIZE) {\n+            m_queue.pop_front();\n+            LogPrintf(\"RPC Notification limit has been reached, dropping oldest element\\n\");\n+        }\n+        m_map_sequence_numbers[entry.m_type]++;\n+        entry.m_sequence_number = m_map_sequence_numbers[entry.m_type];\n+        m_queue.push_back(entry);\n+    }\n+\n+    /* checks if a certain notification type is registered */\n+    bool isTypeRegistered(NotificationType type)\n+    {\n+        LOCK(m_cs_notification_queue);\n+        return (m_registered_notification_types.find(type) != m_registered_notification_types.end());\n+    }\n+};\n+\n+class NotificationQueueManager : public CValidationInterface\n+{\n+public:\n+    CCriticalSection m_cs_queue_manager;\n+    std::map<clientUUID_t, NotificationQueue*> m_map_sequence_numbers;\n+\n+    NotificationQueue* getQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    NotificationQueue* addQueue(const clientUUID_t& clientid)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        m_map_sequence_numbers[clientid] = new NotificationQueue();\n+        return m_map_sequence_numbers[clientid];\n+    }\n+\n+    void NotifyTransaction(const CTransactionRef& ptx)\n+    {\n+        LOCK(m_cs_queue_manager);\n+        for (auto& queueEntry : m_map_sequence_numbers) {\n+            if (!queueEntry.second->isTypeRegistered(NotificationType::Tx)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Tx;\n+            entry.m_notification.setStr(ptx->GetHash().GetHex());\n+            queueEntry.second->addToQueue(entry);\n+        }\n+    }\n+\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction added in the block\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override\n+    {\n+        for (const CTransactionRef& ptx : pblock->vtx) {\n+            // Do a normal notify for each transaction removed in block disconnection\n+            NotifyTransaction(ptx);\n+        }\n+    }\n+\n+    void UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockIndex* pindexFork, bool fInitialDownload) override\n+    {\n+        LOCK(m_cs_queue_manager);\n+        BOOST_FOREACH (NotificationQueue* queue, m_map_sequence_numbers | boost::adaptors::map_values) {\n+            if (!queue->isTypeRegistered(NotificationType::Block)) continue;\n+\n+            NotificationEntry entry;\n+            entry.m_type = NotificationType::Block;\n+            entry.m_notification.setStr(pindexNew->GetBlockHash().GetHex());\n+            queue->addToQueue(entry);\n+        }\n+    }\n+\n+    void TransactionAddedToMempool(const CTransactionRef& ptx) override\n+    {\n+        NotifyTransaction(ptx);\n+    }\n+};\n+\n+CCriticalSection cs_queueManagerSharedInstance;\n+static NotificationQueueManager* queueManagerSharedInstance = NULL;\n+\n+NotificationQueue* getQueue(const std::string& clientID, bool createIfNotExists)\n+{\n+    LOCK(cs_queueManagerSharedInstance);\n+    NotificationQueue* clientQueue = queueManagerSharedInstance->getQueue(clientID);\n+    if (!clientQueue && !createIfNotExists)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Client UUID not found.\");\n+    if (!clientQueue)\n+        clientQueue = queueManagerSharedInstance->addQueue(clientID);\n+    return clientQueue;\n+}\n+\n+UniValue setregisterednotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 2)\n+        throw std::runtime_error(\n+            \"setregisterednotifications <uuid> [<type>, <type>, ...]\\n\"\n+            \"Register for rpc notification(s).\\n\"\n+            \"Notifications can be polled by calling pollnotifications.\"\n+            \"The client UUID must be unique per client application and will define the used queue.\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"2. \\\"type\\\"         (string, required) The notification type to register for (\\\"hashblock\\\", \\\"hashtx\\\")\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nRegister for block and transaction notifications\\n\" +\n+            HelpExampleCli(\"setregisterednotifications\", \"\\\"[\\\"hashblock\\\", \\\"hashtx\\\"]\\\" \\\"\") +\n+            \"register for transaction and block signals\\n\");\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VARR), true);\n+\n+    NotificationQueue* clientQueue = getQueue(request.params[0].get_str(), true);\n+\n+    /* remove all current registered types */\n+    clientQueue->unregisterAllTypes();\n+\n+    UniValue types = request.params[1].get_array();\n+    BOOST_FOREACH (const UniValue& newType, types.getValues()) {\n+        if (!newType.isStr())\n+            continue;\n+\n+        NotificationType type = clientQueue->stringToType(newType.get_str());\n+        if (type == NotificationType::Unknown) {\n+            /* don't register only for a subset of the requested notifications */\n+            clientQueue->unregisterAllTypes();\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Notification type not found\");\n+        }\n+\n+        clientQueue->registerType(type);\n+    }\n+\n+    return NullUniValue;\n+}\n+\n+UniValue getregisterednotifications(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"getregisterednotifications <uuid>\\n\"\n+            \"\\nReturns the currently registered RPC notification types for the given uuid.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"uuid\\\"         (string, required) The client uuid\\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"[\\\"\\n\"\n+            \"\\\"  \\\"<signal>\\\"             (string) The registered signal\\n\"\n+            \"\\\"  ,...\\n\"\n+            \"\\\"]\\\"\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate a transaction\\n\" +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7949#discussion_r231934058",
      "id" : 231934058,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTkzNDA1OA==",
      "original_commit_id" : "2652c55b7a8a65bbdb8ad7c09dcb09870aa913f3",
      "original_position" : 303,
      "path" : "src/rpc/notifications.cpp",
      "position" : 303,
      "pull_request_review_id" : 173015132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7949",
      "updated_at" : "2018-11-30T14:51:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231934058",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   }
]
