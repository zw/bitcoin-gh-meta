[
   {
      "body" : "Since github shows the commits sorted by author date rather than dependency order, here is a list of all commits:\r\n* preparation (https://github.com/sipa/bitcoin/compare/fb0ac482eee761ec17ed2c11df11e054347a026d...e69265d)\r\n  * 644b2c5 Keep addrman's nService bits consistent with outbound observations\r\n  * afdc413 Verify that outbound connections have expected services\r\n  * fdec2bc Only store and connect to NODE_NETWORK nodes\r\n* segnet (https://github.com/sipa/bitcoin/compare/e69265d...bb4bb47)\r\n  * 66dbd81 Don't check the genesis block PoW\r\n  * 70ebe86 Create segnet4\r\n  * f8bcd86 Add segnet seed nodes\r\n  * 58847fe qt: Work (don't crash) with -segnet\r\n* P2P/node/consensus (https://github.com/sipa/bitcoin/compare/bb4bb47...351a2fe)\r\n  * 3b1ff49 Add segregated witness transaction serialization\r\n  * e35d020 Removed ppszTypeName from protocol.cpp\r\n  * adb1c09 getdata enum issue fix\r\n  * ac6886d Introduce and preferentially peer with NODE_WITNESS service bit\r\n  * cb9d4d3 Witness commitment validation\r\n  * 2c87be1 Script validation logic for witnesses\r\n  * 1e47805 Enable SCRIPT_VERIFY_WITNESS for mempool transactions\r\n  * 97f34f7 Activate script consensus rules through BIP9\r\n  * 6a8021f Only download blocks from witness peers after fork\r\n  * 271e45e Observe input amounts: verification\r\n  * d374139 Add signature version 1 with updated sighash\r\n  * 92c6dc3 Return witness data\r\n  * 3955218 Implement block size/sigop cost rules, limits, and GBT support\r\n  * 5a47b98 Add command line options to loosen mempool acceptance rules\r\n  * e573571 bitcoinconsensus: add method that accepts amount, and return error when verify_script receives VERIFY_WITNESS flag\r\n  * a6386c2 Increase MAX_PROTOCOL_MESSAGE_LENGTH\r\n  * 1b6c6f1 Add rewind logic to deal with post-fork software updates\r\n* wallet (https://github.com/sipa/bitcoin/compare/351a2fe...a2d6f8a)\r\n  * abbe085 Witness script signing\r\n  * c3fe53f Add witness address RPCs (using P2SH)\r\n  * ec385fa signrawtransaction can sign P2WSH\r\n* tests (https://github.com/sipa/bitcoin/compare/a2d6f8a...cfb0a83)\r\n  * 2ed1d11 Signing tests\r\n  * 3c0b16f Add rpc test for segwit\r\n  * 24746d2 Add transaction tests for segwit\r\n  * 3409ad6 Add segwit support to script_tests\r\n  * e5ffcc1 Autogeneration support for witness in script_tests\r\n  * 5e6abe5 Update p2p test framework with segwit support\r\n  * 7b539f9 P2P test for segwit\r\n* fixups (https://github.com/sipa/bitcoin/compare/cfb0a83...77c613c)\r\n  * bb2bfca fixup Implement block size/sigop cost rules, limits, and GBT support: use int64_t for sigopcost everywhere\r\n  * 64c1527 fixup Implement block size/sigop cost rules, limits, and GBT support: update block cost comment\r\n  * cc741f5 fixup Add segregated witness transaction serialization: comments\r\n  * c28179f fixup Update p2p test framework with segwit support: fix comment\r\n  * 6a5da9b fixup Witness commitment validation: list the mentioned BIPs\r\n  * 88e0135 fixup Add command line options to loosen mempool acceptance rules: simplify comment\r\n  * da60fae fixup Witness commitment validation: factor out GetWitnessCommitmentPos\r\n  * 4f827be fixup Witness commitment validation: fix typo in comment\r\n  * 058f495 fixup Implement block size/sigop cost rules, limits, and GBT support: improve GBT help\r\n  * c1e7a95 fixup Add witness address RPCs (using P2SH): test hex & wallet available\r\n  * dbe6391 fixup Add segregated witness transaction serialization: revert extformat-if-empty-vin\r\n  * 97d7402 tidy up CInv::GetCommand\r\n  * f0f6123 fixup Witness commitment validation: function UpdateUncommitedBlockStructures redefine\r\n  * a613599 [qa] Use integer division, byte strings properly\r\n  * 5d6b6e2 fixup Add segregated witness transaction serialization: add missing witness flags\r\n* fixups 2 (https://github.com/sipa/bitcoin/compare/77c613c...f38671f)\r\n  * f889bec fixup Add segregated witness transaction serialization: add negative flag\r\n  * 3ddabe4 fixup Add segregated witness transaction serialization: test with no inputs no longer possible\r\n  * c744a1e fixup Add segregated witness transaction serialization: deal with overwrite and inconsistencies\r\n  * 4709595 fixup Witness commitment validation: revert adding of commitment in IncrementExtraNonce\r\n  * 122ca81 fixup Witness commitment validation: correct comment\r\n  * 5df3e51 fixup Witness commitment validation: add comment about witness checking in miner\r\n  * 36e1656 fixup Witness commitment validation: better validation error message\r\n  * f726402 fixup Implement block size/sigop cost rules, limits, and GBT support: update comment\r\n  * cf2c531 fixup Enable SCRIPT_VERIFY_WITNESS for mempool transactions: do not reject/punish invalid witness orphans\r\n  * 0fb6e4e fixup Return witness data: don't list nextblockhash twice\r\n  * ccd0e6c [qa] mininode: Use hexlify wrapper from util\r\n  * 3a62cb9 Implement RecursiveDynamicUsage for witness structures\r\n  * a541f0b Use an enum for signature versions\r\n* fixups 3 (https://github.com/sipa/bitcoin/compare/f38671f...8708de8)\r\n  * ba7e292 test: WITNESS flag must be used with P2SH flag\r\n  * e7821e9 BIP9 parameters for testnet\r\n  * 76142af Segwit script error unit tests\r\n* fixups 4 (https://github.com/sipa/bitcoin/compare/8708de8...306858f)\r\n  * b846298 f cb9d4d34: typo fix\r\n  * 38e3fcd f 3b1ff49f: remove redundant witness clean\r\n  * fd85b77 f 1b6c6f16: Cleanup mapBlocksUnlinked in RewindBlockIndex\r\n  * 433daf4 f ac6886d3: Get rid of leftover WITNESS_VERSION\r\n  * 9590289 f 2c87be12: fix typo\r\n  * 17277c9 f 39552185: GetBlockCost: Clarify comment description\r\n  * 1e9cba2 f 39552185: provide both -maxblocksize and -maxblockcost\r\n  * 8f50b96 [qa] segwit: Switch to py3\r\n  * 75335ca f 1b6c6f16: pass CChainParams rather than Consensus::Params to RewindBlockIndex\r\n* fixups 5 (https://github.com/sipa/bitcoin/compare/306858f...869f26e)\r\n  * 036fa47 Improve FindForkInGlobalIndex when locator contains chain tip\r\n  * 7eb0d75 VerifyDB: don't check blocks that have been pruned\r\n  * 8adb03a Improve RewindBlockIndex when pruning\r\n  * a1d1d0c Make sure upgraded nodes don't ask for non-wit blocks\r\n  * 019860e script_tests: witness tests can specify tx amount\r\n  * c815c16 [Qt] Add support for NODE_WITNESS in formatServicesStr\r\n  * f16067f bitcoinconsensus.h: Accept amount as int64_t\r\n  * 059d4d1 Add GetTransactionSigOpCost unit tests\r\n  * c1c38a2 segwit: fix gui wallet send transaction size calculation assertion failed\r\n  * 0acd1dc segwit: txout dust threshold calculation update\r\n* fixups 6 (https://github.com/sipa/bitcoin/compare/869f26e...f98de5f)\r\n  * 14d4d1d Extend the max witness program length to 40 bytes\r\n  * 4840f6d Prevent witness addresses from being constructed before fork\r\n  * 3dbf852 Remove positive SERIALIZE_TRANSACTION_WITNESS flag\r\n* fixups 7 (https://github.com/sipa/bitcoin/compare/f98de5f...7613bbb)\r\n  * c06c40b Actually count the witness data in memusage of CTransaction\r\n  * d8b5db9 Correctly count maximum size in mining\r\n  * 57d4bd2 Rework -maxblocksize and -maxblockcost\r\n  * 0bfbf60 Cache transaction cost in mempool\r\n  * 496d8c0 Delete segnet\r\n  * 7799a7c Do not send witnesses in response to bip37 blocks\r\n  * 4c19c18 33 to 40 bytes push should now be considered a witness scriptPubKey\r\n* fixups 8 (https://github.com/sipa/bitcoin/compare/7613bbb...1b9893f)\r\n  * a9bff09 Tests: add getblocktemplate/segwit test\r\n  * 92ab64c Add test for getrawtransaction\r\n  * 40f7829 p2p-segwit.py: more RPC coverage\r\n  * b644339 Rename deployment (witness -> segwit)\r\n  * 00bf5e1 Update p2p-segwit.py for new deployment name\r\n  * c8f2fb2 BIP143 P2WSH examples\r\n  * f3a7ed4 Fix unused variable in sigopcount test\r\n* fixups 9 (https://github.com/sipa/bitcoin/compare/1b9893f...b508f5b)\r\n  * 3483e5c DEPLOYMENT_WITNESS -> DEPLOYMENT_SEGWIT\r\n  * 2a6516f Behave as a non-witness node when start time is far away\r\n  * c7b5de5 test: BIP143 examples fix and clarify\r\n  * cc19adc Remove segnet from mininode\r\n  * efc251d Tests: ensure that signrawtransaction failures are caught in segwit.py\r\n  * 396f4b8 spelling fix: uncommited -> uncommitted\r\n* fixups 10 (https://github.com/sipa/bitcoin/compare/b508f5b...a6840e5)\r\n  * 10433cf Fix direct fetching of blocks after 2a6516fc\r\n  * 2948c02 Consistency in serialization flags\r\n* fixups 11 (https://github.com/sipa/bitcoin/compare/d7fe873...fb348c6)\r\n  * 0e177a2 Don't treat NODE_WITNESS as relevant before a fork is defined\r\n  * c7795ee Revert \"Don't check the genesis block PoW\" as segnet has been dropped.\r\n* merge (https://github.com/sipa/bitcoin/compare/fb348c6...e84733733d0ec3deee3b0d1cdcf643082b78ee1e)\r\n  * e847337 Merge remote-tracking branch 'upstream/master' into segwit-master\r\n\r\nCode to generate this list:\r\n```\r\nPREV=\"$(git rev-parse HEAD)\"; (git log --oneline upstream/master..HEAD; echo \"$(git rev-parse upstream/master) --- [SEGWIT] begin: preparation ---\") | while read C L; do if [ \"d${L:0:13}\" == \"d--- [SEGWIT] \" ]; then if [ \"d$PREV\" != \"\" ]; then echo \"* ${L:20:-4} (https://github.com/sipa/bitcoin/compare/$C...$PREV)\"; fi; PREV=$C; PREVL=$L; else echo \"  * $C $L\"; fi; done | tac\r\n```",
      "created_at" : "2016-04-19T16:09:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-211998958",
      "id" : 211998958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-16T18:32:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/211998958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60280033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60280033"
         }
      },
      "body" : "Probably should throw an error if it's not hex. Currently accepts anything entered.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-19T18:02:26Z",
      "diff_hunk" : "@@ -312,6 +312,39 @@ UniValue createmultisig(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue createwitnessaddress(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+    {\n+        string msg = \"createwitnessaddress \\\"script\\\"\\n\"\n+            \"\\nCreates a witness address for a particular script.\\n\"\n+            \"It returns a json object with the address and witness script.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"script\\\"       (string, required) A hex encoded script\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n+            \"  \\\"witnessScript\\\":\\\"script\\\"      (string) The string value of the hex-encoded witness script.\\n\"\n+            \"}\\n\"\n+        ;\n+        throw runtime_error(msg);\n+    }\n+\n+    std::vector<unsigned char> code = ParseHex(params[0].get_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60280033",
      "id" : 60280033,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 24,
      "path" : "src/rpc/misc.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60280033",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "Created pull request https://github.com/sipa/bitcoin/pull/75 on sipa's repository against this branch. Explanation of the proposed change:\r\n\r\n> The witness root is allowed to be placed at an arbitrary position up to seven layers deep in a Merkle tree structure. The witness nonce is now the branch through the commitment tree to the witness root, and a single byte is added to the commitment output specifying this path in compact form. This allows other consensus commitments to be added in the future with a minimal number of bytes and without committing at this time for a certain position for the segwit branch within the tree.\r\n>\r\n> In addition, switch to fast Merkle trees for witness. A fast Merkle branch uses midstate to perform a single SHA-256 compression per branch, and is not vulnerable to CVE-2012-2459. It produces different hashes though, so can only be used for new hash trees going forward.\r\n",
      "created_at" : "2016-04-19T18:51:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-212066524",
      "id" : 212066524,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-19T18:52:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/212066524",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69154?v=3",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60292915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60292915"
         }
      },
      "body" : "nit: ensure wallet is available for more useful error than \"not known to wallet\"",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-19T19:14:17Z",
      "diff_hunk" : "@@ -1095,6 +1095,75 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n     return CBitcoinAddress(innerID).ToString();\n }\n \n+class Witnessifier : public boost::static_visitor<bool>\n+{\n+public:\n+    CScriptID result;\n+\n+    bool operator()(const CNoDestination &dest) const { return false; }\n+\n+    bool operator()(const CKeyID &keyID) {\n+        CPubKey pubkey;\n+        if (pwalletMain && pwalletMain->GetPubKey(keyID, pubkey)) {\n+            CScript basescript;\n+            basescript << ToByteVector(pubkey) << OP_CHECKSIG;\n+            CScript witscript = GetScriptForWitness(basescript);\n+            pwalletMain->AddCScript(witscript);\n+            result = CScriptID(witscript);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    bool operator()(const CScriptID &scriptID) {\n+        CScript subscript;\n+        if (pwalletMain && pwalletMain->GetCScript(scriptID, subscript)) {\n+            int witnessversion;\n+            std::vector<unsigned char> witprog;\n+            if (subscript.IsWitnessProgram(witnessversion, witprog)) {\n+                result = scriptID;\n+                return true;\n+            }\n+            CScript witscript = GetScriptForWitness(subscript);\n+            pwalletMain->AddCScript(witscript);\n+            result = CScriptID(witscript);\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+\n+UniValue addwitnessaddress(const UniValue& params, bool fHelp)\n+{",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60292915",
      "id" : 60292915,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 43,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 43,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60292915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "See sipa#76 for fix to CInv::GetCommand",
      "created_at" : "2016-04-19T19:31:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-212079865",
      "id" : 212079865,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-19T19:31:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/212079865",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "Ayayay... a third of the original client's source base. I assume the items left to do will be committed to this PR #7910 ?",
      "created_at" : "2016-04-20T01:03:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-212190166",
      "id" : 212190166,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-20T01:03:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/212190166",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8286077?v=3",
         "events_url" : "https://api.github.com/users/21E14/events{/privacy}",
         "followers_url" : "https://api.github.com/users/21E14/followers",
         "following_url" : "https://api.github.com/users/21E14/following{/other_user}",
         "gists_url" : "https://api.github.com/users/21E14/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/21E14",
         "id" : 8286077,
         "login" : "21E14",
         "organizations_url" : "https://api.github.com/users/21E14/orgs",
         "received_events_url" : "https://api.github.com/users/21E14/received_events",
         "repos_url" : "https://api.github.com/users/21E14/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/21E14/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/21E14/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/21E14"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60356762"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60356762"
         }
      },
      "body" : "this little commitpos check could use a refactor, it appears 3 times. #DRY.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T06:44:28Z",
      "diff_hunk" : "@@ -3301,6 +3347,68 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n+{\n+    LOCK(cs_main);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_WITNESS, versionbitscache) == THRESHOLD_ACTIVE);\n+}\n+\n+void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n+{\n+    int commitpos = -1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60356762",
      "id" : 60356762,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 348,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60356762",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/163977?v=3",
         "events_url" : "https://api.github.com/users/gubatron/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gubatron/followers",
         "following_url" : "https://api.github.com/users/gubatron/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gubatron/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gubatron",
         "id" : 163977,
         "login" : "gubatron",
         "organizations_url" : "https://api.github.com/users/gubatron/orgs",
         "received_events_url" : "https://api.github.com/users/gubatron/received_events",
         "repos_url" : "https://api.github.com/users/gubatron/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gubatron/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gubatron/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gubatron"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60373788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60373788"
         }
      },
      "body" : "Agree!",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T09:07:33Z",
      "diff_hunk" : "@@ -3301,6 +3347,68 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n+{\n+    LOCK(cs_main);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_WITNESS, versionbitscache) == THRESHOLD_ACTIVE);\n+}\n+\n+void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n+{\n+    int commitpos = -1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60373788",
      "id" : 60373788,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 348,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60373788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "function UpdateUncommitedBlockStructures redefine in main.h\r\n\r\n> +\r\n +void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams);\r\n +\r\n +/** Update uncommitted block structures (currently: only the witness nonce). This is safe for submitted blocks. */\r\n +void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams);\r\n +\r\n\r\nsee [sipa#78](https://github.com/sipa/bitcoin/pull/78)",
      "created_at" : "2016-04-20T11:10:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-212383627",
      "id" : 212383627,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-20T11:14:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/212383627",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7669610?v=3",
         "events_url" : "https://api.github.com/users/LongShao007/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LongShao007/followers",
         "following_url" : "https://api.github.com/users/LongShao007/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LongShao007/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LongShao007",
         "id" : 7669610,
         "login" : "LongShao007",
         "organizations_url" : "https://api.github.com/users/LongShao007/orgs",
         "received_events_url" : "https://api.github.com/users/LongShao007/received_events",
         "repos_url" : "https://api.github.com/users/LongShao007/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LongShao007/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LongShao007/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LongShao007"
      }
   },
   {
      "body" : "I can sometimes repeat failed test (https://travis-ci.org/bitcoin/bitcoin/jobs/124242358#L4152) even on master - `wallet.py`, so it seems to be irrelevant to this PR.\r\n",
      "created_at" : "2016-04-20T15:18:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-212473734",
      "id" : 212473734,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-20T15:18:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/212473734",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "Jup, since we are aware of the issue, this might be a good time to disable this specific test.",
      "created_at" : "2016-04-20T15:21:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-212474862",
      "id" : 212474862,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-20T15:21:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/212474862",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60453999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60453999"
         }
      },
      "body" : "GetTransactionSigOpCost() could return a value close to 2^29 (4M * 20 (multisig) * 4) so to be safe nSigOps should be an int64_t. That can prevent overflows on future witness size extensions.\r\n",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T17:40:34Z",
      "diff_hunk" : "@@ -1144,8 +1168,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        unsigned int nSigOps = GetLegacySigOpCount(tx);\n-        nSigOps += GetP2SHSigOpCount(tx, view);\n+        unsigned int nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60453999",
      "id" : 60453999,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 71,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60453999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1752347?v=3",
         "events_url" : "https://api.github.com/users/SergioDemianLerner/events{/privacy}",
         "followers_url" : "https://api.github.com/users/SergioDemianLerner/followers",
         "following_url" : "https://api.github.com/users/SergioDemianLerner/following{/other_user}",
         "gists_url" : "https://api.github.com/users/SergioDemianLerner/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/SergioDemianLerner",
         "id" : 1752347,
         "login" : "SergioDemianLerner",
         "organizations_url" : "https://api.github.com/users/SergioDemianLerner/orgs",
         "received_events_url" : "https://api.github.com/users/SergioDemianLerner/received_events",
         "repos_url" : "https://api.github.com/users/SergioDemianLerner/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/SergioDemianLerner/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/SergioDemianLerner/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/SergioDemianLerner"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60454436"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60454436"
         }
      },
      "body" : "same here. nSigOps -> int64_t",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T17:43:08Z",
      "diff_hunk" : "@@ -2326,7 +2369,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<int> prevheights;\n     CAmount nFees = 0;\n     int nInputs = 0;\n-    unsigned int nSigOps = 0;\n+    unsigned int nSigOpsCost = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60454436",
      "id" : 60454436,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 195,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60454436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1752347?v=3",
         "events_url" : "https://api.github.com/users/SergioDemianLerner/events{/privacy}",
         "followers_url" : "https://api.github.com/users/SergioDemianLerner/followers",
         "following_url" : "https://api.github.com/users/SergioDemianLerner/following{/other_user}",
         "gists_url" : "https://api.github.com/users/SergioDemianLerner/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/SergioDemianLerner",
         "id" : 1752347,
         "login" : "SergioDemianLerner",
         "organizations_url" : "https://api.github.com/users/SergioDemianLerner/orgs",
         "received_events_url" : "https://api.github.com/users/SergioDemianLerner/received_events",
         "repos_url" : "https://api.github.com/users/SergioDemianLerner/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/SergioDemianLerner/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/SergioDemianLerner/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/SergioDemianLerner"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60458667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60458667"
         }
      },
      "body" : "GetBlockCost() is part of consensus-critical code. Why is the phrase \"approximate formula\" used in a comment here?\r\nEither the formula is exact (and matches the BIP) or it is incorrect.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T18:06:53Z",
      "diff_hunk" : "@@ -31,3 +31,11 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n+\n+int64_t GetBlockCost(const CBlock& block)\n+{\n+    // The intended approximate formula is: cost = base_size * 4 + witness_size.\n+    // We can only serialize base or base+witness, so the formula\n+    // becomes: cost = base_size * 3 + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, 0) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, SERIALIZE_TRANSACTION_WITNESS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60458667",
      "id" : 60458667,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 10,
      "path" : "src/primitives/block.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60458667",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1752347?v=3",
         "events_url" : "https://api.github.com/users/SergioDemianLerner/events{/privacy}",
         "followers_url" : "https://api.github.com/users/SergioDemianLerner/followers",
         "following_url" : "https://api.github.com/users/SergioDemianLerner/following{/other_user}",
         "gists_url" : "https://api.github.com/users/SergioDemianLerner/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/SergioDemianLerner",
         "id" : 1752347,
         "login" : "SergioDemianLerner",
         "organizations_url" : "https://api.github.com/users/SergioDemianLerner/orgs",
         "received_events_url" : "https://api.github.com/users/SergioDemianLerner/received_events",
         "repos_url" : "https://api.github.com/users/SergioDemianLerner/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/SergioDemianLerner/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/SergioDemianLerner/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/SergioDemianLerner"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60463090"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60463090"
         }
      },
      "body" : "Why not (4M * 20 (multisig))? You may have 4MB only if it is a segwit tx, and cost of segwit sigops does not need to * 4",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T18:32:29Z",
      "diff_hunk" : "@@ -1144,8 +1168,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        unsigned int nSigOps = GetLegacySigOpCount(tx);\n-        nSigOps += GetP2SHSigOpCount(tx, view);\n+        unsigned int nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60463090",
      "id" : 60463090,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 71,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60463090",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60482327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60482327"
         }
      },
      "body" : "I agree with jl2012, and I think an int64_t is not necessary at this point. It won't hurt though, so I'll switch the type.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T20:34:32Z",
      "diff_hunk" : "@@ -1144,8 +1168,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        unsigned int nSigOps = GetLegacySigOpCount(tx);\n-        nSigOps += GetP2SHSigOpCount(tx, view);\n+        unsigned int nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60482327",
      "id" : 60482327,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 71,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60482327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60483311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60483311"
         }
      },
      "body" : "The formula is exact.\n\nIt's trying to explain the rationale for this rule (basesize * 3 + totalsize) by showing that it corresponds to (basesize * 4 + witsize). But perhaps this rationale belongs in the BIP and not in the code.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-20T20:40:44Z",
      "diff_hunk" : "@@ -31,3 +31,11 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n+\n+int64_t GetBlockCost(const CBlock& block)\n+{\n+    // The intended approximate formula is: cost = base_size * 4 + witness_size.\n+    // We can only serialize base or base+witness, so the formula\n+    // becomes: cost = base_size * 3 + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, 0) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, SERIALIZE_TRANSACTION_WITNESS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60483311",
      "id" : 60483311,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 10,
      "path" : "src/primitives/block.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60483311",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60519803"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60519803"
         }
      },
      "body" : "What was the reasoning behind separating this from being derived from the network rule?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T02:48:43Z",
      "diff_hunk" : "@@ -6,10 +6,14 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60519803",
      "id" : 60519803,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 8,
      "path" : "src/consensus/consensus.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60519803",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60521354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60521354"
         }
      },
      "body" : "> **Reject** witness transactions if segregated witness is disabled [and a witness exists]; override with `-prematurewitness` to bypass\r\n\r\nIMHO, reads easier, less negations to do in my head",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T03:16:58Z",
      "diff_hunk" : "@@ -1033,6 +1052,11 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"premature-version2-tx\");\n     }\n \n+    // Don't accept witness transactions before the final threshold passes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60521354",
      "id" : 60521354,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 57,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60521354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60521686"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60521686"
         }
      },
      "body" : "Could this be bracketed such that precedence rules don't need to be remembered?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T03:24:05Z",
      "diff_hunk" : "@@ -1179,9 +1202,9 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n-        if ((nSigOps > MAX_STANDARD_TX_SIGOPS) || (nBytesPerSigOp && nSigOps > nSize / nBytesPerSigOp))\n+        if ((nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST) || (nBytesPerSigOp && nSigOpsCost > nSize * WITNESS_SCALE_FACTOR / nBytesPerSigOp))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60521686",
      "id" : 60521686,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 89,
      "path" : "src/main.cpp",
      "position" : 103,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60521686",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60522057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60522057"
         }
      },
      "body" : "ACK switch to `uint64_t`,  its what is returned by `GetTransactionSigOpCost` any way... explicit casts should be the rule, not the exception (IMHO).",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T03:32:24Z",
      "diff_hunk" : "@@ -1144,8 +1168,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        unsigned int nSigOps = GetLegacySigOpCount(tx);\n-        nSigOps += GetP2SHSigOpCount(tx, view);\n+        unsigned int nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60522057",
      "id" : 60522057,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 71,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60522057",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60522121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60522121"
         }
      },
      "body" : "Less implicit casts if this is also `uint64_t`",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T03:33:53Z",
      "diff_hunk" : "@@ -6,10 +6,14 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */\n+static const unsigned int MAX_BLOCK_COST = 4000000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60522121",
      "id" : 60522121,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 9,
      "path" : "src/consensus/consensus.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60522121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60643948"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60643948"
         }
      },
      "body" : "You mean \"room *for* spam\"?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T19:48:44Z",
      "diff_hunk" : "@@ -3354,6 +3462,58 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // Validation for witness commitments.\n+    // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n+    //   coinbase (where 0x0000....0000 is used instead).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n+    // * The must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\n+    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256(witness root, witness nonce). In case there are\n+    //   multiple, the last one is used.\n+    bool fHaveWitness = false;\n+    if (IsWitnessEnabled(pindexPrev, consensusParams)) {\n+        int commitpos = -1;\n+        for (size_t o = 0; o < block.vtx[0].vout.size(); o++) {\n+            if (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {\n+                commitpos = o;\n+            }\n+        }\n+        if (commitpos != -1) {\n+            bool malleated = false;\n+            uint256 hashWitness = BlockWitnessMerkleRoot(block, &malleated);\n+            // The malleation check is ignored; as the transaction tree itself\n+            // already does not permit it, it is impossible to trigger in the\n+            // witness tree.\n+            if (block.vtx[0].wit.vtxinwit.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0].size() != 32) {\n+                return state.DoS(100, error(\"%s : invalid witness commitment size\", __func__), REJECT_INVALID, \"bad-witness-merkle-size\", true);\n+            }\n+            CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n+            if (memcmp(hashWitness.begin(), &block.vtx[0].vout[commitpos].scriptPubKey[6], 32)) {\n+                return state.DoS(100, error(\"%s : witness merkle commitment mismatch\", __func__), REJECT_INVALID, \"bad-witness-merkle-match\", true);\n+            }\n+            fHaveWitness = true;\n+        }\n+    }\n+\n+    // No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60643948",
      "id" : 60643948,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 442,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60643948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/573356?v=3",
         "events_url" : "https://api.github.com/users/dooglus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dooglus/followers",
         "following_url" : "https://api.github.com/users/dooglus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dooglus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dooglus",
         "id" : 573356,
         "login" : "dooglus",
         "organizations_url" : "https://api.github.com/users/dooglus/orgs",
         "received_events_url" : "https://api.github.com/users/dooglus/received_events",
         "repos_url" : "https://api.github.com/users/dooglus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dooglus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dooglus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60644990"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60644990"
         }
      },
      "body" : "So just remove the word 'approximate'? I think it is helpful to keep the rest of the explanation here.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T19:56:17Z",
      "diff_hunk" : "@@ -31,3 +31,11 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n+\n+int64_t GetBlockCost(const CBlock& block)\n+{\n+    // The intended approximate formula is: cost = base_size * 4 + witness_size.\n+    // We can only serialize base or base+witness, so the formula\n+    // becomes: cost = base_size * 3 + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, 0) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, SERIALIZE_TRANSACTION_WITNESS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60644990",
      "id" : 60644990,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 10,
      "path" : "src/primitives/block.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60644990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/573356?v=3",
         "events_url" : "https://api.github.com/users/dooglus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dooglus/followers",
         "following_url" : "https://api.github.com/users/dooglus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dooglus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dooglus",
         "id" : 573356,
         "login" : "dooglus",
         "organizations_url" : "https://api.github.com/users/dooglus/orgs",
         "received_events_url" : "https://api.github.com/users/dooglus/received_events",
         "repos_url" : "https://api.github.com/users/dooglus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dooglus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dooglus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dooglus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60646516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60646516"
         }
      },
      "body" : "would be nice to shorten this line, plus it's essentially repeated soon after a few lines later....\r\n\r\n```\r\nif (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {\r\n```",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-21T20:06:31Z",
      "diff_hunk" : "@@ -3301,6 +3347,68 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n+{\n+    LOCK(cs_main);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_WITNESS, versionbitscache) == THRESHOLD_ACTIVE);\n+}\n+\n+void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n+{\n+    int commitpos = -1;\n+    for (size_t o = 0; o < block.vtx[0].vout.size(); o++) {\n+        if (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60646516",
      "id" : 60646516,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 350,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60646516",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/101238?v=3",
         "events_url" : "https://api.github.com/users/kanzure/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kanzure/followers",
         "following_url" : "https://api.github.com/users/kanzure/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kanzure/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kanzure",
         "id" : 101238,
         "login" : "kanzure",
         "organizations_url" : "https://api.github.com/users/kanzure/orgs",
         "received_events_url" : "https://api.github.com/users/kanzure/received_events",
         "repos_url" : "https://api.github.com/users/kanzure/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kanzure/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kanzure/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kanzure"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60715820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60715820"
         }
      },
      "body" : "Needs merge conflict solved.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-22T09:50:35Z",
      "diff_hunk" : "@@ -2629,7 +2669,7 @@ void static UpdateTip(CBlockIndex *pindexNew) {\n }\n \n /** Disconnect chainActive's tip. You probably want to call mempool.removeForReorg and manually re-limit mempool size after this, with cs_main held. */\n-bool static DisconnectTip(CValidationState& state, const Consensus::Params& consensusParams)\n+bool static DisconnectTip(CValidationState& state, const Consensus::Params& consensusParams, bool fBare = false)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60715820",
      "id" : 60715820,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 254,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60715820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60715862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60715862"
         }
      },
      "body" : "Nit: Let's not do wildcard imports in mininode.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-22T09:50:55Z",
      "diff_hunk" : "@@ -23,7 +23,7 @@\n import time\n import sys\n import random\n-from binascii import hexlify, unhexlify\n+from util import *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60715862",
      "id" : 60715862,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 5,
      "path" : "qa/rpc-tests/test_framework/mininode.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60715862",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60716128"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60716128"
         }
      },
      "body" : "When you are deciding to rebase the segwit patchset, let me know if you want #7918 merged first (as that would solve this nit).",
      "commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "created_at" : "2016-04-22T09:53:11Z",
      "diff_hunk" : "@@ -23,7 +23,7 @@\n import time\n import sys\n import random\n-from binascii import hexlify, unhexlify\n+from util import *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60716128",
      "id" : 60716128,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 5,
      "path" : "qa/rpc-tests/test_framework/mininode.py",
      "position" : 5,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-04-22T09:53:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60716128",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60718659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60718659"
         }
      },
      "body" : "This comment doesn't look right, since we're using version bits deployment.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-22T10:17:33Z",
      "diff_hunk" : "@@ -22,6 +22,29 @@ def create_block(hashprev, coinbase, nTime=None):\n     block.calc_sha256()\n     return block\n \n+# From BIP141\n+WITNESS_COMMITMENT_HEADER = \"\\xaa\\x21\\xa9\\xed\"\n+\n+# According to BIP141, nVersion=5 blocks must commit to the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60718659",
      "id" : 60718659,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 16,
      "path" : "qa/rpc-tests/test_framework/blocktools.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60718659",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60720954"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60720954"
         }
      },
      "body" : "Add comment `Deployment of BIP141 and BIP143`",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-22T10:41:28Z",
      "diff_hunk" : "@@ -16,6 +16,7 @@ enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n     DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n+    DEPLOYMENT_WITNESS,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60720954",
      "id" : 60720954,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 4,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60720954",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60721107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60721107"
         }
      },
      "body" : "add the BIP numbers being deployed.\r\n\r\n`Deployment of SegWit, BIP141 and BIP143`",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-22T10:42:57Z",
      "diff_hunk" : "@@ -92,6 +93,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n \n+        // Deployment of SegWit.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60721107",
      "id" : 60721107,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 12,
      "path" : "src/chainparams.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60721107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60809182"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60809182"
         }
      },
      "body" : "Rename to \"witnesshash\", or mention hash is based on witnesshash in description.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-22T22:03:09Z",
      "diff_hunk" : "@@ -330,13 +332,15 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"  \\\"transactions\\\" : [                (array) contents of non-coinbase transactions that should be included in the next block\\n\"\n             \"      {\\n\"\n             \"         \\\"data\\\" : \\\"xxxx\\\",          (string) transaction data encoded in hexadecimal (byte-for-byte)\\n\"\n-            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash/id encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"txid\\\" : \\\"xxxx\\\",          (string) transaction id encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash encoded in little-endian hexadecimal\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60809182",
      "id" : 60809182,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 35,
      "path" : "src/rpc/mining.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60809182",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60824710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60824710"
         }
      },
      "body" : "This is from BIP145, though I agree it's helpful to document.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T07:33:50Z",
      "diff_hunk" : "@@ -330,13 +332,15 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"  \\\"transactions\\\" : [                (array) contents of non-coinbase transactions that should be included in the next block\\n\"\n             \"      {\\n\"\n             \"         \\\"data\\\" : \\\"xxxx\\\",          (string) transaction data encoded in hexadecimal (byte-for-byte)\\n\"\n-            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash/id encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"txid\\\" : \\\"xxxx\\\",          (string) transaction id encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash encoded in little-endian hexadecimal\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60824710",
      "id" : 60824710,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 35,
      "path" : "src/rpc/mining.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60824710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60824714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60824714"
         }
      },
      "body" : "Agree.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T07:34:12Z",
      "diff_hunk" : "@@ -312,6 +312,39 @@ UniValue createmultisig(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue createwitnessaddress(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+    {\n+        string msg = \"createwitnessaddress \\\"script\\\"\\n\"\n+            \"\\nCreates a witness address for a particular script.\\n\"\n+            \"It returns a json object with the address and witness script.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"script\\\"       (string, required) A hex encoded script\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n+            \"  \\\"witnessScript\\\":\\\"script\\\"      (string) The string value of the hex-encoded witness script.\\n\"\n+            \"}\\n\"\n+        ;\n+        throw runtime_error(msg);\n+    }\n+\n+    std::vector<unsigned char> code = ParseHex(params[0].get_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60824714",
      "id" : 60824714,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 24,
      "path" : "src/rpc/misc.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60824714",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826625"
         }
      },
      "body" : "It is not derived from the network rule because it is the (only) network rule. What would you derive it from?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:31:50Z",
      "diff_hunk" : "@@ -6,10 +6,14 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826625",
      "id" : 60826625,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 8,
      "path" : "src/consensus/consensus.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826671"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826671"
         }
      },
      "body" : "I don't think that's necessary here.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:37:44Z",
      "diff_hunk" : "@@ -1179,9 +1202,9 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n-        if ((nSigOps > MAX_STANDARD_TX_SIGOPS) || (nBytesPerSigOp && nSigOps > nSize / nBytesPerSigOp))\n+        if ((nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST) || (nBytesPerSigOp && nSigOpsCost > nSize * WITNESS_SCALE_FACTOR / nBytesPerSigOp))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826671",
      "id" : 60826671,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 89,
      "path" : "src/main.cpp",
      "position" : 103,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826671",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826717"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826717"
         }
      },
      "body" : "Yes, will factor it out to a separate function.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:42:59Z",
      "diff_hunk" : "@@ -3301,6 +3347,68 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n+{\n+    LOCK(cs_main);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_WITNESS, versionbitscache) == THRESHOLD_ACTIVE);\n+}\n+\n+void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n+{\n+    int commitpos = -1;\n+    for (size_t o = 0; o < block.vtx[0].vout.size(); o++) {\n+        if (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826717",
      "id" : 60826717,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 350,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826717",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826733"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826733"
         }
      },
      "body" : "Will do.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:44:51Z",
      "diff_hunk" : "@@ -31,3 +31,11 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n+\n+int64_t GetBlockCost(const CBlock& block)\n+{\n+    // The intended approximate formula is: cost = base_size * 4 + witness_size.\n+    // We can only serialize base or base+witness, so the formula\n+    // becomes: cost = base_size * 3 + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, 0) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, SERIALIZE_TRANSACTION_WITNESS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826733",
      "id" : 60826733,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 10,
      "path" : "src/primitives/block.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826733",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826808"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826808"
         }
      },
      "body" : "Will fix.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:51:12Z",
      "diff_hunk" : "@@ -22,6 +22,29 @@ def create_block(hashprev, coinbase, nTime=None):\n     block.calc_sha256()\n     return block\n \n+# From BIP141\n+WITNESS_COMMITMENT_HEADER = \"\\xaa\\x21\\xa9\\xed\"\n+\n+# According to BIP141, nVersion=5 blocks must commit to the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826808",
      "id" : 60826808,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 16,
      "path" : "qa/rpc-tests/test_framework/blocktools.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826808",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826823"
         }
      },
      "body" : "Will fix.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:51:43Z",
      "diff_hunk" : "@@ -92,6 +93,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n \n+        // Deployment of SegWit.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826823",
      "id" : 60826823,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 12,
      "path" : "src/chainparams.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826823",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826858"
         }
      },
      "body" : "Will turn all sigops cost variables into int64_t",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:54:49Z",
      "diff_hunk" : "@@ -6,10 +6,14 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */\n+static const unsigned int MAX_BLOCK_COST = 4000000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826858",
      "id" : 60826858,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 9,
      "path" : "src/consensus/consensus.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826858",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826863"
         }
      },
      "body" : "Will do.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:55:23Z",
      "diff_hunk" : "@@ -16,6 +16,7 @@ enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n     DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n+    DEPLOYMENT_WITNESS,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826863",
      "id" : 60826863,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 4,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826869"
         }
      },
      "body" : "Will fix.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:55:37Z",
      "diff_hunk" : "@@ -1033,6 +1052,11 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"premature-version2-tx\");\n     }\n \n+    // Don't accept witness transactions before the final threshold passes",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826869",
      "id" : 60826869,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 57,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826869",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826871"
         }
      },
      "body" : "Thanks, will do.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:55:59Z",
      "diff_hunk" : "@@ -2326,7 +2369,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<int> prevheights;\n     CAmount nFees = 0;\n     int nInputs = 0;\n-    unsigned int nSigOps = 0;\n+    unsigned int nSigOpsCost = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826871",
      "id" : 60826871,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 195,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826871",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826874"
         }
      },
      "body" : "I do!",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:56:21Z",
      "diff_hunk" : "@@ -3354,6 +3462,58 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // Validation for witness commitments.\n+    // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n+    //   coinbase (where 0x0000....0000 is used instead).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n+    // * The must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\n+    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256(witness root, witness nonce). In case there are\n+    //   multiple, the last one is used.\n+    bool fHaveWitness = false;\n+    if (IsWitnessEnabled(pindexPrev, consensusParams)) {\n+        int commitpos = -1;\n+        for (size_t o = 0; o < block.vtx[0].vout.size(); o++) {\n+            if (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {\n+                commitpos = o;\n+            }\n+        }\n+        if (commitpos != -1) {\n+            bool malleated = false;\n+            uint256 hashWitness = BlockWitnessMerkleRoot(block, &malleated);\n+            // The malleation check is ignored; as the transaction tree itself\n+            // already does not permit it, it is impossible to trigger in the\n+            // witness tree.\n+            if (block.vtx[0].wit.vtxinwit.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0].size() != 32) {\n+                return state.DoS(100, error(\"%s : invalid witness commitment size\", __func__), REJECT_INVALID, \"bad-witness-merkle-size\", true);\n+            }\n+            CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n+            if (memcmp(hashWitness.begin(), &block.vtx[0].vout[commitpos].scriptPubKey[6], 32)) {\n+                return state.DoS(100, error(\"%s : witness merkle commitment mismatch\", __func__), REJECT_INVALID, \"bad-witness-merkle-match\", true);\n+            }\n+            fHaveWitness = true;\n+        }\n+    }\n+\n+    // No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826874",
      "id" : 60826874,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 442,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826883"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826883"
         }
      },
      "body" : "Will do.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-23T10:57:32Z",
      "diff_hunk" : "@@ -1095,6 +1095,75 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n     return CBitcoinAddress(innerID).ToString();\n }\n \n+class Witnessifier : public boost::static_visitor<bool>\n+{\n+public:\n+    CScriptID result;\n+\n+    bool operator()(const CNoDestination &dest) const { return false; }\n+\n+    bool operator()(const CKeyID &keyID) {\n+        CPubKey pubkey;\n+        if (pwalletMain && pwalletMain->GetPubKey(keyID, pubkey)) {\n+            CScript basescript;\n+            basescript << ToByteVector(pubkey) << OP_CHECKSIG;\n+            CScript witscript = GetScriptForWitness(basescript);\n+            pwalletMain->AddCScript(witscript);\n+            result = CScriptID(witscript);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    bool operator()(const CScriptID &scriptID) {\n+        CScript subscript;\n+        if (pwalletMain && pwalletMain->GetCScript(scriptID, subscript)) {\n+            int witnessversion;\n+            std::vector<unsigned char> witprog;\n+            if (subscript.IsWitnessProgram(witnessversion, witprog)) {\n+                result = scriptID;\n+                return true;\n+            }\n+            CScript witscript = GetScriptForWitness(subscript);\n+            pwalletMain->AddCScript(witscript);\n+            result = CScriptID(witscript);\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+\n+UniValue addwitnessaddress(const UniValue& params, bool fHelp)\n+{",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60826883",
      "id" : 60826883,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 43,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 43,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60826883",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "I have included fixup commits for almost all comments, as well as a merge commit at the end to keep the result testable and show what changes are needed to rebase on master.\r\n\r\nI intend to only overwrite the merge commit at the end, and otherwise only append fixup commits (and where possible, list which commit they modify). I will also keep the broken-down commit list on https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-211998958 up to date with every push.",
      "created_at" : "2016-04-23T12:17:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-213730697",
      "id" : 213730697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-23T12:18:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/213730697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60932289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60932289"
         }
      },
      "body" : "Double SHA256?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T15:22:16Z",
      "diff_hunk" : "@@ -3353,6 +3464,53 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // Validation for witness commitments.\n+    // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n+    //   coinbase (where 0x0000....0000 is used instead).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n+    // * The must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\n+    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256(witness root, witness nonce). In case there are",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60932289",
      "id" : 60932289,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 418,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60932289",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60933279"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60933279"
         }
      },
      "body" : "what does \"may be fine\" mean here?\r\n\r\nedit: nevermind, I see the explanation here: https://github.com/bitcoin/bitcoin/commit/1e478052ca3222d13ce3646dd152ebcf27f07e76#diff-7ec3c68a81efff79b6ca22ac1f1eabbaR5221",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T15:27:33Z",
      "diff_hunk" : "@@ -1373,10 +1396,24 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             }\n         }\n \n+        unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n+        if (!Params().RequireStandard()) {\n+            scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n-            return false; // state filled in by CheckInputs\n+        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true)) {\n+            // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n+            // need to turn both off, and compare against just turning off CLEANSTACK\n+            // to see if the failure is specifically due to witness validation.\n+            if (CheckInputs(tx, state, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true) &&\n+                !CheckInputs(tx, state, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true)) {\n+                // Only the witness is wrong, so the transaction itself may be fine.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60933279",
      "id" : 60933279,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 115,
      "path" : "src/main.cpp",
      "position" : 129,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60933279",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "I think there are a couple of more places that need the SERIALIZE_TRANSACTION_WITNESS flag: `rest_tx` and `rest_block` in rest.cpp, `CDB:Rewrite` in db.cpp, and I wasn't sure about `CWalletDB::Recover` in walletdb.cpp.",
      "created_at" : "2016-04-25T15:30:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-214396188",
      "id" : 214396188,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-25T15:30:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/214396188",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60948634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60948634"
         }
      },
      "body" : "Do we need to handle the case that `flags == 0`? For instance, the serialization of a transaction with no inputs and no outputs, maybe we should explicitly make sure tx.vout is set empty?\r\n\r\n(i put this same comment somewhere wrong initially)",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T16:59:50Z",
      "diff_hunk" : "@@ -194,8 +198,133 @@ class CTxOut\n     std::string ToString() const;\n };\n \n+class CTxinWitness\n+{\n+public:\n+    CScriptWitness scriptWitness;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(scriptWitness.stack);\n+    }\n+\n+    bool IsNull() const { return scriptWitness.IsNull(); }\n+\n+    CTxinWitness() { }\n+};\n+\n+class CTxWitness\n+{\n+public:\n+    /** In case vtxinwit is missing, all entries are treated as if they were empty CTxInWitnesses */\n+    std::vector<CTxinWitness> vtxinwit;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    bool IsEmpty() const { return vtxinwit.empty(); }\n+\n+    bool IsNull() const\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            if (!vtxinwit[n].IsNull()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void SetNull()\n+    {\n+        vtxinwit.clear();\n+    }\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            READWRITE(vtxinwit[n]);\n+        }\n+        if (IsNull()) {\n+            /* It's illegal to encode a witness when all vtxinwit entries are empty. */\n+            throw std::ios_base::failure(\"Superfluous witness record\");\n+        }\n+    }\n+};\n+\n struct CMutableTransaction;\n \n+/**\n+ * Basic transaction serialization format:\n+ * - int32_t nVersion\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - uint32_t nLockTime\n+ *\n+ * Extended transaction serialization format:\n+ * - int32_t nVersion\n+ * - unsigned char dummy = 0x00\n+ * - unsigned char flags (!= 0)\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - if (flags & 1):\n+ *   - CTxWitness wit;\n+ * - uint32_t nLockTime\n+ */\n+template<typename Stream, typename Operation, typename TxType>\n+inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, int nType, int nVersion) {\n+    READWRITE(*const_cast<int32_t*>(&tx.nVersion));\n+    unsigned char flags = 0;\n+    if (ser_action.ForRead()) {\n+        /* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */\n+        READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+        if (tx.vin.size() == 0 && (nVersion & SERIALIZE_TRANSACTION_WITNESS)) {\n+            /* We read a dummy or an empty vin. */\n+            READWRITE(flags);\n+            if (flags != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60948634",
      "id" : 60948634,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 100,
      "path" : "src/primitives/transaction.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60948634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60953084"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60953084"
         }
      },
      "body" : "I think after your fixup commit this doesn't deserialize properly, which probably isn't what we're supposed to be testing here.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T17:29:30Z",
      "diff_hunk" : "@@ -32,7 +32,7 @@\n [\"Tests for CheckTransaction()\"],\n [\"No inputs\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x7a052c840ba73af26755de42cf01cc9e0a49fef0 EQUAL\"]],\n-\"0100000000010000000000000000015100000000\", \"P2SH\"],\n+\"01000000000000010000000000000000015100000000\", \"P2SH\"],",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60953084",
      "id" : 60953084,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 5,
      "path" : "src/test/data/tx_invalid.json",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60953084",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60953841"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60953841"
         }
      },
      "body" : "That is intentional. If a transaction starting with \"[version] 0x00 0x00 ...\" is seen, it is treated as one with no inputs and no outputs.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T17:33:26Z",
      "diff_hunk" : "@@ -194,8 +198,133 @@ class CTxOut\n     std::string ToString() const;\n };\n \n+class CTxinWitness\n+{\n+public:\n+    CScriptWitness scriptWitness;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(scriptWitness.stack);\n+    }\n+\n+    bool IsNull() const { return scriptWitness.IsNull(); }\n+\n+    CTxinWitness() { }\n+};\n+\n+class CTxWitness\n+{\n+public:\n+    /** In case vtxinwit is missing, all entries are treated as if they were empty CTxInWitnesses */\n+    std::vector<CTxinWitness> vtxinwit;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    bool IsEmpty() const { return vtxinwit.empty(); }\n+\n+    bool IsNull() const\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            if (!vtxinwit[n].IsNull()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void SetNull()\n+    {\n+        vtxinwit.clear();\n+    }\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            READWRITE(vtxinwit[n]);\n+        }\n+        if (IsNull()) {\n+            /* It's illegal to encode a witness when all vtxinwit entries are empty. */\n+            throw std::ios_base::failure(\"Superfluous witness record\");\n+        }\n+    }\n+};\n+\n struct CMutableTransaction;\n \n+/**\n+ * Basic transaction serialization format:\n+ * - int32_t nVersion\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - uint32_t nLockTime\n+ *\n+ * Extended transaction serialization format:\n+ * - int32_t nVersion\n+ * - unsigned char dummy = 0x00\n+ * - unsigned char flags (!= 0)\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - if (flags & 1):\n+ *   - CTxWitness wit;\n+ * - uint32_t nLockTime\n+ */\n+template<typename Stream, typename Operation, typename TxType>\n+inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, int nType, int nVersion) {\n+    READWRITE(*const_cast<int32_t*>(&tx.nVersion));\n+    unsigned char flags = 0;\n+    if (ser_action.ForRead()) {\n+        /* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */\n+        READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+        if (tx.vin.size() == 0 && (nVersion & SERIALIZE_TRANSACTION_WITNESS)) {\n+            /* We read a dummy or an empty vin. */\n+            READWRITE(flags);\n+            if (flags != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60953841",
      "id" : 60953841,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 100,
      "path" : "src/primitives/transaction.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60953841",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60993521"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60993521"
         }
      },
      "body" : "This isn't necessary right?  Perhaps we need a better way to identify which rules for block assembly are enforced by the mempool, but I'd rather that we keep redundant checks out to make future work on block assembly easier.  At the very least this should be commented that unless there is a reorg to a lower height more work chain immediately at the segwit activation border, then this check is superfluous.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T21:34:18Z",
      "diff_hunk" : "@@ -183,6 +186,9 @@ CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& s\n \n             const CTransaction& tx = iter->GetTx();\n \n+            if (!fIncludeWitness && !tx.wit.IsNull())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60993521",
      "id" : 60993521,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 14,
      "path" : "src/miner.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60993521",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60996698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60996698"
         }
      },
      "body" : "Agree, this is a hack.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-25T21:56:00Z",
      "diff_hunk" : "@@ -183,6 +186,9 @@ CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& s\n \n             const CTransaction& tx = iter->GetTx();\n \n+            if (!fIncludeWitness && !tx.wit.IsNull())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r60996698",
      "id" : 60996698,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 71,
      "path" : "src/miner.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/60996698",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61024859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61024859"
         }
      },
      "body" : "All good,  I forgot I made that comment before finishing reviewing the majority of the PR,  it makes sense now :+1: ",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-26T03:40:44Z",
      "diff_hunk" : "@@ -6,10 +6,14 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61024859",
      "id" : 61024859,
      "original_commit_id" : "7b539f9bfe4e96a9b30ffdc874aa80e4308c9dec",
      "original_position" : 8,
      "path" : "src/consensus/consensus.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61024859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61092167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61092167"
         }
      },
      "body" : "nit: update comment to cost/4k",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-26T14:12:17Z",
      "diff_hunk" : "@@ -89,22 +89,22 @@ CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& s\n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n-    pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n+    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n     // Largest block you're willing to create:\n-    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+    unsigned int nBlockMaxCost = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE) * WITNESS_SCALE_FACTOR;\n     // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61092167",
      "id" : 61092167,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 19,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61092167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61101582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61101582"
         }
      },
      "body" : "This error message might be clearer if it indicated that it was the \"nonce\" that was the wrong size.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-26T14:58:59Z",
      "diff_hunk" : "@@ -3353,6 +3464,53 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // Validation for witness commitments.\n+    // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n+    //   coinbase (where 0x0000....0000 is used instead).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n+    // * The must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\n+    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256(witness root, witness nonce). In case there are\n+    //   multiple, the last one is used.\n+    bool fHaveWitness = false;\n+    if (IsWitnessEnabled(pindexPrev, consensusParams)) {\n+        int commitpos = GetWitnessCommitmentIndex(block);\n+        if (commitpos != -1) {\n+            bool malleated = false;\n+            uint256 hashWitness = BlockWitnessMerkleRoot(block, &malleated);\n+            // The malleation check is ignored; as the transaction tree itself\n+            // already does not permit it, it is impossible to trigger in the\n+            // witness tree.\n+            if (block.vtx[0].wit.vtxinwit.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0].size() != 32) {\n+                return state.DoS(100, error(\"%s : invalid witness commitment size\", __func__), REJECT_INVALID, \"bad-witness-merkle-size\", true);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61101582",
      "id" : 61101582,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 430,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61101582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61148809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61148809"
         }
      },
      "body" : "This is minor, but shouldn't we put a similar guard up above, where failed-orphan transactions get added to `recentRejects`?  Presumably failed orphans should also only be added to `recentRejects` if the corruption field is not set?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-26T19:27:54Z",
      "diff_hunk" : "@@ -5176,8 +5185,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             if (nEvicted > 0)\n                 LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n         } else {\n-            assert(recentRejects);\n-            recentRejects->insert(tx.GetHash());\n+            if (!state.CorruptionPossible()) {\n+                assert(recentRejects);\n+                recentRejects->insert(tx.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61148809",
      "id" : 61148809,
      "original_commit_id" : "1e478052ca3222d13ce3646dd152ebcf27f07e76",
      "original_position" : 28,
      "path" : "src/main.cpp",
      "position" : 705,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61148809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61296431"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61296431"
         }
      },
      "body" : "nit: would it be easier to read if any time we had a sigversion we used an enum?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T17:02:25Z",
      "diff_hunk" : "@@ -1106,8 +1110,64 @@ class CTransactionSignatureSerializer {\n \n } // anon namespace\n \n-uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, int sigversion)\n {\n+    if (sigversion == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61296431",
      "id" : 61296431,
      "original_commit_id" : "d374139b87d96a3ab4582351ddf52f57b85aee3d",
      "original_position" : 54,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61296431",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61302292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61302292"
         }
      },
      "body" : "maybe rebase error?  nextblockhash is repeated.  to keep the order the same as output, chainwork should go before previousblockhash and nextblockhash.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T17:36:36Z",
      "diff_hunk" : "@@ -331,6 +333,7 @@ UniValue getblockheader(const UniValue& params, bool fHelp)\n             \"  \\\"previousblockhash\\\" : \\\"hash\\\",  (string) The hash of the previous block\\n\"\n             \"  \\\"nextblockhash\\\" : \\\"hash\\\",      (string) The hash of the next block\\n\"\n             \"  \\\"chainwork\\\" : \\\"0000...1f3\\\"     (string) Expected number of hashes required to produce the current chain (in hex)\\n\"\n+            \"  \\\"nextblockhash\\\" : \\\"hash\\\"       (string) The hash of the next block\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61302292",
      "id" : 61302292,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 15,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61302292",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61305131"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61305131"
         }
      },
      "body" : "the ordering has always been wrong: https://github.com/bitcoin/bitcoin/pull/7194",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T17:52:59Z",
      "diff_hunk" : "@@ -331,6 +333,7 @@ UniValue getblockheader(const UniValue& params, bool fHelp)\n             \"  \\\"previousblockhash\\\" : \\\"hash\\\",  (string) The hash of the previous block\\n\"\n             \"  \\\"nextblockhash\\\" : \\\"hash\\\",      (string) The hash of the next block\\n\"\n             \"  \\\"chainwork\\\" : \\\"0000...1f3\\\"     (string) Expected number of hashes required to produce the current chain (in hex)\\n\"\n+            \"  \\\"nextblockhash\\\" : \\\"hash\\\"       (string) The hash of the next block\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61305131",
      "id" : 61305131,
      "original_commit_id" : "81b3d67eac896bcc64c18cc1c31ee27c8ab919bf",
      "original_position" : 15,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61305131",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61351055"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61351055"
         }
      },
      "body" : "Going to replace it with an extra delay before witness transactions are accepted to the mempool.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T22:58:29Z",
      "diff_hunk" : "@@ -183,6 +186,9 @@ CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& s\n \n             const CTransaction& tx = iter->GetTx();\n \n+            if (!fIncludeWitness && !tx.wit.IsNull())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61351055",
      "id" : 61351055,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 14,
      "path" : "src/miner.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61351055",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61352908"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61352908"
         }
      },
      "body" : "@sipa I'm not sure it's necessary to replace it with anything.  Given the way versionbits soft forks activate, its not really possible to have it unactivate without an enormous reorg",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T23:17:35Z",
      "diff_hunk" : "@@ -183,6 +186,9 @@ CBlockTemplate* CreateNewBlock(const CChainParams& chainparams, const CScript& s\n \n             const CTransaction& tx = iter->GetTx();\n \n+            if (!fIncludeWitness && !tx.wit.IsNull())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61352908",
      "id" : 61352908,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 14,
      "path" : "src/miner.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61352908",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61354416"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61354416"
         }
      },
      "body" : "Indeed, and likewise for the misbehaviour assignment.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T23:34:08Z",
      "diff_hunk" : "@@ -5176,8 +5185,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             if (nEvicted > 0)\n                 LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n         } else {\n-            assert(recentRejects);\n-            recentRejects->insert(tx.GetHash());\n+            if (!state.CorruptionPossible()) {\n+                assert(recentRejects);\n+                recentRejects->insert(tx.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61354416",
      "id" : 61354416,
      "original_commit_id" : "1e478052ca3222d13ce3646dd152ebcf27f07e76",
      "original_position" : 28,
      "path" : "src/main.cpp",
      "position" : 705,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61354416",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61356165"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61356165"
         }
      },
      "body" : "Oh yes!",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-27T23:54:29Z",
      "diff_hunk" : "@@ -1106,8 +1110,64 @@ class CTransactionSignatureSerializer {\n \n } // anon namespace\n \n-uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, int sigversion)\n {\n+    if (sigversion == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61356165",
      "id" : 61356165,
      "original_commit_id" : "d374139b87d96a3ab4582351ddf52f57b85aee3d",
      "original_position" : 54,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61356165",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Pushed a new batch of fixups.",
      "created_at" : "2016-04-28T12:32:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-215409199",
      "id" : 215409199,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-04-28T12:32:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/215409199",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61426731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61426731"
         }
      },
      "body" : "this is redundant to line 286 now",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-28T13:31:50Z",
      "diff_hunk" : "@@ -194,8 +199,140 @@ class CTxOut\n     std::string ToString() const;\n };\n \n+class CTxinWitness\n+{\n+public:\n+    CScriptWitness scriptWitness;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(scriptWitness.stack);\n+    }\n+\n+    bool IsNull() const { return scriptWitness.IsNull(); }\n+\n+    CTxinWitness() { }\n+};\n+\n+class CTxWitness\n+{\n+public:\n+    /** In case vtxinwit is missing, all entries are treated as if they were empty CTxInWitnesses */\n+    std::vector<CTxinWitness> vtxinwit;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    bool IsEmpty() const { return vtxinwit.empty(); }\n+\n+    bool IsNull() const\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            if (!vtxinwit[n].IsNull()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void SetNull()\n+    {\n+        vtxinwit.clear();\n+    }\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            READWRITE(vtxinwit[n]);\n+        }\n+        if (IsNull()) {\n+            /* It's illegal to encode a witness when all vtxinwit entries are empty. */\n+            throw std::ios_base::failure(\"Superfluous witness record\");\n+        }\n+    }\n+};\n+\n struct CMutableTransaction;\n \n+/**\n+ * Basic transaction serialization format:\n+ * - int32_t nVersion\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - uint32_t nLockTime\n+ *\n+ * Extended transaction serialization format:\n+ * - int32_t nVersion\n+ * - unsigned char dummy = 0x00\n+ * - unsigned char flags (!= 0)\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - if (flags & 1):\n+ *   - CTxWitness wit;\n+ * - uint32_t nLockTime\n+ */\n+template<typename Stream, typename Operation, typename TxType>\n+inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, int nType, int nVersion) {\n+    READWRITE(*const_cast<int32_t*>(&tx.nVersion));\n+    unsigned char flags = 0;\n+    /* Verify that exactly one of SERIALIZE_TRANSACTION_WITNESS and SERIALIZE_TRANSACTION_NO_WITESS is set */\n+    assert(!(nVersion & SERIALIZE_TRANSACTION_WITNESS) ^ !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS));\n+    if (ser_action.ForRead()) {\n+        const_cast<std::vector<CTxIn>*>(&tx.vin)->clear();\n+        const_cast<std::vector<CTxOut>*>(&tx.vout)->clear();\n+        const_cast<CTxWitness*>(&tx.wit)->SetNull();\n+        /* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */\n+        READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+        if (tx.vin.size() == 0 && !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+            /* We read a dummy or an empty vin. */\n+            READWRITE(flags);\n+            if (flags != 0) {\n+                READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+                READWRITE(*const_cast<std::vector<CTxOut>*>(&tx.vout));\n+            }\n+        } else {\n+            /* We read a non-empty vin. Assume a normal vout follows. */\n+            READWRITE(*const_cast<std::vector<CTxOut>*>(&tx.vout));\n+        }\n+        const_cast<CTxWitness*>(&tx.wit)->SetNull();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61426731",
      "id" : 61426731,
      "original_commit_id" : "588da1e3a35c75c1d4cbe50b0224cca810db0bf0",
      "original_position" : 114,
      "path" : "src/primitives/transaction.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61426731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61438709"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61438709"
         }
      },
      "body" : "do we also need to remove it from mapBlocksUnlinked?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-28T14:41:59Z",
      "diff_hunk" : "@@ -3901,6 +4059,68 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+bool RewindBlockIndex(const CChainParams& params)\n+{\n+    LOCK(cs_main);\n+\n+    int nHeight = 1;\n+    while (nHeight <= chainActive.Height()) {\n+        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+            break;\n+        }\n+        nHeight++;\n+    }\n+\n+    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+    CValidationState state;\n+    CBlockIndex* pindex = chainActive.Tip();\n+    while (chainActive.Height() >= nHeight) {\n+        if (!DisconnectTip(state, params, true)) {\n+            return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n+        }\n+        // Occasionally flush state to disk.\n+        if (!FlushStateToDisk(state, FLUSH_STATE_PERIODIC))\n+            return false;\n+    }\n+\n+    // Reduce validity flag and have-data flags.\n+    // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n+    // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n+    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n+        CBlockIndex* pindexIter = it->second;\n+        if (IsWitnessEnabled(pindexIter->pprev, params.GetConsensus()) && !(pindexIter->nStatus & BLOCK_OPT_WITNESS)) {\n+            // Reduce validity\n+            pindexIter->nStatus = std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (pindexIter->nStatus & ~BLOCK_VALID_MASK);\n+            // Remove have-data flags.\n+            pindexIter->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n+            // Remove storage location.\n+            pindexIter->nFile = 0;\n+            pindexIter->nDataPos = 0;\n+            pindexIter->nUndoPos = 0;\n+            // Remove various other things\n+            pindexIter->nTx = 0;\n+            pindexIter->nChainTx = 0;\n+            pindexIter->nSequenceId = 0;\n+            // Make sure it gets written.\n+            setDirtyBlockIndex.insert(pindexIter);\n+            // Update setBlockIndexCandidates\n+            setBlockIndexCandidates.erase(pindexIter);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61438709",
      "id" : 61438709,
      "original_commit_id" : "588da1e3a35c75c1d4cbe50b0224cca810db0bf0",
      "original_position" : 529,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61438709",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61521620"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61521620"
         }
      },
      "body" : "This variable doesn't appear to be used by anything; I assume this was introduced before switching to the service bit, not sure if you intended to leave it here as a useful marker, or remove?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-29T00:06:10Z",
      "diff_hunk" : "@@ -39,4 +39,7 @@ static const int SENDHEADERS_VERSION = 70012;\n //! \"feefilter\" tells peers to filter invs to you by fee starts with this version\n static const int FEEFILTER_VERSION = 70013;\n \n+//! Version after which witness support potentially exists\n+static const int WITNESS_VERSION = 70013;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61521620",
      "id" : 61521620,
      "original_commit_id" : "588da1e3a35c75c1d4cbe50b0224cca810db0bf0",
      "original_position" : 5,
      "path" : "src/version.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61521620",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61522239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61522239"
         }
      },
      "body" : "This logic will cause pruning nodes to fail (un-gracefully) if they try to upgrade after activation and the activation block has been pruned (which could be as short as two days).  I propose that for pruning nodes, we don't bother trying to rewind past their HAVE_DATA point.  \r\n\r\n",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-29T00:14:23Z",
      "diff_hunk" : "@@ -3901,6 +4059,68 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+bool RewindBlockIndex(const CChainParams& params)\n+{\n+    LOCK(cs_main);\n+\n+    int nHeight = 1;\n+    while (nHeight <= chainActive.Height()) {\n+        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+            break;\n+        }\n+        nHeight++;\n+    }\n+\n+    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+    CValidationState state;\n+    CBlockIndex* pindex = chainActive.Tip();\n+    while (chainActive.Height() >= nHeight) {\n+        if (!DisconnectTip(state, params, true)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61522239",
      "id" : 61522239,
      "original_commit_id" : "588da1e3a35c75c1d4cbe50b0224cca810db0bf0",
      "original_position" : 500,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61522239",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61636847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61636847"
         }
      },
      "body" : "// Making v1-v16 witness program non-standard",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-04-29T20:03:26Z",
      "diff_hunk" : "@@ -86,16 +86,30 @@ enum\n     //\n     // See BIP112 for details\n     SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10),\n+\n+    // Support segregated witness\n+    //\n+    SCRIPT_VERIFY_WITNESS = (1U << 11),\n+\n+    // Making v2-v16 witness program non-standard",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r61636847",
      "id" : 61636847,
      "original_commit_id" : "588da1e3a35c75c1d4cbe50b0224cca810db0bf0",
      "original_position" : 18,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/61636847",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "body" : "As requested in the last two IRC meetings, here's the coverage data for segwit (at 588da1e3a35c75c1d4cbe50b0224cca810db0bf0): https://dev.bitcoincore.org/cfields/post-segwit.coverage/\r\n\r\n~~It's missing branching data, and inlining throws off a few things, but I think it gives a good idea of what's being tested.~~ This data includes tests from test_bitcoin, the java pull-tester, and regular+extended rpc tests (minus pruning).\r\n\r\nA few interesting untested lines that jumped out at a glance:\r\nsrc/primitives/transaction.h:253\r\nsrc/primitives/transaction.h:309\r\n\r\nEdit: Updated with much more accurate info that now includes branching and auto-inlined funcs.",
      "created_at" : "2016-05-02T20:16:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-216350091",
      "id" : 216350091,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-03T00:49:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216350091",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "@theuni @sipa This cover both (to squash with my test commit): https://github.com/NicolasDorier/bitcoin/commit/ad366c56536019c180901194baa376d46052fb4a",
      "created_at" : "2016-05-03T03:54:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-216429678",
      "id" : 216429678,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-03T03:54:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216429678",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "https://github.com/sipa/bitcoin/pull/81/ increases coverage by causing a `SCRIPT_ERR_WITNESS_MALLEATED_P2SH` error.",
      "created_at" : "2016-05-04T01:59:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-216720008",
      "id" : 216720008,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-04T01:59:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/216720008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2582071?v=3",
         "events_url" : "https://api.github.com/users/jonasnick/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasnick/followers",
         "following_url" : "https://api.github.com/users/jonasnick/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasnick/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasnick",
         "id" : 2582071,
         "login" : "jonasnick",
         "organizations_url" : "https://api.github.com/users/jonasnick/orgs",
         "received_events_url" : "https://api.github.com/users/jonasnick/received_events",
         "repos_url" : "https://api.github.com/users/jonasnick/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasnick/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasnick/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasnick"
      }
   },
   {
      "body" : "I'm sorry, I still cannot read this. That doesn't mean that I think the PR is not well written or it's incomplete.\r\nIt's just too much to review for me personally. Completely selfishly, I will promote a division of the PR in 2:\r\n\r\n1) do the most tested still-not-activate consensus changes in 0.12.99 as soon that part is ready.\r\nI don't think we're too far away from that, people have been really testing this since last time I wrote I line on it (which has been re-written a hundred times already).  I'm not trying to claim any credit I don't deserve (that would be the only \"sin\" I couldn't tollerate in any culture, I am really really tolerant for \"mew\" cultures I don't know about): I will review that.\r\n\r\nWhat about consensus -about-ready and the rest we merge next?\r\n\r\nThere shouldn't be many more fixes, specially in the consensus part, let's just separate review and belief. At this point, I bealieve...|\r\n\r\nTL:DR;\r\n\r\nIf this is not going to be merged soon, let's get the inoucuous consensus part firt, now, or...whenever, the timing is not important. That' my nit, I think.\r\n\r\nI simply cannot review consensus-ready changes and the future at the same time.\r\nSimple consensus with bip9 it's the review I'll do. Backport consensus rules, and then the actually useful stuff can join later too.\r\n\r\nEDIT Please, let's just do the consensus commits first without activation and ley's not encourage anyone to upgrade. Than we can review much more easily",
      "created_at" : "2016-05-05T03:38:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-217070795",
      "id" : 217070795,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-05T05:55:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/217070795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "@jtimon All the consensus logic is already combined into a single group of commits (see https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-211998958 which I maintain for every push). As mentioned several times in the weekly meetings, I'm also not rebasing anymore, so you don't have to worry about review going stale.\r\n",
      "created_at" : "2016-05-10T01:58:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-218039952",
      "id" : 218039952,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-10T01:58:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/218039952",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r62604879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62604879"
         }
      },
      "body" : "+    // * ~~The~~There must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\r\n ",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-10T02:39:51Z",
      "diff_hunk" : "@@ -3350,6 +3461,53 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // Validation for witness commitments.\n+    // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n+    //   coinbase (where 0x0000....0000 is used instead).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n+    // * The must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r62604879",
      "id" : 62604879,
      "original_commit_id" : "ad4f9c71d030b2de822c4b9245d818479a66b605",
      "original_position" : 426,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62604879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2033945?v=3",
         "events_url" : "https://api.github.com/users/wallclockbuilder/events{/privacy}",
         "followers_url" : "https://api.github.com/users/wallclockbuilder/followers",
         "following_url" : "https://api.github.com/users/wallclockbuilder/following{/other_user}",
         "gists_url" : "https://api.github.com/users/wallclockbuilder/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/wallclockbuilder",
         "id" : 2033945,
         "login" : "wallclockbuilder",
         "organizations_url" : "https://api.github.com/users/wallclockbuilder/orgs",
         "received_events_url" : "https://api.github.com/users/wallclockbuilder/received_events",
         "repos_url" : "https://api.github.com/users/wallclockbuilder/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/wallclockbuilder/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/wallclockbuilder/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/wallclockbuilder"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r62776324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62776324"
         }
      },
      "body" : "Sounds good, can you provide a patch?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-11T00:26:11Z",
      "diff_hunk" : "@@ -3901,6 +4059,68 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+bool RewindBlockIndex(const CChainParams& params)\n+{\n+    LOCK(cs_main);\n+\n+    int nHeight = 1;\n+    while (nHeight <= chainActive.Height()) {\n+        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+            break;\n+        }\n+        nHeight++;\n+    }\n+\n+    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+    CValidationState state;\n+    CBlockIndex* pindex = chainActive.Tip();\n+    while (chainActive.Height() >= nHeight) {\n+        if (!DisconnectTip(state, params, true)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r62776324",
      "id" : 62776324,
      "original_commit_id" : "588da1e3a35c75c1d4cbe50b0224cca810db0bf0",
      "original_position" : 500,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/62776324",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "More comments and nits addressed, testnet activation included, separated -maxblocksize and -maxblockcost (by @luke-jr).",
      "created_at" : "2016-05-11T07:42:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-218385522",
      "id" : 218385522,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-11T07:42:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/218385522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Since signature/witness data gets a 75% discount in the new cost calculation, I'm wondering if the constant of `148u` in `GetDustThreshold` in transaction.h should be updated too?\r\nShould that be changed to `108*0.25 + 32 + 4 + 4 = 67` ?",
      "created_at" : "2016-05-12T13:19:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-218754334",
      "id" : 218754334,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-12T13:19:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/218754334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6440430?v=3",
         "events_url" : "https://api.github.com/users/mruddy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mruddy/followers",
         "following_url" : "https://api.github.com/users/mruddy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mruddy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mruddy",
         "id" : 6440430,
         "login" : "mruddy",
         "organizations_url" : "https://api.github.com/users/mruddy/orgs",
         "received_events_url" : "https://api.github.com/users/mruddy/received_events",
         "repos_url" : "https://api.github.com/users/mruddy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mruddy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mruddy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mruddy"
      }
   },
   {
      "body" : "I added a commit section \"commentary\" that contains comments on the changes (and not on the resulting code). Maybe they're useful for people asking \"why is X being changed?\".",
      "created_at" : "2016-05-15T00:40:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-219259461",
      "id" : 219259461,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-15T00:40:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/219259461",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64025439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64025439"
         }
      },
      "body" : "This casts uint64_t -> int64_t.\r\nShould probably test the uint64_t directly against MAX_MONEY and fail immediately here as necessary.\r\n\r\nMaybe bitcoinconsensus_ERR_TX_AMOUNT_VALUE?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-20T11:13:08Z",
      "diff_hunk" : "@@ -69,29 +69,49 @@ struct ECCryptoClosure\n ECCryptoClosure instance_of_eccryptoclosure;\n }\n \n-int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n+static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, CAmount amount,\n                                     const unsigned char *txTo        , unsigned int txToLen,\n                                     unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n {\n     try {\n-        TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION, txTo, txToLen);\n+        TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS, txTo, txToLen);\n         CTransaction tx;\n         stream >> tx;\n         if (nIn >= tx.vin.size())\n             return set_error(err, bitcoinconsensus_ERR_TX_INDEX);\n-        if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION) != txToLen)\n+        if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS) != txToLen)\n             return set_error(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n \n-         // Regardless of the verification result, the tx did not error.\n-         set_error(err, bitcoinconsensus_ERR_OK);\n+        // Regardless of the verification result, the tx did not error.\n+        set_error(err, bitcoinconsensus_ERR_OK);\n \n-        CAmount am(0);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, am), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, amount), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }\n }\n \n+int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, uint64_t amount,\n+                                    const unsigned char *txTo        , unsigned int txToLen,\n+                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+{\n+    CAmount am(amount);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64025439",
      "id" : 64025439,
      "original_commit_id" : "e5735719c437a3cd15665e533e7db4b31e280397",
      "original_position" : 37,
      "path" : "src/script/bitcoinconsensus.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64025439",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64027026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64027026"
         }
      },
      "body" : "It looks like none of the tests actually use a non-zero value -- seems like we should add a way to exercise the code in the non-zero value case (as the zero case is special).",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-20T11:30:13Z",
      "diff_hunk" : "@@ -152,16 +152,16 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, co\n         flags |= SCRIPT_VERIFY_WITNESS;\n     }\n     ScriptError err;\n-    CMutableTransaction tx = BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey));\n+    CMutableTransaction txCredit = BuildCreditingTransaction(scriptPubKey);\n+    CMutableTransaction tx = BuildSpendingTransaction(scriptSig, txCredit);\n     CMutableTransaction tx2 = tx;\n-    static const CAmount amountZero = 0;\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0, amountZero), &err) == expect, message);\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, std::string(FormatScriptError(err)) + \" where \" + std::string(FormatScriptError((ScriptError_t)scriptError)) + \" expected: \" + message);\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n     if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n-        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), amountZero, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n+        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64027026",
      "id" : 64027026,
      "original_commit_id" : "abbe085caeecd33f5c4c9a27d4981f84896846b8",
      "original_position" : 17,
      "path" : "src/test/script_tests.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64027026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64033059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64033059"
         }
      },
      "body" : "Or just accept int64_t, as amounts are never interpreted as unsigned..",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-20T12:28:16Z",
      "diff_hunk" : "@@ -69,29 +69,49 @@ struct ECCryptoClosure\n ECCryptoClosure instance_of_eccryptoclosure;\n }\n \n-int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n+static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, CAmount amount,\n                                     const unsigned char *txTo        , unsigned int txToLen,\n                                     unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n {\n     try {\n-        TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION, txTo, txToLen);\n+        TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS, txTo, txToLen);\n         CTransaction tx;\n         stream >> tx;\n         if (nIn >= tx.vin.size())\n             return set_error(err, bitcoinconsensus_ERR_TX_INDEX);\n-        if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION) != txToLen)\n+        if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS) != txToLen)\n             return set_error(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n \n-         // Regardless of the verification result, the tx did not error.\n-         set_error(err, bitcoinconsensus_ERR_OK);\n+        // Regardless of the verification result, the tx did not error.\n+        set_error(err, bitcoinconsensus_ERR_OK);\n \n-        CAmount am(0);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, am), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, amount), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }\n }\n \n+int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, uint64_t amount,\n+                                    const unsigned char *txTo        , unsigned int txToLen,\n+                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+{\n+    CAmount am(amount);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64033059",
      "id" : 64033059,
      "original_commit_id" : "e5735719c437a3cd15665e533e7db4b31e280397",
      "original_position" : 37,
      "path" : "src/script/bitcoinconsensus.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64033059",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5617245?v=3",
         "events_url" : "https://api.github.com/users/afk11/events{/privacy}",
         "followers_url" : "https://api.github.com/users/afk11/followers",
         "following_url" : "https://api.github.com/users/afk11/following{/other_user}",
         "gists_url" : "https://api.github.com/users/afk11/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/afk11",
         "id" : 5617245,
         "login" : "afk11",
         "organizations_url" : "https://api.github.com/users/afk11/orgs",
         "received_events_url" : "https://api.github.com/users/afk11/received_events",
         "repos_url" : "https://api.github.com/users/afk11/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/afk11/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/afk11/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/afk11"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64034244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64034244"
         }
      },
      "body" : "I assumed that (self-documentation) was the reason for the uint64_t.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-20T12:39:10Z",
      "diff_hunk" : "@@ -69,29 +69,49 @@ struct ECCryptoClosure\n ECCryptoClosure instance_of_eccryptoclosure;\n }\n \n-int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n+static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, CAmount amount,\n                                     const unsigned char *txTo        , unsigned int txToLen,\n                                     unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n {\n     try {\n-        TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION, txTo, txToLen);\n+        TxInputStream stream(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS, txTo, txToLen);\n         CTransaction tx;\n         stream >> tx;\n         if (nIn >= tx.vin.size())\n             return set_error(err, bitcoinconsensus_ERR_TX_INDEX);\n-        if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION) != txToLen)\n+        if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS) != txToLen)\n             return set_error(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n \n-         // Regardless of the verification result, the tx did not error.\n-         set_error(err, bitcoinconsensus_ERR_OK);\n+        // Regardless of the verification result, the tx did not error.\n+        set_error(err, bitcoinconsensus_ERR_OK);\n \n-        CAmount am(0);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, am), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, amount), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }\n }\n \n+int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, uint64_t amount,\n+                                    const unsigned char *txTo        , unsigned int txToLen,\n+                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+{\n+    CAmount am(amount);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64034244",
      "id" : 64034244,
      "original_commit_id" : "e5735719c437a3cd15665e533e7db4b31e280397",
      "original_position" : 37,
      "path" : "src/script/bitcoinconsensus.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64034244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64095501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64095501"
         }
      },
      "body" : "do you mind explaining this calculation?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-20T19:32:53Z",
      "diff_hunk" : "@@ -173,13 +173,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000\n         max_bytes_available = max_bytes_per_day - daily_buffer\n         success_count = max_bytes_available // old_block_size\n \n-        # 144MB will be reserved for relaying new blocks, so expect this to\n-        # succeed for ~70 tries.\n+        # 576MB will be reserved for relaying new blocks, so expect this to\n+        # succeed for ~235 tries.\n         for i in range(success_count):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64095501",
      "id" : 64095501,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 24,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 24,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64095501",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1424850?v=3",
         "events_url" : "https://api.github.com/users/nicola/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nicola/followers",
         "following_url" : "https://api.github.com/users/nicola/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nicola/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nicola",
         "id" : 1424850,
         "login" : "nicola",
         "organizations_url" : "https://api.github.com/users/nicola/orgs",
         "received_events_url" : "https://api.github.com/users/nicola/received_events",
         "repos_url" : "https://api.github.com/users/nicola/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nicola/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nicola/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nicola"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131407"
         }
      },
      "body" : "nit: I think we should place this in a utility class and use the same implementation also for bitcoin-txs (`static CAmount AmountFromValue(const UniValue& value)`). Can be done post this PR.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T08:46:19Z",
      "diff_hunk" : "@@ -358,6 +358,18 @@ vector<unsigned char> ParseHexUO(map<string,UniValue>& o, string strKey)\n     return ParseHexUV(o[strKey], strKey);\n }\n \n+static CAmount AmountFromValue(const UniValue& value)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131407",
      "id" : 64131407,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 13,
      "path" : "src/bitcoin-tx.cpp",
      "position" : 13,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131407",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131412"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131412"
         }
      },
      "body" : "nit: \"Uncommited\" -> \"Uncommitted\"",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T08:47:44Z",
      "diff_hunk" : "@@ -3297,6 +3356,71 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n+{\n+    LOCK(cs_main);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_WITNESS, versionbitscache) == THRESHOLD_ACTIVE);\n+}\n+\n+// Compute at which vout of the block's coinbase transaction the witness\n+// commitment occurs, or -1 if not found.\n+static int GetWitnessCommitmentIndex(const CBlock& block)\n+{\n+    int commitpos = -1;\n+    for (size_t o = 0; o < block.vtx[0].vout.size(); o++) {\n+        if (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {\n+            commitpos = o;\n+        }\n+    }\n+    return commitpos;\n+}\n+\n+void UpdateUncommitedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131412",
      "id" : 64131412,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 381,
      "path" : "src/main.cpp",
      "position" : 328,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131412",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131454"
         }
      },
      "body" : "nit: s/mode. \")/mode.\")/",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T08:51:53Z",
      "diff_hunk" : "@@ -21,6 +22,7 @@ void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp)\n     if (debugHelp) {\n         strUsage += HelpMessageOpt(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n                                    \"This is intended for regression testing tools and app development.\");\n+        strUsage += HelpMessageOpt(\"-segnet\", \"Enter segregated witness test mode. \");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131454",
      "id" : 64131454,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 12,
      "path" : "src/chainparamsbase.cpp",
      "position" : 12,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131454",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131474"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131474"
         }
      },
      "body" : "This may be too much bikeshedding, but I think this would be clearer as `MAX_BLOCK_SIZE_COST ` (and eg `GetBlockSizeCost()` elsewhere) to distinguish from the `MAX_BLOCK_SIGOPS_COST`.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T08:53:49Z",
      "diff_hunk" : "@@ -6,10 +6,16 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+#include <stdint.h>\n+\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */\n+static const unsigned int MAX_BLOCK_COST = 4000000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131474",
      "id" : 64131474,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 11,
      "path" : "src/consensus/consensus.h",
      "position" : 11,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131474",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131609"
         }
      },
      "body" : "~~I think \"GetWitnessProgramForScript\" is more direct and clear.~~\r\n\r\nI had a misunderstanding of \"witness program\" definition somehow. \r\n\r\n\"GetScriptForWitnessScript\" isn't much clearer either. Hm.\r\n\r\n",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T09:08:45Z",
      "diff_hunk" : "@@ -282,3 +300,26 @@ CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys)\n     script << CScript::EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n     return script;\n }\n+\n+CScript GetScriptForWitness(const CScript& redeemscript)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131609",
      "id" : 64131609,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 37,
      "path" : "src/script/standard.cpp",
      "position" : 37,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131609",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131750"
         }
      },
      "body" : "WitnessProgram has a specific meaning, which is defined in https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program \r\n\r\nTherefore, this function would be better named as \"VerifyWitness\".",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T09:23:22Z",
      "diff_hunk" : "@@ -1239,28 +1299,106 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131750",
      "id" : 64131750,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 136,
      "path" : "src/script/interpreter.cpp",
      "position" : 136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131853"
         }
      },
      "body" : "Phrasing bothering me. The cleanstackness is implicit(not using the flag) but it requiring some new behavior is surely explicit here. Perhaps rewrite as:\r\n\r\n// Scripts inside witness require implicit cleanstack behavior as a consensus rule.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T09:36:34Z",
      "diff_hunk" : "@@ -1239,28 +1299,106 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n+    vector<vector<unsigned char> > stack;\n+    CScript scriptPubKey;\n+\n+    if (witversion == 0) {\n+        if (program.size() == 32) {\n+            // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n+            if (witness.stack.size() == 0) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+            }\n+            scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n+            stack = std::vector<std::vector<unsigned char> >(witness.stack.begin(), witness.stack.end() - 1);\n+            uint256 hashScriptPubKey;\n+            CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n+            if (memcmp(hashScriptPubKey.begin(), &program[0], 32)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+        } else if (program.size() == 20) {\n+            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            if (witness.stack.size() != 2) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n+            }\n+            scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n+            stack = witness.stack;\n+        } else {\n+            return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n+        }\n+    } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n+        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n+    } else {\n+        // Higher version witness scripts return true for future softfork compatibility\n+        return set_success(serror);\n+    }\n+\n+    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n+    for (unsigned int i = 0; i < stack.size(); i++) {\n+        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE)\n+            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+    }\n+\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n+        return false;\n+    }\n+\n+    // Scripts inside witness implicitly require cleanstack behaviour",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131853",
      "id" : 64131853,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 181,
      "path" : "src/script/interpreter.cpp",
      "position" : 181,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131853",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131992"
         }
      },
      "body" : "s/actual/base/ ?\r\n\r\n",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T09:49:31Z",
      "diff_hunk" : "@@ -1239,28 +1299,106 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n+    vector<vector<unsigned char> > stack;\n+    CScript scriptPubKey;\n+\n+    if (witversion == 0) {\n+        if (program.size() == 32) {\n+            // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n+            if (witness.stack.size() == 0) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+            }\n+            scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n+            stack = std::vector<std::vector<unsigned char> >(witness.stack.begin(), witness.stack.end() - 1);\n+            uint256 hashScriptPubKey;\n+            CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n+            if (memcmp(hashScriptPubKey.begin(), &program[0], 32)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+        } else if (program.size() == 20) {\n+            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            if (witness.stack.size() != 2) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n+            }\n+            scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n+            stack = witness.stack;\n+        } else {\n+            return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n+        }\n+    } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n+        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n+    } else {\n+        // Higher version witness scripts return true for future softfork compatibility\n+        return set_success(serror);\n+    }\n+\n+    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n+    for (unsigned int i = 0; i < stack.size(); i++) {\n+        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE)\n+            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+    }\n+\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n+        return false;\n+    }\n+\n+    // Scripts inside witness implicitly require cleanstack behaviour\n+    if (stack.size() != 1)\n+        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    if (!CastToBool(stack.back()))\n+        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    return true;\n+}\n+\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+{\n+    static const CScriptWitness emptyWitness;\n+    if (witness == NULL) {\n+        witness = &emptyWitness;\n+    }\n+    bool hadWitness = false;\n+\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n \n     if ((flags & SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n         return set_error(serror, SCRIPT_ERR_SIG_PUSHONLY);\n     }\n \n     vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, serror))\n+    if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, serror))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n     if (stack.empty())\n         return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     if (CastToBool(stack.back()) == false)\n         return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n \n+    // Bare witness programs\n+    int witnessversion;\n+    std::vector<unsigned char> witnessprogram;\n+    if (flags & SCRIPT_VERIFY_WITNESS) {\n+        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+            hadWitness = true;\n+            if (scriptSig.size() != 0) {\n+                // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n+                return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n+            }\n+            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                return false;\n+            }\n+            // Bypass the cleanstack check at the end. The actual stack is obviously not clean",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64131992",
      "id" : 64131992,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 232,
      "path" : "src/script/interpreter.cpp",
      "position" : 232,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64131992",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64132010"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64132010"
         }
      },
      "body" : "s/actual/base/",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T09:51:15Z",
      "diff_hunk" : "@@ -1280,26 +1418,102 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stack);\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, serror))\n+        if (!EvalScript(stack, pubKey2, flags, checker, SIGVERSION_BASE, serror))\n             // serror is set\n             return false;\n         if (stack.empty())\n             return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n         if (!CastToBool(stack.back()))\n             return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+\n+        // P2SH witness program\n+        if (flags & SCRIPT_VERIFY_WITNESS) {\n+            if (pubKey2.IsWitnessProgram(witnessversion, witnessprogram)) {\n+                hadWitness = true;\n+                if (scriptSig != CScript() << std::vector<unsigned char>(pubKey2.begin(), pubKey2.end())) {\n+                    // The scriptSig must be _exactly_ a single push of the redeemScript. Otherwise we\n+                    // reintroduce malleability.\n+                    return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);\n+                }\n+                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                    return false;\n+                }\n+                // Bypass the cleanstack check at the end. The actual stack is obviously not clean",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64132010",
      "id" : 64132010,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 266,
      "path" : "src/script/interpreter.cpp",
      "position" : 266,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64132010",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64135342"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64135342"
         }
      },
      "body" : "nit: This comment would also be useful in GetTransactionCost, since the reasoning appears identical.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-21T14:36:13Z",
      "diff_hunk" : "@@ -31,3 +31,12 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n+\n+int64_t GetBlockCost(const CBlock& block)\n+{\n+    // This implements the cost = (stripped_size * 4) + witness_size formula,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64135342",
      "id" : 64135342,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 7,
      "path" : "src/primitives/block.cpp",
      "position" : 7,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64135342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147047"
         }
      },
      "body" : "Why can't this still be `const`?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-22T09:31:59Z",
      "diff_hunk" : "@@ -511,7 +512,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     UniValue transactions(UniValue::VARR);\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {\n+    BOOST_FOREACH (CTransaction& tx, pblock->vtx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147047",
      "id" : 64147047,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 24,
      "path" : "src/rpc/mining.cpp",
      "position" : 61,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147135"
         }
      },
      "body" : "No clue!",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-22T09:42:52Z",
      "diff_hunk" : "@@ -511,7 +512,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     UniValue transactions(UniValue::VARR);\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {\n+    BOOST_FOREACH (CTransaction& tx, pblock->vtx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147135",
      "id" : 64147135,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 24,
      "path" : "src/rpc/mining.cpp",
      "position" : 61,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147135",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147230"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147230"
         }
      },
      "body" : "self.test_node_test_witness_block with withWitness=False will do this fine",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-22T09:49:04Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147230",
      "id" : 64147230,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 262,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : 275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147230",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147996"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147996"
         }
      },
      "body" : "> No clue!\r\n\r\nAs in,  compiler error or is this a mistaken edit?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-22T10:53:29Z",
      "diff_hunk" : "@@ -511,7 +512,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     UniValue transactions(UniValue::VARR);\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {\n+    BOOST_FOREACH (CTransaction& tx, pblock->vtx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64147996",
      "id" : 64147996,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 24,
      "path" : "src/rpc/mining.cpp",
      "position" : 61,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64147996",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64405990"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64405990"
         }
      },
      "body" : "I suggest we change this to 4000000 so that pre-activation, miners who are setting only `-blockmaxsize` don't see a potential behavior change.\r\n\r\nFYI this is what is currently breaking `qa/rpc-tests/pruning.py`.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-24T14:51:24Z",
      "diff_hunk" : "@@ -19,6 +19,8 @@ static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n /** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 0;\n+/** Default for -blockmaxcost, which control the range of block costs the mining code will create **/\n+static const unsigned int DEFAULT_BLOCK_MAX_COST = 3000000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64405990",
      "id" : 64405990,
      "original_commit_id" : "1e9cba2873fd25270a5d368ece46362613ade9a4",
      "original_position" : 5,
      "path" : "src/policy/policy.h",
      "position" : 5,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64405990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64577749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64577749"
         }
      },
      "body" : "nit: mention that this violates consensus cleanstack",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-25T14:03:18Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64577749",
      "id" : 64577749,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 586,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : 599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64577749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64584415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64584415"
         }
      },
      "body" : "only the announcements are relayed in this code?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-25T14:38:04Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.extend([CTxinWitness(), CTxinWitness()])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+\n+        # This has extra witness data, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra witness, but add extra scriptSig data\n+        tx2.vin[0].scriptSig = CScript([OP_TRUE])\n+        tx2.vin[1].scriptSig = CScript([OP_TRUE])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack.pop(0)\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = []\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # This has extra signature data for a witness input, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra scriptsig on the witness input, and verify\n+        # success (even with extra scriptsig data in the non-witness input)\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update utxo for later tests\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_max_witness_push_length(self):\n+        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        print(\"\\tTesting maximum witness push size\")\n+        MAX_SCRIPT_ELEMENT_SIZE = 520\n+        assert(len(self.utxo))\n+\n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        # First try a 521-byte stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now reduce the length of the stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+\n+        add_witness_commitment(block)\n+        block.solve()\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update the utxo for later tests\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+    def test_max_witness_program_length(self):\n+        # Can create witness outputs that are long, but can't be greater than\n+        # 10k bytes to successfully spend\n+        print(\"\\tTesting maximum witness program length\")\n+        assert(len(self.utxo))\n+        MAX_PROGRAM_LENGTH = 10000\n+\n+        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_hash = sha256(long_witness_program)\n+        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+\n+        block = self.build_next_block()\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try again with one less byte in the witness program\n+        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.rehash()\n+        tx2.vin[0].prevout.hash = tx.sha256\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.rehash()\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_input_length(self):\n+        ''' Ensure that vin length must match vtxinwit length '''\n+        print(\"\\tTesting witness input length\")\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        \n+        # Create a transaction that splits our utxo into many outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        nValue = self.utxo[0].nValue\n+        for i in range(10):\n+            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+        tx.vout[0].nValue -= 1000\n+        assert(tx.vout[0].nValue >= 0)\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try various ways to spend tx that should all break.\n+        # This \"broken\" transaction serializer will not normalize\n+        # the length of vtxinwit.\n+        class BrokenCTransaction(CTransaction):\n+            def serialize_with_witness(self):\n+                flags = 0\n+                if not self.wit.is_null():\n+                    flags |= 1\n+                r = b\"\"\n+                r += struct.pack(\"<i\", self.nVersion)\n+                if flags:\n+                    dummy = []\n+                    r += ser_vector(dummy)\n+                    r += struct.pack(\"<B\", flags)\n+                r += ser_vector(self.vin)\n+                r += ser_vector(self.vout)\n+                if flags & 1:\n+                    r += self.wit.serialize()\n+                r += struct.pack(\"<I\", self.nLockTime)\n+                return r\n+\n+        tx2 = BrokenCTransaction()\n+        for i in range(10):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+\n+        # First try using a too long vtxinwit\n+        for i in range(11):\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now try using a too short vtxinwit\n+        tx2.wit.vtxinwit.pop()\n+        tx2.wit.vtxinwit.pop()\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now make one of the intermediate witnesses be incorrect\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Fix the broken witness and the block should be accepted.\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_getdata.inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        try:\n+            self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n+            print(\"Error: duplicate tx getdata!\")\n+            assert(False)\n+        except AssertionError as e:\n+            pass\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Verify that inv's to test_node come with getdata's for witness tx's\n+        # Just tweak the transaction, announce it, and verify we get a getdata\n+        # for a witness_tx\n+        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n+        tx.rehash()\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.test_node.last_getdata.inv[0].type == 1|MSG_WITNESS_FLAG)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+\n+    # After segwit activates, verify that mempool:\n+    # - rejects transactions with unnecessary/extra witnesses\n+    # - accepts transactions with valid witnesses\n+    # and that witness transactions are relayed to non-upgraded peers.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64584415",
      "id" : 64584415,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 859,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : 872,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64584415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64585393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64585393"
         }
      },
      "body" : "Good observation; we should verify that sending the two different kinds of `getdata` give the expected results.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-25T14:42:58Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.extend([CTxinWitness(), CTxinWitness()])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+\n+        # This has extra witness data, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra witness, but add extra scriptSig data\n+        tx2.vin[0].scriptSig = CScript([OP_TRUE])\n+        tx2.vin[1].scriptSig = CScript([OP_TRUE])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack.pop(0)\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = []\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # This has extra signature data for a witness input, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra scriptsig on the witness input, and verify\n+        # success (even with extra scriptsig data in the non-witness input)\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update utxo for later tests\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_max_witness_push_length(self):\n+        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        print(\"\\tTesting maximum witness push size\")\n+        MAX_SCRIPT_ELEMENT_SIZE = 520\n+        assert(len(self.utxo))\n+\n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        # First try a 521-byte stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now reduce the length of the stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+\n+        add_witness_commitment(block)\n+        block.solve()\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update the utxo for later tests\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+    def test_max_witness_program_length(self):\n+        # Can create witness outputs that are long, but can't be greater than\n+        # 10k bytes to successfully spend\n+        print(\"\\tTesting maximum witness program length\")\n+        assert(len(self.utxo))\n+        MAX_PROGRAM_LENGTH = 10000\n+\n+        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_hash = sha256(long_witness_program)\n+        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+\n+        block = self.build_next_block()\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try again with one less byte in the witness program\n+        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.rehash()\n+        tx2.vin[0].prevout.hash = tx.sha256\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.rehash()\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_input_length(self):\n+        ''' Ensure that vin length must match vtxinwit length '''\n+        print(\"\\tTesting witness input length\")\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        \n+        # Create a transaction that splits our utxo into many outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        nValue = self.utxo[0].nValue\n+        for i in range(10):\n+            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+        tx.vout[0].nValue -= 1000\n+        assert(tx.vout[0].nValue >= 0)\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try various ways to spend tx that should all break.\n+        # This \"broken\" transaction serializer will not normalize\n+        # the length of vtxinwit.\n+        class BrokenCTransaction(CTransaction):\n+            def serialize_with_witness(self):\n+                flags = 0\n+                if not self.wit.is_null():\n+                    flags |= 1\n+                r = b\"\"\n+                r += struct.pack(\"<i\", self.nVersion)\n+                if flags:\n+                    dummy = []\n+                    r += ser_vector(dummy)\n+                    r += struct.pack(\"<B\", flags)\n+                r += ser_vector(self.vin)\n+                r += ser_vector(self.vout)\n+                if flags & 1:\n+                    r += self.wit.serialize()\n+                r += struct.pack(\"<I\", self.nLockTime)\n+                return r\n+\n+        tx2 = BrokenCTransaction()\n+        for i in range(10):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+\n+        # First try using a too long vtxinwit\n+        for i in range(11):\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now try using a too short vtxinwit\n+        tx2.wit.vtxinwit.pop()\n+        tx2.wit.vtxinwit.pop()\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now make one of the intermediate witnesses be incorrect\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Fix the broken witness and the block should be accepted.\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_getdata.inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        try:\n+            self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n+            print(\"Error: duplicate tx getdata!\")\n+            assert(False)\n+        except AssertionError as e:\n+            pass\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Verify that inv's to test_node come with getdata's for witness tx's\n+        # Just tweak the transaction, announce it, and verify we get a getdata\n+        # for a witness_tx\n+        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n+        tx.rehash()\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.test_node.last_getdata.inv[0].type == 1|MSG_WITNESS_FLAG)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+\n+    # After segwit activates, verify that mempool:\n+    # - rejects transactions with unnecessary/extra witnesses\n+    # - accepts transactions with valid witnesses\n+    # and that witness transactions are relayed to non-upgraded peers.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64585393",
      "id" : 64585393,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 859,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : 872,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64585393",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64614163"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64614163"
         }
      },
      "body" : "Version 0 (and all references below)",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-25T17:17:58Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.extend([CTxinWitness(), CTxinWitness()])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+\n+        # This has extra witness data, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra witness, but add extra scriptSig data\n+        tx2.vin[0].scriptSig = CScript([OP_TRUE])\n+        tx2.vin[1].scriptSig = CScript([OP_TRUE])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack.pop(0)\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = []\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # This has extra signature data for a witness input, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra scriptsig on the witness input, and verify\n+        # success (even with extra scriptsig data in the non-witness input)\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update utxo for later tests\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_max_witness_push_length(self):\n+        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        print(\"\\tTesting maximum witness push size\")\n+        MAX_SCRIPT_ELEMENT_SIZE = 520\n+        assert(len(self.utxo))\n+\n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        # First try a 521-byte stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now reduce the length of the stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+\n+        add_witness_commitment(block)\n+        block.solve()\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update the utxo for later tests\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+    def test_max_witness_program_length(self):\n+        # Can create witness outputs that are long, but can't be greater than\n+        # 10k bytes to successfully spend\n+        print(\"\\tTesting maximum witness program length\")\n+        assert(len(self.utxo))\n+        MAX_PROGRAM_LENGTH = 10000\n+\n+        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_hash = sha256(long_witness_program)\n+        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+\n+        block = self.build_next_block()\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try again with one less byte in the witness program\n+        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.rehash()\n+        tx2.vin[0].prevout.hash = tx.sha256\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.rehash()\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_input_length(self):\n+        ''' Ensure that vin length must match vtxinwit length '''\n+        print(\"\\tTesting witness input length\")\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        \n+        # Create a transaction that splits our utxo into many outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        nValue = self.utxo[0].nValue\n+        for i in range(10):\n+            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+        tx.vout[0].nValue -= 1000\n+        assert(tx.vout[0].nValue >= 0)\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try various ways to spend tx that should all break.\n+        # This \"broken\" transaction serializer will not normalize\n+        # the length of vtxinwit.\n+        class BrokenCTransaction(CTransaction):\n+            def serialize_with_witness(self):\n+                flags = 0\n+                if not self.wit.is_null():\n+                    flags |= 1\n+                r = b\"\"\n+                r += struct.pack(\"<i\", self.nVersion)\n+                if flags:\n+                    dummy = []\n+                    r += ser_vector(dummy)\n+                    r += struct.pack(\"<B\", flags)\n+                r += ser_vector(self.vin)\n+                r += ser_vector(self.vout)\n+                if flags & 1:\n+                    r += self.wit.serialize()\n+                r += struct.pack(\"<I\", self.nLockTime)\n+                return r\n+\n+        tx2 = BrokenCTransaction()\n+        for i in range(10):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+\n+        # First try using a too long vtxinwit\n+        for i in range(11):\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now try using a too short vtxinwit\n+        tx2.wit.vtxinwit.pop()\n+        tx2.wit.vtxinwit.pop()\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now make one of the intermediate witnesses be incorrect\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Fix the broken witness and the block should be accepted.\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_getdata.inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        try:\n+            self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n+            print(\"Error: duplicate tx getdata!\")\n+            assert(False)\n+        except AssertionError as e:\n+            pass\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Verify that inv's to test_node come with getdata's for witness tx's\n+        # Just tweak the transaction, announce it, and verify we get a getdata\n+        # for a witness_tx\n+        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n+        tx.rehash()\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.test_node.last_getdata.inv[0].type == 1|MSG_WITNESS_FLAG)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+\n+    # After segwit activates, verify that mempool:\n+    # - rejects transactions with unnecessary/extra witnesses\n+    # - accepts transactions with valid witnesses\n+    # and that witness transactions are relayed to non-upgraded peers.\n+    def test_tx_relay_after_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected because we can't use a witness\n+        # when spending a non-witness output.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that unnecessary witnesses are rejected.\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # Verify that removing the witness succeeds.\n+        # Re-announcing won't result in a getdata for ~2.5 minutes, so just\n+        # deliver the modified transaction.\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Now try to add extra witness data to a valid witness tx.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n+        tx2.rehash()\n+\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx3.wit.vtxinwit.append(CTxinWitness())\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n+        tx3.rehash()\n+\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+\n+        # Get rid of the extra witness, and verify acceptance.\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        # Also check that old_node gets a tx announcement, even though this is\n+        # a witness transaction.\n+        self.old_node.wait_for_inv(CInv(1, tx2.sha256)) # wait until tx2 was inv'ed\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        self.old_node.wait_for_inv(CInv(1, tx3.sha256))\n+\n+        # Cleanup: mine the transactions and update utxo for next test\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    # Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG\n+    # This is true regardless of segwit activation.\n+    def test_block_relay(self, segwit_activated):\n+        print(\"\\tTesting block relay\")\n+\n+        # test_node has set NODE_WITNESS, so all getdata requests should be for\n+        # witness blocks.\n+        # Test announcing a block via inv results in a getdata, and that\n+        # announcing a version 4 or random VB block with a header results in a getdata\n+\n+        block1 = self.build_next_block()\n+        block1.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block1, True)\n+\n+        block2 = self.build_next_block(nVersion=4)\n+        block2.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block2, True)\n+\n+        block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n+        block3.solve()\n+        self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block3, True)\n+\n+        # Check that we can getdata for witness blocks or regular blocks,\n+        # and the right thing happens.\n+        if segwit_activated == False:\n+            # Before activation, we should be able to request old blocks with\n+            # or without witness, and they should be the same.\n+            chain_height = self.nodes[0].getblockcount()\n+            # Pick 10 random blocks on main chain, and verify that getdata's\n+            # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n+            all_heights = list(range(chain_height+1))\n+            random.shuffle(all_heights)\n+            all_heights = all_heights[0:10]\n+            for height in all_heights:\n+                block_hash = self.nodes[0].getblockhash(height)\n+                rpc_block = self.nodes[0].getblock(block_hash, False)\n+                block_hash = int(block_hash, 16)\n+                block = self.test_node.request_block(block_hash, 2)\n+                wit_block = self.test_node.request_block(block_hash, 2|MSG_WITNESS_FLAG)\n+                assert_equal(block.serialize(True), wit_block.serialize(True))\n+                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n+        else:\n+            # After activation, witness blocks and non-witness blocks should\n+            # be different.  Verify rpc getblock() returns witness blocks, while\n+            # getdata respects the requested type.\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [])\n+            # This gives us a witness commitment.\n+            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n+            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n+            self.test_node.test_witness_block(block, accepted=True)\n+            # Now try to retrieve it...\n+            rpc_block = self.nodes[0].getblock(block.hash, False)\n+            non_wit_block = self.test_node.request_block(block.sha256, 2)\n+            wit_block = self.test_node.request_block(block.sha256, 2|MSG_WITNESS_FLAG)\n+            assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n+            assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n+            assert_equal(wit_block.serialize(True), block.serialize(True))\n+\n+\n+    # Verify that future segwit upgraded transactions are non-standard,\n+    # but valid in blocks. Can run this before and after segwit activation.\n+    def test_segwit_versions(self):\n+        print(\"\\tTesting standardness/consensus for segwit versions (0-16)\")\n+        assert(len(self.utxo))\n+        NUM_TESTS = 17 # will test OP_0, OP1, ..., OP_16\n+        if (len(self.utxo) < NUM_TESTS):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+            split_value = (self.utxo[0].nValue - 4000) // NUM_TESTS\n+            for i in range(NUM_TESTS):\n+                tx.vout.append(CTxOut(split_value, CScript([OP_TRUE])))\n+            tx.rehash()\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [tx])\n+            self.test_node.test_witness_block(block, accepted=True)\n+            self.utxo.pop(0)\n+            for i in range(NUM_TESTS):\n+                self.utxo.append(UTXO(tx.sha256, i, split_value))\n+\n+        sync_blocks(self.nodes)\n+        temp_utxo = []\n+        tx = CTransaction()\n+        count = 0\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        for version in list(range(OP_1, OP_16+1)) + [OP_0]:\n+            count += 1\n+            # First try to spend to a future version segwit scriptPubKey.\n+            scriptPubKey = CScript([CScriptOp(version), witness_hash])\n+            tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n+            tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n+            tx.rehash()\n+            self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+            self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+            self.utxo.pop(0)\n+            temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+        self.nodes[0].generate(1) # Mine all the transactions\n+        sync_blocks(self.nodes)\n+        assert(len(self.nodes[0].getrawmempool()) == 0)\n+\n+        # Finally, verify that version 0 -> version 1 transactions\n+        # are non-standard\n+        scriptPubKey = CScript([CScriptOp(OP_1), witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+        tx2.vout = [CTxOut(tx.vout[0].nValue-1000, scriptPubKey)]\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        tx2.rehash()\n+        # Gets accepted to test_node, because standardness of outputs isn't\n+        # checked with fRequireStandard\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=False)\n+        temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n+        temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+        # Spend everything in temp_utxo back to an OP_TRUE output.\n+        tx3 = CTransaction()\n+        total_value = 0\n+        for i in temp_utxo:\n+            tx3.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx3.wit.vtxinwit.append(CTxinWitness())\n+            total_value += i.nValue\n+        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+        tx3.vout.append(CTxOut(total_value - 1000, CScript([OP_TRUE])))\n+        tx3.rehash()\n+        # Spending a higher version witness output is not allowed by policy,\n+        # even with fRequireStandard=false.\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        self.test_node.sync_with_ping()\n+        with mininode_lock:\n+            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_reject.reason)\n+\n+        # Building a block with the transaction must be valid, however.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2, tx3])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+        # Add utxo to our list\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_premature_coinbase_witness_spend(self):\n+        print(\"\\tTesting premature coinbase witness spend\")\n+        block = self.build_next_block()\n+        # Change the output of the block to be a witness output.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        block.vtx[0].vout[0].scriptPubKey = scriptPubKey\n+        # This next line will rehash the coinbase and update the merkle\n+        # root, and solve.\n+        self.update_witness_block_with_transactions(block, [])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        spend_tx = CTransaction()\n+        spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n+        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n+        spend_tx.wit.vtxinwit.append(CTxinWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        spend_tx.rehash()\n+\n+        # Now test a premature spend.\n+        self.nodes[0].generate(98)\n+        sync_blocks(self.nodes)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=False)\n+\n+        # Advancing one more block should allow the spend.\n+        self.nodes[0].generate(1)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+\n+    def test_signature_version_1(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64614163",
      "id" : 64614163,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 1110,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : 1136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64614163",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "nits aside, p2p-segwit.py code review ACK https://github.com/bitcoin/bitcoin/pull/7910/commits/5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "created_at" : "2016-05-25T17:35:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-221649375",
      "id" : 221649375,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-05-25T17:35:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221649375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64619665"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64619665"
         }
      },
      "body" : "For clarity, we should probably change this to SIGVERSION_WITNESS_V0 to match the enum that was added to the code, but that enum has value 1 (which is where \"signature version 1\" comes from).",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-25T17:48:38Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.extend([CTxinWitness(), CTxinWitness()])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+\n+        # This has extra witness data, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra witness, but add extra scriptSig data\n+        tx2.vin[0].scriptSig = CScript([OP_TRUE])\n+        tx2.vin[1].scriptSig = CScript([OP_TRUE])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack.pop(0)\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = []\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # This has extra signature data for a witness input, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra scriptsig on the witness input, and verify\n+        # success (even with extra scriptsig data in the non-witness input)\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update utxo for later tests\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_max_witness_push_length(self):\n+        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        print(\"\\tTesting maximum witness push size\")\n+        MAX_SCRIPT_ELEMENT_SIZE = 520\n+        assert(len(self.utxo))\n+\n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        # First try a 521-byte stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now reduce the length of the stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+\n+        add_witness_commitment(block)\n+        block.solve()\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update the utxo for later tests\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+    def test_max_witness_program_length(self):\n+        # Can create witness outputs that are long, but can't be greater than\n+        # 10k bytes to successfully spend\n+        print(\"\\tTesting maximum witness program length\")\n+        assert(len(self.utxo))\n+        MAX_PROGRAM_LENGTH = 10000\n+\n+        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_hash = sha256(long_witness_program)\n+        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+\n+        block = self.build_next_block()\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try again with one less byte in the witness program\n+        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.rehash()\n+        tx2.vin[0].prevout.hash = tx.sha256\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.rehash()\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_input_length(self):\n+        ''' Ensure that vin length must match vtxinwit length '''\n+        print(\"\\tTesting witness input length\")\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        \n+        # Create a transaction that splits our utxo into many outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        nValue = self.utxo[0].nValue\n+        for i in range(10):\n+            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+        tx.vout[0].nValue -= 1000\n+        assert(tx.vout[0].nValue >= 0)\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try various ways to spend tx that should all break.\n+        # This \"broken\" transaction serializer will not normalize\n+        # the length of vtxinwit.\n+        class BrokenCTransaction(CTransaction):\n+            def serialize_with_witness(self):\n+                flags = 0\n+                if not self.wit.is_null():\n+                    flags |= 1\n+                r = b\"\"\n+                r += struct.pack(\"<i\", self.nVersion)\n+                if flags:\n+                    dummy = []\n+                    r += ser_vector(dummy)\n+                    r += struct.pack(\"<B\", flags)\n+                r += ser_vector(self.vin)\n+                r += ser_vector(self.vout)\n+                if flags & 1:\n+                    r += self.wit.serialize()\n+                r += struct.pack(\"<I\", self.nLockTime)\n+                return r\n+\n+        tx2 = BrokenCTransaction()\n+        for i in range(10):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+\n+        # First try using a too long vtxinwit\n+        for i in range(11):\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now try using a too short vtxinwit\n+        tx2.wit.vtxinwit.pop()\n+        tx2.wit.vtxinwit.pop()\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now make one of the intermediate witnesses be incorrect\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Fix the broken witness and the block should be accepted.\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_getdata.inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        try:\n+            self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n+            print(\"Error: duplicate tx getdata!\")\n+            assert(False)\n+        except AssertionError as e:\n+            pass\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Verify that inv's to test_node come with getdata's for witness tx's\n+        # Just tweak the transaction, announce it, and verify we get a getdata\n+        # for a witness_tx\n+        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n+        tx.rehash()\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.test_node.last_getdata.inv[0].type == 1|MSG_WITNESS_FLAG)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+\n+    # After segwit activates, verify that mempool:\n+    # - rejects transactions with unnecessary/extra witnesses\n+    # - accepts transactions with valid witnesses\n+    # and that witness transactions are relayed to non-upgraded peers.\n+    def test_tx_relay_after_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected because we can't use a witness\n+        # when spending a non-witness output.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that unnecessary witnesses are rejected.\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # Verify that removing the witness succeeds.\n+        # Re-announcing won't result in a getdata for ~2.5 minutes, so just\n+        # deliver the modified transaction.\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Now try to add extra witness data to a valid witness tx.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n+        tx2.rehash()\n+\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx3.wit.vtxinwit.append(CTxinWitness())\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n+        tx3.rehash()\n+\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+\n+        # Get rid of the extra witness, and verify acceptance.\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        # Also check that old_node gets a tx announcement, even though this is\n+        # a witness transaction.\n+        self.old_node.wait_for_inv(CInv(1, tx2.sha256)) # wait until tx2 was inv'ed\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        self.old_node.wait_for_inv(CInv(1, tx3.sha256))\n+\n+        # Cleanup: mine the transactions and update utxo for next test\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    # Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG\n+    # This is true regardless of segwit activation.\n+    def test_block_relay(self, segwit_activated):\n+        print(\"\\tTesting block relay\")\n+\n+        # test_node has set NODE_WITNESS, so all getdata requests should be for\n+        # witness blocks.\n+        # Test announcing a block via inv results in a getdata, and that\n+        # announcing a version 4 or random VB block with a header results in a getdata\n+\n+        block1 = self.build_next_block()\n+        block1.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block1, True)\n+\n+        block2 = self.build_next_block(nVersion=4)\n+        block2.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block2, True)\n+\n+        block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n+        block3.solve()\n+        self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block3, True)\n+\n+        # Check that we can getdata for witness blocks or regular blocks,\n+        # and the right thing happens.\n+        if segwit_activated == False:\n+            # Before activation, we should be able to request old blocks with\n+            # or without witness, and they should be the same.\n+            chain_height = self.nodes[0].getblockcount()\n+            # Pick 10 random blocks on main chain, and verify that getdata's\n+            # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n+            all_heights = list(range(chain_height+1))\n+            random.shuffle(all_heights)\n+            all_heights = all_heights[0:10]\n+            for height in all_heights:\n+                block_hash = self.nodes[0].getblockhash(height)\n+                rpc_block = self.nodes[0].getblock(block_hash, False)\n+                block_hash = int(block_hash, 16)\n+                block = self.test_node.request_block(block_hash, 2)\n+                wit_block = self.test_node.request_block(block_hash, 2|MSG_WITNESS_FLAG)\n+                assert_equal(block.serialize(True), wit_block.serialize(True))\n+                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n+        else:\n+            # After activation, witness blocks and non-witness blocks should\n+            # be different.  Verify rpc getblock() returns witness blocks, while\n+            # getdata respects the requested type.\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [])\n+            # This gives us a witness commitment.\n+            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n+            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n+            self.test_node.test_witness_block(block, accepted=True)\n+            # Now try to retrieve it...\n+            rpc_block = self.nodes[0].getblock(block.hash, False)\n+            non_wit_block = self.test_node.request_block(block.sha256, 2)\n+            wit_block = self.test_node.request_block(block.sha256, 2|MSG_WITNESS_FLAG)\n+            assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n+            assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n+            assert_equal(wit_block.serialize(True), block.serialize(True))\n+\n+\n+    # Verify that future segwit upgraded transactions are non-standard,\n+    # but valid in blocks. Can run this before and after segwit activation.\n+    def test_segwit_versions(self):\n+        print(\"\\tTesting standardness/consensus for segwit versions (0-16)\")\n+        assert(len(self.utxo))\n+        NUM_TESTS = 17 # will test OP_0, OP1, ..., OP_16\n+        if (len(self.utxo) < NUM_TESTS):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+            split_value = (self.utxo[0].nValue - 4000) // NUM_TESTS\n+            for i in range(NUM_TESTS):\n+                tx.vout.append(CTxOut(split_value, CScript([OP_TRUE])))\n+            tx.rehash()\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [tx])\n+            self.test_node.test_witness_block(block, accepted=True)\n+            self.utxo.pop(0)\n+            for i in range(NUM_TESTS):\n+                self.utxo.append(UTXO(tx.sha256, i, split_value))\n+\n+        sync_blocks(self.nodes)\n+        temp_utxo = []\n+        tx = CTransaction()\n+        count = 0\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        for version in list(range(OP_1, OP_16+1)) + [OP_0]:\n+            count += 1\n+            # First try to spend to a future version segwit scriptPubKey.\n+            scriptPubKey = CScript([CScriptOp(version), witness_hash])\n+            tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n+            tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n+            tx.rehash()\n+            self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+            self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+            self.utxo.pop(0)\n+            temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+        self.nodes[0].generate(1) # Mine all the transactions\n+        sync_blocks(self.nodes)\n+        assert(len(self.nodes[0].getrawmempool()) == 0)\n+\n+        # Finally, verify that version 0 -> version 1 transactions\n+        # are non-standard\n+        scriptPubKey = CScript([CScriptOp(OP_1), witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+        tx2.vout = [CTxOut(tx.vout[0].nValue-1000, scriptPubKey)]\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        tx2.rehash()\n+        # Gets accepted to test_node, because standardness of outputs isn't\n+        # checked with fRequireStandard\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=False)\n+        temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n+        temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+        # Spend everything in temp_utxo back to an OP_TRUE output.\n+        tx3 = CTransaction()\n+        total_value = 0\n+        for i in temp_utxo:\n+            tx3.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx3.wit.vtxinwit.append(CTxinWitness())\n+            total_value += i.nValue\n+        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+        tx3.vout.append(CTxOut(total_value - 1000, CScript([OP_TRUE])))\n+        tx3.rehash()\n+        # Spending a higher version witness output is not allowed by policy,\n+        # even with fRequireStandard=false.\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        self.test_node.sync_with_ping()\n+        with mininode_lock:\n+            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_reject.reason)\n+\n+        # Building a block with the transaction must be valid, however.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2, tx3])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+        # Add utxo to our list\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_premature_coinbase_witness_spend(self):\n+        print(\"\\tTesting premature coinbase witness spend\")\n+        block = self.build_next_block()\n+        # Change the output of the block to be a witness output.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        block.vtx[0].vout[0].scriptPubKey = scriptPubKey\n+        # This next line will rehash the coinbase and update the merkle\n+        # root, and solve.\n+        self.update_witness_block_with_transactions(block, [])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        spend_tx = CTransaction()\n+        spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n+        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n+        spend_tx.wit.vtxinwit.append(CTxinWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        spend_tx.rehash()\n+\n+        # Now test a premature spend.\n+        self.nodes[0].generate(98)\n+        sync_blocks(self.nodes)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=False)\n+\n+        # Advancing one more block should allow the spend.\n+        self.nodes[0].generate(1)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+\n+    def test_signature_version_1(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64619665",
      "id" : 64619665,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 1110,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : 1136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64619665",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64633343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64633343"
         }
      },
      "body" : "Appears unused",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-25T19:04:16Z",
      "diff_hunk" : "@@ -0,0 +1,1575 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'witness')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'witness')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.extend([CTxinWitness(), CTxinWitness()])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+\n+        # This has extra witness data, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra witness, but add extra scriptSig data\n+        tx2.vin[0].scriptSig = CScript([OP_TRUE])\n+        tx2.vin[1].scriptSig = CScript([OP_TRUE])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack.pop(0)\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = []\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # This has extra signature data for a witness input, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra scriptsig on the witness input, and verify\n+        # success (even with extra scriptsig data in the non-witness input)\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update utxo for later tests\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_max_witness_push_length(self):\n+        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        print(\"\\tTesting maximum witness push size\")\n+        MAX_SCRIPT_ELEMENT_SIZE = 520\n+        assert(len(self.utxo))\n+\n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        # First try a 521-byte stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now reduce the length of the stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+\n+        add_witness_commitment(block)\n+        block.solve()\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update the utxo for later tests\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+    def test_max_witness_program_length(self):\n+        # Can create witness outputs that are long, but can't be greater than\n+        # 10k bytes to successfully spend\n+        print(\"\\tTesting maximum witness program length\")\n+        assert(len(self.utxo))\n+        MAX_PROGRAM_LENGTH = 10000\n+\n+        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_hash = sha256(long_witness_program)\n+        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+\n+        block = self.build_next_block()\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try again with one less byte in the witness program\n+        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.rehash()\n+        tx2.vin[0].prevout.hash = tx.sha256\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.rehash()\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_input_length(self):\n+        ''' Ensure that vin length must match vtxinwit length '''\n+        print(\"\\tTesting witness input length\")\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        \n+        # Create a transaction that splits our utxo into many outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        nValue = self.utxo[0].nValue\n+        for i in range(10):\n+            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+        tx.vout[0].nValue -= 1000\n+        assert(tx.vout[0].nValue >= 0)\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try various ways to spend tx that should all break.\n+        # This \"broken\" transaction serializer will not normalize\n+        # the length of vtxinwit.\n+        class BrokenCTransaction(CTransaction):\n+            def serialize_with_witness(self):\n+                flags = 0\n+                if not self.wit.is_null():\n+                    flags |= 1\n+                r = b\"\"\n+                r += struct.pack(\"<i\", self.nVersion)\n+                if flags:\n+                    dummy = []\n+                    r += ser_vector(dummy)\n+                    r += struct.pack(\"<B\", flags)\n+                r += ser_vector(self.vin)\n+                r += ser_vector(self.vout)\n+                if flags & 1:\n+                    r += self.wit.serialize()\n+                r += struct.pack(\"<I\", self.nLockTime)\n+                return r\n+\n+        tx2 = BrokenCTransaction()\n+        for i in range(10):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+\n+        # First try using a too long vtxinwit\n+        for i in range(11):\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now try using a too short vtxinwit\n+        tx2.wit.vtxinwit.pop()\n+        tx2.wit.vtxinwit.pop()\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now make one of the intermediate witnesses be incorrect\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Fix the broken witness and the block should be accepted.\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_getdata.inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        try:\n+            self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n+            print(\"Error: duplicate tx getdata!\")\n+            assert(False)\n+        except AssertionError as e:\n+            pass\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Verify that inv's to test_node come with getdata's for witness tx's\n+        # Just tweak the transaction, announce it, and verify we get a getdata\n+        # for a witness_tx\n+        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n+        tx.rehash()\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.test_node.last_getdata.inv[0].type == 1|MSG_WITNESS_FLAG)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+\n+    # After segwit activates, verify that mempool:\n+    # - rejects transactions with unnecessary/extra witnesses\n+    # - accepts transactions with valid witnesses\n+    # and that witness transactions are relayed to non-upgraded peers.\n+    def test_tx_relay_after_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected because we can't use a witness\n+        # when spending a non-witness output.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that unnecessary witnesses are rejected.\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # Verify that removing the witness succeeds.\n+        # Re-announcing won't result in a getdata for ~2.5 minutes, so just\n+        # deliver the modified transaction.\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Now try to add extra witness data to a valid witness tx.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n+        tx2.rehash()\n+\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx3.wit.vtxinwit.append(CTxinWitness())\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n+        tx3.rehash()\n+\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+\n+        # Get rid of the extra witness, and verify acceptance.\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        # Also check that old_node gets a tx announcement, even though this is\n+        # a witness transaction.\n+        self.old_node.wait_for_inv(CInv(1, tx2.sha256)) # wait until tx2 was inv'ed\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        self.old_node.wait_for_inv(CInv(1, tx3.sha256))\n+\n+        # Cleanup: mine the transactions and update utxo for next test\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    # Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG\n+    # This is true regardless of segwit activation.\n+    def test_block_relay(self, segwit_activated):\n+        print(\"\\tTesting block relay\")\n+\n+        # test_node has set NODE_WITNESS, so all getdata requests should be for\n+        # witness blocks.\n+        # Test announcing a block via inv results in a getdata, and that\n+        # announcing a version 4 or random VB block with a header results in a getdata\n+\n+        block1 = self.build_next_block()\n+        block1.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block1, True)\n+\n+        block2 = self.build_next_block(nVersion=4)\n+        block2.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block2, True)\n+\n+        block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n+        block3.solve()\n+        self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        self.test_node.test_witness_block(block3, True)\n+\n+        # Check that we can getdata for witness blocks or regular blocks,\n+        # and the right thing happens.\n+        if segwit_activated == False:\n+            # Before activation, we should be able to request old blocks with\n+            # or without witness, and they should be the same.\n+            chain_height = self.nodes[0].getblockcount()\n+            # Pick 10 random blocks on main chain, and verify that getdata's\n+            # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n+            all_heights = list(range(chain_height+1))\n+            random.shuffle(all_heights)\n+            all_heights = all_heights[0:10]\n+            for height in all_heights:\n+                block_hash = self.nodes[0].getblockhash(height)\n+                rpc_block = self.nodes[0].getblock(block_hash, False)\n+                block_hash = int(block_hash, 16)\n+                block = self.test_node.request_block(block_hash, 2)\n+                wit_block = self.test_node.request_block(block_hash, 2|MSG_WITNESS_FLAG)\n+                assert_equal(block.serialize(True), wit_block.serialize(True))\n+                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n+        else:\n+            # After activation, witness blocks and non-witness blocks should\n+            # be different.  Verify rpc getblock() returns witness blocks, while\n+            # getdata respects the requested type.\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [])\n+            # This gives us a witness commitment.\n+            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n+            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n+            self.test_node.test_witness_block(block, accepted=True)\n+            # Now try to retrieve it...\n+            rpc_block = self.nodes[0].getblock(block.hash, False)\n+            non_wit_block = self.test_node.request_block(block.sha256, 2)\n+            wit_block = self.test_node.request_block(block.sha256, 2|MSG_WITNESS_FLAG)\n+            assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n+            assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n+            assert_equal(wit_block.serialize(True), block.serialize(True))\n+\n+\n+    # Verify that future segwit upgraded transactions are non-standard,\n+    # but valid in blocks. Can run this before and after segwit activation.\n+    def test_segwit_versions(self):\n+        print(\"\\tTesting standardness/consensus for segwit versions (0-16)\")\n+        assert(len(self.utxo))\n+        NUM_TESTS = 17 # will test OP_0, OP1, ..., OP_16\n+        if (len(self.utxo) < NUM_TESTS):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+            split_value = (self.utxo[0].nValue - 4000) // NUM_TESTS\n+            for i in range(NUM_TESTS):\n+                tx.vout.append(CTxOut(split_value, CScript([OP_TRUE])))\n+            tx.rehash()\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [tx])\n+            self.test_node.test_witness_block(block, accepted=True)\n+            self.utxo.pop(0)\n+            for i in range(NUM_TESTS):\n+                self.utxo.append(UTXO(tx.sha256, i, split_value))\n+\n+        sync_blocks(self.nodes)\n+        temp_utxo = []\n+        tx = CTransaction()\n+        count = 0\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        for version in list(range(OP_1, OP_16+1)) + [OP_0]:\n+            count += 1\n+            # First try to spend to a future version segwit scriptPubKey.\n+            scriptPubKey = CScript([CScriptOp(version), witness_hash])\n+            tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n+            tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n+            tx.rehash()\n+            self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+            self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+            self.utxo.pop(0)\n+            temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+        self.nodes[0].generate(1) # Mine all the transactions\n+        sync_blocks(self.nodes)\n+        assert(len(self.nodes[0].getrawmempool()) == 0)\n+\n+        # Finally, verify that version 0 -> version 1 transactions\n+        # are non-standard\n+        scriptPubKey = CScript([CScriptOp(OP_1), witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+        tx2.vout = [CTxOut(tx.vout[0].nValue-1000, scriptPubKey)]\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        tx2.rehash()\n+        # Gets accepted to test_node, because standardness of outputs isn't\n+        # checked with fRequireStandard\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=False)\n+        temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n+        temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+        # Spend everything in temp_utxo back to an OP_TRUE output.\n+        tx3 = CTransaction()\n+        total_value = 0\n+        for i in temp_utxo:\n+            tx3.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx3.wit.vtxinwit.append(CTxinWitness())\n+            total_value += i.nValue\n+        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+        tx3.vout.append(CTxOut(total_value - 1000, CScript([OP_TRUE])))\n+        tx3.rehash()\n+        # Spending a higher version witness output is not allowed by policy,\n+        # even with fRequireStandard=false.\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        self.test_node.sync_with_ping()\n+        with mininode_lock:\n+            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_reject.reason)\n+\n+        # Building a block with the transaction must be valid, however.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2, tx3])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+        # Add utxo to our list\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_premature_coinbase_witness_spend(self):\n+        print(\"\\tTesting premature coinbase witness spend\")\n+        block = self.build_next_block()\n+        # Change the output of the block to be a witness output.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        block.vtx[0].vout[0].scriptPubKey = scriptPubKey\n+        # This next line will rehash the coinbase and update the merkle\n+        # root, and solve.\n+        self.update_witness_block_with_transactions(block, [])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        spend_tx = CTransaction()\n+        spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n+        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n+        spend_tx.wit.vtxinwit.append(CTxinWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        spend_tx.rehash()\n+\n+        # Now test a premature spend.\n+        self.nodes[0].generate(98)\n+        sync_blocks(self.nodes)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=False)\n+\n+        # Advancing one more block should allow the spend.\n+        self.nodes[0].generate(1)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+\n+    def test_signature_version_1(self):\n+        print(\"\\tTesting segwit signature hash version 1\")\n+        key = CECKey()\n+        key.set_secretbytes(b\"9\")\n+        pubkey = CPubKey(key.get_pubkey())\n+\n+        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First create a witness output for use in the tests.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+        # Mine this transaction in preparation for following tests.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        sync_blocks(self.nodes)\n+        self.utxo.pop(0)\n+\n+        # Add signature for a P2PK witness program.\n+        def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n+            tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n+            signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n+            txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n+            txTo.rehash()\n+\n+        # Test each hashtype\n+        prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+        for sigflag in [ 0, SIGHASH_ANYONECANPAY ]:\n+            for hashtype in [SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE]:\n+                hashtype |= sigflag\n+                block = self.build_next_block()\n+                tx = CTransaction()\n+                tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n+                tx.vout.append(CTxOut(prev_utxo.nValue - 1000, scriptPubKey))\n+                tx.wit.vtxinwit.append(CTxinWitness())\n+                # Too-large input value\n+                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue+1, key)\n+                self.update_witness_block_with_transactions(block, [tx])\n+                self.test_node.test_witness_block(block, accepted=False)\n+\n+                # Too-small input value\n+                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue-1, key)\n+                block.vtx.pop() # remove last tx\n+                self.update_witness_block_with_transactions(block, [tx])\n+                self.test_node.test_witness_block(block, accepted=False)\n+\n+                # Now try correct value\n+                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n+                block.vtx.pop()\n+                self.update_witness_block_with_transactions(block, [tx])\n+                self.test_node.test_witness_block(block, accepted=True)\n+\n+                prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+\n+        # Test combinations of signature hashes.\n+        # Split the utxo into a lot of outputs.\n+        # Randomly choose up to 10 to spend, sign with different hashtypes, and\n+        # output to a random number of outputs.  Repeat NUM_TESTS times.\n+        # Ensure that we've tested a situation where we use SIGHASH_SINGLE with\n+        # an input index > number of outputs.\n+        NUM_TESTS = 500\n+        temp_utxos = []\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n+        split_value = prev_utxo.nValue // NUM_TESTS\n+        for i in range(NUM_TESTS):\n+            tx.vout.append(CTxOut(split_value, scriptPubKey))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        sign_P2PK_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n+        for i in range(NUM_TESTS):\n+            temp_utxos.append(UTXO(tx.sha256, i, split_value))\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        block = self.build_next_block()\n+        used_sighash_single_out_of_bounds = False\n+        for i in range(NUM_TESTS):\n+            # Choose random number of inputs to use.\n+            num_inputs = random.randint(1, 10)\n+            # Create a slight bias for producing more utxos\n+            num_outputs = random.randint(1, 11)\n+            random.shuffle(temp_utxos)\n+            assert(len(temp_utxos) > num_inputs)\n+            tx = CTransaction()\n+            total_value = 0\n+            for i in range(num_inputs):\n+                tx.vin.append(CTxIn(COutPoint(temp_utxos[i].sha256, temp_utxos[i].n), b\"\"))\n+                tx.wit.vtxinwit.append(CTxinWitness())\n+                total_value += temp_utxos[i].nValue\n+            split_value = total_value // num_outputs\n+            for i in range(num_outputs):\n+                tx.vout.append(CTxOut(split_value, scriptPubKey))\n+            for i in range(num_inputs):\n+                # Now try to sign each input, using a random hashtype.\n+                anyonecanpay = 0\n+                if random.randint(0, 1):\n+                    anyonecanpay = SIGHASH_ANYONECANPAY\n+                hashtype = random.randint(1, 3) | anyonecanpay\n+                sign_P2PK_witness_input(witness_program, tx, i, hashtype, temp_utxos[i].nValue, key)\n+                if (hashtype == SIGHASH_SINGLE and i >= num_outputs):\n+                    used_sighash_single_out_of_bounds = True\n+            tx.rehash()\n+            for i in range(num_outputs):\n+                temp_utxos.append(UTXO(tx.sha256, i, split_value))\n+            temp_utxos = temp_utxos[num_inputs:]\n+\n+            block.vtx.append(tx)\n+\n+            # Test the block periodically, if we're close to maxblocksize\n+            if (get_virtual_size(block) > MAX_BLOCK_SIZE - 1000):\n+                self.update_witness_block_with_transactions(block, [])\n+                self.test_node.test_witness_block(block, accepted=True)\n+                block = self.build_next_block()\n+\n+        if (not used_sighash_single_out_of_bounds):\n+            print(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n+        # Test the transactions we've added to the block\n+        if (len(block.vtx) > 1):\n+            self.update_witness_block_with_transactions(block, [])\n+            self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now test witness version 0 P2PKH transactions\n+        pubkeyhash = hash160(pubkey)\n+        scriptPKH = CScript([OP_0, pubkeyhash])\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(temp_utxos[0].sha256, temp_utxos[0].n), b\"\"))\n+        tx.vout.append(CTxOut(temp_utxos[0].nValue, scriptPKH))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        sign_P2PK_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+\n+        script = CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+        sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n+        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+\n+        # Check that we can't have a scriptSig\n+        tx2.vin[0].scriptSig = CScript([signature, pubkey])\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Move the signature to the witness.\n+        block.vtx.pop()\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        temp_utxos.pop(0)\n+\n+        # Update self.utxos for later tests. Just spend everything in\n+        # temp_utxos to a corresponding entry in self.utxos\n+        tx = CTransaction()\n+        index = 0\n+        for i in temp_utxos:\n+            # Just spend to our usual anyone-can-spend output\n+            # Use SIGHASH_SINGLE|SIGHASH_ANYONECANPAY so we can build up\n+            # the signatures as we go.\n+            tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx.vout.append(CTxOut(i.nValue, CScript([OP_TRUE])))\n+            tx.wit.vtxinwit.append(CTxinWitness())\n+            sign_P2PK_witness_input(witness_program, tx, index, SIGHASH_SINGLE|SIGHASH_ANYONECANPAY, i.nValue, key)\n+            index += 1\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        for i in range(len(tx.vout)):\n+            self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n+\n+\n+    # Test P2SH wrapped witness programs.\n+    def test_p2sh_witness(self, segwit_activated):\n+        print(\"\\tTesting P2SH witness transactions\")\n+\n+        assert(len(self.utxo))\n+\n+        # Prepare the p2sh-wrapped witness output\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        p2wsh_pubkey = CScript([OP_0, witness_hash])\n+        p2sh_witness_hash = hash160(p2wsh_pubkey)\n+        scriptPubKey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        scriptSig = CScript([p2wsh_pubkey]) # a push of the redeem script\n+\n+        # Fund the P2SH output\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # Verify mempool acceptance and block validity\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True, with_witness=segwit_activated)\n+        sync_blocks(self.nodes)\n+\n+        # Now test attempts to spend the output.\n+        spend_tx = CTransaction()\n+        spend_tx.vin.append(CTxIn(COutPoint(tx.sha256, 0), scriptSig))\n+        spend_tx.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        spend_tx.rehash()\n+\n+        # This transaction should not be accepted into the mempool pre- or\n+        # post-segwit.  Mempool acceptance will use SCRIPT_VERIFY_WITNESS which\n+        # will require a witness to spend a witness program regardless of\n+        # segwit activation.  Note that older bitcoind's that are not\n+        # segwit-aware would also reject this for failing CLEANSTACK.\n+        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+\n+        # Try to put the witness script in the scriptSig, should also fail.\n+        spend_tx.vin[0].scriptSig = CScript([p2wsh_pubkey, b'a'])\n+        spend_tx.rehash()\n+        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+\n+        # Now put the witness script in the witness, should succeed after\n+        # segwit activates.\n+        spend_tx.vin[0].scriptSig = scriptSig\n+        spend_tx.rehash()\n+        spend_tx.wit.vtxinwit.append(CTxinWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a', witness_program ]\n+\n+        # Verify mempool acceptance\n+        self.test_node.test_transaction_acceptance(spend_tx, with_witness=True, accepted=segwit_activated)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [spend_tx])\n+\n+        # If we're before activation, then sending this without witnesses\n+        # should be valid.  If we're after activation, then sending this with\n+        # witnesses should be valid.\n+        if segwit_activated:\n+            self.test_node.test_witness_block(block, accepted=True)\n+        else:\n+            self.test_node.test_witness_block(block, accepted=True, with_witness=False)\n+\n+        # Update self.utxo\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(spend_tx.sha256, 0, spend_tx.vout[0].nValue))\n+\n+    # Test the behavior of starting up a segwit-aware node after the softfork\n+    # has activated.  As segwit requires different block data than pre-segwit\n+    # nodes would have stored, this requires special handling.\n+    # To enable this test, pass --oldbinary=<path-to-pre-segwit-bitcoind> to\n+    # the test.\n+    def test_upgrade_after_activation(self, node, node_id):\n+        print(\"\\tTesting software upgrade after softfork activation\")\n+\n+        assert(node_id != 0) # node0 is assumed to be a segwit-active bitcoind\n+\n+        # Make sure the nodes are all up\n+        sync_blocks(self.nodes)\n+\n+        # Restart with the new binary\n+        stop_node(node, node_id)\n+        self.nodes[node_id] = start_node(node_id, self.options.tmpdir, [\"-debug\"])\n+        connect_nodes(self.nodes[0], node_id)\n+\n+        sync_blocks(self.nodes)\n+\n+        # Make sure that this peer thinks segwit has activated.\n+        assert(get_bip9_status(node, 'witness')['status'] == \"active\")\n+\n+        # Make sure this peers blocks match those of node0.\n+        height = node.getblockcount()\n+        while height >= 0:\n+            block_hash = node.getblockhash(height)\n+            assert_equal(block_hash, self.nodes[0].getblockhash(height))\n+            assert_equal(self.nodes[0].getblock(block_hash), node.getblock(block_hash))\n+            height -= 1\n+\n+\n+    def test_witness_sigops(self):\n+        '''Ensure sigop counting is correct inside witnesses.'''\n+        print(\"\\tTesting sigops limit\")\n+\n+        assert(len(self.utxo))\n+\n+        # Keep this under MAX_OPS_PER_SCRIPT (201)\n+        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG]*5 + [OP_CHECKSIG]*193 + [OP_ENDIF])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        sigops_per_script = 20*5 + 193*1\n+        # We'll produce 2 extra outputs, one with a program that would take us\n+        # over max sig ops, and one with a program that would exactly reach max\n+        # sig ops\n+        outputs = (MAX_SIGOP_COST // sigops_per_script) + 2\n+        extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n+\n+        # We chose the number of checkmultisigs/checksigs to make this work:\n+        assert(extra_sigops_available < 100) # steer clear of MAX_OPS_PER_SCRIPT\n+\n+        # This script, when spent with the first\n+        # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n+        # would push us just over the block sigop limit.\n+        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available + 1) + [OP_ENDIF])\n+        witness_hash_toomany = sha256(witness_program_toomany)\n+        scriptPubKey_toomany = CScript([OP_0, witness_hash_toomany])\n+\n+        # If we spend this script instead, we would exactly reach our sigop\n+        # limit (for witness sigops).\n+        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available) + [OP_ENDIF])\n+        witness_hash_justright = sha256(witness_program_justright)\n+        scriptPubKey_justright = CScript([OP_0, witness_hash_justright])\n+\n+        # First split our available utxo into a bunch of outputs\n+        split_value = self.utxo[0].nValue // outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        for i in range(outputs):\n+            tx.vout.append(CTxOut(split_value, scriptPubKey))\n+        tx.vout[-2].scriptPubKey = scriptPubKey_toomany\n+        tx.vout[-1].scriptPubKey = scriptPubKey_justright\n+        tx.rehash()\n+\n+        block_1 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_1, [tx])\n+        self.test_node.test_witness_block(block_1, accepted=True)\n+\n+        tx2 = CTransaction()\n+        # If we try to spend the first n-1 outputs from tx, that should be\n+        # too many sigops.\n+        total_value = 0\n+       ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r64633343",
      "id" : 64633343,
      "original_commit_id" : "5b0cd48d9f29f4a839640819230d4e88e077ce40",
      "original_position" : 1506,
      "path" : "qa/rpc-tests/p2p-segwit.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/64633343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65207630"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65207630"
         }
      },
      "body" : "must be a mistaken edit: all references in that loop are const",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-05-31T15:39:47Z",
      "diff_hunk" : "@@ -511,7 +512,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     UniValue transactions(UniValue::VARR);\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {\n+    BOOST_FOREACH (CTransaction& tx, pblock->vtx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65207630",
      "id" : 65207630,
      "original_commit_id" : "cb9d4d34cab7834f9050293ab90a87a19bd8ff61",
      "original_position" : 24,
      "path" : "src/rpc/mining.cpp",
      "position" : 61,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65207630",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/50769?v=3",
         "events_url" : "https://api.github.com/users/earonesty/events{/privacy}",
         "followers_url" : "https://api.github.com/users/earonesty/followers",
         "following_url" : "https://api.github.com/users/earonesty/following{/other_user}",
         "gists_url" : "https://api.github.com/users/earonesty/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/earonesty",
         "id" : 50769,
         "login" : "earonesty",
         "organizations_url" : "https://api.github.com/users/earonesty/orgs",
         "received_events_url" : "https://api.github.com/users/earonesty/received_events",
         "repos_url" : "https://api.github.com/users/earonesty/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/earonesty/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/earonesty/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/earonesty"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65664565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65664565"
         }
      },
      "body" : "Why is the max arbitrarily set here?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-03T07:09:42Z",
      "diff_hunk" : "@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65664565",
      "id" : 65664565,
      "original_commit_id" : "e82f2fc38827815a635390dfde5afb26229ff053",
      "original_position" : 16,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65664565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25104?v=3",
         "events_url" : "https://api.github.com/users/JDutil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JDutil/followers",
         "following_url" : "https://api.github.com/users/JDutil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JDutil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JDutil",
         "id" : 25104,
         "login" : "JDutil",
         "organizations_url" : "https://api.github.com/users/JDutil/orgs",
         "received_events_url" : "https://api.github.com/users/JDutil/received_events",
         "repos_url" : "https://api.github.com/users/JDutil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JDutil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JDutil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JDutil"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65665109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65665109"
         }
      },
      "body" : "This is in test code. It has to test a specific scenario.\n",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-03T07:16:01Z",
      "diff_hunk" : "@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65665109",
      "id" : 65665109,
      "original_commit_id" : "e82f2fc38827815a635390dfde5afb26229ff053",
      "original_position" : 16,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65665109",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65665505"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65665505"
         }
      },
      "body" : "Though, it could help to name constants that have more than 4 trailing\nzeros and put them in test_framework/ e.g. /mininode.py.\n",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-03T07:20:51Z",
      "diff_hunk" : "@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65665505",
      "id" : 65665505,
      "original_commit_id" : "e82f2fc38827815a635390dfde5afb26229ff053",
      "original_position" : 16,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65665505",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65666064"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65666064"
         }
      },
      "body" : "Okay so this is test code, but the test code used to be against the MAX_BLOCK_SIZE why is the max block size no longer important? Sorry if I sound stupid here being ruby dev not python, but I'd like to understand this seemingly arbitrary change that IMHO is way worse than being arbitrary it is changing the TEST ITSELF.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-03T07:25:42Z",
      "diff_hunk" : "@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65666064",
      "id" : 65666064,
      "original_commit_id" : "e82f2fc38827815a635390dfde5afb26229ff053",
      "original_position" : 16,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:03:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65666064",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25104?v=3",
         "events_url" : "https://api.github.com/users/JDutil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JDutil/followers",
         "following_url" : "https://api.github.com/users/JDutil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JDutil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JDutil",
         "id" : 25104,
         "login" : "JDutil",
         "organizations_url" : "https://api.github.com/users/JDutil/orgs",
         "received_events_url" : "https://api.github.com/users/JDutil/received_events",
         "repos_url" : "https://api.github.com/users/JDutil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JDutil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JDutil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JDutil"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65800645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65800645"
         }
      },
      "body" : "Oh, I misunderstood your comment. Sure, I should add a constant for the new max block size on the python side.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-04T10:05:29Z",
      "diff_hunk" : "@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65800645",
      "id" : 65800645,
      "original_commit_id" : "e82f2fc38827815a635390dfde5afb26229ff053",
      "original_position" : 16,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:05:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65800645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65800717"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65800717"
         }
      },
      "body" : "@sipa  on a new constant to make things readable, but sorry I'm just starting to learn the source code here so I still have simple questions.  Is the reason your setting this different than the MAX_BLOCK_SIZE because segwit is supposed to help double the amount of data per block?  I would think this would be 4MB not 4_000_000 which is close... Makes me think the test would be MAX_BLOCK_SIZE * 2.  My main misunderstanding is why this value is changing from max constant when the test appears to be testing mining full blocks... Hopefully that helps clear up my confusion.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-04T10:12:55Z",
      "diff_hunk" : "@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65800717",
      "id" : 65800717,
      "original_commit_id" : "e82f2fc38827815a635390dfde5afb26229ff053",
      "original_position" : 16,
      "path" : "qa/rpc-tests/maxuploadtarget.py",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-04T10:12:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65800717",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25104?v=3",
         "events_url" : "https://api.github.com/users/JDutil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JDutil/followers",
         "following_url" : "https://api.github.com/users/JDutil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JDutil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JDutil",
         "id" : 25104,
         "login" : "JDutil",
         "organizations_url" : "https://api.github.com/users/JDutil/orgs",
         "received_events_url" : "https://api.github.com/users/JDutil/received_events",
         "repos_url" : "https://api.github.com/users/JDutil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JDutil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JDutil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JDutil"
      }
   },
   {
      "body" : "I've created a rebased/squash branch against master, whose tip tree is identical to the tree in this PR: https://github.com/sipa/bitcoin/compare/segwit-master2-base...segwit-master2\r\n\r\nEDIT: moved to a separate PR #8149.",
      "created_at" : "2016-06-04T20:51:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-223777674",
      "id" : 223777674,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-06T13:41:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223777674",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65925707"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65925707"
         }
      },
      "body" : "@sipa I think this still needs to be addressed?",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-06T16:49:54Z",
      "diff_hunk" : "@@ -19,6 +19,8 @@ static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n /** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 0;\n+/** Default for -blockmaxcost, which control the range of block costs the mining code will create **/\n+static const unsigned int DEFAULT_BLOCK_MAX_COST = 3000000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r65925707",
      "id" : 65925707,
      "original_commit_id" : "1e9cba2873fd25270a5d368ece46362613ade9a4",
      "original_position" : 5,
      "path" : "src/policy/policy.h",
      "position" : 5,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-06T16:49:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65925707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r66026986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66026986"
         }
      },
      "body" : "`ret` is unused here.",
      "commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "created_at" : "2016-06-07T08:14:58Z",
      "diff_hunk" : "@@ -64,4 +65,179 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n     BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig2), 3U);\n }\n \n+/**\n+ * Verifies script execution of the zeroth scriptPubKey of tx output and\n+ * zeroth scriptSig and witness of tx input.\n+ */\n+ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n+{\n+    ScriptError error;\n+    CTransaction inputi(input);\n+    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, inputi.wit.vtxinwit.size() > 0 ? &inputi.wit.vtxinwit[0].scriptWitness : NULL, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue), &error);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#discussion_r66026986",
      "id" : 66026986,
      "original_commit_id" : "3cb46c1a4ac94f4a7f25368bc2ba3c784c901b89",
      "original_position" : 20,
      "path" : "src/test/sigopcount_tests.cpp",
      "position" : 20,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7910",
      "updated_at" : "2016-06-07T08:14:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66026986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "As brought up in https://github.com/sipa/bitcoin/issues/95 (and subsequent IRC discussion), we currently will respond to a MSG_FILTERED_BLOCK with transactions that will be serialized with witness, even though the peer may not support it.  \r\n\r\nWe should change this to returning transactions without witness, and in the future we could add support for filtered block requests to indicate whether responses should include witnesses or not (eg by setting MSG_FILTERED_BLOCK | MSG_WITNESS_FLAG in the getdata request).\r\n\r\nMental note: look into adding a p2p test to cover filtered blocks.",
      "created_at" : "2016-06-07T19:32:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-224389025",
      "id" : 224389025,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-07T19:32:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224389025",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Updates:\r\n* Removed segnet\r\n* Changes meaning of -maxblocksize and -maxblockcost: if only of one them is given, that becomes the only constraint\r\n* Avoid recomputing transaction sizes/costs in mining code\r\n* Bugfix: count serialized bytes rather than vsize for -maxblockcost\r\n* Bugfix: don't send witnesses in response to getdata MSG_FILTERED_BLOCK\r\n* New merge with master (on top of the mempool/relay refactors, and bip9/bip145 changes)\r\n\r\n#8149 has been updated with a rebase/squash of the above.",
      "created_at" : "2016-06-12T20:31:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-225458615",
      "id" : 225458615,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-12T20:31:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225458615",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Updates:\r\n* Removed commentary\r\n* Fix inconsistent naming 'witness' vs 'segwit'\r\n* Added more tests by @jl2012 and @sdaftuar \r\n* New merge with master (on top of #7598 and #7749).\r\n\r\nThere have been significant changes in master since this PR was branched off, and as a result, many things are now hidden under the merge commit here (including adapting for the tx relay/mempool changes from #8082 #8080 #8059 #7840 , the shared_ptr changed from #8126, the new CNB code from #7598, and the GBT changes from #7935). Especially for the new CNB code, it is probably easier to review the relevant commit from #8149 (which is rebased and squashed and completely identical to this PR).\r\n\r\nI would like to see some final reviews.",
      "created_at" : "2016-06-13T20:28:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-225698251",
      "id" : 225698251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-13T20:28:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225698251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "PROTOCOL_VERSION is indeed unused, so it doesn't matter. I'll change it for consistency.\n\nLonger term, I think the nSerType/nVersion should be replaced by a context object that encapsulates serialization parameters (for example, there could be a TransactionSerializationContext with a boolean fWitness, and a BlockSerializationContext that inherits from TransactionSerializationContext etc).",
      "created_at" : "2016-06-14T07:19:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-225799237",
      "id" : 225799237,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-14T07:19:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225799237",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "ACK 3cb46c1. ACK 17389dc. ACK #8149 having same git tree hash for 3cb46c1 and 17389dc. Also, other reviewers might benefit from some segwit code review notes from https://bitcoincore.org/logs/2016-05-zurich-meeting-notes.html although I believe code review is possible in absence of looking at those notes.",
      "created_at" : "2016-06-14T14:29:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-225899147",
      "id" : 225899147,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-14T14:29:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225899147",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/101238?v=3",
         "events_url" : "https://api.github.com/users/kanzure/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kanzure/followers",
         "following_url" : "https://api.github.com/users/kanzure/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kanzure/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kanzure",
         "id" : 101238,
         "login" : "kanzure",
         "organizations_url" : "https://api.github.com/users/kanzure/orgs",
         "received_events_url" : "https://api.github.com/users/kanzure/received_events",
         "repos_url" : "https://api.github.com/users/kanzure/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kanzure/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kanzure/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kanzure"
      }
   },
   {
      "body" : "tACK wallet section plus fixups https://github.com/sipa/bitcoin/compare/3f989b9...be976b7\r\ntACK p2p-segwit.py tests  plus fixups https://github.com/bitcoin/bitcoin/commit/da0c46e1bbee0413bb5fb107c21a31fd4bbe1f42\r\ncode review ACK for the rest minus unit tests through beginning of merge section: https://github.com/bitcoin/bitcoin/pull/7910/commits/2311cf6ab879b352da39d89b959c735d06cbbf59\r\n\r\n",
      "created_at" : "2016-06-14T15:52:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-225926853",
      "id" : 225926853,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-14T15:52:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225926853",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "body" : "tACK 2311cf6 : consensus behavior matches descriptions in BIP141 and BIP143",
      "created_at" : "2016-06-14T18:49:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-225979380",
      "id" : 225979380,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-14T18:49:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225979380",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8403418?v=3",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "body" : "A few more changes:\r\n* Spelling and naming consistency nits (by @sdaftuar and @instagibbs)\r\n* Test improvements (by @jl2012 and @sdaftuar)\r\n* Make a node fully behave as a non-witness node as long as there is no softfork defined\r\n",
      "created_at" : "2016-06-16T00:58:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-226361837",
      "id" : 226361837,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-16T00:58:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226361837",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "New merge on top of #7600.",
      "created_at" : "2016-06-16T18:35:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7910#issuecomment-226574050",
      "id" : 226574050,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/7910",
      "updated_at" : "2016-06-16T18:35:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226574050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
