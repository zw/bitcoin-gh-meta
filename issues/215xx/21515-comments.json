[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599969335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599969335"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\r\n\r\nnit `#include <memory>` for `std::unique_ptr`.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-23T21:34:00Z",
      "diff_hunk" : "@@ -0,0 +1,57 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <tuple>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599969335",
      "id" : 599969335,
      "line" : 12,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTk2OTMzNQ==",
      "original_commit_id" : "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "original_line" : 12,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/txreconciliation.h",
      "position" : 12,
      "pull_request_review_id" : 619102655,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599969335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599974713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599974713"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\r\n\r\nMove to txreconciliation.cpp",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-23T21:39:09Z",
      "diff_hunk" : "@@ -0,0 +1,57 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <tuple>\n+#include <unordered_map>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599974713",
      "id" : 599974713,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTk3NDcxMw==",
      "original_commit_id" : "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "original_line" : 12,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/txreconciliation.h",
      "position" : null,
      "pull_request_review_id" : 619102655,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599974713",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599979335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599979335"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623\r\n\r\nLooks like insertion should always happen? If so you could assert `.second` of `emplace()` result. If not, then `GetRand()` could be avoided in case it exists, and below it should return the existing salt.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-23T21:47:10Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d\\n\", peer_id);\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        WITH_LOCK(m_mutex, m_local_salts.emplace(peer_id, m_local_recon_salt));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r599979335",
      "id" : 599979335,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTk3OTMzNQ==",
      "original_commit_id" : "8110da8b1b8bc83fa7fd2b76f9cc4688a7a02623",
      "original_line" : 45,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 619102655,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/599979335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept NACK | [ghost](https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885899988), [rebroad](https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885743229) |\n| Concept ACK | [glozow](https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981672502) |\n| Stale ACK | [promag](https://github.com/bitcoin/bitcoin/pull/21515#pullrequestreview-619157940) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#28912](https://github.com/bitcoin/bitcoin/pull/28912) (refactor: VectorWriter and SpanReader without nVersion by maflcko)\n* [#28892](https://github.com/bitcoin/bitcoin/pull/28892) (refactor: P2P transport without serialize version and type by maflcko)\n* [#28765](https://github.com/bitcoin/bitcoin/pull/28765) (p2p: Fill reconciliation sets (Erlay) by naumenkogs)\n* [#28463](https://github.com/bitcoin/bitcoin/pull/28463) (p2p: Increase inbound capacity for block-relay only connections by mzumsande)\n* [#28451](https://github.com/bitcoin/bitcoin/pull/28451) (refactor: Remove unused SER_DISK, SER_NETWORK, SER_GETHASH by maflcko)\n* [#28429](https://github.com/bitcoin/bitcoin/pull/28429) (Do not log p2p bip61 reject messages, improve log, add tests by jonatack)\n* [#27826](https://github.com/bitcoin/bitcoin/pull/27826) (validation: log which peer sent us a header by Sjors)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2021-03-24T09:59:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-805662879",
      "id" : 805662879,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwNTY2Mjg3OQ==",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/805662879/reactions"
      },
      "updated_at" : "2023-11-27T18:30:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/805662879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602929047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602929047"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3e4022a4a87c91b4b671ab4b71ccbd6d7136bade\r\n\r\nCould make this log conditional to whether `peer_id` was erased from `m_local_salts`.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-28T20:35:51Z",
      "diff_hunk" : "@@ -52,6 +52,14 @@ class TxReconciliationTracker::Impl {\n \n         return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n     }\n+\n+    void RemovePeer(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        m_local_salts.erase(peer_id);\n+        LogPrint(BCLog::NET, \"Stop tracking reconciliation state for peer=%d.\\n\", peer_id);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602929047",
      "id" : 602929047,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkyOTA0Nw==",
      "original_commit_id" : "3e4022a4a87c91b4b671ab4b71ccbd6d7136bade",
      "original_line" : 60,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 619157940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602929047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602930818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602930818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8cdaf385aee34a9a10406eef73d6dcae74b5a2c4\r\n\r\nShould be \"SuggestReconciling\"?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-28T20:50:59Z",
      "diff_hunk" : "@@ -68,10 +111,48 @@ class TxReconciliationTracker::Impl {\n         return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n     }\n \n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        // Must match SuggestReconciliation logic.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602930818",
      "id" : 602930818,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkzMDgxOA==",
      "original_commit_id" : "8cdaf385aee34a9a10406eef73d6dcae74b5a2c4",
      "original_line" : 126,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 619157940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602930818",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602941978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602941978"
         }
      },
      "author_association" : "MEMBER",
      "body" : "49108e38941f7136fafdbfc64a989aba0f1cc99f\r\n\r\nnit, `->second`.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-28T22:26:29Z",
      "diff_hunk" : "@@ -161,6 +161,17 @@ class TxReconciliationTracker::Impl {\n         LOCK(m_mutex);\n         return m_states.find(peer_id) != m_states.end();\n     }\n+\n+    std::optional<bool> IsPeerChosenForFlooding(NodeId peer_id) const\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) {\n+            return std::nullopt;\n+        }\n+        return (*recon_state).second.m_flood_to;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602941978",
      "id" : 602941978,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0MTk3OA==",
      "original_commit_id" : "49108e38941f7136fafdbfc64a989aba0f1cc99f",
      "original_line" : 172,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 619157940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602941978",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602943795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602943795"
         }
      },
      "author_association" : "MEMBER",
      "body" : "99906e0c3399225ee361ce85291074971d2025e1\r\n\r\n`IsPeerRegistered` is not needed since `IsPeerChosenForFlooding` returns `nullopt`. Maybe:\r\n```cpp\r\nif (pfrom.MightSupportTransactionRelay()) {\r\n    we_may_flood_to = m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId()).value_or(true);\r\n}\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-28T22:39:57Z",
      "diff_hunk" : "@@ -2539,6 +2547,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r602943795",
      "id" : 602943795,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjk0Mzc5NQ==",
      "original_commit_id" : "99906e0c3399225ee361ce85291074971d2025e1",
      "original_line" : 2665,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 619157940,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/602943795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603143723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603143723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree this is way cleaner, but I think the current code is easier to understand, so I'm leaning towards my approach.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T09:27:57Z",
      "diff_hunk" : "@@ -2539,6 +2547,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603143723",
      "id" : 603143723,
      "in_reply_to_id" : 602943795,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzE0MzcyMw==",
      "original_commit_id" : "99906e0c3399225ee361ce85291074971d2025e1",
      "original_line" : 2665,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623031306,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603143723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603144648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603144648"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The problem is that you can hit undefined behavior with the current code - assuming peer can be disconnected between `IsPeerRegistered` and  `IsPeerChosenForFlooding`.\r\n\r\nEdit: Looks like the above is not possible.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T09:29:16Z",
      "diff_hunk" : "@@ -2539,6 +2547,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603144648",
      "id" : 603144648,
      "in_reply_to_id" : 602943795,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzE0NDY0OA==",
      "original_commit_id" : "99906e0c3399225ee361ce85291074971d2025e1",
      "original_line" : 2665,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623032451,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603144648",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603200987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603200987"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3692db74f86186789c9dad4005f7b768721d5afe\r\n\r\nnit, could move to inner scope.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:01:03Z",
      "diff_hunk" : "@@ -4552,15 +4554,19 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             }\n             peer->m_blocks_for_inv_relay.clear();\n \n+            const bool supports_recon = m_reconciliation.IsPeerRegistered(pto->GetId());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603200987",
      "id" : 603200987,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMDk4Nw==",
      "original_commit_id" : "3692db74f86186789c9dad4005f7b768721d5afe",
      "original_line" : 4557,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603200987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603202580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603202580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "83a08c5ea07f7f7e3e67501ac8666521427ae9d3\r\n\r\nnit, `assert(txs_to_reconcile.size() > 0)`",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:04:13Z",
      "diff_hunk" : "@@ -154,6 +178,19 @@ class TxReconciliationTracker::Impl {\n             full_salt.GetUint64(1), we_initiate, flood_to));\n     }\n \n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        LOCK(m_mutex);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603202580",
      "id" : 603202580,
      "line" : 675,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMjU4MA==",
      "original_commit_id" : "83a08c5ea07f7f7e3e67501ac8666521427ae9d3",
      "original_line" : 675,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 675,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603202580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603203867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603203867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "83a08c5ea07f7f7e3e67501ac8666521427ae9d3\r\n\r\nCould `m_local_set already` have some of `txs_to_reconcile`? If so maybe we should count successful `.insert()` and log that?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:06:33Z",
      "diff_hunk" : "@@ -154,6 +178,19 @@ class TxReconciliationTracker::Impl {\n             full_salt.GetUint64(1), we_initiate, flood_to));\n     }\n \n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+        for (auto& wtxid: txs_to_reconcile) {\n+            recon_state->second.m_local_set.m_wtxids.insert(wtxid);\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i transactions to the reconciliation set for peer=%d.\\n\",",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603203867",
      "id" : 603203867,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMzg2Nw==",
      "original_commit_id" : "83a08c5ea07f7f7e3e67501ac8666521427ae9d3",
      "original_line" : 190,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603203867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603206903"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603206903"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3692db74f86186789c9dad4005f7b768721d5afe\r\n\r\nMove to inner scope, make const.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:12:08Z",
      "diff_hunk" : "@@ -4622,6 +4629,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                         uint256 hash = vInvTx.back();\n+                        bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603206903",
      "id" : 603206903,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNjkwMw==",
      "original_commit_id" : "3692db74f86186789c9dad4005f7b768721d5afe",
      "original_line" : 4632,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603206903",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603207731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603207731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "05ac9dc21e5697a1e0261909b64de4f7d6e21eb1\r\n\r\ntypo \"differene\"",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:13:40Z",
      "diff_hunk" : "@@ -120,6 +120,13 @@ class TxReconciliationTracker::Impl {\n      */\n     std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n \n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set differene size.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603207731",
      "id" : 603207731,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNzczMQ==",
      "original_commit_id" : "05ac9dc21e5697a1e0261909b64de4f7d6e21eb1",
      "original_line" : 126,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603207731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210177"
         }
      },
      "author_association" : "MEMBER",
      "body" : "e854bcf5391d02a28690f7eedad8382cbb05f85b\r\n\r\nAdd TSAN annotation?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:17:55Z",
      "diff_hunk" : "@@ -127,6 +135,16 @@ class TxReconciliationTracker::Impl {\n      */\n     std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n \n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210177",
      "id" : 603210177,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxMDE3Nw==",
      "original_commit_id" : "e854bcf5391d02a28690f7eedad8382cbb05f85b",
      "original_line" : 142,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210177",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210815"
         }
      },
      "author_association" : "MEMBER",
      "body" : "e854bcf5391d02a28690f7eedad8382cbb05f85b\r\n\r\nnit `assert(m_queue.size() > 0)`",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:19:03Z",
      "diff_hunk" : "@@ -127,6 +135,16 @@ class TxReconciliationTracker::Impl {\n      */\n     std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n \n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request{0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603210815",
      "id" : 603210815,
      "line" : 443,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxMDgxNQ==",
      "original_commit_id" : "e854bcf5391d02a28690f7eedad8382cbb05f85b",
      "original_line" : 443,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 443,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603210815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603214394"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603214394"
         }
      },
      "author_association" : "MEMBER",
      "body" : "476ced6df27c13fd8d1dae46d09b91549977cac1\r\n\r\nnit, enum class and use as `ReconciliationPhase::NONE`?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:25:31Z",
      "diff_hunk" : "@@ -27,6 +34,14 @@ constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n  */\n constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n \n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum ReconciliationPhase {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603214394",
      "id" : 603214394,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxNDM5NA==",
      "original_commit_id" : "476ced6df27c13fd8d1dae46d09b91549977cac1",
      "original_line" : 40,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 623106592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603214394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603219571"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603219571"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's no need to update this public interface method. The only users of this method outside net_processing will _always_ call `RelayTransaction()` without a `from` parameter.\r\n\r\n(it's also unnecessary to wrap an optional parameter in a `std::optional` since the fact that it's an optional parameter already gives you a way to indicate no value)",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:34:44Z",
      "diff_hunk" : "@@ -47,8 +47,12 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n-    /** Relay transaction to all peers. */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+    /**\n+     * Relay transaction to every node.\n+     * The announcement protocol (flooding or reconciliation) will be chosen based on from which\n+     * peer the transaction came to us. For transactions originated locally, pass from=nullopt.\n+     */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from=std::nullopt)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603219571",
      "id" : 603219571,
      "line" : 56,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIxOTU3MQ==",
      "original_commit_id" : "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "original_line" : 56,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/net_processing.h",
      "position" : 11,
      "pull_request_review_id" : 623130809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603219571",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221491"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221491"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No need to protect this with `cs_main`. You can just make it atomic.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:38:10Z",
      "diff_hunk" : "@@ -365,6 +372,9 @@ class PeerManagerImpl final : public PeerManager\n     /** Number of peers with wtxid relay. */\n     int m_wtxid_relay_peers GUARDED_BY(cs_main) = 0;\n \n+    /** Number of outbound peers we may flood transactions to. */\n+    int m_out_flood_to GUARDED_BY(cs_main) = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221491",
      "id" : 603221491,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIyMTQ5MQ==",
      "original_commit_id" : "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "original_line" : 376,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623133260,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221491",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221670"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221670"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Again, no need for this to be protected by main. I think it can easily live in `Peer`.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:38:34Z",
      "diff_hunk" : "@@ -597,6 +607,9 @@ struct CNodeState {\n     //! Whether this peer relays txs via wtxid\n     bool m_wtxid_relay{false};\n \n+    //! Whether this peer may be used by us for flooding txs.\n+    bool m_we_may_flood_to{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603221670",
      "id" : 603221670,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIyMTY3MA==",
      "original_commit_id" : "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "original_line" : 611,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623133260,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603221670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603223119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603223119"
         }
      },
      "author_association" : "MEMBER",
      "body" : "New `from` parameter is unused.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-03-29T11:41:12Z",
      "diff_hunk" : "@@ -2017,8 +2063,9 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n  *                                  orphan will be reconsidered on each call of this function. This set\n  *                                  may be added to if accepting an orphan causes its children to be\n  *                                  reconsidered.\n+ * @param           from            The peer for which we are processing the orphan set.\n  */\n-void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n+void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set, NodeId from)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r603223119",
      "id" : 603223119,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIyMzExOQ==",
      "original_commit_id" : "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "original_line" : 2068,
      "original_position" : 171,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 623133260,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/603223119",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606384776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606384776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Making const. Can't move because it's erased in two lines after, so it won't be accessible in the inner scope.\r\nAnd I can't call `.second` on `.erase`, because it returns a number of erased elements.\r\n\r\nOne alternative could be to use `txid_to_ann_protocol` in `vInvTx` (instead of uint256). But then I won't be able to reuse `CompareInvMempoolOrder` in `AnnounceTxs`.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-02T19:26:16Z",
      "diff_hunk" : "@@ -4622,6 +4629,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                         uint256 hash = vInvTx.back();\n+                        bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606384776",
      "id" : 606384776,
      "in_reply_to_id" : 603206903,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjM4NDc3Ng==",
      "original_commit_id" : "3692db74f86186789c9dad4005f7b768721d5afe",
      "original_line" : 4632,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 627222659,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606384776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606389480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606389480"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry I don't understand this comment, despite your elaborate explanation. Probably my lack of C++ expertise.\r\n\r\nIf I remove just this change in the `virtual void` line, I get a compilation error.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-02T19:39:35Z",
      "diff_hunk" : "@@ -47,8 +47,12 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n-    /** Relay transaction to all peers. */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+    /**\n+     * Relay transaction to every node.\n+     * The announcement protocol (flooding or reconciliation) will be chosen based on from which\n+     * peer the transaction came to us. For transactions originated locally, pass from=nullopt.\n+     */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from=std::nullopt)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r606389480",
      "id" : 606389480,
      "in_reply_to_id" : 603219571,
      "line" : 56,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjM4OTQ4MA==",
      "original_commit_id" : "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "original_line" : 56,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/net_processing.h",
      "position" : 11,
      "pull_request_review_id" : 627228209,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/606389480",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613595312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613595312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks for the clear write-up, may I suggest to insert a stable link to the paper ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-14T21:21:06Z",
      "diff_hunk" : "@@ -0,0 +1,163 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer\n+ */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613595312",
      "id" : 613595312,
      "line" : 37,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzU5NTMxMg==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 37,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/txreconciliation.h",
      "position" : 37,
      "pull_request_review_id" : 636090761,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613595312",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613599268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613599268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think one obvious extension of the test coverage would be to join basic fuzz coverage of `TxReconciliationTracker` interface to assert its robustness. Have a look on `src/test/fuzz/addrman.cpp` or `src/test/fuzz/banman.cpp`.\r\n\r\nFuzz coverage might test further sanity of `TxReconciliationTracker` after each call or in function of `m_we_initiate` or `m_flood_to`. Still thinking about concrete suggestions there.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-14T21:28:34Z",
      "diff_hunk" : "@@ -0,0 +1,163 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer\n+ */\n+class TxReconciliationTracker {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613599268",
      "id" : 613599268,
      "line" : 38,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzU5OTI2OA==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 38,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txreconciliation.h",
      "position" : 38,
      "pull_request_review_id" : 636090761,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613599268",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613926434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613926434"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, you'll need to change the function signature in `PeerManagerImpl()` as well. An `override` function must have the same signature as the function it's overriding.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-15T09:50:05Z",
      "diff_hunk" : "@@ -47,8 +47,12 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n     /** Whether this node ignores txs received over p2p. */\n     virtual bool IgnoresIncomingTxs() = 0;\n \n-    /** Relay transaction to all peers. */\n-    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid)\n+    /**\n+     * Relay transaction to every node.\n+     * The announcement protocol (flooding or reconciliation) will be chosen based on from which\n+     * peer the transaction came to us. For transactions originated locally, pass from=nullopt.\n+     */\n+    virtual void RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from=std::nullopt)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r613926434",
      "id" : 613926434,
      "in_reply_to_id" : 603219571,
      "line" : 56,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzkyNjQzNA==",
      "original_commit_id" : "272b3b2db9f941b5784024983b9152dfccc5aebe",
      "original_line" : 56,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/net_processing.h",
      "position" : 11,
      "pull_request_review_id" : 636493106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/613926434",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614166227"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614166227"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Surprised that modifying those 2 values doesn't lead to functional test changes. Apparently, they're not covered in p2p_tx_download.py. I can extend coverage there in another PR.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-15T15:21:39Z",
      "diff_hunk" : "@@ -123,16 +126,16 @@ static constexpr auto AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL = 24h;\n static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL = 30s;\n /** Average delay between trickled inventory transmissions for inbound peers.\n  *  Blocks and peers with noban permission bypass this. */\n-static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL = 5s;\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL = 2s;\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n  *  Blocks and peers with noban permission bypass this. */\n-static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL = 2s;\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL = 1s;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614166227",
      "id" : 614166227,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDE2NjIyNw==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 134,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 29,
      "pull_request_review_id" : 636820159,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614166227",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614211171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614211171"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do we have privacy leaks for the following cases not mentioned in this comment ?\r\n\r\nA non-reachable node reconciliate with reconciliation-supporting _flooding_ outbound peers ? As it would be a deviation from the expected announcement policy.\r\n\r\nA reachable node reconciliate with reconciliation-supporting _flooding_ inbound/outbound peers ? Likewise, it would be a deviation from the expected announcement policy on those links.\r\n\r\nI think those cases are handled well at tx-announcement in SendMessages. Though I believe this comment would be better if it said that reconciliation is _downgraded_ to flooding if this the announcement previously selected for the to-be-announced-to peer.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-15T16:18:39Z",
      "diff_hunk" : "@@ -1507,17 +1526,44 @@ void PeerManagerImpl::SendPings()\n     for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n-void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from)\n {\n-    m_connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    bool flood;\n+    if (from) {\n+        // Flood those transactions which were received either from pre-reconciliation peers, or\n+        // inbound reconciliation but NOT via outbound reconciliation. Flooding then is mainly\n+        // used for initial propagation of new transactions across a network of reachable nodes\n+        // quickly, while most of the bandwidth is still conserved.\n+        if (m_reconciliation.IsPeerRegistered(*from)) {\n+            flood = !(*m_reconciliation.IsPeerResponder(*from));\n+        } else {\n+            flood = true;\n+        }\n+    }\n+    else {\n+        // Transactions originated locally should be always announced through reconciliation\n+        // for the privacy reasons.\n+        //\n+        // Consider a non-reachable node: the general policy is *flood transactions came from\n+        // inbounds* (see above), so non-reachable nodes would never flood any transactions.\n+        // Now, if they flood their local transactions, it will be obvious for their immediate peers\n+        // that those transactions belong to those non-reachable nodes.\n+        //\n+        // On the other hand, if non-reachable nodes reconcile those transactions, they would look\n+        // like any other transactions of non-reachable nodes.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614211171",
      "id" : 614211171,
      "line" : 1587,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIxMTE3MQ==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 1587,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 174,
      "pull_request_review_id" : 636820159,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614211171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614225402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614225402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In theory, peer's feefilter might have increased between transaction selection for announcement at INV sending and receiving a SKETCH or RECONCILDIFF messages. Though AVG_FEEFILTER_BROADCAST_INTERVAL is 10min so it should be really okay.\r\n\r\nIs this gap could be exploited by an off-path attacker to interfere with tx-relay ? I don't think so, or at least without costly manipulation of victim's mempools.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-15T16:37:59Z",
      "diff_hunk" : "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614225402",
      "id" : 614225402,
      "line" : 2439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIyNTQwMg==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 2439,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 242,
      "pull_request_review_id" : 636820159,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614225402",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614231349"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614231349"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is logically equivalent ? \r\n\r\n```\r\n@@ -2386,15 +2390,11 @@ void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CN\r\n         remote_missing_wtxids.pop_back();\r\n \r\n         remote_missing_invs.push_back(CInv(MSG_WTX, wtxid));\r\n-        if (remote_missing_invs.size() == MAX_INV_SZ) {\r\n+        if (remote_missing_invs.size() == MAX_INV_SZ || remote_missing_wtxids.empty()) {\r\n             m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\r\n             remote_missing_invs.clear();\r\n         }\r\n     }\r\n-\r\n-    if (remote_missing_invs.size() != 0) {\r\n-        m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\r\n-    }\r\n }\r\n ```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-15T16:44:32Z",
      "diff_hunk" : "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.\n+        std::pop_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+        uint256 wtxid = remote_missing_wtxids.back();\n+        remote_missing_wtxids.pop_back();\n+\n+        remote_missing_invs.push_back(CInv(MSG_WTX, wtxid));\n+        if (remote_missing_invs.size() == MAX_INV_SZ) {\n+            m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));\n+            remote_missing_invs.clear();\n+        }\n+    }\n+\n+    if (remote_missing_invs.size() != 0) {\n+        m_connman.PushMessage(&pto, msgMaker.Make(NetMsgType::INV, remote_missing_invs));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614231349",
      "id" : 614231349,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDIzMTM0OQ==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 2406,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 636820159,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614231349",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614934750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614934750"
         }
      },
      "author_association" : "MEMBER",
      "body" : "[The linter](https://cirrus-ci.com/task/6704150097428480) is not happy with this comment style.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-16T15:37:09Z",
      "diff_hunk" : "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614934750",
      "id" : 614934750,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDkzNDc1MA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 38,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 637839318,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614934750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/755825?v=4",
         "events_url" : "https://api.github.com/users/adamjonas/events{/privacy}",
         "followers_url" : "https://api.github.com/users/adamjonas/followers",
         "following_url" : "https://api.github.com/users/adamjonas/following{/other_user}",
         "gists_url" : "https://api.github.com/users/adamjonas/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/adamjonas",
         "id" : 755825,
         "login" : "adamjonas",
         "node_id" : "MDQ6VXNlcjc1NTgyNQ==",
         "organizations_url" : "https://api.github.com/users/adamjonas/orgs",
         "received_events_url" : "https://api.github.com/users/adamjonas/received_events",
         "repos_url" : "https://api.github.com/users/adamjonas/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/adamjonas/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/adamjonas"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614943424"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614943424"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/substraction/subtraction/",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-16T15:45:48Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614943424",
      "id" : 614943424,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk0MzQyNA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2797,
      "original_position" : 307,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 637847119,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614943424",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/755825?v=4",
         "events_url" : "https://api.github.com/users/adamjonas/events{/privacy}",
         "followers_url" : "https://api.github.com/users/adamjonas/followers",
         "following_url" : "https://api.github.com/users/adamjonas/following{/other_user}",
         "gists_url" : "https://api.github.com/users/adamjonas/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/adamjonas",
         "id" : 755825,
         "login" : "adamjonas",
         "node_id" : "MDQ6VXNlcjc1NTgyNQ==",
         "organizations_url" : "https://api.github.com/users/adamjonas/orgs",
         "received_events_url" : "https://api.github.com/users/adamjonas/received_events",
         "repos_url" : "https://api.github.com/users/adamjonas/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/adamjonas/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/adamjonas"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614944439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614944439"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/loosing/losing/",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-16T15:46:47Z",
      "diff_hunk" : "@@ -3806,6 +3976,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        std::optional<bool> recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without loosing the initial data.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r614944439",
      "id" : 614944439,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk0NDQzOQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4003,
      "original_position" : 362,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 637848006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/614944439",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/755825?v=4",
         "events_url" : "https://api.github.com/users/adamjonas/events{/privacy}",
         "followers_url" : "https://api.github.com/users/adamjonas/followers",
         "following_url" : "https://api.github.com/users/adamjonas/following{/other_user}",
         "gists_url" : "https://api.github.com/users/adamjonas/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/adamjonas",
         "id" : 755825,
         "login" : "adamjonas",
         "node_id" : "MDQ6VXNlcjc1NTgyNQ==",
         "organizations_url" : "https://api.github.com/users/adamjonas/orgs",
         "received_events_url" : "https://api.github.com/users/adamjonas/received_events",
         "repos_url" : "https://api.github.com/users/adamjonas/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/adamjonas/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/adamjonas"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615320860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615320860"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why 1024? Is it an arbitrary number? I tested it using 500 blocks and it seems to work. Is there an explanation?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-18T00:26:05Z",
      "diff_hunk" : "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########\n+#################################\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+def GetShortID(tx, salt):\n+    (k0, k1) = salt\n+    wtxid = tx.calc_sha256(with_witness = True)\n+    s = siphash256(k0, k1, wtxid)\n+    return 1 + (s & 0xFFFFFFFF)\n+\n+def estimate_capacity(theirs, ours=1):\n+    return int(abs(theirs - ours) + DEFAULT_Q * min(theirs, ours)) + 1\n+\n+def generate_transaction(node, coinbase):\n+    amount = 0.001\n+    to_address = node.getnewaddress()\n+    from_txid = node.getblock(coinbase)['tx'][0]\n+    inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+    outputs = { to_address : amount }\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransactionwithwallet(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+    tx.rehash()\n+    return tx\n+\n+#################################\n+### General message handlers ####\n+#################################\n+\n+class TestP2PConn(P2PDataStore):\n+    def __init__(self, recon_version, mininode_salt, be_recon_requestor=False, be_recon_responder=False):\n+        super().__init__()\n+        self.recon_version = recon_version\n+        self.mininode_salt = mininode_salt\n+        self.be_recon_requestor = be_recon_requestor\n+        self.be_recon_responder= be_recon_responder\n+        self.node_salt = 0\n+        self.last_sendrecon = []\n+        self.last_sketch = []\n+        self.last_inv = []\n+        self.last_tx = []\n+        self.last_reqreconcil = []\n+        self.last_reconcildiff = []\n+        self.last_reqsketchext = []\n+        self.last_getdata = []\n+        self.node_q = DEFAULT_Q\n+        self.last_wtxidrelay = []\n+\n+    def on_version(self, message):\n+        if self.recon_version == 1:\n+            assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+            if message.nVersion >= 70016 and self.wtxidrelay:\n+                self.send_message(msg_wtxidrelay())\n+                self.send_sendrecon(self.be_recon_requestor, self.be_recon_responder)\n+            self.send_message(msg_verack())\n+            self.nServices = message.nServices\n+        else:\n+            super().on_version(message)\n+\n+    def on_sendrecon(self, message):\n+        self.last_sendrecon.append(message)\n+        self.node_salt = message.salt\n+\n+    def on_wtxidrelay(self, message):\n+        self.last_wtxidrelay.append(message)\n+\n+    def on_sketch(self, message):\n+        self.last_sketch.append(message)\n+\n+    def on_inv(self, message):\n+        MSG_BLOCK = 2\n+        for inv in message.inv:\n+            if inv.type != MSG_BLOCK: # ignore block invs\n+                self.last_inv.append(inv.hash)\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def on_reqrecon(self, message):\n+        self.last_reqreconcil.append(message)\n+\n+    def on_reqsketchext(self, message):\n+        self.last_reqsketchext.append(message)\n+\n+    def on_reconcildiff(self, message):\n+        self.last_reconcildiff.append(message)\n+\n+    def send_sendrecon(self, sender, responder):\n+        msg = msg_sendrecon()\n+        msg.salt = self.mininode_salt\n+        msg.version = self.recon_version\n+        msg.sender = sender\n+        msg.responder = responder\n+        self.send_message(msg)\n+\n+    def send_reqrecon(self, set_size, q):\n+        msg = msg_reqrecon()\n+        msg.set_size = set_size\n+        msg.q = q\n+        self.send_message(msg)\n+\n+    def send_sketch(self, skdata):\n+        msg = msg_sketch()\n+        msg.skdata = skdata\n+        self.send_message(msg)\n+\n+    def send_reqsketchext(self):\n+        msg = msg_reqsketchext()\n+        self.send_message(msg)\n+\n+    def send_reconcildiff(self, success, ask_shortids):\n+        msg = msg_reconcildiff()\n+        msg.success = success\n+        msg.ask_shortids = ask_shortids\n+        self.send_message(msg)\n+\n+    def send_inv(self, inv_wtxids):\n+        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])\n+        self.send_message(msg)\n+\n+    def send_getdata(self, ask_wtxids):\n+        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])\n+        self.send_message(msg)\n+\n+#################################\n+##### High-level functions ######\n+#################################\n+\n+class ReconciliationTest(BitcoinTestFramework):\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.blocks_offset = 0\n+\n+    def proceed_in_time(self, jump_in_seconds):\n+        time.sleep(0.01) # We usually need the node to process some messages first.\n+        self.mocktime += jump_in_seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def generate_txs(self, n_mininode_unique, n_node_unique, n_shared, blocks, send=True):\n+        mininode_unique = []\n+        node_unique = []\n+        shared = []\n+\n+        for i in range(n_mininode_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            mininode_unique.append(tx)\n+\n+        for i in range(n_mininode_unique, n_mininode_unique + n_node_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            node_unique.append(tx)\n+\n+        for i in range(n_mininode_unique + n_node_unique, n_mininode_unique + n_node_unique + n_shared):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            shared.append(tx)\n+\n+        if send:\n+            self.nodes[0].p2ps[0].send_txs_and_test(node_unique + shared, self.nodes[0], success = True)\n+            self.blocks_offset += (n_mininode_unique + n_node_unique + n_shared)\n+\n+        return mininode_unique, node_unique, shared\n+\n+    def compute_salt(self):\n+        RECON_STATIC_SALT = \"Tx Relay Salting\"\n+        salt1, salt2 = self.test_node.node_salt, self.test_node.mininode_salt\n+        if salt1 > salt2:\n+            salt1, salt2 = salt2, salt1\n+        salt = struct.pack(\"<Q\", salt1) + struct.pack(\"<Q\", salt2)\n+        h = TaggedHash(RECON_STATIC_SALT, salt)\n+        k0 = int.from_bytes(h[0:8], \"little\")\n+        k1 = int.from_bytes(h[8:16], \"little\")\n+        return k0, k1\n+\n+    def request_reconciliation(self, test_node, mininode_set_size, expected_sketch):\n+        q_to_send = int(DEFAULT_Q * Q_PRECISION)\n+        test_node.send_reqrecon(mininode_set_size, q_to_send)\n+        self.proceed_in_time(3) # Hit sending sketches out\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) == 1)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(test_node.last_sketch[-1].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def transmit_sketch(self, test_node, txs_to_sketch, extension, capacity, expected_announced_txs):\n+        short_txids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_sketch]\n+        if extension:\n+            sketch = create_sketch(short_txids, capacity * 2)[int(capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            test_node.last_full_mininode_size = len(txs_to_sketch)\n+            sketch = create_sketch(short_txids, capacity)\n+        test_node.send_sketch(sketch)\n+        expected_wtxds = [tx.calc_sha256(True) for tx in expected_announced_txs]\n+        if len(expected_wtxds) > 0:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(expected_wtxds))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxds))\n+            test_node.last_inv_size = len(test_node.last_inv) # Needed to recompute node q later\n+            test_node.last_inv = []\n+        else:\n+            assert_equal(test_node.last_inv, [])\n+\n+    def handle_reconciliation_finalization(self, test_node, expected_success, expected_requested_txs):\n+        expected_requested_shortids = [GetShortID(tx, self.compute_salt()) for tx in expected_requested_txs]\n+\n+        def received_reconcildiff():\n+            return (len(test_node.last_reconcildiff) == 1)\n+        self.wait_until(received_reconcildiff, timeout=30)\n+        success = test_node.last_reconcildiff[0].success\n+        assert_equal(success, int(expected_success))\n+        assert_equal(set(test_node.last_reconcildiff[0].ask_shortids), set(expected_requested_shortids))\n+        if success:\n+            mininode_missing = test_node.last_inv_size\n+            node_missing = len(test_node.last_reconcildiff[0].ask_shortids)\n+            total_missing = mininode_missing + node_missing\n+            mininode_size = test_node.last_full_mininode_size\n+            node_size = mininode_size + mininode_missing - node_missing\n+            min_size = min(mininode_size, node_size)\n+            if min_size != 0:\n+                test_node.node_q = (total_missing - abs(mininode_missing - node_missing)) / min_size\n+        else:\n+            test_node.node_q = DEFAULT_Q\n+        test_node.last_reconcildiff = []\n+\n+    def handle_extension_request(self, test_node):\n+        def received_reqsketchext():\n+            return (len(test_node.last_reqsketchext) == 1)\n+        self.wait_until(received_reqsketchext, timeout=30)\n+        test_node.last_reqsketchext = []\n+\n+    def request_sketchext(self, test_node, expected_sketch):\n+        test_node.send_reqsketchext()\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) > 0)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(len(test_node.last_sketch), 1)\n+        assert_equal(test_node.last_sketch[0].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def finalize_reconciliation(self, test_node, success, txs_to_request, txs_to_expect):\n+        ask_shortids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_request]\n+        expected_wtxids = [tx.calc_sha256(with_witness = True) for tx in txs_to_expect]\n+        test_node.send_reconcildiff(success, ask_shortids)\n+        if txs_to_expect != []:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(txs_to_expect))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxids))\n+            test_node.last_inv = []\n+\n+    def request_transactions(self, test_node, txs_to_request):\n+        assert_equal(test_node.last_tx, []) # Make sure there were no unexpected transactions received before\n+        wtxids_to_request = [tx.calc_sha256(with_witness = True) for tx in txs_to_request]\n+        test_node.send_getdata(wtxids_to_request)\n+\n+        def received_tx():\n+            return (len(test_node.last_tx) == len(txs_to_request))\n+        self.wait_until(received_tx, timeout=30)\n+        assert_equal(set([tx.calc_sha256(True) for tx in txs_to_request]), set(test_node.last_tx))\n+        test_node.last_tx = []\n+\n+    def receive_reqreconcil(self, test_node, expected_set_size):\n+        def received_reqreconcil():\n+            return (len(test_node.last_reqreconcil) == 1)\n+        self.wait_until(received_reqreconcil, timeout=30)\n+\n+        if test_node.last_reqreconcil[-1].set_size == 0 and expected_set_size != 0:\n+            # Sometimes transactions are added to the reconciliation sets after the reqrecon\n+            # message is sent out by the peer. In that case, we need to immediately terminate\n+            # this reconciliation by sending an empty sketch, and proceed to the expected\n+            # scenario.\n+            test_node.last_reqreconcil = []\n+            self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False,\n+                capacity=0, expected_announced_txs=[])\n+            self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                expected_requested_txs=[])\n+\n+            self.wait_until(received_reqreconcil, timeout=30)\n+\n+        assert_equal(test_node.last_reqreconcil[-1].set_size, expected_set_size)\n+        assert_equal(test_node.last_reqreconcil[-1].q, int(test_node.node_q * Q_PRECISION))\n+        test_node.last_reqreconcil = []\n+\n+#################################\n+####### Actual test cases #######\n+#################################\n+\n+    def reconciliation_responder_flow(self, n_mininode, n_node, extension, result):\n+        mininode_txs, node_txs, _ = self.generate_txs(n_mininode, n_node, 0, self.blocks)\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_node_txs = []\n+        node_short_ids = [GetShortID(tx, self.compute_salt()) for tx in node_txs]\n+        if n_mininode == 0 or n_node == 0:\n+            expected_sketch_capacity = 0\n+        else:\n+            expected_sketch_capacity = estimate_capacity(n_mininode, n_node)\n+        expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity)\n+        self.request_reconciliation(self.test_node, len(mininode_txs), expected_sketch)\n+        more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks)[1])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        if extension:\n+            expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity * 2)[int(expected_sketch_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+            self.request_sketchext(self.test_node, expected_sketch)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+        if result:\n+            txs_to_request = random.sample(node_txs, 3)\n+            self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        else:\n+            self.finalize_reconciliation(self.test_node, True, [], txs_to_expect=[])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+\n+        # Check those additional transactions are not lost.\n+        short_ids = [GetShortID(tx, self.compute_salt()) for tx in more_node_txs]\n+        capacity = estimate_capacity(len(more_node_txs), 1)\n+        if capacity < 3:\n+            capacity += 1\n+        expected_sketch = create_sketch(short_ids, capacity)\n+        self.request_reconciliation(self.test_node, 1, expected_sketch)\n+        self.finalize_reconciliation(self.test_node, success=True, txs_to_request=[], txs_to_expect=[])\n+\n+    # The mininode is a reconciliation initiator, the node being tested is responder.\n+    def test_recon_responder(self):\n+        mininode_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # Needed to submit txs\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=0, mininode_salt=mininode_SALT))\n+        self.test_node0.wait_for_verack()\n+\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=mininode_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node.wait_for_verack()\n+        self.blocks = self.nodes[0].generate(nblocks=1024)\n+        self.sync_blocks()\n+\n+        # 0 at mininode, 20 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(0, 20, False, False)\n+        # 20 at mininode, 0 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(20, 0, False, False)\n+        # Initial reconciliation succeeds\n+        self.reconciliation_responder_flow(10, 20, False, False)\n+        # Initial reconciliation fails, extension succeeds\n+        self.reconciliation_responder_flow(1, 20, True, True)\n+        # Initial reconciliation fails, extension fails\n+        self.reconciliation_responder_flow(1, 20, True, False)\n+\n+    def reconciliation_initiator_flow(self, n_mininode, n_node, n_shared, capacity, terminate_after_initial, expected_success):\n+        mininode_unique_txs, node_unique_txs, shared_txs = self.generate_txs(n_mininode, n_node, n_shared, self.blocks, self)\n+        mininode_txs = mininode_unique_txs + shared_txs\n+        node_txs = node_unique_txs + shared_txs\n+        more_node_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(node_txs))\n+\n+        if terminate_after_initial:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=node_unique_txs)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                # This happens only if one of the sets (or both) was empty.\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+        else:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=[])\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            self.handle_extension_request(self.test_node)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_unique_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+\n+        self.request_transactions(self.test_node, node_unique_txs)\n+        # Check those additional transactions are not lost.\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(more_node_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False, capacity=0, expected_announced_txs=more_node_txs)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[])\n+\n+    # The node being tested is a reconciliation initiator, the mininode is responder.\n+    def test_recon_initiator(self):\n+        MININODE_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # The first node is used to feed the node being tested with transactions.\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node0.wait_for_verack()\n+\n+        # These nodes will consume regular tx flood forwarding\n+        for i in range(MAX_OUTBOUND_FLOOD_TO):\n+            flooding_node = self.nodes[0].add_p2p_connection(TestP2PConn(\n+                recon_version=0, mininode_salt=MININODE_SALT), node_outgoing=True)\n+            flooding_node.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=False, be_recon_responder=True), node_outgoing=True)\n+        self.test_node.wait_for_verack()\n+\n+        self.blocks = self.nodes[0].generate(nblocks=1024)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615320860",
      "id" : 615320860,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMyMDg2MA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 556,
      "original_position" : 480,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 638283440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615320860",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615322415"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why have you used CamelCase here? ",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-18T00:46:58Z",
      "diff_hunk" : "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########\n+#################################\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+def GetShortID(tx, salt):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322415",
      "id" : 615322415,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMyMjQxNQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 65,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 638284202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615322415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322950"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615322950"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not only with that.  I ran pycodestyle and got many warnings about it.\r\n\r\n![image](https://user-images.githubusercontent.com/19480819/115130588-3c113100-9fc7-11eb-8efd-77b0b406f732.png)\r\n",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-18T00:52:59Z",
      "diff_hunk" : "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615322950",
      "id" : 615322950,
      "in_reply_to_id" : 614934750,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMyMjk1MA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 38,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 638284435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615322950",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615594571"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615594571"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, pretty arbitrary. I could generate them in `generate_transactions` function, but then it would force block sync across nodes, which is not ideal to test that transactions are not lost between scenarios (block sync could hide this effect by forcing tx sync)",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-19T07:14:13Z",
      "diff_hunk" : "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########\n+#################################\n+def mul2(x):\n+    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n+    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n+\n+def mul(x, y):\n+    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n+    ret = 0\n+    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n+        ret, y = ret ^ bit * y, mul2(y)\n+    return ret\n+\n+def create_sketch(shortids, capacity):\n+    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n+    odd_sums = [0 for _ in range(capacity)]\n+    for shortid in shortids:\n+        squared = mul(shortid, shortid)\n+        for i in range(capacity):\n+            odd_sums[i] ^= shortid\n+            shortid = mul(shortid, squared)\n+    sketch_bytes = []\n+    for odd_sum in odd_sums:\n+        for i in range(4):\n+            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)\n+    return sketch_bytes\n+\n+def GetShortID(tx, salt):\n+    (k0, k1) = salt\n+    wtxid = tx.calc_sha256(with_witness = True)\n+    s = siphash256(k0, k1, wtxid)\n+    return 1 + (s & 0xFFFFFFFF)\n+\n+def estimate_capacity(theirs, ours=1):\n+    return int(abs(theirs - ours) + DEFAULT_Q * min(theirs, ours)) + 1\n+\n+def generate_transaction(node, coinbase):\n+    amount = 0.001\n+    to_address = node.getnewaddress()\n+    from_txid = node.getblock(coinbase)['tx'][0]\n+    inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+    outputs = { to_address : amount }\n+    rawtx = node.createrawtransaction(inputs, outputs)\n+    signresult = node.signrawtransactionwithwallet(rawtx)\n+    tx = CTransaction()\n+    tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))\n+    tx.rehash()\n+    return tx\n+\n+#################################\n+### General message handlers ####\n+#################################\n+\n+class TestP2PConn(P2PDataStore):\n+    def __init__(self, recon_version, mininode_salt, be_recon_requestor=False, be_recon_responder=False):\n+        super().__init__()\n+        self.recon_version = recon_version\n+        self.mininode_salt = mininode_salt\n+        self.be_recon_requestor = be_recon_requestor\n+        self.be_recon_responder= be_recon_responder\n+        self.node_salt = 0\n+        self.last_sendrecon = []\n+        self.last_sketch = []\n+        self.last_inv = []\n+        self.last_tx = []\n+        self.last_reqreconcil = []\n+        self.last_reconcildiff = []\n+        self.last_reqsketchext = []\n+        self.last_getdata = []\n+        self.node_q = DEFAULT_Q\n+        self.last_wtxidrelay = []\n+\n+    def on_version(self, message):\n+        if self.recon_version == 1:\n+            assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+            if message.nVersion >= 70016 and self.wtxidrelay:\n+                self.send_message(msg_wtxidrelay())\n+                self.send_sendrecon(self.be_recon_requestor, self.be_recon_responder)\n+            self.send_message(msg_verack())\n+            self.nServices = message.nServices\n+        else:\n+            super().on_version(message)\n+\n+    def on_sendrecon(self, message):\n+        self.last_sendrecon.append(message)\n+        self.node_salt = message.salt\n+\n+    def on_wtxidrelay(self, message):\n+        self.last_wtxidrelay.append(message)\n+\n+    def on_sketch(self, message):\n+        self.last_sketch.append(message)\n+\n+    def on_inv(self, message):\n+        MSG_BLOCK = 2\n+        for inv in message.inv:\n+            if inv.type != MSG_BLOCK: # ignore block invs\n+                self.last_inv.append(inv.hash)\n+\n+    def on_tx(self, message):\n+        self.last_tx.append(message.tx.calc_sha256(True))\n+\n+    def on_reqrecon(self, message):\n+        self.last_reqreconcil.append(message)\n+\n+    def on_reqsketchext(self, message):\n+        self.last_reqsketchext.append(message)\n+\n+    def on_reconcildiff(self, message):\n+        self.last_reconcildiff.append(message)\n+\n+    def send_sendrecon(self, sender, responder):\n+        msg = msg_sendrecon()\n+        msg.salt = self.mininode_salt\n+        msg.version = self.recon_version\n+        msg.sender = sender\n+        msg.responder = responder\n+        self.send_message(msg)\n+\n+    def send_reqrecon(self, set_size, q):\n+        msg = msg_reqrecon()\n+        msg.set_size = set_size\n+        msg.q = q\n+        self.send_message(msg)\n+\n+    def send_sketch(self, skdata):\n+        msg = msg_sketch()\n+        msg.skdata = skdata\n+        self.send_message(msg)\n+\n+    def send_reqsketchext(self):\n+        msg = msg_reqsketchext()\n+        self.send_message(msg)\n+\n+    def send_reconcildiff(self, success, ask_shortids):\n+        msg = msg_reconcildiff()\n+        msg.success = success\n+        msg.ask_shortids = ask_shortids\n+        self.send_message(msg)\n+\n+    def send_inv(self, inv_wtxids):\n+        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])\n+        self.send_message(msg)\n+\n+    def send_getdata(self, ask_wtxids):\n+        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])\n+        self.send_message(msg)\n+\n+#################################\n+##### High-level functions ######\n+#################################\n+\n+class ReconciliationTest(BitcoinTestFramework):\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.blocks_offset = 0\n+\n+    def proceed_in_time(self, jump_in_seconds):\n+        time.sleep(0.01) # We usually need the node to process some messages first.\n+        self.mocktime += jump_in_seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def generate_txs(self, n_mininode_unique, n_node_unique, n_shared, blocks, send=True):\n+        mininode_unique = []\n+        node_unique = []\n+        shared = []\n+\n+        for i in range(n_mininode_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            mininode_unique.append(tx)\n+\n+        for i in range(n_mininode_unique, n_mininode_unique + n_node_unique):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            node_unique.append(tx)\n+\n+        for i in range(n_mininode_unique + n_node_unique, n_mininode_unique + n_node_unique + n_shared):\n+            tx = generate_transaction(self.nodes[0], blocks[self.blocks_offset + i])\n+            shared.append(tx)\n+\n+        if send:\n+            self.nodes[0].p2ps[0].send_txs_and_test(node_unique + shared, self.nodes[0], success = True)\n+            self.blocks_offset += (n_mininode_unique + n_node_unique + n_shared)\n+\n+        return mininode_unique, node_unique, shared\n+\n+    def compute_salt(self):\n+        RECON_STATIC_SALT = \"Tx Relay Salting\"\n+        salt1, salt2 = self.test_node.node_salt, self.test_node.mininode_salt\n+        if salt1 > salt2:\n+            salt1, salt2 = salt2, salt1\n+        salt = struct.pack(\"<Q\", salt1) + struct.pack(\"<Q\", salt2)\n+        h = TaggedHash(RECON_STATIC_SALT, salt)\n+        k0 = int.from_bytes(h[0:8], \"little\")\n+        k1 = int.from_bytes(h[8:16], \"little\")\n+        return k0, k1\n+\n+    def request_reconciliation(self, test_node, mininode_set_size, expected_sketch):\n+        q_to_send = int(DEFAULT_Q * Q_PRECISION)\n+        test_node.send_reqrecon(mininode_set_size, q_to_send)\n+        self.proceed_in_time(3) # Hit sending sketches out\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) == 1)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(test_node.last_sketch[-1].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def transmit_sketch(self, test_node, txs_to_sketch, extension, capacity, expected_announced_txs):\n+        short_txids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_sketch]\n+        if extension:\n+            sketch = create_sketch(short_txids, capacity * 2)[int(capacity * BYTES_PER_SKETCH_CAPACITY):]\n+        else:\n+            test_node.last_full_mininode_size = len(txs_to_sketch)\n+            sketch = create_sketch(short_txids, capacity)\n+        test_node.send_sketch(sketch)\n+        expected_wtxds = [tx.calc_sha256(True) for tx in expected_announced_txs]\n+        if len(expected_wtxds) > 0:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(expected_wtxds))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxds))\n+            test_node.last_inv_size = len(test_node.last_inv) # Needed to recompute node q later\n+            test_node.last_inv = []\n+        else:\n+            assert_equal(test_node.last_inv, [])\n+\n+    def handle_reconciliation_finalization(self, test_node, expected_success, expected_requested_txs):\n+        expected_requested_shortids = [GetShortID(tx, self.compute_salt()) for tx in expected_requested_txs]\n+\n+        def received_reconcildiff():\n+            return (len(test_node.last_reconcildiff) == 1)\n+        self.wait_until(received_reconcildiff, timeout=30)\n+        success = test_node.last_reconcildiff[0].success\n+        assert_equal(success, int(expected_success))\n+        assert_equal(set(test_node.last_reconcildiff[0].ask_shortids), set(expected_requested_shortids))\n+        if success:\n+            mininode_missing = test_node.last_inv_size\n+            node_missing = len(test_node.last_reconcildiff[0].ask_shortids)\n+            total_missing = mininode_missing + node_missing\n+            mininode_size = test_node.last_full_mininode_size\n+            node_size = mininode_size + mininode_missing - node_missing\n+            min_size = min(mininode_size, node_size)\n+            if min_size != 0:\n+                test_node.node_q = (total_missing - abs(mininode_missing - node_missing)) / min_size\n+        else:\n+            test_node.node_q = DEFAULT_Q\n+        test_node.last_reconcildiff = []\n+\n+    def handle_extension_request(self, test_node):\n+        def received_reqsketchext():\n+            return (len(test_node.last_reqsketchext) == 1)\n+        self.wait_until(received_reqsketchext, timeout=30)\n+        test_node.last_reqsketchext = []\n+\n+    def request_sketchext(self, test_node, expected_sketch):\n+        test_node.send_reqsketchext()\n+\n+        def received_sketch():\n+            return (len(test_node.last_sketch) > 0)\n+        self.wait_until(received_sketch, timeout=30)\n+        assert_equal(len(test_node.last_sketch), 1)\n+        assert_equal(test_node.last_sketch[0].skdata, expected_sketch)\n+        test_node.last_sketch = []\n+\n+    def finalize_reconciliation(self, test_node, success, txs_to_request, txs_to_expect):\n+        ask_shortids = [GetShortID(tx, self.compute_salt()) for tx in txs_to_request]\n+        expected_wtxids = [tx.calc_sha256(with_witness = True) for tx in txs_to_expect]\n+        test_node.send_reconcildiff(success, ask_shortids)\n+        if txs_to_expect != []:\n+            def received_inv():\n+                return (len(test_node.last_inv) == len(txs_to_expect))\n+            self.wait_until(received_inv, timeout=30)\n+            assert_equal(set(test_node.last_inv), set(expected_wtxids))\n+            test_node.last_inv = []\n+\n+    def request_transactions(self, test_node, txs_to_request):\n+        assert_equal(test_node.last_tx, []) # Make sure there were no unexpected transactions received before\n+        wtxids_to_request = [tx.calc_sha256(with_witness = True) for tx in txs_to_request]\n+        test_node.send_getdata(wtxids_to_request)\n+\n+        def received_tx():\n+            return (len(test_node.last_tx) == len(txs_to_request))\n+        self.wait_until(received_tx, timeout=30)\n+        assert_equal(set([tx.calc_sha256(True) for tx in txs_to_request]), set(test_node.last_tx))\n+        test_node.last_tx = []\n+\n+    def receive_reqreconcil(self, test_node, expected_set_size):\n+        def received_reqreconcil():\n+            return (len(test_node.last_reqreconcil) == 1)\n+        self.wait_until(received_reqreconcil, timeout=30)\n+\n+        if test_node.last_reqreconcil[-1].set_size == 0 and expected_set_size != 0:\n+            # Sometimes transactions are added to the reconciliation sets after the reqrecon\n+            # message is sent out by the peer. In that case, we need to immediately terminate\n+            # this reconciliation by sending an empty sketch, and proceed to the expected\n+            # scenario.\n+            test_node.last_reqreconcil = []\n+            self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False,\n+                capacity=0, expected_announced_txs=[])\n+            self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                expected_requested_txs=[])\n+\n+            self.wait_until(received_reqreconcil, timeout=30)\n+\n+        assert_equal(test_node.last_reqreconcil[-1].set_size, expected_set_size)\n+        assert_equal(test_node.last_reqreconcil[-1].q, int(test_node.node_q * Q_PRECISION))\n+        test_node.last_reqreconcil = []\n+\n+#################################\n+####### Actual test cases #######\n+#################################\n+\n+    def reconciliation_responder_flow(self, n_mininode, n_node, extension, result):\n+        mininode_txs, node_txs, _ = self.generate_txs(n_mininode, n_node, 0, self.blocks)\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        more_node_txs = []\n+        node_short_ids = [GetShortID(tx, self.compute_salt()) for tx in node_txs]\n+        if n_mininode == 0 or n_node == 0:\n+            expected_sketch_capacity = 0\n+        else:\n+            expected_sketch_capacity = estimate_capacity(n_mininode, n_node)\n+        expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity)\n+        self.request_reconciliation(self.test_node, len(mininode_txs), expected_sketch)\n+        more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks)[1])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+        if extension:\n+            expected_sketch = create_sketch(node_short_ids, expected_sketch_capacity * 2)[int(expected_sketch_capacity * BYTES_PER_SKETCH_CAPACITY):]\n+            self.request_sketchext(self.test_node, expected_sketch)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+        if result:\n+            txs_to_request = random.sample(node_txs, 3)\n+            self.finalize_reconciliation(self.test_node, True, txs_to_request, txs_to_expect=txs_to_request)\n+        else:\n+            self.finalize_reconciliation(self.test_node, True, [], txs_to_expect=[])\n+        self.proceed_in_time(INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL + 1)\n+\n+        # Check those additional transactions are not lost.\n+        short_ids = [GetShortID(tx, self.compute_salt()) for tx in more_node_txs]\n+        capacity = estimate_capacity(len(more_node_txs), 1)\n+        if capacity < 3:\n+            capacity += 1\n+        expected_sketch = create_sketch(short_ids, capacity)\n+        self.request_reconciliation(self.test_node, 1, expected_sketch)\n+        self.finalize_reconciliation(self.test_node, success=True, txs_to_request=[], txs_to_expect=[])\n+\n+    # The mininode is a reconciliation initiator, the node being tested is responder.\n+    def test_recon_responder(self):\n+        mininode_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # Needed to submit txs\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=0, mininode_salt=mininode_SALT))\n+        self.test_node0.wait_for_verack()\n+\n+        self.mocktime = int(time.time())\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=mininode_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node.wait_for_verack()\n+        self.blocks = self.nodes[0].generate(nblocks=1024)\n+        self.sync_blocks()\n+\n+        # 0 at mininode, 20 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(0, 20, False, False)\n+        # 20 at mininode, 0 at node, 0 shared, early exit, expect empty sketch.\n+        self.reconciliation_responder_flow(20, 0, False, False)\n+        # Initial reconciliation succeeds\n+        self.reconciliation_responder_flow(10, 20, False, False)\n+        # Initial reconciliation fails, extension succeeds\n+        self.reconciliation_responder_flow(1, 20, True, True)\n+        # Initial reconciliation fails, extension fails\n+        self.reconciliation_responder_flow(1, 20, True, False)\n+\n+    def reconciliation_initiator_flow(self, n_mininode, n_node, n_shared, capacity, terminate_after_initial, expected_success):\n+        mininode_unique_txs, node_unique_txs, shared_txs = self.generate_txs(n_mininode, n_node, n_shared, self.blocks, self)\n+        mininode_txs = mininode_unique_txs + shared_txs\n+        node_txs = node_unique_txs + shared_txs\n+        more_node_txs = []\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(node_txs))\n+\n+        if terminate_after_initial:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=node_unique_txs)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                # This happens only if one of the sets (or both) was empty.\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+        else:\n+            self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=False,\n+                capacity=capacity, expected_announced_txs=[])\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            self.handle_extension_request(self.test_node)\n+            more_node_txs.extend(self.generate_txs(0, 1, 0, self.blocks, self)[1])\n+            if expected_success:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_unique_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=True,\n+                    expected_requested_txs=mininode_unique_txs)\n+            else:\n+                self.transmit_sketch(self.test_node, txs_to_sketch=mininode_txs, extension=True,\n+                    capacity=capacity, expected_announced_txs=node_txs)\n+                self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+                    expected_requested_txs=[])\n+\n+        self.request_transactions(self.test_node, node_unique_txs)\n+        # Check those additional transactions are not lost.\n+        self.proceed_in_time(RECON_REQUEST_INTERVAL + 1)\n+        self.receive_reqreconcil(self.test_node, expected_set_size=len(more_node_txs))\n+        self.transmit_sketch(self.test_node, txs_to_sketch=[], extension=False, capacity=0, expected_announced_txs=more_node_txs)\n+        self.handle_reconciliation_finalization(self.test_node, expected_success=False,\n+            expected_requested_txs=[])\n+\n+    # The node being tested is a reconciliation initiator, the mininode is responder.\n+    def test_recon_initiator(self):\n+        MININODE_SALT = random.randrange(0xffffff)\n+        self.blocks_offset = 0\n+\n+        # The first node is used to feed the node being tested with transactions.\n+        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=True, be_recon_responder=False))\n+        self.test_node0.wait_for_verack()\n+\n+        # These nodes will consume regular tx flood forwarding\n+        for i in range(MAX_OUTBOUND_FLOOD_TO):\n+            flooding_node = self.nodes[0].add_p2p_connection(TestP2PConn(\n+                recon_version=0, mininode_salt=MININODE_SALT), node_outgoing=True)\n+            flooding_node.wait_for_verack()\n+\n+        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1,\n+            mininode_salt=MININODE_SALT, be_recon_requestor=False, be_recon_responder=True), node_outgoing=True)\n+        self.test_node.wait_for_verack()\n+\n+        self.blocks = self.nodes[0].generate(nblocks=1024)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r615594571",
      "id" : 615594571,
      "in_reply_to_id" : 615320860,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTU5NDU3MQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 556,
      "original_position" : 480,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 638527852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/615594571",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-04-19T07:45:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-822250898",
      "id" : 822250898,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgyMjI1MDg5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-04-19T07:45:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/822250898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616814867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616814867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think we should update BIP330 to mark the dependency on BIP339. Also, should we bump the protocol version ? Otherwise a bip330 peer will send `SENDRECON` for nothing to bip339-only peer (core version 20+).",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T15:45:54Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616814867",
      "id" : 616814867,
      "line" : 2829,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjgxNDg2Nw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2829,
      "original_position" : 295,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 331,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616814867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616846325"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616846325"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think what said in comment \"which pass... !IsInboundConn\" is enforced and actually inbound peers might take outbound flooding peers slots ?\r\n\r\nTurning this flag to false break `test_outgoing_recon` as all added peers L475-479 aren't occupying anymore flooding peers slots and as such the tested peers is flood to. IIRC `add_p2p_connection`'s peers are seen as inbound ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T16:24:21Z",
      "diff_hunk" : "@@ -2535,6 +2643,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {\n+                        // We flood txs to only a subset of outbound reconciling peers.\n+                        we_may_flood_to = true;\n+                    }\n+                } else {\n+                    // All non-reconciling peers which pass the MightSupportTransactionRelay and\n+                    // !IsInboundConn checks are outbound flooding peers.\n+                    we_may_flood_to = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616846325",
      "id" : 616846325,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg0NjMyNQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2672,
      "original_position" : 256,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616846325",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616855063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616855063"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is the following scenario possible ?\r\n* current outbound flooding peers=MAX_OUTBOUND_FLOOD_TO - 1\r\n* outbound peer 1 connects\r\n* outbound peer 2 connects\r\n* outbound peer 1 send a SENDRECON is marked as outbound flooding peers as a slot is still available\r\n* outbound peer 2 send a SENDRECON is marked as outbound flooding peers as a slot is still available\r\n* outbound peer 1 send a VERACK, current outbound flooding peers = MAX_OUTBOUND_FLOOD_TO\r\n* outbound peer 2 send a VERACK, current outbound flooding peers = MAX_OUTBOUND_FLOOD_TO +1 \r\n\r\nWhat do you think about moving outbound flooding peers accouting from VERACK to SENDRECON ? Independently of my scenario truthiness, I believe it would even avoid to reason on how message ordering is influencing accounting.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T16:35:59Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt, m_out_flood_to);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616855063",
      "id" : 616855063,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg1NTA2Mw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2818,
      "original_position" : 309,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616855063",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616861921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616861921"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this variable belong more to our transaction relay policy rather than the reconciliation module in itself.  Its effect on the reconciliation module are function of the connection state, which is located outside this module. I'm leaning towards removing any \"flooding\" mention from this module, it should be agnostic about the existence of another transaction-announcement protocol.\r\n\r\nI guess \"flood\" could be a flag in `CNodeState`/`Peer` and allow to remove `IsPeerChosenForFlooding` here.\r\n\r\nWhat do you think ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T16:43:49Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616861921",
      "id" : 616861921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg2MTkyMQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616861921",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616897107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616897107"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think `MAX_PEER_TX_ANNOUNCEMENTS` is covered by `p2p_erlay.py` ? This diff doesn't yell an error.\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 689b899f1..0703fcea7 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -81,7 +81,7 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\r\n  *  the actual transaction (from any peer) in response to requests for them.\r\n  *  Also limits a maximum number of elements to store in the reconciliation set.\r\n  */\r\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\r\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 4999;\r\n /** How long to delay requesting transactions via txids, if we have wtxid-relaying peers */\r\n static constexpr auto TXID_RELAY_DELAY = std::chrono::seconds{2};\r\n /** How long to delay requesting transactions from non-preferred peers */\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T17:32:07Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616897107",
      "id" : 616897107,
      "line" : 4817,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjg5NzEwNw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4817,
      "original_position" : 522,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 567,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616897107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616903681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616903681"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IIUC, erlay is introducing an interdependency between transaction's source and selection of outgoing announcement-protocol (cf `RelayTransaction`), but I'm not if this is covered by `p2p_erlay.py` ? Following diff doesn't yell a failure. Same we turning to always true.\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 1818fc0f2..a4e847110 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -4732,7 +4732,8 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\r\n                         // Fetch the top element from the heap\r\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\r\n                         uint256 hash = vInvTx.back();\r\n-                        bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);\r\n+                        //bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);\r\n+                        bool flood_tx = false;\r\n                         vInvTx.pop_back();\r\n                         CInv inv(state.m_wtxid_relay ? MSG_WTX : MSG_TX, hash);\r\n                         // Remove it from the to-be-sent set\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T17:40:31Z",
      "diff_hunk" : "@@ -4525,12 +4741,12 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                     while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                         // Fetch the top element from the heap\n                         std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                        std::set<uint256>::iterator it = vInvTx.back();\n+                        uint256 hash = vInvTx.back();\n+                        const bool flood_tx = pto->m_tx_relay->m_txs_to_announce.at(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616903681",
      "id" : 616903681,
      "line" : 4778,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjkwMzY4MQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4778,
      "original_position" : 491,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 536,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616903681",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616905161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616905161"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it should be AND not an OR here. If `recon_peer_flood_to`= false, even if transaction is marked for flooding, it will be added to reconciliation set. Is it the semantic intended ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T17:42:51Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616905161",
      "id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjkwNTE2MQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616905161",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616910754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616910754"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure if the following change on how reconciliation is influencing broadcast interval is covered by `p2p_erlay.py`\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 1818fc0f2..28641f576 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -4664,7 +4664,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\r\n                 bool fSendTrickle = pto->HasPermission(PF_NOBAN);\r\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\r\n                     fSendTrickle = true;\r\n-                    if (!supports_recon && pto->IsInboundConn()) {\r\n+                    if (pto->IsInboundConn()) {\r\n                         pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\r\n                     } else {\r\n                         // Use half the delay for outbound peers, as there is less privacy concern for them.\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-20T17:51:11Z",
      "diff_hunk" : "@@ -4457,22 +4668,26 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             peer->m_blocks_for_inv_relay.clear();\n \n             if (pto->m_tx_relay != nullptr) {\n+                const bool supports_recon = m_reconciliation.IsPeerRegistered(pto->GetId());\n                 LOCK(pto->m_tx_relay->cs_tx_inventory);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n                 if (pto->m_tx_relay->nNextInvSend < current_time) {\n                     fSendTrickle = true;\n-                    if (pto->IsInboundConn()) {\n+                    if (!supports_recon && pto->IsInboundConn()) {\n                         pto->m_tx_relay->nNextInvSend = m_connman.PoissonNextSendInbound(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n                     } else {\n+                        // Use half the delay for outbound peers, as there is less privacy concern for them.\n+                        // Also use half delay for inbound peers if they use reconciliations,\n+                        // because we have an additional delay for sending out requested sketches.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r616910754",
      "id" : 616910754,
      "line" : 4715,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjkxMDc1NA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4715,
      "original_position" : 447,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 492,
      "pull_request_review_id" : 640132240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/616910754",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617332543"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617332543"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">Is it the semantic intended?\r\n\r\nYes. Whether the transaction is marked for flooding *only* matters for reconciliation peers which are set for flooding.\r\nSo, if `flood_tx=true` but `recon_peer_flood_to= false`, we should reconcile.\r\n\r\nPerhaps this comment covers it already, no:\r\n```\r\n    /**\r\n     * Per BIP-330, we may want to flood certain transactions to a subset of peers with whom we\r\n     * reconcile.\r\n     * If the peer was not previously registered for reconciliations, returns nullopt.\r\n     */\r\n    std::optional<bool> IsPeerChosenForFlooding(NodeId peer_id) const;\r\n```\r\n\r\nShould I repeat it here?\r\n\r\n",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T08:57:22Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617332543",
      "id" : 617332543,
      "in_reply_to_id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzMzMjU0Mw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 640794804,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617332543",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617336557"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617336557"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">I don't think what said in comment \"which pass... !IsInboundConn\" is enforced and actually inbound peers might take outbound flooding peers slots ?\r\n\r\nSee line above: `if (!pfrom.IsInboundConn()) {`, that's where it's enforced.\r\n\r\n>IIRC add_p2p_connection's peers are seen as inbound ?\r\n\r\nNope, I added a hack for that: 108b0233be7735b793e488ba5bda836d24b75d4e",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T09:02:46Z",
      "diff_hunk" : "@@ -2535,6 +2643,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {\n+                        // We flood txs to only a subset of outbound reconciling peers.\n+                        we_may_flood_to = true;\n+                    }\n+                } else {\n+                    // All non-reconciling peers which pass the MightSupportTransactionRelay and\n+                    // !IsInboundConn checks are outbound flooding peers.\n+                    we_may_flood_to = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617336557",
      "id" : 617336557,
      "in_reply_to_id" : 616846325,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzMzNjU1Nw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2672,
      "original_position" : 256,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 640800102,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617336557",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617353731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617353731"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">I think we should update BIP330 to mark the dependency on BIP339.\r\n\r\nAgree.\r\n\r\n>Also, should we bump the protocol version ? Otherwise a bip330 peer will send SENDRECON for nothing to bip339-only peer (core version 20+).\r\n\r\nI don't understand what you mean here. \r\n",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T09:25:55Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617353731",
      "id" : 617353731,
      "in_reply_to_id" : 616814867,
      "line" : 2829,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzM1MzczMQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2829,
      "original_position" : 295,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 331,
      "pull_request_review_id" : 640822764,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617353731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617367944"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617367944"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Accidentally some nodes might ignore fee filter, but we don't punish, so it's safe in that sense. Some useless transactions could be sent, but I think it's too hard to exploit in a real way.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T09:45:07Z",
      "diff_hunk" : "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617367944",
      "id" : 617367944,
      "in_reply_to_id" : 614225402,
      "line" : 2439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzM2Nzk0NA==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 2439,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 242,
      "pull_request_review_id" : 640868059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617367944",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617622941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617622941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "linter not happy with this line:\r\n\r\n`All calls to LogPrintf() and LogPrint() should be terminated with \\n`\r\n",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T14:52:01Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continue */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617622941",
      "id" : 617622941,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzYyMjk0MQ==",
      "original_commit_id" : "eede5dc518502fd31c2b83ffc8a212f645f75cf8",
      "original_line" : 493,
      "original_position" : 493,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 641193149,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617622941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/755825?v=4",
         "events_url" : "https://api.github.com/users/adamjonas/events{/privacy}",
         "followers_url" : "https://api.github.com/users/adamjonas/followers",
         "following_url" : "https://api.github.com/users/adamjonas/following{/other_user}",
         "gists_url" : "https://api.github.com/users/adamjonas/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/adamjonas",
         "id" : 755825,
         "login" : "adamjonas",
         "node_id" : "MDQ6VXNlcjc1NTgyNQ==",
         "organizations_url" : "https://api.github.com/users/adamjonas/orgs",
         "received_events_url" : "https://api.github.com/users/adamjonas/received_events",
         "repos_url" : "https://api.github.com/users/adamjonas/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/adamjonas/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/adamjonas"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617664798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617664798"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes I recognize that's hard to exploit but even further any mempool manipulation comes up with a priced cost for the attacker as you need utxo value to fan out in victim(s) mempools.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T15:39:43Z",
      "diff_hunk" : "@@ -2308,6 +2354,59 @@ void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)\n     m_connman.PushMessage(&peer, std::move(msg));\n }\n \n+namespace {\n+class CompareInvMempoolOrder\n+{\n+    CTxMemPool *mp;\n+    bool m_wtxid_relay;\n+public:\n+    explicit CompareInvMempoolOrder(CTxMemPool *_mempool, bool use_wtxid)\n+    {\n+        mp = _mempool;\n+        m_wtxid_relay = use_wtxid;\n+    }\n+\n+    bool operator()(const uint256& a, const uint256& b)\n+    {\n+        /* As std::make_heap produces a max-heap, we want the entries with the\n+         * fewest ancestors/highest fee to sort later. */\n+        return mp->CompareDepthAndScore(b, a, m_wtxid_relay);\n+    }\n+};\n+}\n+\n+void PeerManagerImpl::AnnounceTxs(std::vector<uint256> remote_missing_wtxids, CNode& pto)\n+{\n+    if (remote_missing_wtxids.size() == 0) return;\n+\n+    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+    // A heap is used so that not all items need sorting if only a few are being sent.\n+    CompareInvMempoolOrder compareInvMempoolOrder(&m_mempool, true);\n+    std::make_heap(remote_missing_wtxids.begin(), remote_missing_wtxids.end(), compareInvMempoolOrder);\n+\n+    const CNetMsgMaker msgMaker(pto.GetCommonVersion());\n+    std::vector<CInv> remote_missing_invs;\n+    remote_missing_invs.reserve(std::min<size_t>(remote_missing_wtxids.size(), MAX_INV_SZ));\n+\n+    while (!remote_missing_wtxids.empty()) {\n+        // No need to add transactions to peer's filter or do checks\n+        // because it was already done when adding to the reconciliation set.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617664798",
      "id" : 617664798,
      "in_reply_to_id" : 614225402,
      "line" : 2439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY2NDc5OA==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 2439,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 242,
      "pull_request_review_id" : 641248911,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617664798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617670809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617670809"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A bip330 peer sends a SENDRECON message to a wtxid-relay peer but not supporting bip330. \r\nThe wtxid-relay peer doesn't understand SENDRECON and will ignore the message.\r\nThe bip330 wasted SENDRECON message bandwidth.\r\n\r\nIf the bip330 peer would have been aware that the wtxid-relay peer didn't support bip330 it could have avoid sending SENDRECON. Right now, I think your check implies that wtxid-relay peers also support bip330, I believe a protocol version bump would avoid this minor issue.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T15:46:48Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617670809",
      "id" : 617670809,
      "in_reply_to_id" : 616814867,
      "line" : 2829,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY3MDgwOQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2829,
      "original_position" : 295,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 331,
      "pull_request_review_id" : 641256818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617670809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617686514"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617686514"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah sorry didn't see the patch was the reason of my confusion. So yes it's tested and the logic works as documented. \r\n\r\nMaybe add a friendly note L475 in `p2p_erlay.py` \"Contrary to default mininode setting, we mark those peers as node_outgoing=true to simulate them as outgoing connections and thus have them consume regular flood tx forwarding\" ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T16:05:38Z",
      "diff_hunk" : "@@ -2535,6 +2643,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                       pfrom.nVersion.load(), peer->m_starting_height,\n                       pfrom.GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom.addr.ToString()) : \"\"),\n                       pfrom.ConnectionTypeAsString());\n+\n+            // Keep track of the number of outbound flooding peers.\n+            bool we_may_flood_to = false;\n+            if (pfrom.MightSupportTransactionRelay()) {\n+                if (m_reconciliation.IsPeerRegistered(pfrom.GetId())) {\n+                    if (*m_reconciliation.IsPeerChosenForFlooding(pfrom.GetId())) {\n+                        // We flood txs to only a subset of outbound reconciling peers.\n+                        we_may_flood_to = true;\n+                    }\n+                } else {\n+                    // All non-reconciling peers which pass the MightSupportTransactionRelay and\n+                    // !IsInboundConn checks are outbound flooding peers.\n+                    we_may_flood_to = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617686514",
      "id" : 617686514,
      "in_reply_to_id" : 616846325,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY4NjUxNA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2672,
      "original_position" : 256,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 641277457,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617686514",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617690684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617690684"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@brunoerg I think following best practices beyond what *our* linter does is not necessary, but still I tried to resolve most of those complaints from `pycodestyle` where it makes sense.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T16:11:02Z",
      "diff_hunk" : "@@ -0,0 +1,503 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, hex_str_to_bytes\n+\n+# These parameters are specified in the BIP-0330.\n+Q_PRECISION = (2 << 14) - 1\n+FIELD_BITS = 32\n+FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n+\n+# These parameters are suggested by the Erlay paper based on analysis and simulations.\n+DEFAULT_Q = 0.02\n+RECON_REQUEST_INTERVAL = 16\n+INBOUND_PENALIZED_INVENTORY_BROADCAST_INTERVAL = 5\n+MAX_OUTBOUND_FLOOD_TO = 8\n+\n+BYTES_PER_SKETCH_CAPACITY = FIELD_BITS / 8\n+\n+#################################\n+######## General helpers ########",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617690684",
      "id" : 617690684,
      "in_reply_to_id" : 614934750,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzY5MDY4NA==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 38,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 641282944,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617690684",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617718341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617718341"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">  So, if flood_tx=true but recon_peer_flood_to= false, we should reconcile.\r\n\r\nThis case I understand. The case I don't get the rational for is recon_peer_flood_to=true and flood_tx=false. \r\n\r\nAFAICT, it's motivated to preserve privacy of transactions originated locally as detailed in `RelayTransaction` ? I don't think it's achieving its goal as this announcement (i.e _reconciliation_) will diverge from the announcement-protocol expected on the link (i.e _flooding_) and this is observable by the peer on the other side of the link ?\r\n\r\nOverall, yes the comment could be better as it's describing code behavior but not it's rational (or pointing where the rational is laid out). Instead, what do you think of ?\r\n\r\n```\r\n\r\n// Unless sketch capacity has been reached, expected announcement policy should not diverge\r\n// for reconciling peers.\r\n// Outbound flooding peers may the expected announcement policy overridden in function of\r\n// the transaction source. Transactions originated locally should be always announced through\r\n// reconciliation, see RelayTransaction().\r\n\r\n``` ",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T16:49:19Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617718341",
      "id" : 617718341,
      "in_reply_to_id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzcxODM0MQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 641318641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617718341",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617765235"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617765235"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If your peer has been marked as a responder but it sends you anyway a REQRECON, should we severe the connection ? I think it's qualify as a violation of protocol roles (sender, responder) as negotiated in SENDRECON.\r\n\r\nSame reasoning for other Erlay messages, should we enforce protocol flow ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T17:58:28Z",
      "diff_hunk" : "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617765235",
      "id" : 617765235,
      "line" : 4012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc2NTIzNQ==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4012,
      "original_position" : 336,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 384,
      "pull_request_review_id" : 641380591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617765235",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617774781"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617774781"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mutating this flag to false doesn't seem to break `p2p_erlay.py` ?\r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex bbab3f92c..1dfdc3017 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -3998,7 +3998,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\r\n         } else {\r\n             // Disconnect peers that send reconciliation sketch violating the protocol.\r\n             LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\r\n-            pfrom.fDisconnect = true;\r\n+            pfrom.fDisconnect = false;\r\n             return;\r\n         }\r\n         return;\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T18:13:54Z",
      "diff_hunk" : "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        std::optional<bool> recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without losing the initial data.\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::REQSKETCHEXT));\n+            }\n+            AnnounceTxs(txs_to_announce, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation sketch violating the protocol.\n+            LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617774781",
      "id" : 617774781,
      "line" : 4042,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc3NDc4MQ==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4042,
      "original_position" : 366,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 414,
      "pull_request_review_id" : 641380591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617774781",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617784280"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617784280"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should we sanitize `peer_recon_set_size` ?\r\n\r\nWhat if a peer send you peer_recon_set_size=UINT16_MAX, may this provoke issues in `EstimateSketchCapacity` or `ComputeBaseSketch`, which are both consuming this value or product of it ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T18:28:32Z",
      "diff_hunk" : "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617784280",
      "id" : 617784280,
      "line" : 4014,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc4NDI4MA==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4014,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 386,
      "pull_request_review_id" : 641380591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617784280",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617790228"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617790228"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should `MAX_SKETCH_CAPACITY` be exposed in the BIP ?\r\n\r\nOtherwise I think other implementation can't verify when they're not in violation of your reconciliation bounds.\r\n\r\n",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T18:38:18Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if(local_salt == m_local_salts.end()) return;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        if (!(they_initiate || we_initiate)) return;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        // To save bandwidth, we never flood to inbound peers we reconcile with. We may flood *some*\n+        // transactions to a limited number outbound peers we reconcile with.\n+        bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciliation with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i, flood_to=%i.\\n\", peer_id, we_initiate, they_initiate, flood_to);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate, flood_to));\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, recon_state->second.m_local_set.GetSize(), peer_id);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+        if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+                m_queue.pop_back();\n+                m_queue.push_front(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+                double local_q = recon_state->second.m_state_init_by_us.m_local_q;\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i, local_q=%i.\\n\", peer_id, local_set_size, local_q);\n+\n+                return std::make_pair(local_set_size, local_q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;\n+\n+        double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\n+        recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\n+        recon_state->second.m_state_init_by_them.m_remote_set_size = peer_recon_set_size;\n+        recon_state->second.m_state_init_by_them.m_next_recon_respond = NextReconRespond();\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_REQUESTED;\n+\n+        LogPrint(BCLog::NET, \"Reconciliation initiated by peer=%d with the following params: \" /* Continued */\n+            \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n+    }\n+\n+    bool RespondToReconciliationRequest(NodeId peer_id, std::vector<uint8_t>& skdata)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return false;\n+        if (recon_state->second.m_we_initiate) return false;\n+\n+        Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\n+\n+        // For initial requests, respond only periodically to a) limit CPU usage for sketch computation,\n+        // and, b) limit transaction possession privacy leak.\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        bool timely_initial_request = incoming_phase == Phase::INIT_REQUESTED &&\n+            current_time > recon_state->second.m_state_init_by_them.m_next_recon_respond;\n+        bool extension_request = incoming_phase == Phase::EXT_REQUESTED;\n+        if (!timely_initial_request && !extension_request) {\n+            return false;\n+        }\n+\n+        Minisketch sketch;\n+        if (timely_initial_request) {\n+            // Responding to an initial reconciliation request.\n+\n+            uint16_t sketch_capacity = 0;\n+            // We send an empty vector at initial request in the following 2 cases because\n+            // reconciliation can't help:\n+            // - if we have nothing on our side\n+            // - if they have nothing on their side\n+            // Then, they will terminate reconciliation early and force flooding-style announcement.\n+            if (recon_state->second.m_state_init_by_them.m_remote_set_size > 0 &&\n+                    recon_state->second.m_local_set.GetSize() > 0) {\n+\n+                sketch_capacity = recon_state->second.m_state_init_by_them.EstimateSketchCapacity(\n+                    recon_state->second.m_local_set.GetSize());\n+                Minisketch sketch = recon_state->second.ComputeBaseSketch(sketch_capacity);\n+                if (sketch) skdata = sketch.Serialize();\n+            }\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n+            recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n+\n+            LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n+                \"sending sketch of capacity=%i.\\n\", peer_id, sketch_capacity);\n+        } else {\n+            // Responding to an extension request.\n+            if (recon_state->second.m_capacity_snapshot == 0) {\n+                // In this case, the peer is supposed to terminate the reconciliation and not\n+                // request extension.\n+                LogPrint(BCLog::NET, \"Peer=%d violated the protocol by requesting an extension \" /* Continued */\n+                    \"even though we initially provided an empty sketch.\\n\", peer_id);\n+                return false;\n+            }\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\n+\n+            // Local extension sketch can be null only if initial sketch or initial capacity was 0,\n+            // in which case we would have terminated reconciliation already.\n+            uint16_t extended_capacity = std::min(uint16_t(recon_state->second.m_capacity_snapshot * 2), MAX_SKETCH_CAPACITY);\n+            sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+            assert(sketch);\n+            skdata = sketch.Serialize();\n+\n+            // For the sketch extension, send only the higher sketch elements.\n+            size_t lower_bytes_to_drop = extended_capacity / 2 * BYTES_PER_SKETCH_CAPACITY;\n+            // Extended sketch is twice the size of the initial sketch (which is m_capacity_snapshot).\n+            assert(lower_bytes_to_drop <= skdata.size());\n+            skdata.erase(skdata.begin(), skdata.begin() + lower_bytes_to_drop);\n+\n+            LogPrint(BCLog::NET, \"Responding with a sketch extension to reconciliation initiated by peer=%d.\\n\", peer_id);\n+        }\n+        return true;\n+    }\n+\n+    bool HandleSketch(NodeId peer_id, const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617790228",
      "id" : 617790228,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzc5MDIyOA==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 805,
      "original_position" : 811,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 641380591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617790228",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617800136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617800136"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How do we handle failure if the responder never replies to our reconciliation request ?\r\n\r\nI don't think this is handled by `TxReconciliationTracker` for now. After RECON_REQUEST_INTERVAL expires again, is `MaybeRequestReconciliation` going to generate a new reconciliation request ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T18:54:51Z",
      "diff_hunk" : "@@ -4577,12 +4822,43 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_reconciliation.AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n             }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            auto reconciliation_request_data = m_reconciliation.MaybeRequestReconciliation(pto->GetId());\n+            if (reconciliation_request_data) {\n+                const auto [local_set_size, local_q_formatted] = (*reconciliation_request_data);\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::REQRECON, local_set_size, local_q_formatted));\n+            }\n+        }\n+\n+        //\n+        // Message: reconciliation response\n+        //\n+        {\n+            std::vector<uint8_t> skdata;\n+            bool respond = m_reconciliation.RespondToReconciliationRequest(pto->GetId(), skdata);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617800136",
      "id" : 617800136,
      "line" : 4892,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzgwMDEzNg==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4892,
      "original_position" : 570,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 616,
      "pull_request_review_id" : 641380591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617800136",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617803685"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617803685"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mutating this flag doesn't seem to break `p2p_erlay.py` \r\n\r\n```\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex bbab3f92c..62afc0eb3 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -4023,7 +4023,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\r\n         } else {\r\n             // Disconnect peers that send reconciliation finalization violating the protocol.\r\n             LogPrint(BCLog::NET, \"reconcildiff from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\r\n-            pfrom.fDisconnect = true;\r\n+            pfrom.fDisconnect = false;\r\n             return;\r\n         }\r\n         return;\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-21T19:00:24Z",
      "diff_hunk" : "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::SKETCH) {\n+        std::vector<uint8_t> skdata;\n+        vRecv >> skdata;\n+\n+        std::vector<uint32_t> txs_to_request;\n+        std::vector<uint256> txs_to_announce;\n+        std::optional<bool> recon_result;\n+        bool valid_sketch = m_reconciliation.HandleSketch(pfrom.GetId(), skdata, txs_to_request, txs_to_announce, recon_result);\n+\n+        if (valid_sketch) {\n+            if (recon_result) {\n+                // Handles both successful and failed reconciliation (but not the case per which\n+                // we want to request extension).\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::RECONCILDIFF,\n+                    *recon_result, txs_to_request));\n+            } else {\n+                // No final result means we should request sketch extension to make another\n+                // reconciliation attempt without losing the initial data.\n+                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::REQSKETCHEXT));\n+            }\n+            AnnounceTxs(txs_to_announce, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation sketch violating the protocol.\n+            LogPrint(BCLog::NET, \"sketch from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+        return;\n+    }\n+\n+    if (msg_type == NetMsgType::REQSKETCHEXT) {\n+        m_reconciliation.HandleExtensionRequest(pfrom.GetId());\n+        return;\n+    }\n+\n+    // Among transactions requested by short ID here, we should send only those transactions\n+    // sketched (stored in local set snapshot), because otherwise we would leak privacy (mempool content).\n+    if (msg_type == NetMsgType::RECONCILDIFF) {\n+        bool recon_result;\n+        std::vector<uint32_t> ask_shortids;\n+        vRecv >> recon_result >> ask_shortids;\n+\n+        std::vector<uint256> remote_missing;\n+        bool valid_finalization = m_reconciliation.FinalizeInitByThem(pfrom.GetId(), recon_result, ask_shortids, remote_missing);\n+        if (valid_finalization) {\n+            AnnounceTxs(remote_missing, pfrom);\n+        } else {\n+            // Disconnect peers that send reconciliation finalization violating the protocol.\n+            LogPrint(BCLog::NET, \"reconcildiff from peer=%d violates reconciliation protocol; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r617803685",
      "id" : 617803685,
      "line" : 4067,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzgwMzY4NQ==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4067,
      "original_position" : 391,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 439,
      "pull_request_review_id" : 641380591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/617803685",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618127934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618127934"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It is enforced in `txreconciliation.cpp`, but currently these requests are just ignored. I'm not sure if we should disconnect.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-22T06:55:00Z",
      "diff_hunk" : "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618127934",
      "id" : 618127934,
      "in_reply_to_id" : 617765235,
      "line" : 4012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODEyNzkzNA==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4012,
      "original_position" : 336,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 384,
      "pull_request_review_id" : 641835595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618127934",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618129008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618129008"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">What if a peer send you peer_recon_set_size=UINT16_MAX, may this provoke issues in EstimateSketchCapacity or ComputeBaseSketch, which are both consuming this value or product of it ?\r\n\r\nThis is taken care by `capacity = std::min(capacity, MAX_SKETCH_CAPACITY);` in `ComputeBaseSketch`, so this shouldn't cause any harm.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-22T06:56:43Z",
      "diff_hunk" : "@@ -3800,6 +3967,68 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    if (msg_type == NetMsgType::REQRECON) {\n+        uint16_t peer_recon_set_size, peer_q;\n+        vRecv >> peer_recon_set_size >> peer_q;\n+        m_reconciliation.HandleReconciliationRequest(pfrom.GetId(), peer_recon_set_size, peer_q);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618129008",
      "id" : 618129008,
      "in_reply_to_id" : 617784280,
      "line" : 4014,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODEyOTAwOA==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4014,
      "original_position" : 338,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 386,
      "pull_request_review_id" : 641836901,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618129008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618130349"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618130349"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">is MaybeRequestReconciliation going to generate a new reconciliation request ?\r\n\r\nNo, because `if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;` takes care of that. Basically, an initiator will wait forever.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-22T06:58:55Z",
      "diff_hunk" : "@@ -4577,12 +4822,43 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             pto->m_tx_relay->filterInventoryKnown.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_reconciliation.AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n             }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            auto reconciliation_request_data = m_reconciliation.MaybeRequestReconciliation(pto->GetId());\n+            if (reconciliation_request_data) {\n+                const auto [local_set_size, local_q_formatted] = (*reconciliation_request_data);\n+                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::REQRECON, local_set_size, local_q_formatted));\n+            }\n+        }\n+\n+        //\n+        // Message: reconciliation response\n+        //\n+        {\n+            std::vector<uint8_t> skdata;\n+            bool respond = m_reconciliation.RespondToReconciliationRequest(pto->GetId(), skdata);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618130349",
      "id" : 618130349,
      "in_reply_to_id" : 617800136,
      "line" : 4892,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODEzMDM0OQ==",
      "original_commit_id" : "0b142cce89b625bdc1155f87bc45a84a40791a0c",
      "original_line" : 4892,
      "original_position" : 570,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 616,
      "pull_request_review_id" : 641838567,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618130349",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618457926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618457926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "linter turned up:\r\n`test/functional/p2p_erlay.py:20:1: F401 'test_framework.p2p.MIN_P2P_VERSION_SUPPORTED' imported but unused`",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-22T14:32:47Z",
      "diff_hunk" : "@@ -0,0 +1,555 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618457926",
      "id" : 618457926,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODQ1NzkyNg==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 642279533,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618457926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/755825?v=4",
         "events_url" : "https://api.github.com/users/adamjonas/events{/privacy}",
         "followers_url" : "https://api.github.com/users/adamjonas/followers",
         "following_url" : "https://api.github.com/users/adamjonas/following{/other_user}",
         "gists_url" : "https://api.github.com/users/adamjonas/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/adamjonas",
         "id" : 755825,
         "login" : "adamjonas",
         "node_id" : "MDQ6VXNlcjc1NTgyNQ==",
         "organizations_url" : "https://api.github.com/users/adamjonas/orgs",
         "received_events_url" : "https://api.github.com/users/adamjonas/received_events",
         "repos_url" : "https://api.github.com/users/adamjonas/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/adamjonas/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/adamjonas/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/adamjonas"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618689965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618689965"
         }
      },
      "author_association" : "MEMBER",
      "body" : "oops, sorry I keep missing these issues. Linter broke on my machine for some reason, I better fix it before pushing again.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-22T19:42:48Z",
      "diff_hunk" : "@@ -0,0 +1,555 @@\n+#!/usr/bin/env python3\n+# Copyhigh (c) 2016-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test reconciliation-based transaction relay protocol.\"\"\"\n+\n+from io import BytesIO\n+from test_framework.siphash import siphash256\n+import random\n+import struct\n+import time\n+\n+from test_framework.key import TaggedHash\n+from test_framework.messages import (\n+    msg_inv, msg_getdata, msg_wtxidrelay,\n+    msg_verack, msg_sendrecon, msg_reqrecon,\n+    msg_sketch, msg_reqsketchext, msg_reconcildiff,\n+    MSG_WTX, CTransaction, CInv,\n+)\n+from test_framework.p2p import P2PDataStore, MIN_P2P_VERSION_SUPPORTED",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r618689965",
      "id" : 618689965,
      "in_reply_to_id" : 618457926,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODY4OTk2NQ==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 20,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "test/functional/p2p_erlay.py",
      "position" : null,
      "pull_request_review_id" : 642603060,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/618689965",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r620993937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/620993937"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">This case I understand. The case I don't get the rational for is recon_peer_flood_to=true and flood_tx=false.\r\n\r\nOk, what exactly are you suggesting? Always flood if `recon_peer_flood_to=true` and drop `flood_tx` at all?\r\n\r\n1. If this is applied, non-reachable nodes will flood transactions to 7 (erlay enabled) peers after receiving transactions from the 8th. No bandwidth savings because almost all transactions are flooded, bad.\r\n\r\n2. How erlay solves this? Adding a policy: \"flood only if a transaction is received from reconciliation initiator [or legacy peer]\". Now non-reachable nodes will never flood, because they have no recon initiator peers (because they have no inbounds). Assuming no legacy peers.\r\n\r\n3. Now, what to do with local transactions? If non-reachable nodes flood them, their reconciling peers will easily tell those are local transactions, because this is the only case non-reachable node floods.\r\nFor this special case, we also use reconciliation, to provide privacy.\r\n\r\n-------------------ââââ-------\r\n\r\nNow, I assume you can change step (2) or even step (1) here and have some different logic. Feel free to suggest, but this is my thinking for now, and Erlay is based on it. \r\n\r\nLet me know if it's clear.\r\n",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-27T08:43:43Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r620993937",
      "id" : 620993937,
      "in_reply_to_id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDk5MzkzNw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 645594742,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/620993937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621060125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621060125"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, this scenario is possible.\r\n\r\n>What do you think about moving outbound flooding peers accouting from VERACK to SENDRECON ?\r\n\r\nThe problem with your suggestion is that we also need to account for peers which will never send SENDRECON (legacy flooding peers). There are 2 possible solutions:\r\n\r\n1. Handle legacy peers as a special case, so have this accounting twice (in VERACK for legacy, in SENDRECON for reconciliation).\r\n2. Always initialize ReconciliationState with `m_flood_to=false`, and update it to true on VERACK if there are still slots (along with tracking out peers in VERACK)",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-27T10:01:07Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt, m_out_flood_to);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621060125",
      "id" : 621060125,
      "in_reply_to_id" : 616855063,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTA2MDEyNQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2818,
      "original_position" : 309,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 645670857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621060125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621156563"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621156563"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I will implement the latter.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-27T12:24:37Z",
      "diff_hunk" : "@@ -2630,6 +2760,46 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        bool they_initiator, they_responder;\n+        uint32_t recon_version;\n+        uint64_t remote_salt;\n+        vRecv >> they_initiator >> they_responder >> recon_version >> remote_salt;\n+\n+        // Since this is called before VERACK, m_out_flooding_peers doesn't include this peer\n+        // being considered for reconciliation support, so no need for substraction.\n+        m_reconciliation.EnableReconciliationSupport(pfrom.GetId(), pfrom.IsInboundConn(),\n+            they_initiator, they_responder, recon_version, remote_salt, m_out_flood_to);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r621156563",
      "id" : 621156563,
      "in_reply_to_id" : 616855063,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTE1NjU2Mw==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 2818,
      "original_position" : 309,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 645788901,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/621156563",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622379909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622379909"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks for implementing the suggestion. \r\n\r\nFurther, should we disconnect sendrecon sender with a protocol version inferior to `RECONCILIATION_RELAY_VERSION` ? \r\n\r\nGood point to keep the check on `WTXID_RELAY_VERSION` support, I thought at first it should be removed but you might have sendrecon sender who don't signal wtxid-relay.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-28T17:10:54Z",
      "diff_hunk" : "@@ -2645,6 +2774,51 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (pfrom.GetCommonVersion() < RECONCILIATION_RELAY_VERSION) {\n+            LogPrint(BCLog::NET, \"ignoring sendrecon due to old common version=%d from peer=%d\\n\", pfrom.GetCommonVersion(), pfrom.GetId());\n+            return;\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622379909",
      "id" : 622379909,
      "line" : 2840,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjM3OTkwOQ==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 2840,
      "original_position" : 303,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 342,
      "pull_request_review_id" : 647321593,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622379909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622435781"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622435781"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> If this is applied, non-reachable nodes will flood transactions to 7 (erlay enabled) peers after receiving transactions from the 8th. No bandwidth savings because almost all transactions are flooded, bad.\r\n\r\nCan you point me where as a _non-reachable node_ we necessary mark our peers as reconciling ones ? AFAICT, it's decided there without evaluating node reachability : https://github.com/naumenkogs/bitcoin/blob/5b8c65d32c142e7d91aef13772cf8c771020bee7/src/txreconciliation.cpp#L654\r\n\r\nThat said, I agree with your laid out reasoning on flooding-vs-reconciling peers selection for non-reachable nodes and how to protect their local transaction privacy. \r\n\r\nBut I don't think current code logic hinders well reachable nodes's local transactions as you will reconciliate (flood_tx=false) with your outbound flooding peers.\r\n\r\nLet me write a functional test to sustain (or not) my thinking :)",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-28T18:28:18Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r622435781",
      "id" : 622435781,
      "in_reply_to_id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjQzNTc4MQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 647321593,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/622435781",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623211332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623211332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should interface documentation say that peer must not be registered more than once ?\r\n\r\nI think that's a property enforced by the assert in the implementation.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T16:29:55Z",
      "diff_hunk" : "@@ -0,0 +1,169 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer and announces all transactions from the\n+ *    corresponding set. Once the peer received the failure notification, the peer announces all\n+ *    transactions from the corresponding set.\n+ *\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+    public:\n+\n+    explicit TxReconciliationTracker();\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generate and pass reconciliation parameters to be sent along with the suggestion\n+     * to announce transactions via reconciliations.\n+     * Generates (and stores) a peer-specific salt which will be used for reconciliations.\n+     * Reconciliation roles are based on inbound/outbound role in the connection.\n+     * Returns the following values which will be used to invite a peer to reconcile:\n+     * - whether we want to initiate reconciliation requests (ask for sketches)\n+     * - whether we agree to respond to reconciliation requests (send our sketches)\n+     * - reconciliation protocol version\n+     * - salt used for short ID computation required for reconciliation\n+     * A peer can't be registered for future reconciliations without this call.\n+     */\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623211332",
      "id" : 623211332,
      "line" : 61,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIxMTMzMg==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 61,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/txreconciliation.h",
      "position" : 61,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623211332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623213192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623213192"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`assert(recon_version == RECON_VERSION)` ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T16:32:22Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623213192",
      "id" : 623213192,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIxMzE5Mg==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 134,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623213192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623219478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623219478"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What's purpose serves the `TxReconciliationTrackerTest` wrapper given in that unit test you're using directly the reference implementation of `TxReconciliationTracker` ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T16:40:52Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623219478",
      "id" : 623219478,
      "line" : 143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIxOTQ3OA==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 143,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 143,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623219478",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623238188"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623238188"
         }
      },
      "author_association" : "MEMBER",
      "body" : "W.r.t to future reconciliation upgrades, IIUC if peer support a lower version than us we downgrade to the lowest common version ? I think it's interesting to document in the `EnableReconciliationSupport` declaration how reconciliation version conflicts are negotiated. Further, why RECON_VERSION=1 and not just 0 ?\r\n\r\nReally likely we'll have to upgrade reconciliation if we introduce package_ids as tx-relay announcements in a near future.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T17:07:14Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623238188",
      "id" : 623238188,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzIzODE4OA==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 628,
      "original_position" : 630,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623238188",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623255076"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623255076"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Just test peer has been registered ?\r\n\r\n```\r\ndiff --git a/src/test/txreconciliation_tests.cpp b/src/test/txreconciliation_tests.cpp\r\nindex e7f20d7de..8dbad9461 100644\r\n--- a/src/test/txreconciliation_tests.cpp\r\n+++ b/src/test/txreconciliation_tests.cpp\r\n@@ -146,6 +146,10 @@ BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\r\n     // Test inbound peers.\r\n     bool inbound = true;\r\n \r\n+    NodeId non_registered_peer = 100;\r\n+    // Do nothing if peer is not registered\r\n+    tracker.EnableReconciliationSupport(non_registered_peer, inbound, false, false, 1, salt, 0);\r\n+\r\n     NodeId peer_id0 = 0;\r\n     tracker.SuggestReconciling(peer_id0, inbound);\r\n     // Both roles are false, don't register.\r\n```\r\n\r\nIt's maybe covered in other tests but otherwise asserting on \r\n\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex d4cfc8ee4..a325e0a2a 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -632,7 +632,9 @@ class TxReconciliationTracker::Impl {\r\n         auto local_salt = m_local_salts.find(peer_id);\r\n \r\n         // This function should be called only after generating the local salt.\r\n-        if(local_salt == m_local_salts.end()) return;\r\n+        if(local_salt == m_local_salts.end()) {\r\n+            assert(false);\r\n+        }\r\n \r\n         // Must match SuggestReconciling logic.\r\n         bool we_may_initiate = !inbound, we_may_respond = inbound;\r\n```\r\n\r\nDoesn't break `EnableReconciliationSupportTest`.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T17:32:06Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    // Test inbound peers.\n+    bool inbound = true;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623255076",
      "id" : 623255076,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzI1NTA3Ng==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 148,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623255076",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623260500"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623260500"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IIUC, you can only hit this return if the peer is sending us both `they_may_initiate`=false and `they_may_respond`=false. This is def a pathological case and maybe we should disconnect such buggy peer ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T17:40:06Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if(local_salt == m_local_salts.end()) return;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        if (!(they_initiate || we_initiate)) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623260500",
      "id" : 623260500,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzI2MDUwMA==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 644,
      "original_position" : 646,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623260500",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623308713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623308713"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe add some transactions to the set, to exercise that the correct `local_set_size` is returned \r\n\r\n```\r\n@@ -264,6 +270,25 @@ BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\r\n     assert(!tracker.MaybeRequestReconciliation(peer_id2));\r\n     tracker.RemovePeer(peer_id1);\r\n     assert(tracker.MaybeRequestReconciliation(peer_id2));\r\n+    tracker.RemovePeer(peer_id2);\r\n+\r\n+    NodeId peer_id3 = 3;\r\n+    tracker.SuggestReconciling(peer_id3, false);\r\n+    tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0, 0);\r\n+\r\n+    size_t count = 10;\r\n+    for (size_t i = 0; i < count; i++) {\r\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\r\n+    }\r\n+\r\n+    SetMockTime(start_time + 20000);\r\n+    // Make a request.\r\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\r\n+    if (request_data) {\r\n+        const auto [local_set_size, local_q_formatted] = (*request_data);\r\n+        assert(local_set_size == 10);\r\n+        assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\r\n+    }\r\n }\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T18:52:05Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    // Test inbound peers.\n+    bool inbound = true;\n+\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    // Both roles are false, don't register.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, false, false, 1, salt, 0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid roles for the given direction.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, false, true, 1, salt, 0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid version.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 0, salt, 0);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Valid peer.\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, salt, 0);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+    // Don't flood to inbound reconciling peers.\n+    assert(!*tracker.IsPeerChosenForFlooding(peer_id0));\n+\n+    // Test outbound peers.\n+    inbound = false;\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, inbound);\n+    // Say we already have many flooding peers, don't flood to this one.\n+    tracker.EnableReconciliationSupport(peer_id1, inbound, false, true, 1, salt, 127);\n+    assert(!*tracker.IsPeerChosenForFlooding(peer_id1));\n+\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, inbound);\n+    // We choose this peer for flooding because we haven't reached MAX_OUTBOUND_FLOOD_TO.\n+    tracker.EnableReconciliationSupport(peer_id2, inbound, false, true, 1, salt, 1);\n+    assert(*tracker.IsPeerChosenForFlooding(peer_id2));\n+\n+    // We do not support updates.\n+    tracker.EnableReconciliationSupport(peer_id2, inbound, false, true, 1, salt, 127);\n+    assert(*tracker.IsPeerChosenForFlooding(peer_id2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0, 0);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0, 0);\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0, 0);\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0, 0);\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623308713",
      "id" : 623308713,
      "line" : 265,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzMwODcxMw==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 265,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 265,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623308713",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623312838"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623312838"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This doesn't seem to break `HandleReconciliationRequestTest` ?\r\n\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex d4cfc8ee4..65dcc2675 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -715,7 +715,9 @@ class TxReconciliationTracker::Impl {\r\n         auto recon_state = m_states.find(peer_id);\r\n         if (recon_state == m_states.end()) return;\r\n         if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\r\n-        if (recon_state->second.m_we_initiate) return;\r\n+        if (recon_state->second.m_we_initiate) {\r\n+            assert(false);\r\n+        }\r\n \r\n         double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\r\n         recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-29T18:58:30Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if(local_salt == m_local_salts.end()) return;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        if (!(they_initiate || we_initiate)) return;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        // To save bandwidth, we never flood to inbound peers we reconcile with. We may flood *some*\n+        // transactions to a limited number outbound peers we reconcile with.\n+        bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciliation with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i, flood_to=%i.\\n\", peer_id, we_initiate, they_initiate, flood_to);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate, flood_to));\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, recon_state->second.m_local_set.GetSize(), peer_id);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+        if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+                m_queue.pop_back();\n+                m_queue.push_front(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+                double local_q = recon_state->second.m_state_init_by_us.m_local_q;\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i, local_q=%i.\\n\", peer_id, local_set_size, local_q);\n+\n+                return std::make_pair(local_set_size, local_q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623312838",
      "id" : 623312838,
      "line" : 725,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzMxMjgzOA==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 725,
      "original_position" : 718,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 725,
      "pull_request_review_id" : 648417961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623312838",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758208"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758208"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">W.r.t to future reconciliation upgrades, IIUC if peer support a lower version than us we downgrade to the lowest common version ? I think it's interesting to document in the EnableReconciliationSupport declaration how reconciliation version conflicts are negotiated.?\r\n\r\nAgree.\r\n\r\n>Further, why RECON_VERSION=1 and not just 0 ?\r\n\r\nI think this is about personal taste, 0 might have special meaning or something. Gonna keep it 1.\r\n\r\n>Really likely we'll have to upgrade reconciliation if we introduce package_ids as tx-relay announcements in a near future.\r\n\r\nThen we have v2 :)",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-30T09:54:48Z",
      "diff_hunk" : "@@ -0,0 +1,1005 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/** Limit sketch capacity to avoid DoS. */\n+constexpr uint16_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * When considering whether we should flood to an outbound connection supporting reconciliation,\n+ * see how many outbound connections are already used for flooding. Flood only if the limit is not reached.\n+ * It helps to save bandwidth and reduce the privacy leak.\n+ */\n+constexpr uint32_t MAX_OUTBOUND_FLOOD_TO = 8;\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint16_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint16_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    const bool m_flood_to;\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate, bool flood_to) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate), m_flood_to(flood_to) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint16_t capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint16_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex) {0};\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    void HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint16_t remote_sketch_capacity = uint16_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch.\" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits.\n+        uint16_t extended_capacity = uint16_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    void EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt,\n+        size_t outbound_flooders)\n+    {\n+        // We do not support reconciliation salt/version updates, so receiving this message\n+        // for the second time should not happen\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return;\n+\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        if (recon_version < 1) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758208",
      "id" : 623758208,
      "in_reply_to_id" : 623238188,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc1ODIwOA==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 628,
      "original_position" : 630,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 649062011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758208",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758952"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758952"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The purpose is to deduplicate the repeatable valid handshake (Suggest/Enable) by hiding it under the `TxReconciliationTrackerTest`",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-30T09:56:00Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623758952",
      "id" : 623758952,
      "in_reply_to_id" : 623219478,
      "line" : 143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc1ODk1Mg==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 143,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 143,
      "pull_request_review_id" : 649062994,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623758952",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623759838"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623759838"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1. Not sure this is really useful.\r\n2. RECON_VERSION is currently hidden in the module, it it worth moving it out? ",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-30T09:57:37Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt, 0);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt, 0);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623759838",
      "id" : 623759838,
      "in_reply_to_id" : 623213192,
      "line" : 134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc1OTgzOA==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 134,
      "pull_request_review_id" : 649064217,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623759838",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623760722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623760722"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1. I think there is a confusion about \"register\". Register for me is when Enable[...] is called and when ReconciliationState is created Here, we just generate the salt.\r\n2. Ok, adding the mention.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-30T09:59:10Z",
      "diff_hunk" : "@@ -0,0 +1,169 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXRECONCILIATION_H\n+#define BITCOIN_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all reconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0. Reconciliation protocol handshake.\n+ * 1. Once we receive a new transaction, add it to the set instead of announcing immediately\n+ * 2. When the time comes, a reconciliation initiator requests a sketch from the peer, where a sketch\n+ *    is a compressed representation of their set\n+ * 3. Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *    and combines the two skethes to find the difference in *sets*.\n+ * 4. Now the initiator knows full symmetrical difference and can request what the initiator is\n+ *    missing and announce to the peer what the peer is missing. For the former, an extra round is\n+ *    required because the initiator knows only short IDs of those transactions.\n+ * 5. Sometimes reconciliation fails if the difference is larger than the parties estimated,\n+ *    then there is one sketch extension round, in which the initiator requests for extra data.\n+ * 6. If extension succeeds, go to step 4.\n+ * 7. If extension fails, the initiator notifies the peer and announces all transactions from the\n+ *    corresponding set. Once the peer received the failure notification, the peer announces all\n+ *    transactions from the corresponding set.\n+ *\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+    public:\n+\n+    explicit TxReconciliationTracker();\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generate and pass reconciliation parameters to be sent along with the suggestion\n+     * to announce transactions via reconciliations.\n+     * Generates (and stores) a peer-specific salt which will be used for reconciliations.\n+     * Reconciliation roles are based on inbound/outbound role in the connection.\n+     * Returns the following values which will be used to invite a peer to reconcile:\n+     * - whether we want to initiate reconciliation requests (ask for sketches)\n+     * - whether we agree to respond to reconciliation requests (send our sketches)\n+     * - reconciliation protocol version\n+     * - salt used for short ID computation required for reconciliation\n+     * A peer can't be registered for future reconciliations without this call.\n+     */\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623760722",
      "id" : 623760722,
      "in_reply_to_id" : 623211332,
      "line" : 61,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzc2MDcyMg==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 61,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/txreconciliation.h",
      "position" : 61,
      "pull_request_review_id" : 649065413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623760722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "See comment here if you think replacing assert with exception is better to exercise coverage in unit tests : https://github.com/bitcoin/bitcoin/issues/16700#issuecomment-829494172",
      "created_at" : "2021-04-30T15:11:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-830164004",
      "id" : 830164004,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMDE2NDAwNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-04-30T15:11:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/830164004",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623977943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623977943"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Though embedding the peer in `TxReconciliationTrackerTest` doesn't let you test the no-registered peer or initiation direction for this method ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-04-30T15:41:50Z",
      "diff_hunk" : "@@ -0,0 +1,651 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt);\n+        } else {\n+            m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt);\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid roles for the given direction.\n+    tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Invalid version.\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt);\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    // Valid peer.\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt);\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0);\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0);\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0);\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0);\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r623977943",
      "id" : 623977943,
      "line" : 321,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzk3Nzk0Mw==",
      "original_commit_id" : "96c261630cc42e3bad41a61ba2a589bf2ae22676",
      "original_line" : 321,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 321,
      "pull_request_review_id" : 649348312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/623977943",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624948905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624948905"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">Further, should we disconnect sendrecon sender with a protocol version inferior to RECONCILIATION_RELAY_VERSION ?\r\n\r\nYeah seems right.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-03T08:32:35Z",
      "diff_hunk" : "@@ -2645,6 +2774,51 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         return;\n     }\n \n+    // Received from a peer demonstrating readiness to announce transactions via reconciliations.\n+    // This feature negotiation should happen:\n+    // - between VERSION and VERACK to avoid relay problems from switching annoyncement protocols\n+    //   after the connection is up\n+    // - after WTXID because we reconcile only with peers supporting wtxid-relay\n+    if (msg_type == NetMsgType::SENDRECON) {\n+        if (pfrom.fSuccessfullyConnected) {\n+            // Disconnect peers that send a SENDRECON message after VERACK.\n+            LogPrint(BCLog::NET, \"sendrecon received after verack from peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (!pfrom.m_tx_relay) {\n+            // If we chose a peer to not send us transactions, disconnect if they want to reconcile.\n+            LogPrint(BCLog::NET, \"sendrecon received from non-tx-relay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        LOCK(cs_main);\n+        if (!State(pfrom.GetId())->m_wtxid_relay) {\n+            // Disconnect peers that send a SENDRECON message before/without WTXIDRELAY.\n+            LogPrint(BCLog::NET, \"sendrecon received before wtxidrelay peer=%d; disconnecting\\n\", pfrom.GetId());\n+            pfrom.fDisconnect = true;\n+            return;\n+        }\n+\n+        if (pfrom.GetCommonVersion() < RECONCILIATION_RELAY_VERSION) {\n+            LogPrint(BCLog::NET, \"ignoring sendrecon due to old common version=%d from peer=%d\\n\", pfrom.GetCommonVersion(), pfrom.GetId());\n+            return;\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624948905",
      "id" : 624948905,
      "in_reply_to_id" : 622379909,
      "line" : 2840,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDk0ODkwNQ==",
      "original_commit_id" : "5b8c65d32c142e7d91aef13772cf8c771020bee7",
      "original_line" : 2840,
      "original_position" : 303,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 342,
      "pull_request_review_id" : 650173888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624948905",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624952992"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">Can you point me where as a non-reachable node we necessary mark our peers as reconciling ones ? AFAICT, it's decided there without evaluating node reachability : https://github.com/naumenkogs/bitcoin/blob/5b8c65d32c142e7d91aef13772cf8c771020bee7/src/txreconciliation.cpp#L654\r\n\r\nYes, that exact line: `bool flood_to = !inbound && outbound_flooders < MAX_OUTBOUND_FLOOD_TO;`\r\n\r\nFor a non-reachable node, all the peers are `inbound=false`.... and I just realized that my logic only works if connectivity=MAX_OUTBOUND_FLOOD_TO. Is that understandable?\r\n\r\nNow, we should think what to do when we bump the connectivity... Non-reachable nodes will have both `flood_to` false AND true peers.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-03T08:41:43Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992",
      "id" : 624952992,
      "in_reply_to_id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNDk1Mjk5Mg==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 650179011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/624952992",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-05-03T09:22:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-831136546",
      "id" : 831136546,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMTEzNjU0Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-03T09:22:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/831136546",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nðµï¸ @hebasto @sipa @practicalswift have been requested to review this pull request as specified in the REVIEWERS file.",
      "created_at" : "2021-05-03T09:32:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-831142156",
      "id" : 831142156,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMTE0MjE1Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-03T09:32:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/831142156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r625010038"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625010038"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Let's continue this same discussion in one place: https://github.com/bitcoin/bitcoin/pull/21515#discussion_r624952992",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-03T10:52:36Z",
      "diff_hunk" : "@@ -1507,17 +1526,44 @@ void PeerManagerImpl::SendPings()\n     for(auto& it : m_peer_map) it.second->m_ping_queued = true;\n }\n \n-void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n+void PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid, std::optional<NodeId> from)\n {\n-    m_connman.ForEachNode([&txid, &wtxid](CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+    bool flood;\n+    if (from) {\n+        // Flood those transactions which were received either from pre-reconciliation peers, or\n+        // inbound reconciliation but NOT via outbound reconciliation. Flooding then is mainly\n+        // used for initial propagation of new transactions across a network of reachable nodes\n+        // quickly, while most of the bandwidth is still conserved.\n+        if (m_reconciliation.IsPeerRegistered(*from)) {\n+            flood = !(*m_reconciliation.IsPeerResponder(*from));\n+        } else {\n+            flood = true;\n+        }\n+    }\n+    else {\n+        // Transactions originated locally should be always announced through reconciliation\n+        // for the privacy reasons.\n+        //\n+        // Consider a non-reachable node: the general policy is *flood transactions came from\n+        // inbounds* (see above), so non-reachable nodes would never flood any transactions.\n+        // Now, if they flood their local transactions, it will be obvious for their immediate peers\n+        // that those transactions belong to those non-reachable nodes.\n+        //\n+        // On the other hand, if non-reachable nodes reconcile those transactions, they would look\n+        // like any other transactions of non-reachable nodes.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r625010038",
      "id" : 625010038,
      "in_reply_to_id" : 614211171,
      "line" : 1587,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTAxMDAzOA==",
      "original_commit_id" : "baa461151d9f5377aaa5b40bf05290d3c320d38e",
      "original_line" : 1587,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 174,
      "pull_request_review_id" : 650251297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/625010038",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626118561"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626118561"
         }
      },
      "author_association" : "MEMBER",
      "body" : ">Now, we should think what to do when we bump the connectivity... Non-reachable nodes will have both flood_to false AND true peers.\r\n\r\nOk, so this is fine, because again, local transactions and transactions from outbounds are always reconciled, so it doesn't matter if a non-reachable node has some peers with `flood_to=true`.\r\n\r\nI will improve the docs.\r\n\r\nKeeping this open, it's likely gonna change a bit after I do some experiments.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-04T21:26:27Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {\n+                                // Check that:\n+                                // 1) the peer isn't set for flooding OR\n+                                // 2) the transaction isn't set for flooding\n+                                const bool recon_peer_flood_to = *m_reconciliation.IsPeerChosenForFlooding(pto->GetId());\n+                                if (!recon_peer_flood_to || !flood_tx) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626118561",
      "id" : 626118561,
      "in_reply_to_id" : 616905161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNjExODU2MQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4787,
      "original_position" : 527,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 651682258,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626118561",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626311725"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626311725"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I tried to make this test, but signing 5000 transactions takes minutes (that's expected, right?), and that's the only way to test this.\r\n\r\nInstead, I'm adding tests for `MAX_SKETCH_CAPACITY = 2 << 12`",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-05T07:14:07Z",
      "diff_hunk" : "@@ -4549,7 +4765,39 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool added_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via flooding.\n+                            const size_t recon_set_size = *m_reconciliation.GetPeerSetSize(pto->GetId());\n+                            if (txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r626311725",
      "id" : 626311725,
      "in_reply_to_id" : 616897107,
      "line" : 4817,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNjMxMTcyNQ==",
      "original_commit_id" : "a9270714e545337aaf8a510094cc12ef97b92ce0",
      "original_line" : 4817,
      "original_position" : 522,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 567,
      "pull_request_review_id" : 651988670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-05T11:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/626311725",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-05-05T15:49:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-832804294",
      "id" : 832804294,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMjgwNDI5NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-05T15:49:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/832804294",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628258132"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628258132"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What's the unit of the mocktime bump here, seconds or microseconds ? If it's second I would recommend to replace the bumping value by RECON_RESPOND_INTERVAL, I think it can be taken verbatim from txreconciliation.cpp like you're already doing for few values.\r\n\r\nThat way you can assert that's the module is binding to the interval expectation. Otherwise, slightly increasing RECON_RESPOND_INTERVAL doesn't break the test.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T14:33:06Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628258132",
      "id" : 628258132,
      "line" : 283,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODI1ODEzMg==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 283,
      "original_position" : 283,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 283,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628258132",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628262633"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628262633"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it's missing a small case coverage if node is the initiator. It should be ignored.\r\n\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex 0218d21ad..9cac2eba5 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -786,7 +786,7 @@ class TxReconciliationTracker::Impl {\r\n         LOCK(m_mutex);\r\n         auto recon_state = m_states.find(peer_id);\r\n         if (recon_state == m_states.end()) return false;\r\n-        if (recon_state->second.m_we_initiate) return false;\r\n+        //if (recon_state->second.m_we_initiate) return false;\r\n \r\n         Phase incoming_phase = recon_state->second.m_state_init_by_them.m_phase;\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T14:39:10Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628262633",
      "id" : 628262633,
      "line" : 315,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODI2MjYzMw==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 315,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 315,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628262633",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628313826"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628313826"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this comment should be reverse with the test case above ?\r\n\r\nLocal set is increased by `AddTransaction(5)` though initiator set is empty `HandleReconciliationRequest`",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T15:31:28Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628313826",
      "id" : 628313826,
      "line" : 324,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMxMzgyNg==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 324,
      "original_position" : 324,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 324,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628313826",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628315271"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628315271"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also I don't understand why you bump mocktime by +1000 at each new test case ? You're renewing `tracker_test` everytime so it shouldn't matter",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T15:33:15Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628315271",
      "id" : 628315271,
      "line" : 329,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMxNTI3MQ==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 329,
      "original_position" : 329,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 329,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628315271",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628325062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628325062"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If this helper is called in `RespondToInitialRequest` I believe the check on local set size is duplicated. \r\n\r\nTo avoid this, what do you think about uplifting this check to `HandleInitialSketch` and returning true and empty `skdata` there ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T15:45:03Z",
      "diff_hunk" : "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628325062",
      "id" : 628325062,
      "line" : 320,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMyNTA2Mg==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 320,
      "original_position" : 320,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 320,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628325062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628332247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628332247"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can verify that `PrepareForExtensionRequest` did clear up `local_set` for `local_snapshot`.\r\n\r\n```\r\ndiff --git a/src/test/txreconciliation_tests.cpp b/src/test/txreconciliation_tests.cpp\r\nindex 2e12d55dc..35e3db5e5 100644\r\n--- a/src/test/txreconciliation_tests.cpp\r\n+++ b/src/test/txreconciliation_tests.cpp\r\n@@ -343,344 +343,345 @@ BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\r\n     // Then respond with an extension sketch.\r\n     tracker_test3.HandleExtensionRequest();\r\n     assert(tracker_test3.RespondToReconciliationRequest(skdata));\r\n+    assert(tracker_test3.GetPeerSetSize() == 0);\r\n     std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\r\n     std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\r\n     assert(skdata == sketch_extension);\r\n ```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T15:53:26Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628332247",
      "id" : 628332247,
      "line" : 345,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMzMjI0Nw==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 345,
      "original_position" : 345,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 345,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628332247",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628339736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628339736"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Verify but I believe that module's previous steps guarantee that `m_capacity_snapshot` can't be superior to `MAX_SKETCH_CAPCITY`.\r\n\r\nAt least following diff seems to pass unit tests:\r\n```\r\ndiff --git a/src/txreconciliation.cpp b/src/txreconciliation.cpp\r\nindex 0218d21ad..d035569af 100644\r\n--- a/src/txreconciliation.cpp\r\n+++ b/src/txreconciliation.cpp\r\n@@ -762,12 +762,13 @@ class TxReconciliationTracker::Impl {\r\n     void RespondToExtensionRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\r\n     {\r\n         assert(recon_state->second.m_capacity_snapshot > 0);\r\n+        assert(MAX_SKETCH_CAPACITY * 2 > recon_state->second.m_capacity_snapshot * 2);\r\n         // Update local reconciliation state for the peer.\r\n         recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\r\n \r\n         // Local extension sketch can be null only if initial sketch or initial capacity was 0,\r\n         // in which case we would have terminated reconciliation already.\r\n-        uint32_t extended_capacity = std::min(uint32_t(recon_state->second.m_capacity_snapshot * 2), MAX_SKETCH_CAPACITY * 2);\r\n+        uint32_t extended_capacity = uint32_t(recon_state->second.m_capacity_snapshot * 2);\r\n         Minisketch sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\r\n         assert(sketch);\r\n         skdata = sketch.Serialize();\r\n```",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T16:04:47Z",
      "diff_hunk" : "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch. \" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return true;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at initial step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Initial reconciliation step failed.\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.PrepareForExtensionResponse(remote_sketch_capacity, skdata);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::EXT_REQUESTED;\n+\n+            result = std::nullopt;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at initial step, \" /* Continued */\n+                \"request sketch extension.\\n\", recon_state->first);\n+        }\n+        return true;\n+    }\n+\n+    bool HandleSketchExtension(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::EXT_REQUESTED);\n+\n+        std::vector<uint8_t> working_skdata = std::vector<uint8_t>(skdata);\n+        // A sketch extension is missing the lower elements (to be a valid extended sketch),\n+        // which we stored on our side at initial reconciliation step.\n+        working_skdata.insert(working_skdata.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.begin(),\n+            recon_state->second.m_state_init_by_us.m_remote_sketch_snapshot.end());\n+\n+        // We allow the peer to send an extension for any capacity, not just original capacity * 2,\n+        // but it should be within the limits. The limits are MAX_SKETCH_CAPACITY * 2, so that\n+        // they can extend even the largest (originally) sketch.\n+        uint16_t extended_capacity = uint32_t(working_skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        if (extended_capacity > MAX_SKETCH_CAPACITY * 2) return false;\n+\n+        Minisketch local_sketch = recon_state->second.ComputeExtendedSketch(extended_capacity);\n+        assert(local_sketch);\n+        Minisketch remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity).Deserialize(working_skdata);\n+\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, extended_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Extension step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set_snapshot.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set_snapshot.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = true;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has succeeded at extension step, \" /* Continued */\n+                \"request %i txs, announce %i txs.\\n\", recon_state->first, txs_to_request.size(), txs_to_announce.size());\n+        } else {\n+            // Reconciliation over extended sketch failed.\n+\n+            // Announce all local transactions from the reconciliation set.\n+            // All remote transactions will be announced by peer based on the reconciliation\n+            // failure flag.\n+            txs_to_announce = recon_state->second.m_local_set_snapshot.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(false, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d has failed at extension step, \" /* Continued */\n+                \"request all txs, announce %i txs.\\n\", recon_state->first, txs_to_announce.size());\n+        }\n+        return true;\n+    }\n+\n+    public:\n+\n+    std::tuple<bool, bool, uint32_t, uint64_t> SuggestReconciling(NodeId peer_id, bool inbound)\n+    {\n+        bool we_initiate_recon, we_respond_recon;\n+        // Currently reconciliation roles are defined by the connection direction: only the inbound\n+        // peer initiate reconciliations and the outbound peer is supposed to only respond.\n+        if (inbound) {\n+            we_initiate_recon = false;\n+            we_respond_recon = true;\n+        } else {\n+            we_initiate_recon = true;\n+            we_respond_recon = false;\n+        }\n+\n+        uint64_t m_local_recon_salt(GetRand(UINT64_MAX));\n+        bool added = WITH_LOCK(m_mutex, return m_local_salts.emplace(peer_id, m_local_recon_salt).second);\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        assert(added);\n+\n+        LogPrint(BCLog::NET, \"Prepare to announce reconciliation support to peer=%d.\\n\", peer_id);\n+\n+        return std::make_tuple(we_initiate_recon, we_respond_recon, RECON_VERSION, m_local_recon_salt);\n+    }\n+\n+    bool EnableReconciliationSupport(NodeId peer_id, bool inbound,\n+        bool they_may_initiate, bool they_may_respond, uint32_t recon_version, uint64_t remote_salt)\n+    {\n+        // We do not support reconciliation salt/version updates. We treat an attempt to update\n+        // after a successful registration as a protocol violation.\n+        LOCK(m_mutex);\n+        if (m_states.find(peer_id) != m_states.end()) return false;\n+\n+        // If the peer supports the version which is lower than our, we downgrade to the version\n+        // they support. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        recon_version = std::min(recon_version, RECON_VERSION);\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return false;\n+\n+        auto local_salt = m_local_salts.find(peer_id);\n+\n+        // This function should be called only after generating the local salt.\n+        if (local_salt == m_local_salts.end()) return false;\n+\n+        // Must match SuggestReconciling logic.\n+        bool we_may_initiate = !inbound, we_may_respond = inbound;\n+\n+        bool they_initiate = they_may_initiate && we_may_respond;\n+        bool we_initiate = we_may_initiate && they_may_respond;\n+        // If we ever announce we_initiate && we_may_respond, this will need tie-breaking. For now,\n+        // this is mutually exclusive because both are based on the inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return false;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrint(BCLog::NET, \"Register peer=%d for reconciliation with the following params: \" /* Continued */\n+            \"we_initiate=%i, they_initiate=%i.\\n\", peer_id, we_initiate, they_initiate);\n+\n+        uint256 full_salt = ComputeSalt(local_salt->second, remote_salt);\n+\n+        assert(m_states.emplace(peer_id, ReconciliationState(full_salt.GetUint64(0),\n+            full_salt.GetUint64(1), we_initiate)).second);\n+        return true;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile)\n+    {\n+        assert(txs_to_reconcile.size() > 0);\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        assert(recon_state != m_states.end());\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state->second.m_local_set.m_wtxids.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, recon_state->second.m_local_set.GetSize(), peer_id);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return std::nullopt;\n+        if (recon_state->second.m_state_init_by_us.m_phase != Phase::NONE) return std::nullopt;\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order based on the queue,\n+            // and with a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request < current_time && m_queue.back() == peer_id) {\n+                recon_state->second.m_state_init_by_us.m_phase = Phase::INIT_REQUESTED;\n+                m_queue.pop_back();\n+                m_queue.push_front(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+                double local_q = recon_state->second.m_state_init_by_us.m_local_q;\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i, local_q=%i.\\n\", peer_id, local_set_size, local_q);\n+\n+                return std::make_pair(local_set_size, local_q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    void HandleReconciliationRequest(NodeId peer_id, uint16_t peer_recon_set_size, uint16_t peer_q)\n+    {\n+        LOCK(m_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        if (recon_state == m_states.end()) return;\n+        if (recon_state->second.m_state_init_by_them.m_phase != Phase::NONE) return;\n+        if (recon_state->second.m_we_initiate) return;\n+\n+        double peer_q_converted = peer_q * 1.0 / Q_PRECISION;\n+        recon_state->second.m_state_init_by_them.m_remote_q = peer_q_converted;\n+        recon_state->second.m_state_init_by_them.m_remote_set_size = peer_recon_set_size;\n+        recon_state->second.m_state_init_by_them.m_next_recon_respond = NextReconRespond();\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_REQUESTED;\n+\n+        LogPrint(BCLog::NET, \"Reconciliation initiated by peer=%d with the following params: \" /* Continued */\n+            \"remote_q=%d, remote_set_size=%i.\\n\", peer_id, peer_q_converted, peer_recon_set_size);\n+    }\n+\n+    void RespondToInitialRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\n+    {\n+        uint32_t sketch_capacity = 0;\n+        // We send an empty vector at initial request in the following 2 cases because\n+        // reconciliation can't help:\n+        // - if we have nothing on our side\n+        // - if they have nothing on their side\n+        // Then, they will terminate reconciliation early and force flooding-style announcement.\n+        if (recon_state->second.m_state_init_by_them.m_remote_set_size > 0 &&\n+                recon_state->second.m_local_set.GetSize() > 0) {\n+\n+            sketch_capacity = recon_state->second.m_state_init_by_them.EstimateSketchCapacity(\n+                recon_state->second.m_local_set.GetSize());\n+            Minisketch sketch = recon_state->second.ComputeBaseSketch(sketch_capacity);\n+            if (sketch) skdata = sketch.Serialize();\n+        }\n+\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::INIT_RESPONDED;\n+        recon_state->second.PrepareForExtensionRequest(sketch_capacity);\n+\n+        LogPrint(BCLog::NET, \"Responding with a sketch to reconciliation initiated by peer=%d: \" /* Continued */\n+            \"sending sketch of capacity=%i.\\n\", recon_state->first, sketch_capacity);\n+    }\n+\n+    void RespondToExtensionRequest(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state, std::vector<uint8_t>& skdata)\n+    {\n+        assert(recon_state->second.m_capacity_snapshot > 0);\n+        // Update local reconciliation state for the peer.\n+        recon_state->second.m_state_init_by_them.m_phase = Phase::EXT_RESPONDED;\n+\n+        // Local extension sketch can be null only if initial sketch or initial capacity was 0,\n+        // in which case we would have terminated reconciliation already.\n+        uint32_t extended_capacity = std::min(uint32_t(recon_state->second.m_capacity_snapshot * 2), MAX_SKETCH_CAPACITY * 2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628339736",
      "id" : 628339736,
      "line" : 770,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODMzOTczNg==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 770,
      "original_position" : 770,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 770,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628339736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628343839"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628343839"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: verify if we're reconciliation responder and not initiator.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T16:11:24Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + 1000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + 2000);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    // Protocol violation: unknown peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628343839",
      "id" : 628343839,
      "line" : 394,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM0MzgzOQ==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 394,
      "original_position" : 394,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 394,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628343839",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628345073"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628345073"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also I don't think this unit test is covering sketch reception during wrong reconciliation phase, the final branch of `HandleSketch` ?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T16:13:28Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + 1000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + 2000);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    // Protocol violation: unknown peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628345073",
      "id" : 628345073,
      "line" : 395,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM0NTA3Mw==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 395,
      "original_position" : 395,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 395,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628345073",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628372727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628372727"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would verify returned pointer before to try `Deserialize()`. Beyond capacity == 0, minisketch API will also return a nullptr in case of memory allocation failure inside library. I don't know how to tread it, but definitively not crashing on it :/",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T16:58:53Z",
      "diff_hunk" : "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628372727",
      "id" : 628372727,
      "line" : 477,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM3MjcyNw==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 477,
      "original_position" : 477,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 477,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628372727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628381177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628381177"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note, coefficient recomputation doesn't seem covered by unit tests but sounds to be by functional tests. I would favor covering it unit tests too. An unrelated change in `p2p_erlay.py` in the future might remove coverage, up to you.",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T17:12:55Z",
      "diff_hunk" : "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+/**\n+  * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+  * Specified by BIP-330.\n+  */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with a given peer.\n+ * This value allows to reconcile ~100 transactions (7 tx/s * 16s) during normal system operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{16s};\n+/**\n+ * Interval between responding to peers' reconciliation requests.\n+ * We don't respond to reconciliation requests right away because that would enable monitoring\n+ * when we receive transactions (privacy leak).\n+ */\n+constexpr std::chrono::microseconds RECON_RESPONSE_INTERVAL{2s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+    INIT_RESPONDED,\n+    EXT_REQUESTED,\n+    EXT_RESPONDED\n+};\n+\n+/**\n+ * Salt is specified by BIP-330 is constructed from contributions from both peers. It is later used\n+ * to compute transaction short IDs, which are needed to construct a sketch representing a set of\n+ * transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t local_salt, uint64_t remote_salt)\n+{\n+    uint64_t salt1 = local_salt, salt2 = remote_salt;\n+    if (salt1 > salt2) std::swap(salt1, salt2);\n+    static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+    return (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of the transactions we want to announce to the peer along with the state\n+ * required to reconcile them.\n+ */\n+struct ReconciliationSet {\n+    /** Transactions we want to announce to the peer */\n+    std::set<uint256> m_wtxids;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * This is a cache of these IDs enabling faster lookups of full wtxids,\n+     * useful when peer will ask for missing transactions by short IDs\n+     * at the end of a reconciliation round.\n+     */\n+    std::map<uint32_t, uint256> m_short_id_mapping;\n+\n+    /** Get a number of transactions in the set. */\n+    size_t GetSize() const {\n+        return m_wtxids.size();\n+    }\n+\n+    std::vector<uint256> GetAllTransactions() const {\n+        return std::vector<uint256>(m_wtxids.begin(), m_wtxids.end());\n+    }\n+\n+    /**\n+     * When during reconciliation we find a set difference successfully (by combining sketches),\n+     * we want to find which transactions are missing on our and on their side.\n+     * For those missing on our side, we may only find short IDs.\n+     */\n+    void GetRelevantIDsFromShortIDs(const std::vector<uint64_t>& diff,\n+        // returning values\n+        std::vector<uint32_t>& local_missing, std::vector<uint256>& remote_missing) const\n+    {\n+        for (const auto& diff_short_id: diff) {\n+            const auto local_tx = m_short_id_mapping.find(diff_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            } else {\n+                local_missing.push_back(diff_short_id);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After a reconciliation round passed, transactions missing by our peer are known by short ID.\n+     * Look up their full wtxid locally to announce them to the peer.\n+     */\n+    std::vector<uint256> GetWTXIDsFromShortIDs(const std::vector<uint32_t>& remote_missing_short_ids) const\n+    {\n+        std::vector<uint256> remote_missing;\n+        for (const auto& missing_short_id: remote_missing_short_ids) {\n+            const auto local_tx = m_short_id_mapping.find(missing_short_id);\n+            if (local_tx != m_short_id_mapping.end()) {\n+                remote_missing.push_back(local_tx->second);\n+            }\n+        }\n+        return remote_missing;\n+    }\n+\n+    /** This should be called at the end of every reconciliation to avoid unbounded state growth. */\n+    void Clear() {\n+        m_wtxids.clear();\n+        m_short_id_mapping.clear();\n+    }\n+\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by us.\n+ */\n+struct ReconciliationInitByUs {\n+    /**\n+     * Computing a set reconciliation sketch involves estimating the difference\n+     * between sets of transactions on two sides of the connection. More specifically,\n+     * a sketch capacity is computed as\n+     * |set_size - local_set_size| + q * (set_size + local_set_size) + c,\n+     * where c is a small constant, and q is a node+connection-specific coefficient.\n+     * This coefficient is recomputed by every node based on the previous reconciliations,\n+     * to better estimate future set size differences.\n+     */\n+    double m_local_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * In a reconciliation round initiated by us, if we asked for an extension, we want to store\n+     * the sketch computed/transmitted in the initial step, so that we can use it when\n+     * sketch extension arrives.\n+     */\n+    std::vector<uint8_t> m_remote_sketch_snapshot;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+};\n+\n+/**\n+ * Track ongoing reconciliations with a giving peer which were initiated by them.\n+ */\n+struct ReconciliationInitByThem {\n+    /**\n+     * The use of q coefficients is described above (see local_q comment).\n+     * The value transmitted from the peer with a reconciliation requests is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    double m_remote_q{DEFAULT_RECON_Q};\n+\n+    /**\n+     * A reconciliation request comes from a peer with a reconciliation set size from their side,\n+     * which is supposed to help us to estimate set difference size. The value is stored here until\n+     * we respond to that request with a sketch.\n+     */\n+    uint16_t m_remote_set_size;\n+\n+    /**\n+     * When a reconciliation request is received, instead of responding to it right away,\n+     * we schedule a response for later, so that a spy canât monitor our reconciliation sets.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase{Phase::NONE};\n+\n+    /**\n+     * Estimate a capacity of a sketch we will send or use locally (to find set difference)\n+     * based on the local set size.\n+     */\n+    uint32_t EstimateSketchCapacity(size_t local_set_size) const\n+    {\n+        const uint16_t set_size_diff = std::abs(uint16_t(local_set_size) - m_remote_set_size);\n+        const uint16_t min_size = std::min(uint16_t(local_set_size), m_remote_set_size);\n+        const uint16_t weighted_min_size = m_remote_q * min_size;\n+        const uint32_t estimated_diff = 1 + weighted_min_size + set_size_diff;\n+        return minisketch_compute_capacity(RECON_FIELD_SIZE, estimated_diff, RECON_FALSE_POSITIVE_COEF);\n+    }\n+};\n+\n+/**\n+ * After a reconciliation round is over, the local q coefficient may be adjusted to enable\n+ * better accuracy of future set difference estimations.\n+ */\n+double RecomputeQ(uint8_t local_set_size, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+    uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+    uint8_t min_size = std::min(local_set_size, remote_set_size);\n+    uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+    if (min_size != 0) {\n+        return double(actual_difference - set_size_diff) / min_size;\n+    }\n+    return DEFAULT_RECON_Q;\n+}\n+\n+/**\n+ * Used to keep track of the ongoing reconciliations, the transactions we want to announce to the\n+ * peer when next transaction reconciliation happens, and also all parameters required to perform\n+ * reconciliations.\n+ */\n+class ReconciliationState {\n+\n+    /**\n+     * Reconciliation involves exchanging sketches, which efficiently represent transactions each\n+     * peer wants to announce. Sketches are computed over transaction short IDs.\n+     * These values are used to salt short IDs.\n+     */\n+    const uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Reconciliation sketches are computed over short transaction IDs.\n+     * Short IDs are salted with a link-specific constant value.\n+     */\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    public:\n+\n+    /**\n+     * A reconciliation round may involve an extension, in which case we should remember\n+     * a capacity of the sketch sent out initially, so that a sketch extension is of the same size.\n+     */\n+    uint16_t m_capacity_snapshot{0};\n+\n+    /**\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     * */\n+    const bool m_we_initiate;\n+\n+    /**\n+     * We flood specific transactions to some of the peers we reconcile with to enable faster\n+     * transaction relay while still conserving bandwidth by reconciling in most of the cases.\n+     * More specifically, we flood to a limited number of outbound reconciling peers\n+     * *for which this flag is enabled* (and also to non-reconciling peers, although this is\n+     * irrelevant here).\n+     * This flag is enabled based on whether we have a sufficient number of outbound transaction\n+     * relay peers already.\n+     * Transactions announced via flooding should not be added to the reconciliation set.\n+     */\n+    bool m_flood_to{false};\n+\n+    /**\n+     * Store all transactions which we would relay to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute an efficient representation of this set (\"sketch\") and use it to efficient reconcile\n+     * this set with a similar set on the other side of the connection.\n+     */\n+    ReconciliationSet m_local_set;\n+\n+    /**\n+     * A reconciliation round may involve an extension, which is an extra exchange of messages.\n+     * Since it may happen after a delay (at least network latency), new transactions may come\n+     * during that time. To avoid mixing old and new transactions, those which are subject for\n+     * extension of a current reconciliation round are moved to a reconciliation set snapshot\n+     * after an initial (non-extended) sketch is sent.\n+     * New transactions are kept in the regular reconciliation set.\n+     */\n+    ReconciliationSet m_local_set_snapshot;\n+\n+    /** Keep track of reconciliations with the peer. */\n+    ReconciliationInitByUs m_state_init_by_us;\n+    ReconciliationInitByThem m_state_init_by_them;\n+\n+    ReconciliationState(uint64_t k0, uint64_t k1, bool we_initiate) :\n+        m_k0(k0), m_k1(k1), m_we_initiate(we_initiate) {}\n+\n+    /**\n+     * Reconciliation involves computing a space-efficient representation of transaction identifiers\n+     * (a sketch). A sketch has a capacity meaning it allows reconciling at most a certain number\n+     * of elements (see BIP-330).\n+     */\n+    Minisketch ComputeBaseSketch(uint32_t& capacity)\n+    {\n+        Minisketch sketch;\n+        // Avoid serializing/sending an empty sketch.\n+        if (m_local_set.GetSize() == 0 || capacity == 0) return sketch;\n+\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+\n+        // To be used for sketch extension of the exact same size.\n+        m_capacity_snapshot = capacity;\n+\n+        sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+\n+        for (const auto& wtxid: m_local_set.m_wtxids) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+            m_local_set.m_short_id_mapping.emplace(short_txid, wtxid);\n+        }\n+\n+        return sketch;\n+    }\n+\n+    /**\n+     * When our peer tells us that our sketch was insufficient to reconcile transactions because\n+     * of the low capacity, we compute an extended sketch with the double capacity, and then send\n+     * only the part the peer is missing to that peer.\n+     */\n+    Minisketch ComputeExtendedSketch(uint32_t extended_capacity)\n+    {\n+        assert(extended_capacity > 0);\n+        // This can't happen because we should have terminated reconciliation early.\n+        assert(m_local_set_snapshot.GetSize() > 0);\n+\n+        // For now, compute a sketch of twice the capacity were computed originally.\n+        // TODO: optimize by computing the extension *on top* of the existent sketch\n+        // instead of computing the lower order elements again.\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, extended_capacity);\n+\n+        // We don't have to recompute short IDs here.\n+        for (const auto& shortid_to_wtxid: m_local_set_snapshot.m_short_id_mapping) {\n+            sketch.Add(shortid_to_wtxid.first);\n+        }\n+        return sketch;\n+    }\n+\n+    /**\n+     * Once we are fully done with the reconciliation we initiated, prepare the state for the\n+     * following reconciliations we initiate.\n+     */\n+    void FinalizeInitByUs(bool clear_local_set, double updated_q)\n+    {\n+        assert(m_we_initiate);\n+        m_state_init_by_us.m_local_q = updated_q;\n+        if (clear_local_set) m_local_set.Clear();\n+        m_local_set_snapshot.Clear();\n+        // This is currently belt-and-suspenders, as the code should work even without these calls.\n+        m_capacity_snapshot = 0;\n+        m_state_init_by_us.m_remote_sketch_snapshot.clear();\n+    }\n+\n+    /**\n+     * Be ready to respond to extension request, to compute the extended sketch over\n+     * the same initial set (without transactions received during the reconciliation).\n+     * Allow to store new transactions separately in the original set.\n+     */\n+    void PrepareForExtensionRequest(uint16_t sketch_capacity)\n+    {\n+        assert(!m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+\n+    /**\n+     * To be efficient in transmitting extended sketch, we store a snapshot of the sketch\n+     * received in the initial reconciliation step, so that only the necessary extension data\n+     * has to be transmitted.\n+     * We also store a snapshot of our local reconciliation set, to better keep track of\n+     * transactions arriving during this reconciliation (they will be added to the cleared\n+     * original reconciliation set, to be reconciled next time).\n+     */\n+    void PrepareForExtensionResponse(uint16_t sketch_capacity, const std::vector<uint8_t>& remote_sketch)\n+    {\n+        assert(m_we_initiate);\n+        m_capacity_snapshot = sketch_capacity;\n+        m_state_init_by_us.m_remote_sketch_snapshot = remote_sketch;\n+        m_local_set_snapshot = m_local_set;\n+        m_local_set.Clear();\n+    }\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl {\n+\n+    mutable Mutex m_mutex;\n+\n+    /**\n+     * Per-peer salt is used to compute transaction short IDs, which will be later used to\n+     * construct reconciliation sketches.\n+     * Salt is generated randomly per-peer to prevent:\n+     * - linking of network nodes belonging to the same physical node\n+     * - halting of relay of particular transactions due to short ID collisions (DoS)\n+     */\n+    std::unordered_map<NodeId, uint64_t> m_local_salts GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Keeps track of ongoing reconciliations with a given peer.\n+     */\n+    std::unordered_map<NodeId, ReconciliationState> m_states GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_mutex);\n+\n+    /**\n+     * Reconciliations are requested periodically:\n+     * every RECON_REQUEST_INTERVAL seconds we pick a peer from the queue.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_mutex);\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)\n+    {\n+        assert(m_queue.size() > 0);\n+        m_next_recon_request = now + RECON_REQUEST_INTERVAL / m_queue.size();\n+    }\n+\n+    /**\n+     * Used to schedule the next initial response for any pending reconciliation request.\n+     * Respond to all requests at the same time to prevent transaction possession leak.\n+     */\n+    std::chrono::microseconds m_next_recon_respond{0};\n+    std::chrono::microseconds NextReconRespond()\n+    {\n+        auto current_time = GetTime<std::chrono::microseconds>();\n+        if (m_next_recon_respond < current_time) {\n+            m_next_recon_respond = current_time + RECON_RESPONSE_INTERVAL;\n+        }\n+        return m_next_recon_respond;\n+    }\n+\n+    bool HandleInitialSketch(std::unordered_map<NodeId, ReconciliationState>::iterator& recon_state,\n+        const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result)\n+    {\n+        assert(recon_state->second.m_we_initiate);\n+        assert(recon_state->second.m_state_init_by_us.m_phase == Phase::INIT_REQUESTED);\n+\n+        uint32_t remote_sketch_capacity = uint32_t(skdata.size() / BYTES_PER_SKETCH_CAPACITY);\n+        // Protocol violation: our peer exceeded the sketch capacity, or sent a malformed sketch.\n+        if (remote_sketch_capacity > MAX_SKETCH_CAPACITY) {\n+            return false;\n+        }\n+\n+        Minisketch local_sketch = recon_state->second.ComputeBaseSketch(remote_sketch_capacity);\n+        Minisketch remote_sketch;\n+        if (remote_sketch_capacity != 0) {\n+            remote_sketch = Minisketch(RECON_FIELD_SIZE, 0, remote_sketch_capacity).Deserialize(skdata);\n+        }\n+\n+        // Remote sketch is empty in two cases per which reconciliation is pointless:\n+        // 1. the peer has no transactions for us\n+        // 2. we told the peer we have no transactions for them while initiating reconciliation.\n+        // In case (2), local sketch is also empty.\n+        if (remote_sketch_capacity == 0 || !remote_sketch || !local_sketch) {\n+\n+            // Announce all transactions we have.\n+            txs_to_announce = recon_state->second.m_local_set.GetAllTransactions();\n+\n+            // Update local reconciliation state for the peer.\n+            recon_state->second.FinalizeInitByUs(true, DEFAULT_RECON_Q);\n+            recon_state->second.m_state_init_by_us.m_phase = Phase::NONE;\n+\n+            result = false;\n+\n+            LogPrint(BCLog::NET, \"Reconciliation we initiated with peer=%d terminated due to empty sketch. \" /* Continued */\n+                \"Announcing all %i transactions from the local set.\\n\", recon_state->first, txs_to_announce.size());\n+\n+            return true;\n+        }\n+\n+        assert(remote_sketch);\n+        assert(local_sketch);\n+        // Attempt to decode the set difference\n+        size_t max_elements = minisketch_compute_max_elements(RECON_FIELD_SIZE, remote_sketch_capacity, RECON_FALSE_POSITIVE_COEF);\n+        std::vector<uint64_t> differences(max_elements);\n+        if (local_sketch.Merge(remote_sketch).Decode(differences)) {\n+            // Initial reconciliation step succeeded.\n+\n+            // Identify locally/remotely missing transactions.\n+            recon_state->second.m_local_set.GetRelevantIDsFromShortIDs(differences, txs_to_request, txs_to_announce);\n+\n+            // Update local reconciliation state for the peer.\n+            size_t local_set_size = recon_state->second.m_local_set.GetSize();\n+            recon_state->second.FinalizeInitByUs(true,\n+                RecomputeQ(local_set_size, txs_to_request.size(), txs_to_announce.size()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628381177",
      "id" : 628381177,
      "line" : 515,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM4MTE3Nw==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 515,
      "original_position" : 515,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 515,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628381177",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628389326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628389326"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Interesting, default value sounds to diverge from Erlay paper recommendation : \r\n\r\n\"The coefficient q characterizes earlier reconciliation, so before the very first reconciliation round it is set to zero.\"\r\n\r\nYou find empirically that a small coefficient was better to start with?",
      "commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "created_at" : "2021-05-07T17:27:10Z",
      "diff_hunk" : "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r628389326",
      "id" : 628389326,
      "line" : 39,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyODM4OTMyNg==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 39,
      "pull_request_review_id" : 654524878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-07T17:35:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/628389326",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@naumenkogs #21859 should be sufficiently ready to rebase on, if you want CI-testable code. Note the src/minisketchwrapper module, which automatically benchmarks.",
      "created_at" : "2021-05-17T02:58:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-841946130",
      "id" : 841946130,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0MTk0NjEzMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-17T03:00:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/841946130",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660490867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660490867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For future conversations, I will refer to my findings [here](https://github.com/naumenkogs/txrelaysim/tree/master/results/flood-erlay).",
      "commit_id" : "494c54984553ddc1116d1e8d70d1359cd6023b68",
      "created_at" : "2021-06-29T10:34:41Z",
      "diff_hunk" : "@@ -0,0 +1,996 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <unordered_map>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static component of the salt used to compute short txids for inclusion in sketches. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;\n+/**\n+* It is possible that if sketch encodes more elements than the capacity, or\n+* if it is constructed of random bytes, sketch decoding may \"succeed\",\n+* but the result will be nonsense (false-positive decoding).\n+* Given this coef, a false positive probability will be of 1 in 2**coef.\n+*/\n+constexpr unsigned int RECON_FALSE_POSITIVE_COEF = 16;\n+static_assert(RECON_FALSE_POSITIVE_COEF <= 256,\n+    \"Reducing reconciliation false positives beyond 1 in 2**256 is not supported\");\n+/** Default value for the coefficient used to estimate reconciliation set differences. */\n+constexpr double DEFAULT_RECON_Q = 0.02;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660490867",
      "id" : 660490867,
      "in_reply_to_id" : 628389326,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQ5MDg2Nw==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 694865394,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-29T10:34:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660490867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660668925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660668925"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No way to test this. HandleSketch() can be legally called only after MaybeRequestSketch (`m_state_init_by_us.m_phase = Phase::INIT_REQUESTED`) , which is not possible for responders in the first place.",
      "commit_id" : "5a5581fd35aba854deb0d21972a49c9f13926597",
      "created_at" : "2021-06-29T14:22:36Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    std::vector<uint8_t> extended_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity * 2).Serialize();\n+    std::vector<uint8_t> sketch_extension(extended_sketch.begin() + extended_sketch.size() / 2, extended_sketch.end());\n+    assert(skdata == sketch_extension);\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleExtensionRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.AddTransactions(5);\n+\n+    // Extension request without initial request does nothing.\n+    std::vector<uint8_t> skdata;\n+    tracker_test.HandleExtensionRequest();\n+    assert(!tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    tracker_test.HandleReconciliationRequest();\n+    SetMockTime(start_time + 1000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() != 0);\n+    // Then respond with an extension sketch.\n+    tracker_test.HandleExtensionRequest();\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+\n+    TxReconciliationTrackerTest tracker_test2(true);\n+\n+    tracker_test2.HandleReconciliationRequest();\n+    SetMockTime(start_time + 2000);\n+    std::vector<uint8_t> skdata2;\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata2));\n+    assert(skdata2.size() == 0);\n+    // Do not respond if the initial sketch we sent out was empty.\n+    tracker_test2.HandleExtensionRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata2));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleInitialSketchTest)\n+{\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    TxReconciliationTrackerTest tracker_test(false);\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+\n+    // Protocol violation: unknown peer.\n+    assert(!tracker_test.HandleSketch(std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result, true));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660668925",
      "id" : 660668925,
      "in_reply_to_id" : 628343839,
      "line" : 414,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY2ODkyNQ==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 414,
      "original_position" : 394,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 414,
      "pull_request_review_id" : 695105491,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-29T14:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660668925",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660671746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660671746"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Adding a check for `local_set`, but it's hard to get into `local_set_snapshot` because it's a private variable with no getter method. I could possibly check it implicitly, but that's more of a functional test thing.",
      "commit_id" : "5a5581fd35aba854deb0d21972a49c9f13926597",
      "created_at" : "2021-06-29T14:25:25Z",
      "diff_hunk" : "@@ -0,0 +1,686 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <minisketch/include/minisketch.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txreconciliation_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+// Taken verbatim from txreconciliation.cpp\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+constexpr double DEFAULT_RECON_Q = 0.02;\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+\n+class TxReconciliationTrackerTest\n+{\n+    TxReconciliationTracker m_tracker;\n+\n+    uint64_t m_k0, m_k1;\n+\n+    NodeId m_peer_id;\n+\n+    public:\n+\n+    std::vector<uint256> m_transactions;\n+\n+    TxReconciliationTrackerTest(bool inbound)\n+    {\n+        m_peer_id = 1;\n+        uint64_t our_salt = 0;\n+        auto recon_params = m_tracker.SuggestReconciling(m_peer_id, inbound);\n+        uint64_t node_salt = std::get<3>(recon_params);\n+        if (inbound) {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, true, true, false, 1, our_salt));\n+        } else {\n+            assert(m_tracker.EnableReconciliationSupport(m_peer_id, false, false, true, 1, our_salt));\n+        }\n+        assert(m_tracker.IsPeerRegistered(m_peer_id));\n+\n+        uint64_t salt1 = 0, salt2 = node_salt;\n+        if (salt1 > salt2) std::swap(salt1, salt2);\n+        static const auto RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+        uint256 full_salt = (CHashWriter(RECON_SALT_HASHER) << salt1 << salt2).GetSHA256();\n+\n+        m_k0 = full_salt.GetUint64(0);\n+        m_k1 = full_salt.GetUint64(1);\n+    }\n+\n+    void HandleReconciliationRequest(uint16_t set_size=1, uint16_t q=uint16_t(DEFAULT_RECON_Q * Q_PRECISION))\n+    {\n+        m_tracker.HandleReconciliationRequest(m_peer_id, set_size, q);\n+    }\n+\n+    bool RespondToReconciliationRequest(std::vector<uint8_t>& skdata)\n+    {\n+        return m_tracker.RespondToReconciliationRequest(m_peer_id, skdata);\n+    }\n+\n+    bool FinalizeInitByThem(bool recon_result,\n+        const std::vector<uint32_t>& remote_missing_short_ids, std::vector<uint256>& remote_missing,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.FinalizeInitByThem(fake_peer ? 2 : m_peer_id, recon_result, remote_missing_short_ids, remote_missing);\n+    }\n+\n+    void HandleExtensionRequest()\n+    {\n+        m_tracker.HandleExtensionRequest(m_peer_id);\n+    }\n+\n+    bool HandleSketch(const std::vector<uint8_t>& skdata,\n+        // returning values\n+        std::vector<uint32_t>& txs_to_request, std::vector<uint256>& txs_to_announce, std::optional<bool>& result,\n+        bool fake_peer=false)\n+    {\n+        return m_tracker.HandleSketch(fake_peer ? 2 : m_peer_id, skdata, txs_to_request, txs_to_announce, result);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation()\n+    {\n+        return m_tracker.MaybeRequestReconciliation(m_peer_id);\n+    }\n+\n+    std::optional<size_t> GetPeerSetSize() const\n+    {\n+        return m_tracker.GetPeerSetSize(m_peer_id);\n+    }\n+\n+    void AddTransactions(size_t count)\n+    {\n+        std::vector<uint256> their_txs;\n+        for (size_t i = 0; i < count; i++) {\n+            uint256 wtxid = GetRandHash();\n+            their_txs.push_back(wtxid);\n+            m_transactions.push_back(wtxid);\n+        }\n+        m_tracker.AddToReconSet(m_peer_id, their_txs);\n+    }\n+\n+    uint32_t ComputeShortID(const uint256 wtxid) const\n+    {\n+        const uint64_t s = SipHashUint256(m_k0, m_k1, wtxid);\n+        const uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+        return short_txid;\n+    }\n+\n+    Minisketch ComputeSketch(std::vector<uint256> txs, uint16_t capacity)\n+    {\n+        Minisketch sketch = Minisketch(RECON_FIELD_SIZE, 0, capacity);\n+        for (const auto& wtxid: txs) {\n+            uint32_t short_txid = ComputeShortID(wtxid);\n+            sketch.Add(short_txid);\n+        }\n+        return sketch;\n+    }\n+};\n+\n+}  // namespace\n+\n+BOOST_AUTO_TEST_CASE(SuggestReconcilingTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    auto [we_initiate_recon, we_respond_recon, recon_version, recon_salt] = tracker.SuggestReconciling(0, true);\n+    assert(!we_initiate_recon);\n+    assert(we_respond_recon);\n+\n+    std::tie(we_initiate_recon, we_respond_recon, recon_version, recon_salt) = tracker.SuggestReconciling(1, false);\n+    assert(we_initiate_recon);\n+    assert(!we_respond_recon);\n+}\n+\n+BOOST_AUTO_TEST_CASE(EnableReconciliationSupportTest)\n+{\n+    TxReconciliationTracker tracker;\n+    const uint64_t salt = 0;\n+\n+    NodeId peer_id0 = 0;\n+    // Generate salt.\n+    tracker.SuggestReconciling(peer_id0, true);\n+    // Both roles are false, don't register.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, false, 1, salt));\n+    // Invalid roles for the given direction.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, false, true, 1, salt));\n+    // Invalid version.\n+    assert(!tracker.EnableReconciliationSupport(peer_id0, true, true, false, 0, salt));\n+    // Valid peer.\n+    assert(!tracker.IsPeerRegistered(peer_id0));\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, salt));\n+    assert(tracker.IsPeerRegistered(peer_id0));\n+\n+    NodeId unknown_peer = 100;\n+    // Do not register if salt is not generated for a given peer.\n+    assert(!tracker.EnableReconciliationSupport(unknown_peer, true, true, false, 1, salt));\n+    assert(!tracker.IsPeerRegistered(unknown_peer));\n+}\n+\n+BOOST_AUTO_TEST_CASE(AddToReconSetTest)\n+{\n+    TxReconciliationTracker tracker;\n+\n+    NodeId peer_id0 = 0;\n+    bool inbound = true;\n+    tracker.SuggestReconciling(peer_id0, inbound);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, inbound, true, false, 1, 0));\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == 0);\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id0, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    assert(tracker.GetPeerSetSize(peer_id0) == count);\n+}\n+\n+BOOST_AUTO_TEST_CASE(MaybeRequestReconciliationTest)\n+{\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    int64_t start_time = GetTime();\n+    SetMockTime(start_time);\n+\n+    // Don't request from a non-registered peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+\n+    SetMockTime(start_time);\n+    // Don't request from an inbound peer.\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        assert(!tracker.MaybeRequestReconciliation(peer_id0));\n+    }\n+\n+    NodeId peer_id1 = 1;\n+    tracker.SuggestReconciling(peer_id1, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id1, false, false, true, 1, 0));\n+\n+    // Make a request.\n+    size_t requested = 0;\n+    SetMockTime(start_time);\n+    for (int i = 0; i < 10; i++) {\n+        SetMockTime(start_time + i * 10);\n+        auto request_data = tracker.MaybeRequestReconciliation(peer_id1 );\n+        if (request_data) {\n+            const auto [local_set_size, local_q_formatted] = (*request_data);\n+            assert(local_set_size == 0);\n+            assert(local_q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+            ++requested;\n+        }\n+    }\n+    // Request only once until it's responded.\n+    assert(requested == 1);\n+\n+    // If the reconciliation is over, the next request should happen after some interval.\n+    NodeId peer_id2 = 2;\n+    tracker.SuggestReconciling(peer_id2, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id2, false, false, true, 1, 0));\n+    SetMockTime(start_time + 10000);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    std::vector<uint32_t> txs_to_request;\n+    std::vector<uint256> txs_to_announce;\n+    std::optional<bool> recon_result;\n+    tracker.HandleSketch(peer_id2, std::vector<uint8_t>(), txs_to_request, txs_to_announce, recon_result);\n+    assert(recon_result && !*recon_result); // Check it's finalized.\n+\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    SetMockTime(start_time + 20000);\n+    // Still don't request because the other peer is earlier in the queue.\n+    assert(!tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id1);\n+    assert(tracker.MaybeRequestReconciliation(peer_id2));\n+    tracker.RemovePeer(peer_id2);\n+\n+    // Check that the request has a correct set size.\n+    NodeId peer_id3 = 3;\n+    tracker.SuggestReconciling(peer_id3, false);\n+    assert(tracker.EnableReconciliationSupport(peer_id3, false, false, true, 1, 0));\n+\n+    size_t count = 10;\n+    for (size_t i = 0; i < count; i++) {\n+        tracker.AddToReconSet(peer_id3, std::vector<uint256>{GetRandHash()});\n+    }\n+\n+    SetMockTime(start_time + 24000);\n+    auto request_data = tracker.MaybeRequestReconciliation(peer_id3);\n+    if (request_data) {\n+        const auto [set_size, q_formatted] = (*request_data);\n+        assert(set_size == count);\n+        assert(q_formatted == uint16_t(DEFAULT_RECON_Q * Q_PRECISION));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(HandleReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Request from a non-registered peer should not trigger a response.\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // Request from a non-initiating peer should be ignored.\n+    TxReconciliationTrackerTest tracker_test1(false);\n+    tracker_test1.HandleReconciliationRequest();\n+    SetMockTime(start_time + 4000);\n+    assert(!tracker_test1.RespondToReconciliationRequest(skdata));\n+\n+    // The node receives a reconciliation request and should respond with a sketch after a delay.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.HandleReconciliationRequest();\n+    // Too early, do not respond yet.\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+    SetMockTime(start_time + 8000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+\n+    // Request at the wrong reconciliation phase should be ignored.\n+    SetMockTime(start_time + 12000);\n+    tracker_test2.HandleReconciliationRequest();\n+    assert(!tracker_test2.RespondToReconciliationRequest(skdata));\n+}\n+\n+BOOST_AUTO_TEST_CASE(RespondToReconciliationRequestTest)\n+{\n+    int64_t start_time = GetTime();\n+    std::vector<uint8_t> skdata;\n+    SetMockTime(start_time);\n+\n+    // Check that we won't respond if the peer is removed (\"unregistered\").\n+    TxReconciliationTracker tracker;\n+    NodeId peer_id0 = 0;\n+    tracker.SuggestReconciling(peer_id0, true);\n+    assert(tracker.EnableReconciliationSupport(peer_id0, true, true, false, 1, 0));\n+    tracker.HandleReconciliationRequest(peer_id0, 1, 1);\n+    SetMockTime(start_time + 1000);\n+    tracker.RemovePeer(peer_id0);\n+    assert(!tracker.RespondToReconciliationRequest(peer_id0, skdata));\n+\n+    // The node receives a reconciliation request noting that the initiator has an empty set.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test(true);\n+    tracker_test.HandleReconciliationRequest(1);\n+    SetMockTime(start_time + 2000);\n+    assert(tracker_test.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request noting that their local set is empty.\n+    // The node should terminate reconciliation by sending an empty sketch.\n+    TxReconciliationTrackerTest tracker_test2(true);\n+    tracker_test2.AddTransactions(5);\n+    tracker_test2.HandleReconciliationRequest(0);\n+    SetMockTime(start_time + 3000);\n+    assert(tracker_test2.RespondToReconciliationRequest(skdata));\n+    assert(skdata.size() == 0);\n+\n+    // The node receives a reconciliation request and should respond with an expected sketch.\n+    TxReconciliationTrackerTest tracker_test3(true);\n+    double q = 1;\n+    tracker_test3.AddTransactions(10);\n+    tracker_test3.HandleReconciliationRequest(1, q * Q_PRECISION);\n+    SetMockTime(start_time + 4000);\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));\n+    uint32_t expected_capacity = (10 - 1) + q * 1 + 1;\n+    Minisketch expected_sketch = tracker_test3.ComputeSketch(tracker_test3.m_transactions, expected_capacity);\n+    assert(skdata == expected_sketch.Serialize());\n+    // Then respond with an extension sketch.\n+    tracker_test3.HandleExtensionRequest();\n+    assert(tracker_test3.RespondToReconciliationRequest(skdata));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r660671746",
      "id" : 660671746,
      "in_reply_to_id" : 628332247,
      "line" : 364,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY3MTc0Ng==",
      "original_commit_id" : "1d8d43ed095ef7abade4d62ddc2ede34d4a1a59b",
      "original_line" : 364,
      "original_position" : 345,
      "original_start_line" : null,
      "path" : "src/test/txreconciliation_tests.cpp",
      "position" : 364,
      "pull_request_review_id" : 695109261,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-29T14:25:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660671746",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "How can I help test this? I've been running it for a few hours so far on mainnet, but haven't noticed much difference compared to the master branch.",
      "created_at" : "2021-06-29T23:07:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-870975622",
      "id" : 870975622,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg3MDk3NTYyMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-29T23:07:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/870975622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@rebroad It only makes a difference if your erlay-enabled node connects to other erlay-enabled nodes :)\r\nI'm planning to invite people to a such sub-network soon (where we can connect to each other by --addnode manually). I'll let you know once I start that :)\r\n\r\nYou can obviously run several nodes with this patch by yourself too, just make sure to connect them.",
      "created_at" : "2021-06-30T16:43:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-871564829",
      "id" : 871564829,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg3MTU2NDgyOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-30T17:15:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/871564829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663755989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663755989"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: Why is this change here? ",
      "commit_id" : "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "created_at" : "2021-07-05T08:53:06Z",
      "diff_hunk" : "@@ -30,8 +30,8 @@ Drag Bitcoin Core to your applications folder, and then run Bitcoin Core.\n \n * See the documentation at the [Bitcoin Wiki](https://en.bitcoin.it/wiki/Main_Page)\n for help and more information.\n-* Ask for help on the [Bitcoin StackExchange](https://bitcoin.stackexchange.com)\n-* Ask for help on [#bitcoin](https://webchat.freenode.net/#bitcoin) on Freenode. If you don't have an IRC client, use [webchat here](https://webchat.freenode.net/#bitcoin).\n+* Ask for help on [Bitcoin StackExchange](https://bitcoin.stackexchange.com).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663755989",
      "id" : 663755989,
      "line" : 33,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc1NTk4OQ==",
      "original_commit_id" : "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "original_line" : 33,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "doc/README.md",
      "position" : 6,
      "pull_request_review_id" : 698947525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-07-05T08:53:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663755989",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/58662979?v=4",
         "events_url" : "https://api.github.com/users/kiminuo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kiminuo/followers",
         "following_url" : "https://api.github.com/users/kiminuo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kiminuo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kiminuo",
         "id" : 58662979,
         "login" : "kiminuo",
         "node_id" : "MDQ6VXNlcjU4NjYyOTc5",
         "organizations_url" : "https://api.github.com/users/kiminuo/orgs",
         "received_events_url" : "https://api.github.com/users/kiminuo/received_events",
         "repos_url" : "https://api.github.com/users/kiminuo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kiminuo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kiminuo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kiminuo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663759139"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663759139"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nit: Is it a good idea to reformat this file? Maybe that can be done in a separate PR.",
      "commit_id" : "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "created_at" : "2021-07-05T08:57:25Z",
      "diff_hunk" : "@@ -322,19 +327,32 @@ def main():\n                                      epilog='''\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n-    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(), help=\"Use ANSI colors and dots in output (enabled by default when standard output is a TTY)\")\n-    parser.add_argument('--combinedlogslen', '-c', type=int, default=0, metavar='n', help='On failure, print a log (of length n lines) to the console, combined from the test framework and all test nodes.')\n-    parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n-    parser.add_argument('--ci', action='store_true', help='Run checks and code that are usually only enabled in a continuous integration environment')\n-    parser.add_argument('--exclude', '-x', help='specify a comma-separated-list of scripts to exclude.')\n-    parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n-    parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n-    parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n-    parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n-    parser.add_argument('--quiet', '-q', action='store_true', help='only print dots, results summary and failure logs')\n-    parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n-    parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n-    parser.add_argument('--filter', help='filter scripts to run by regular expression')\n+    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663759139",
      "id" : 663759139,
      "line" : 330,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc1OTEzOQ==",
      "original_commit_id" : "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "original_line" : 330,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "test/functional/test_runner.py",
      "position" : 51,
      "pull_request_review_id" : 698951767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-07-05T08:57:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663759139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/58662979?v=4",
         "events_url" : "https://api.github.com/users/kiminuo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kiminuo/followers",
         "following_url" : "https://api.github.com/users/kiminuo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kiminuo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kiminuo",
         "id" : 58662979,
         "login" : "kiminuo",
         "node_id" : "MDQ6VXNlcjU4NjYyOTc5",
         "organizations_url" : "https://api.github.com/users/kiminuo/orgs",
         "received_events_url" : "https://api.github.com/users/kiminuo/received_events",
         "repos_url" : "https://api.github.com/users/kiminuo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kiminuo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kiminuo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kiminuo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988352"
         }
      },
      "author_association" : "MEMBER",
      "body" : "oops, definitely not indented. Probably a rebasing mistake.",
      "commit_id" : "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "created_at" : "2021-07-05T14:51:39Z",
      "diff_hunk" : "@@ -322,19 +327,32 @@ def main():\n                                      epilog='''\n     Help text and arguments for individual test script:''',\n                                      formatter_class=argparse.RawTextHelpFormatter)\n-    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(), help=\"Use ANSI colors and dots in output (enabled by default when standard output is a TTY)\")\n-    parser.add_argument('--combinedlogslen', '-c', type=int, default=0, metavar='n', help='On failure, print a log (of length n lines) to the console, combined from the test framework and all test nodes.')\n-    parser.add_argument('--coverage', action='store_true', help='generate a basic coverage report for the RPC interface')\n-    parser.add_argument('--ci', action='store_true', help='Run checks and code that are usually only enabled in a continuous integration environment')\n-    parser.add_argument('--exclude', '-x', help='specify a comma-separated-list of scripts to exclude.')\n-    parser.add_argument('--extended', action='store_true', help='run the extended test suite in addition to the basic tests')\n-    parser.add_argument('--help', '-h', '-?', action='store_true', help='print help text and exit')\n-    parser.add_argument('--jobs', '-j', type=int, default=4, help='how many test scripts to run in parallel. Default=4.')\n-    parser.add_argument('--keepcache', '-k', action='store_true', help='the default behavior is to flush the cache directory on startup. --keepcache retains the cache from the previous testrun.')\n-    parser.add_argument('--quiet', '-q', action='store_true', help='only print dots, results summary and failure logs')\n-    parser.add_argument('--tmpdirprefix', '-t', default=tempfile.gettempdir(), help=\"Root directory for datadirs\")\n-    parser.add_argument('--failfast', action='store_true', help='stop execution after the first test failure')\n-    parser.add_argument('--filter', help='filter scripts to run by regular expression')\n+    parser.add_argument('--ansi', action='store_true', default=sys.stdout.isatty(),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988352",
      "id" : 663988352,
      "in_reply_to_id" : 663759139,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzk4ODM1Mg==",
      "original_commit_id" : "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "original_line" : 330,
      "original_position" : 51,
      "original_start_line" : null,
      "path" : "test/functional/test_runner.py",
      "position" : null,
      "pull_request_review_id" : 699254360,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988352/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-07-05T14:51:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988352",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988384"
         }
      },
      "author_association" : "MEMBER",
      "body" : "oops, definitely not indented. Probably a rebasing mistake.",
      "commit_id" : "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "created_at" : "2021-07-05T14:51:41Z",
      "diff_hunk" : "@@ -30,8 +30,8 @@ Drag Bitcoin Core to your applications folder, and then run Bitcoin Core.\n \n * See the documentation at the [Bitcoin Wiki](https://en.bitcoin.it/wiki/Main_Page)\n for help and more information.\n-* Ask for help on the [Bitcoin StackExchange](https://bitcoin.stackexchange.com)\n-* Ask for help on [#bitcoin](https://webchat.freenode.net/#bitcoin) on Freenode. If you don't have an IRC client, use [webchat here](https://webchat.freenode.net/#bitcoin).\n+* Ask for help on [Bitcoin StackExchange](https://bitcoin.stackexchange.com).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r663988384",
      "id" : 663988384,
      "in_reply_to_id" : 663755989,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzk4ODM4NA==",
      "original_commit_id" : "1a0868c90daab56734ec99e4a63f96500b2464bb",
      "original_line" : 33,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "doc/README.md",
      "position" : null,
      "pull_request_review_id" : 699254400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-07-05T14:51:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/663988384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-07-07T12:33:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-875564656",
      "id" : 875564656,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg3NTU2NDY1Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-07T12:33:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/875564656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've been testing this, and so far I've found that the efficiency is reduced with this patch - i.e. a lower PERCENTAGE of the bandwidth is used for ACCEPTED transactions compared to not using this patch. Therefore it is better NOT to use this patch. Therefore, NACK, for now, perhaps premature.\r\n\r\nI'll continue testing, and share my data in the near future.",
      "created_at" : "2021-07-23T16:07:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885743229",
      "id" : 885743229,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5840y159",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-27T16:12:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/885743229",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@rebroad That's interesting, and surprising. Can you share your data? Which other Erlay-capable nodes have you been testing with? Substantial improvements are only expected once significant subgraphs adopt it.",
      "created_at" : "2021-07-23T19:29:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885868272",
      "id" : 885868272,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5840zUbw",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-23T19:40:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/885868272",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "rebroad: \r\n> How can I help test this? I've been running it for a few hours so far on mainnet, but haven't noticed much difference compared to the master branch.\r\n\r\n> I've been testing this, and so far I've found that the efficiency is reduced with this patch - i.e. a lower PERCENTAGE of the bandwidth is used for ACCEPTED transactions compared to not using this patch. Therefore it is better NOT to use this patch. Therefore, NACK.\r\n\r\nsipa: \r\n> **Can you share your data?**\r\n\r\n+1 I love NACK data. Please share else NACK is meaningless. ",
      "created_at" : "2021-07-23T20:34:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-885899988",
      "id" : 885899988,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5840zcLU",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-23T20:35:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/885899988",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13405205?v=4",
         "events_url" : "https://api.github.com/users/prayank23/events{/privacy}",
         "followers_url" : "https://api.github.com/users/prayank23/followers",
         "following_url" : "https://api.github.com/users/prayank23/following{/other_user}",
         "gists_url" : "https://api.github.com/users/prayank23/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/prayank23",
         "id" : 13405205,
         "login" : "prayank23",
         "node_id" : "MDQ6VXNlcjEzNDA1MjA1",
         "organizations_url" : "https://api.github.com/users/prayank23/orgs",
         "received_events_url" : "https://api.github.com/users/prayank23/received_events",
         "repos_url" : "https://api.github.com/users/prayank23/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/prayank23/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/prayank23/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/prayank23"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa @prayank23 @rebroad \r\nI've spent last couple days running my own subnetwork of Erlay nodes connected to mainnet. I was slightly tuning implementation/configurations and observing savings of 20-50% of overall bandwidth.\r\n\r\nI can imagine this PR with no modifications yeilding suboptimal results. I will update the PR with good actual-peformance (according to my real-time experiments) in the next few days, and bring that up at the meeting.\r\n\r\nI think judging/nacking this based on the perf is premature.\r\n\r\nSorry for spending your time testing this commit. At this point, the PR was open mainly for concept/code review rather than pefr (maybe it could have been a draft PR, yeah).\r\n",
      "created_at" : "2021-07-24T14:23:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-886060698",
      "id" : 886060698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII58400Daa",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-24T14:30:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/886060698",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "![image](https://user-images.githubusercontent.com/1530283/128164829-cb1eef81-705d-433a-b1ce-1cb42106a660.png)\r\nI'm now running the latest erlay patch on 2 nodes, and created a manual connection between them. Compared to non-erlay nodes, the percentage of mempool-successful receive traffic seems below average, and the upload bps seems significantly higher than for the other nodes.\r\n\r\nUpdate (5th August 2021) - still getting very poor TX percentage compared to regular nodes - and a lot of wasted bandwidth - far more than any other connection. I get better percentage with an onion connection even though it has a much larger minimum ping - usually the lower the ping the higher the TX percentage, but not with erlay!\r\n\r\n![image](https://user-images.githubusercontent.com/1530283/128416897-d8cd7829-76d6-4c66-abb0-240b534094f9.png)\r\n",
      "created_at" : "2021-08-04T10:19:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-892542075",
      "id" : 892542075,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5841Mxx7",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-05T20:30:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/892542075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Debug build is clean. I'll try to start looking at this soon.",
      "created_at" : "2021-08-17T17:54:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-900511655",
      "id" : 900511655,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5841rLen",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-17T17:54:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900511655",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I created 2 discussion boards, please discuss not-code-related topics there:\r\n1. [Understanding bandwidth savings](https://github.com/naumenkogs/txrelaysim/issues/7)\r\n2. [Joining mainnet testing](https://github.com/naumenkogs/txrelaysim/issues/8)",
      "created_at" : "2021-08-19T18:37:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902149222",
      "id" : 902149222,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5841xbRm",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T18:37:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902149222",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "After running this for a few minutes, I'm so far seeing better performance from non-erlay nodes, but perhaps we need more erlay nodes for testing to really see if there's really an improvement.\r\n![image](https://user-images.githubusercontent.com/1530283/130253576-76edc275-b00d-4888-8606-f7adee87634d.png)\r\n",
      "created_at" : "2021-08-20T15:04:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902758735",
      "id" : 902758735,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5841zwFP",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-20T15:04:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902758735",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@rebroad no, the bandwidth savings should come immediately for your node. Maybe the difference is that you run too many conns (I always tested 8/12 erlay conns and that's it)...\r\n\r\nWe could also try to understand why it eats more bandwidth in your case, but perhaps we should stick to the realistic case? E.g., 4 erlay conns + 4 legacy conns for. \r\n\r\nAnyway, could we continue the bandwidth-related discussion [here](https://github.com/naumenkogs/txrelaysim/issues/7)?",
      "created_at" : "2021-08-20T17:17:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-902839760",
      "id" : 902839760,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII58410D3Q",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-20T17:17:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902839760",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe this is an \"the emperor has no clothes moment\", but I shall say what's on my mind without fear of appearing stupid.\r\n\r\nTo me, this change looks like the improvements are simply due to reducing the delay between sending TXs. With this change I see greater bandwidth, greater TX throughput but reduced efficiency (i.e. percentage of useful bandwidth). I've been seeing this since I started testing months ago.\r\n\r\nFor example, there's a node in Toronto currently that is managing to be the main provider of TXs, and is not using erlay. I suspect they have changed the code to reduce the delay between TXs:-\r\n\r\n![image](https://user-images.githubusercontent.com/1530283/133979106-690e62c1-c724-4022-9b69-66fb57dc9f3f.png)\r\n\r\nThis seems easily achieveable without erlay. Erlay also reduces the delay between sending TXs, so it's an easy hack to get better TX throughput, but the difference with erlay is that it also reduces efficiency (in all my tests so far).\r\n\r\nErlay does well with throughput:-\r\n![image](https://user-images.githubusercontent.com/1530283/133979283-9a4b6476-c0b0-4708-a9bb-760819127954.png)\r\n\r\nbut badly with efficency:-\r\n![image](https://user-images.githubusercontent.com/1530283/133979323-39f1f1c2-0490-49a9-867d-eeceb4066c1a.png)\r\n\r\nI'd like to see some test results from others that contradict mine though.",
      "created_at" : "2021-09-20T09:10:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-922753000",
      "id" : 922753000,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5843ABfo",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-20T09:13:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/922753000",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-09-30T01:33:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-930677595",
      "id" : 930677595,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5843eQNb",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-30T01:33:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/930677595",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-11-10T13:59:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-965207512",
      "id" : 965207512,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5845h-XY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/965207512/reactions"
      },
      "updated_at" : "2021-11-10T13:59:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/965207512",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Minisketch is merged! Please rebase :)",
      "created_at" : "2021-11-12T10:59:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-967011885",
      "id" : 967011885,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5845o24t",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/967011885/reactions"
      },
      "updated_at" : "2021-11-12T10:59:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/967011885",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "#23491 will conflict with this pull after rebase. Let me know if this acceptable or if you prefer to defer 23491 until after all other changes are merged.",
      "created_at" : "2021-11-12T11:07:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-967016604",
      "id" : 967016604,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5845o4Cc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/967016604/reactions"
      },
      "updated_at" : "2021-11-12T11:07:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/967016604",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "what is the 2021-11-erlay1 branch please? confused as it looks more recent (from the name) but this one is also getting updated.",
      "created_at" : "2021-11-25T13:20:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-979209269",
      "id" : 979209269,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5846XYw1",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/979209269/reactions"
      },
      "updated_at" : "2021-11-25T13:20:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/979209269",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This does not compile:-\r\n\r\n```\r\n8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\r\ncommit 8d4354499f39a49bbb8675494c532802ef034b03\r\nAuthor: Gleb Naumenko <naumenko.gs@gmail.com>\r\nDate:   Sat Mar 20 17:36:08 2021 +0200\r\n\r\n    Respond to a reconciliation request\r\n\r\n    When the time comes, we should send a sketch of our\r\n    local reconciliation set to the reconciliation initiator.\r\n\r\n src/net_processing.cpp   | 15 +++++++++++++++\r\n src/protocol.cpp         |  2 ++\r\n src/protocol.h           |  6 ++++++\r\n src/txreconciliation.cpp | 50 +++++++++++++++++++++++++++++++++++++++++++++++-\r\n src/txreconciliation.h   |  8 ++++++++\r\n 5 files changed, 80 insertions(+), 1 deletion(-)\r\n8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\r\n```",
      "created_at" : "2021-11-25T19:26:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-979436224",
      "id" : 979436224,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5846YQLA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/979436224/reactions"
      },
      "updated_at" : "2021-11-25T19:26:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/979436224",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=4",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "node_id" : "MDQ6VXNlcjE1MzAyODM=",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@rebroad hey\r\n\r\n>what is the 2021-11-erlay1 branch please? confused as it looks more recent (from the name) but this one is also getting updated.\r\n\r\nThat branch is a first batch of this PR commits, forked to be merged separately within [that PR](https://github.com/bitcoin/bitcoin/pull/23443).\r\nI try to keep the OP PR up-to-date with that one, but also not too often to avoid too many notifications here.\r\n\r\n>8d4354499f39a49bbb8675494c532802ef034b03 is the first bad commit\r\n\r\nYeah I somehow can't reproduce CI compiler errors neither on my mac nor on my linux, are you referring to those as well? Or can you share your compilation output?",
      "created_at" : "2021-11-29T09:53:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981466935",
      "id" : 981466935,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5846f_83",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981466935/reactions"
      },
      "updated_at" : "2021-11-29T09:53:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981466935",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK, thanks for splitting the big PR up :) Will review soon.",
      "created_at" : "2021-11-29T14:13:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981672502",
      "id" : 981672502,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5846gyI2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981672502/reactions"
      },
      "updated_at" : "2021-11-29T14:13:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981672502",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixing new CI issues here, for now please review the first batch separately [here](https://github.com/bitcoin/bitcoin/pull/23443) :)",
      "created_at" : "2021-11-29T14:57:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-981712350",
      "id" : 981712350,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5846g73e",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981712350/reactions"
      },
      "updated_at" : "2021-11-29T14:57:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/981712350",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-01-06T14:14:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1006623175",
      "id" : 1006623175,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII5847_9nH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1006623175/reactions"
      },
      "updated_at" : "2022-01-06T14:14:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1006623175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r805335106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/805335106"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The value chosen here seems too large based on some tests that i did.\r\n\r\nOn my laptop (with a decent CPU) a sketch with a capacity of  `2 << 13` and `2 << 13` differences (possible if an extension is requested) took ~20 seconds to decode. On lower end devices this will likely be worse. This is not super bad since sketches are only requested on outbound connections but having the `msghand` thread block like this is undesirable in any case.\r\n\r\nI am not entirely sure what an appropriate value would be but given the expected average set difference of 7 i would assume that 256 - 1024 as the max. sketch capacity would suffice.",
      "commit_id" : "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "created_at" : "2022-02-13T13:27:20Z",
      "diff_hunk" : "@@ -0,0 +1,1048 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <node/minisketchwrapper.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r805335106",
      "id" : 805335106,
      "line" : 32,
      "node_id" : "PRRC_kwDOABII584wAHBC",
      "original_commit_id" : "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "original_line" : 32,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 32,
      "pull_request_review_id" : 880981819,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/805335106/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-13T13:27:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/805335106",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r806556529"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806556529"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Excellent point. I will address this once I have to rebase these changes.",
      "commit_id" : "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "created_at" : "2022-02-15T08:11:59Z",
      "diff_hunk" : "@@ -0,0 +1,1048 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txreconciliation.h>\n+\n+#include <node/minisketchwrapper.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+\n+namespace {\n+\n+/** Current protocol version */\n+constexpr uint32_t RECON_VERSION = 1;\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** The size of the field, used to compute sketches to reconcile transactions (see BIP-330). */\n+constexpr unsigned int RECON_FIELD_SIZE = 32;\n+/**\n+ * Allows to infer capacity of a reconciliation sketch based on it's char[] representation,\n+ * which is necessary to deserealize a received sketch.\n+ */\n+constexpr unsigned int BYTES_PER_SKETCH_CAPACITY = RECON_FIELD_SIZE / 8;\n+/**\n+ * Limit sketch capacity to avoid DoS. This applies only to the original sketches,\n+ * and implies that extended sketches could be at most twice the size.\n+ */\n+constexpr uint32_t MAX_SKETCH_CAPACITY = 2 << 12;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#discussion_r806556529",
      "id" : 806556529,
      "in_reply_to_id" : 805335106,
      "line" : 32,
      "node_id" : "PRRC_kwDOABII584wExNx",
      "original_commit_id" : "5728fac4d3d29f64ea811f5978e80dabdc083d87",
      "original_line" : 32,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txreconciliation.cpp",
      "position" : 32,
      "pull_request_review_id" : 882603544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21515",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806556529/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-02-15T08:12:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/806556529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-05-19T10:21:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1131513012",
      "id" : 1131513012,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585DcYS0",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1131513012/reactions"
      },
      "updated_at" : "2022-05-19T10:21:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1131513012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Should this be marked as draft since it's a parent/meta PR?",
      "created_at" : "2022-10-12T18:28:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1276571833",
      "id" : 1276571833,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585MFvC5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276571833/reactions"
      },
      "updated_at" : "2022-10-12T18:28:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276571833",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-30T12:08:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1332050599",
      "id" : 1332050599,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585PZXqn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1332050599/reactions"
      },
      "updated_at" : "2022-11-30T12:08:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1332050599",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--13523179cfe9479db18ec6c5d236f789-->\nThere hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? â¡ï¸ Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? â¡ï¸ Please close.\n* Did the author lose interest or time to work on this? â¡ï¸ Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
      "created_at" : "2023-03-01T00:34:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1449135031",
      "id" : 1449135031,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585WYAu3",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1449135031/reactions"
      },
      "updated_at" : "2023-03-01T00:34:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1449135031",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--13523179cfe9479db18ec6c5d236f789-->\nThere hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? â¡ï¸ Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? â¡ï¸ Please close.\n* Did the author lose interest or time to work on this? â¡ï¸ Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
      "created_at" : "2023-05-30T01:10:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1567638094",
      "id" : 1567638094,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585dcEJO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1567638094/reactions"
      },
      "updated_at" : "2023-05-30T01:10:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1567638094",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--13523179cfe9479db18ec6c5d236f789-->\nThere hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? â¡ï¸ Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? â¡ï¸ Please close.\n* Did the author lose interest or time to work on this? â¡ï¸ Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
      "created_at" : "2023-08-29T00:34:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1696603886",
      "id" : 1696603886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585lIB7u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1696603886/reactions"
      },
      "updated_at" : "2023-08-29T00:34:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1696603886",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-11-28T12:44:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21515#issuecomment-1829770889",
      "id" : 1829770889,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21515",
      "node_id" : "IC_kwDOABII585tEBaJ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1829770889/reactions"
      },
      "updated_at" : "2023-11-28T12:44:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1829770889",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
