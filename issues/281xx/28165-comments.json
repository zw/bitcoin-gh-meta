[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1658115391), [jonatack](https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1662963276), [theStack](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1566293438), [vincenzopalazzo](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1575433253), [mzumsande](https://github.com/bitcoin/bitcoin/pull/28165#pullrequestreview-1573562580) |\n| Stale ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1683968332) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2023-07-26T20:04:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1652418427",
      "id" : 1652418427,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585ifed7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1652418427/reactions"
      },
      "updated_at" : "2023-08-18T14:04:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1652418427",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\n> Merging the two means a future V2Transport can handle all this interaction without callers needing to be aware.\r\n\r\nð",
      "created_at" : "2023-07-31T10:41:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1658115391",
      "id" : 1658115391,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585i1NU_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1658115391/reactions"
      },
      "updated_at" : "2023-07-31T10:41:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1658115391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2023-08-02T21:04:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1662963276",
      "id" : 1662963276,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585jHs5M",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662963276/reactions"
      },
      "updated_at" : "2023-08-02T21:04:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662963276",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283037011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283037011"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c7720844a4357aa497362fd5b481bc1a9c27687d: I assume this separation of `CompleteInternal()` is because `EXCLUSIVE_LOCKS_REQUIRED` is only set for `V1Transport` rather than on `Transport`?",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T11:03:06Z",
      "diff_hunk" : "@@ -306,29 +307,38 @@ class V1Transport final : public Transport\n         hasher.Reset();\n     }\n \n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283037011",
      "id" : 1283037011,
      "line" : 331,
      "node_id" : "PRRC_kwDOABII585MeZdT",
      "original_commit_id" : "c7720844a4357aa497362fd5b481bc1a9c27687d",
      "original_line" : 310,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 114,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283037011/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283037011",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283084032"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283084032"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463 this `LOCK` should have been moved in the previous commit. Otherwise it gives a thread safety warning.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T11:48:42Z",
      "diff_hunk" : "@@ -783,6 +783,8 @@ CNetMessage V1Transport::GetMessage(const std::chrono::microseconds time, bool&\n {\n     // Initialize out parameter\n     reject_message = false;\n+\n+    LOCK(m_cs_recv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283084032",
      "id" : 1283084032,
      "line" : 804,
      "node_id" : "PRRC_kwDOABII585Mek8A",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 787,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 99,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283084032/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283084032",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283202700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283202700"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: `NoPendingSend()` ? That makes it more clear this method doesn't mark something done. Also it applies before the first message too.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T13:25:31Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283202700",
      "id" : 1283202700,
      "line" : 282,
      "node_id" : "PRRC_kwDOABII585MfB6M",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 279,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 46,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283202700/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283202700",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283265993"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283265993"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: this new `assert` and the one below had me a bit worried, but they disappear in 68e48a0185751d24eecb194b8efd7028c8b590f3.\r\n\r\nI think they're ok here though:\r\n\r\n1. The very first message it's trivially clear this won't be a problem: `m_sending_header` starts out `false`, `m_bytes_sent` at `0` and `m_message_to_send.data` is initialised empty.\r\n2. `MarkBytesSent` sets these things back when (exactly) all bytes have been put in the send buffer (`vSendMsg`). In v1 this is always the case after the second (header only) or third call to `GetBytesToSend()`, after which we leave the while loop.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:11:11Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283265993",
      "id" : 1283265993,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MfRXJ",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2919,
      "original_position" : 98,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283265993/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:09:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283265993",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283288152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283288152"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: could add a comment here:\r\n\r\n```cpp\r\n// In v1 transport GetBytesToSend first returns a header and next the data (if any).\r\n```",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:26:56Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283288152",
      "id" : 1283288152,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MfWxY",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2922,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283288152/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283288152",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283297036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283297036"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: Since we're notifying two different things about these sent bytes - and also setting `nSendSize` - I suggested some extra comments...\r\n\r\n```cpp\r\n// Update statistics per message type\r\n```",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:32:34Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283297036",
      "id" : 1283297036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MfY8M",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2924,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283297036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283297036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283298309"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283298309"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463\r\n\r\n```cpp\r\n// Notify Transport that bytes have been processed\r\n```\r\n",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:33:28Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());\n+            pnode->nSendSize += bytes.size();\n+            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283298309",
      "id" : 1283298309,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MfZQF",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2928,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283298309/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283298309",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283301879"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283301879"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463\r\n\r\n```cpp\r\n// Update bytes in send buffer\r\n```\r\n\r\n(becomes \"Update memory use of send buffer\" in the next commit)",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:36:03Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283301879",
      "id" : 1283301879,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585MfaH3",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2925,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283301879/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283301879",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283305145"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283305145"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463: could we just assume bytes will get sent this if `GetBytesToSend()` has been called? Afaik there's no way to handle a failure anyway. But I guess it's safer to track it explicitly.\r\n\r\nUpdate: in 68e48a0185751d24eecb194b8efd7028c8b590f3 this function becomes more important, and is used to track when not all bytes are sent.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:38:24Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;\n+    /** Set a message to send (only allowed if DoneSendingMessage()). */\n+    virtual void SetMessageToSend(CSerializedNetMsg&& msg) noexcept = 0;\n+    /** Whether there are bytes to send on the wire. */\n+    virtual bool HaveBytesToSend() const noexcept = 0;\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t>: span of bytes to be sent over the wire (empty if !HaveBytesToSend())\n+     *  - bool: whether more bytes to be sent follow after the ones in the span have been sent\n+     *  - const std::string&: message type on behalf of which this is being sent (or \"\" if n/a)\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+    /** Get bytes to send on the wire. */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+    /** Report how many bytes returned by GetBytesToSend() have been sent. No effect if 0. */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283305145",
      "id" : 1283305145,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585Mfa65",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 293,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 60,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283305145/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:12:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283305145",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283320253"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283320253"
         }
      },
      "author_association" : "MEMBER",
      "body" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463 this `reserve` wasn't useful?",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T14:49:03Z",
      "diff_hunk" : "@@ -827,8 +834,46 @@ void V1Transport::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsign\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283320253",
      "id" : 1283320253,
      "line" : 829,
      "node_id" : "PRRC_kwDOABII585Mfem9",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 830,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 125,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283320253/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283320253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283352376"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283352376"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1937a5fcf795149c44b7f4f016c05000ac3adaf9  Isn't `>m_transport->GetSendMemoryUsage()` 0 since we just sent the message and cleared it?\r\n\r\n(but that changes in the next commit 68e48a0185751d24eecb194b8efd7028c8b590f3)",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T15:13:16Z",
      "diff_hunk" : "@@ -2923,11 +2940,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n             const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n             if (bytes.empty()) break;\n             pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->nSendSize += bytes.size();\n-            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n             pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n+            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n             pnode->m_transport->MarkBytesSent(bytes.size());\n         }\n+        if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283352376",
      "id" : 1283352376,
      "line" : 2951,
      "node_id" : "PRRC_kwDOABII585Mfmc4",
      "original_commit_id" : "1937a5fcf795149c44b7f4f016c05000ac3adaf9",
      "original_line" : 2947,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 300,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283352376/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283352376",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283416754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283416754"
         }
      },
      "author_association" : "MEMBER",
      "body" : "68e48a0185751d24eecb194b8efd7028c8b590f3: this is much readable than the intermediate calculation introduced in 1937a5fcf795149c44b7f4f016c05000ac3adaf9. It might be worth moving that commit after here.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T16:03:02Z",
      "diff_hunk" : "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283416754",
      "id" : 1283416754,
      "line" : 2949,
      "node_id" : "PRRC_kwDOABII585Mf2Ky",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 2941,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 298,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283416754/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283416754",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283427444"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283427444"
         }
      },
      "author_association" : "MEMBER",
      "body" : "68e48a0185751d24eecb194b8efd7028c8b590f3: This could be a good time to document what optimistic send actually is. From 1817398b397afebcc857c40a16d201c84878cb89:\r\n\r\n```cpp\r\n// Because the poll/select loop may pause for 100msec before actually doing a\r\n// send, and we have no way to force the loop awake, try sending from the calling\r\n// thread if the queue is empty.\r\n```\r\n\r\nOr shorter: `// which avoids a delay of up to SELECT_TIMEOUT_MILLISECONDS.`\r\n",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T16:12:01Z",
      "diff_hunk" : "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();\n+        pnode->vSendMsg.push_back(std::move(msg));\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\n \n-        assert(pnode->m_transport->DoneSendingMessage());\n-\n         // If write queue empty, attempt \"optimistic write\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283427444",
      "id" : 1283427444,
      "line" : 2953,
      "node_id" : "PRRC_kwDOABII585Mf4x0",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 2945,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 302,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283427444/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283427444",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283440338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283440338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "68e48a0185751d24eecb194b8efd7028c8b590f3 Is the above comment still correct? \"As this only happens when optimistic write failed\"",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T16:23:16Z",
      "diff_hunk" : "@@ -1298,7 +1301,9 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n         bool select_send;\n         {\n             LOCK(pnode->cs_vSend);\n-            select_send = !pnode->vSendMsg.empty();\n+            // This relies on optimistic send to make sure the transport always has a message to\n+            // send if there are any.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283440338",
      "id" : 1283440338,
      "line" : 1313,
      "node_id" : "PRRC_kwDOABII585Mf77S",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 1305,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 261,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283440338/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283440338",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283461349"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283461349"
         }
      },
      "author_association" : "MEMBER",
      "body" : "68e48a0185751d24eecb194b8efd7028c8b590f3\r\n\r\n```cpp\r\n// Leave message in the transport for when the socket is available.\r\n// v2 transport would also require waiting for the handshake to complete\r\n```\r\n\r\nWith v2 I assume we can't even call `GetBytesToSend` before the handshake?",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T16:41:56Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283461349",
      "id" : 1283461349,
      "line" : 921,
      "node_id" : "PRRC_kwDOABII585MgBDl",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 913,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 198,
      "pull_request_review_id" : 1560842698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283461349/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T17:07:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283461349",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283605312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283605312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We can - In fact the handshake itself is sent this way (that's the nice part about this abstraction, the caller doesn't know or care whether bytes being sent are on behalf of a message we're trying to send or something else).",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T19:02:32Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283605312",
      "id" : 1283605312,
      "in_reply_to_id" : 1283461349,
      "line" : 921,
      "node_id" : "PRRC_kwDOABII585MgkNA",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 913,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 198,
      "pull_request_review_id" : 1561694994,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283605312/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T19:02:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283605312",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283606280"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283606280"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, it should be 0 at this point, but that won't remain with the next commit. A temporary explanation message could be added to explain that here.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T19:03:41Z",
      "diff_hunk" : "@@ -2923,11 +2940,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n             const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n             if (bytes.empty()) break;\n             pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->nSendSize += bytes.size();\n-            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n             pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n+            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n             pnode->m_transport->MarkBytesSent(bytes.size());\n         }\n+        if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283606280",
      "id" : 1283606280,
      "in_reply_to_id" : 1283352376,
      "line" : 2951,
      "node_id" : "PRRC_kwDOABII585MgkcI",
      "original_commit_id" : "1937a5fcf795149c44b7f4f016c05000ac3adaf9",
      "original_line" : 2947,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 300,
      "pull_request_review_id" : 1561696448,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283606280/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T19:03:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283606280",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283610490"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283610490"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's because I don't want a recursive lock, and I'm introducing a caller of `CompleteInternal()` that already holds `m_cs_recv`.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T19:08:23Z",
      "diff_hunk" : "@@ -306,29 +307,38 @@ class V1Transport final : public Transport\n         hasher.Reset();\n     }\n \n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283610490",
      "id" : 1283610490,
      "in_reply_to_id" : 1283037011,
      "line" : 331,
      "node_id" : "PRRC_kwDOABII585Mgld6",
      "original_commit_id" : "c7720844a4357aa497362fd5b481bc1a9c27687d",
      "original_line" : 310,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 114,
      "pull_request_review_id" : 1561702502,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283610490/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T19:08:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283610490",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283633525"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283633525"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In general, it's true that the new sending interface is overly complicated for how it is used initially, and then it only becomes apparent in the next commit. \r\n\r\nHere specifically, indeed, everything returned by `GetBytesToSend` is initially always marked sent, but in the next commit that changes, as the buffering responsibility is moved from `vSendMsg` to `m_transport`. I'm happy to add (possibly temporary) comments to explain what's happening.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T19:29:45Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;\n+    /** Set a message to send (only allowed if DoneSendingMessage()). */\n+    virtual void SetMessageToSend(CSerializedNetMsg&& msg) noexcept = 0;\n+    /** Whether there are bytes to send on the wire. */\n+    virtual bool HaveBytesToSend() const noexcept = 0;\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t>: span of bytes to be sent over the wire (empty if !HaveBytesToSend())\n+     *  - bool: whether more bytes to be sent follow after the ones in the span have been sent\n+     *  - const std::string&: message type on behalf of which this is being sent (or \"\" if n/a)\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+    /** Get bytes to send on the wire. */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+    /** Report how many bytes returned by GetBytesToSend() have been sent. No effect if 0. */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283633525",
      "id" : 1283633525,
      "in_reply_to_id" : 1283305145,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585MgrF1",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 293,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 60,
      "pull_request_review_id" : 1561737078,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283633525/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T19:29:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283633525",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283660977"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283660977"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't reordering works without (even) more intermediary complexity. The issue is \"net: move message serialization from PushMessage to SocketSendData\" changes the data type of `vSendMsg` from bytes-to-be-sent to messages-to-be-sent, and the latter just don't have a known size-on-the-wire (unless an additional API to transports is added for that, or hardcoding the V1 message encoding size rules). That's why this PR first changes the notion of send buffer size: the old notion just doesn't really make sense anymore after the buffer changes introduced here.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T20:00:47Z",
      "diff_hunk" : "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283660977",
      "id" : 1283660977,
      "in_reply_to_id" : 1283416754,
      "line" : 2949,
      "node_id" : "PRRC_kwDOABII585Mgxyx",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 2941,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 298,
      "pull_request_review_id" : 1561776670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283660977/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T20:00:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283660977",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283674053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283674053"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, that name would be confusing for V2, where it's possible that there is no pending message, but also no message can be provided (yet) because the handshake has not completed.\r\n\r\nPerhaps `CanSetNewMessageToSend()` is better? (let the bikesheddening begin!)",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-03T20:15:35Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283674053",
      "id" : 1283674053,
      "in_reply_to_id" : 1283202700,
      "line" : 282,
      "node_id" : "PRRC_kwDOABII585Mg0_F",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 279,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 46,
      "pull_request_review_id" : 1561795385,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283674053/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-03T20:15:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283674053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> https://github.com/bitcoin/bitcoin/commit/68e48a0185751d24eecb194b8efd7028c8b590f3: can you elaborate a bit in the commit description why nSendOffset can be dropped?\r\n\r\nIn the current codebase, the send buffering (= remembering the to-be-sent bytes which we haven't managed to send yet) is done using `vSendMsg` (a queue of *byte arrays*) + `nSendOffset` (the position within `vSendMsg[0]` up to where we've sent things). After this PR, `vSendMsg` is turned into a queue of *messages*, which have not yet been converted to bytes-on-the-wire; this conversion is now handled by `m_transport`, and it's the transport that remembers what/how much has been sent yet.",
      "created_at" : "2023-08-03T21:09:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1664651486",
      "id" : 1664651486,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585jOJDe",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1664651486/reactions"
      },
      "updated_at" : "2023-08-03T21:10:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1664651486",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1284194811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284194811"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess it's not entirely clear to me whose responsibility it is to ensure the handshake has been done: https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1283674053 (I assume it will be in the main PR)",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-04T09:22:28Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1284194811",
      "id" : 1284194811,
      "in_reply_to_id" : 1283461349,
      "line" : 921,
      "node_id" : "PRRC_kwDOABII585Mi0H7",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 913,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 198,
      "pull_request_review_id" : 1562506904,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284194811/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-04T09:22:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284194811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1284382381"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284382381"
         }
      },
      "author_association" : "MEMBER",
      "body" : "My view is that anything that is different between v1 and v2 connections ought to be handled by the respective transport class.\n\nIn V2 there are multiple stages a connection goes through (pubkey, garbage+terminator, garbage authentication packet, version negotiation packet, and finally application data during which bitcoin P2P messages can be sent); this will be implemented using a finite state machine on sender and receiver side to control what state we are in. Only during the last phase (application data) can `SetMessageToSend` be called.\n\n`GetBytesToSend` can always be called. If there is nothing to send, it'll return empty. If there is, (at least) some part of it will be returned.\n* For V1, `GetBytesToSend()` is non-empty whenever there is a header or a payload to be sent.\n* For V2, `GetBytesToSend()` is non-empty whenever there are handshake bytes (pubkey, garbage, garbage auth, version packet) or an application packet (encoding a message) to be sent.",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-04T12:50:49Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1284382381",
      "id" : 1284382381,
      "in_reply_to_id" : 1283461349,
      "line" : 921,
      "node_id" : "PRRC_kwDOABII585Mjh6t",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 913,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 198,
      "pull_request_review_id" : 1562808679,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284382381/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-04T14:14:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1284382381",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1286479195"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286479195"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "FWIW, I agree that the `Done` prefix of the method name is quite confusing, for both the reasons Sjors lined out. `CanSetNewMessageToSend()` sounds much better to me (maybe even just `CanSetMessageToSend`, to have the full name of the method included which can be called if `true` is returned?).",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-08T00:08:50Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1286479195",
      "id" : 1286479195,
      "in_reply_to_id" : 1283202700,
      "line" : 282,
      "node_id" : "PRRC_kwDOABII585Mrh1b",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 279,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 46,
      "pull_request_review_id" : 1566293059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286479195/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-08T00:08:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1286479195",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1291310726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291310726"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit 8f5c65a464b7ed47939a055a4b65286d20a5b126:\r\nCould rename to `Complete()` to `DeserComplete()`, `DoneReceivingMessage()` or somthing similar to make it clearer that this function refers to deserialization side, now that both direction are in one class.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-11T12:59:29Z",
      "diff_hunk" : "@@ -253,24 +253,31 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload). Callers must guarantee that none of these\n+    // functions are called concurrently w.r.t. one another.\n+\n     // returns true if the current deserialization is complete\n     virtual bool Complete() const = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1291310726",
      "id" : 1291310726,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585M99aG",
      "original_commit_id" : "8f5c65a464b7ed47939a055a4b65286d20a5b126",
      "original_line" : 266,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1573562580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291310726/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-14T18:19:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291310726",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1292498404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292498404"
         }
      },
      "author_association" : "NONE",
      "body" : "Mh looks like that `header` is no longer used?",
      "commit_id" : "b7a7ed70d06ab3f994ff58e3a0c99105ee88ab6e",
      "created_at" : "2023-08-12T21:20:11Z",
      "diff_hunk" : "@@ -827,8 +834,46 @@ void V1Transport::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsign\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1292498404",
      "id" : 1292498404,
      "in_reply_to_id" : 1283320253,
      "line" : 829,
      "node_id" : "PRRC_kwDOABII585NCfXk",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 830,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 125,
      "pull_request_review_id" : 1575430346,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292498404/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-12T21:20:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292498404",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/17150045?v=4",
         "events_url" : "https://api.github.com/users/vincenzopalazzo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vincenzopalazzo/followers",
         "following_url" : "https://api.github.com/users/vincenzopalazzo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vincenzopalazzo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vincenzopalazzo",
         "id" : 17150045,
         "login" : "vincenzopalazzo",
         "node_id" : "MDQ6VXNlcjE3MTUwMDQ1",
         "organizations_url" : "https://api.github.com/users/vincenzopalazzo/orgs",
         "received_events_url" : "https://api.github.com/users/vincenzopalazzo/received_events",
         "repos_url" : "https://api.github.com/users/vincenzopalazzo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vincenzopalazzo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vincenzopalazzo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vincenzopalazzo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1292945676"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292945676"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The `header` argument no longer exists (as the caller doesn't have any notion of headers anymore, that's local to the transport implementation). Instead there is an `m_header_to_send` variable, but it's reused across messages, so (repeated) reserving makes no sense.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-14T03:49:59Z",
      "diff_hunk" : "@@ -827,8 +834,46 @@ void V1Transport::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsign\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1292945676",
      "id" : 1292945676,
      "in_reply_to_id" : 1283320253,
      "line" : 832,
      "node_id" : "PRRC_kwDOABII585NEMkM",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 832,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 131,
      "pull_request_review_id" : 1576023745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292945676/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-14T03:50:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1292945676",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1293749015"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293749015"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why the second condition within the context of this unit test - It's not like it could have sent the message partially before? (same for the other Check below)",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-14T17:12:15Z",
      "diff_hunk" : "@@ -87,8 +87,15 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     {\n         LOCK(dummyNode1.cs_vSend);\n-        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        BOOST_CHECK(!dummyNode1.vSendMsg.empty() || dummyNode1.m_transport->HaveBytesToSend());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1293749015",
      "id" : 1293749015,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NHQsX",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 90,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/test/denialofservice_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1573562580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293749015/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-14T18:19:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293749015",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1293814156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293814156"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems confusing and not ideal that a function called `ReceiveMsgFrom` has so much code dealing with the Send part, and also the side effect of flushing the send message buffer, when the goal is just to create a header for `ser_msg` to be able to receive that, but not to send anything. For example, it should be possible to call `ReceiveMsgFrom` in situations where the send buffer has unrelated contents. Maybe it'd be better to just have the relevant code (i.e. the old `prepareForTransport` duplicated here to extract the header instead of changing the send parts of `m_transport`?)",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-14T18:15:12Z",
      "diff_hunk" : "@@ -72,6 +72,12 @@ void ConnmanTestMsg::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_by\n \n bool ConnmanTestMsg::ReceiveMsgFrom(CNode& node, CSerializedNetMsg&& ser_msg) const\n {\n+    /* Flush out any unsent bytes from previous messages. */\n+    while (node.m_transport->HaveBytesToSend()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1293814156",
      "id" : 1293814156,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NHgmM",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 76,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/test/util/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1573562580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293814156/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-14T18:19:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293814156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208216"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208216"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:29:10Z",
      "diff_hunk" : "@@ -783,6 +783,8 @@ CNetMessage V1Transport::GetMessage(const std::chrono::microseconds time, bool&\n {\n     // Initialize out parameter\n     reject_message = false;\n+\n+    LOCK(m_cs_recv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208216",
      "id" : 1295208216,
      "in_reply_to_id" : 1283084032,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM08Y",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 787,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579558676,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208216/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:29:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208216",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208716"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've made some significant changes to the code, and `DoneSendingMessage` is now gone: instead the caller just tries `SetMessageToSend`, and it'll fail if the message can't be set. This avoids a virtual function call in some cases, doing both at once.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:30:04Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208716",
      "id" : 1295208716,
      "in_reply_to_id" : 1283202700,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1EM",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 279,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1579559347,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 2,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208716/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:30:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208716",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`DoneSendingMessage` is gone.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:30:23Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208895",
      "id" : 1295208895,
      "in_reply_to_id" : 1283265993,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1G_",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2919,
      "original_position" : 98,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579559594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208895/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:30:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208988"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208988"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a comment to this effect.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:30:36Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295208988",
      "id" : 1295208988,
      "in_reply_to_id" : 1283288152,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1Ic",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2922,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579559734,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208988/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:30:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295208988",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209060"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209060"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:30:45Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209060",
      "id" : 1295209060,
      "in_reply_to_id" : 1283297036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1Jk",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2924,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579559831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209060/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:30:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209060",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209148"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209148"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:30:52Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());\n+            pnode->nSendSize += bytes.size();\n+            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209148",
      "id" : 1295209148,
      "in_reply_to_id" : 1283298309,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1K8",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2928,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579559914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209148/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:30:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209148",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209305"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209305"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (and also updated the one in the next commit).",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:31:07Z",
      "diff_hunk" : "@@ -2866,23 +2911,25 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n         bool optimisticSend(pnode->vSendMsg.empty());\n \n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n+        assert(pnode->m_transport->DoneSendingMessage());\n+        pnode->m_transport->SetMessageToSend(std::move(msg));\n+\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n+            if (bytes.empty()) break;\n+            pnode->AccountForSentBytes(msg_type, bytes.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209305",
      "id" : 1295209305,
      "in_reply_to_id" : 1283301879,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1NZ",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 2925,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579560120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209305/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:31:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209305",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209655"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added some more comments in various places hopefully addresses this complexity, foreshadowing that some added code will be removed in a future commit.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:31:46Z",
      "diff_hunk" : "@@ -271,10 +271,26 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n-\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+    // Callers must guarantee that none of these functions are called concurrently w.r.t. one\n+    // another.\n+\n+    /** Whether the last provided message has been sent, and a new one can be provided. */\n+    virtual bool DoneSendingMessage() const noexcept = 0;\n+    /** Set a message to send (only allowed if DoneSendingMessage()). */\n+    virtual void SetMessageToSend(CSerializedNetMsg&& msg) noexcept = 0;\n+    /** Whether there are bytes to send on the wire. */\n+    virtual bool HaveBytesToSend() const noexcept = 0;\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t>: span of bytes to be sent over the wire (empty if !HaveBytesToSend())\n+     *  - bool: whether more bytes to be sent follow after the ones in the span have been sent\n+     *  - const std::string&: message type on behalf of which this is being sent (or \"\" if n/a)\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+    /** Get bytes to send on the wire. */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+    /** Report how many bytes returned by GetBytesToSend() have been sent. No effect if 0. */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209655",
      "id" : 1295209655,
      "in_reply_to_id" : 1283305145,
      "line" : 331,
      "node_id" : "PRRC_kwDOABII585NM1S3",
      "original_commit_id" : "f97adbf3e93e89b1e8ce1dc212e84ac6b2879463",
      "original_line" : 331,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 100,
      "pull_request_review_id" : 1579560583,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209655/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:31:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209655",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209819"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209819"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a comment to explain this better.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:32:03Z",
      "diff_hunk" : "@@ -2923,11 +2940,11 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n             const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n             if (bytes.empty()) break;\n             pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->nSendSize += bytes.size();\n-            if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n             pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n+            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n             pnode->m_transport->MarkBytesSent(bytes.size());\n         }\n+        if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209819",
      "id" : 1295209819,
      "in_reply_to_id" : 1283352376,
      "line" : 3014,
      "node_id" : "PRRC_kwDOABII585NM1Vb",
      "original_commit_id" : "1937a5fcf795149c44b7f4f016c05000ac3adaf9",
      "original_line" : 3014,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 320,
      "pull_request_review_id" : 1579560792,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209819/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:32:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209819",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209963"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not done yet; will do on a future push.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:32:21Z",
      "diff_hunk" : "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();\n+        pnode->vSendMsg.push_back(std::move(msg));\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\n \n-        assert(pnode->m_transport->DoneSendingMessage());\n-\n         // If write queue empty, attempt \"optimistic write\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295209963",
      "id" : 1295209963,
      "in_reply_to_id" : 1283427444,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1Xr",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 2945,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579561007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209963/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:32:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295209963",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295210296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210296"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The comment is gone (due to significant changes; the code also works differently now).",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:32:58Z",
      "diff_hunk" : "@@ -1298,7 +1301,9 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n         bool select_send;\n         {\n             LOCK(pnode->cs_vSend);\n-            select_send = !pnode->vSendMsg.empty();\n+            // This relies on optimistic send to make sure the transport always has a message to\n+            // send if there are any.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295210296",
      "id" : 1295210296,
      "in_reply_to_id" : 1283440338,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1c4",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 1305,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579561468,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210296/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:32:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295210753"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210753"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I haven't added a comment here as I'm not entirely sure under what scenarios `if (!node.m_sock)` triggers; it's code that existed beforehand, and is untouched by this PR.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:33:48Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295210753",
      "id" : 1295210753,
      "in_reply_to_id" : 1283461349,
      "line" : 938,
      "node_id" : "PRRC_kwDOABII585NM1kB",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 938,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 217,
      "pull_request_review_id" : 1579562084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210753/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295210753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295211040"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211040"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a commit that renames all receive-side functions to have \"Receive\" somewhere in the name.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:34:24Z",
      "diff_hunk" : "@@ -253,24 +253,31 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload). Callers must guarantee that none of these\n+    // functions are called concurrently w.r.t. one another.\n+\n     // returns true if the current deserialization is complete\n     virtual bool Complete() const = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295211040",
      "id" : 1295211040,
      "in_reply_to_id" : 1291310726,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1og",
      "original_commit_id" : "8f5c65a464b7ed47939a055a4b65286d20a5b126",
      "original_line" : 266,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1579562475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211040/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:34:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211040",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295211509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It can be (and is), due to optimistic send logic triggering SocketSendData, which now moves `vSendMsg` objects into the transport.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:35:18Z",
      "diff_hunk" : "@@ -87,8 +87,15 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     {\n         LOCK(dummyNode1.cs_vSend);\n-        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        BOOST_CHECK(!dummyNode1.vSendMsg.empty() || dummyNode1.m_transport->HaveBytesToSend());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295211509",
      "id" : 1295211509,
      "in_reply_to_id" : 1293749015,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM1v1",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 90,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/test/denialofservice_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1579563131,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211509/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:35:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295211509",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295214603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295214603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's complicated. You're right that duplicating the old `prepareForTransport` here would work, but I feel that's not really the right approach, as it's kind of hiding what's really going on. It'd also be incompatible with a potential future upgrade to using v2 transports inside the affected unit and fuzz tests.\r\n\r\nWhat's really going on is that we're using the CNode's own *sending* infrastructure to construct bytes, which are then fed to the same CNode's *receive* infrastructure. But there is also \"normal\" non-test sending logic (e.g. sending of version/verack automatically) that uses the same sending infrastucture (however, failing as there is no real socket to send anything on). The flushing here was necessary to wipe the non-test messages that enter the same transport.\r\n\r\nI have for now tried to address your concern here by introducing a more explicit `FlushSendBuffer` call, and adding it where necessary to make tests pass, making it clear where and what is being flushed away, however I think the more proper solution would involve:\r\n* Somehow prevent the sending of non-test messages entirely in test connmans (rather that hacking them away after the fact).\r\n* Give the test connman dedicated per-receive-node send transports which are just used for the test messages sent there. That would make it compatible with v2 operation too.\r\n\r\nDoing those things here feel out of scope, though.\r\n\r\n",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-15T22:41:25Z",
      "diff_hunk" : "@@ -72,6 +72,12 @@ void ConnmanTestMsg::NodeReceiveMsgBytes(CNode& node, Span<const uint8_t> msg_by\n \n bool ConnmanTestMsg::ReceiveMsgFrom(CNode& node, CSerializedNetMsg&& ser_msg) const\n {\n+    /* Flush out any unsent bytes from previous messages. */\n+    while (node.m_transport->HaveBytesToSend()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295214603",
      "id" : 1295214603,
      "in_reply_to_id" : 1293814156,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NM2gL",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 76,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/test/util/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1579567550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295214603/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-15T22:48:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295214603",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've made some significant changes to this PR:\r\n* `DoneSendingMessage` is gone (the caller can just call `SetMessageToSend` directly, which will fail if nothing can be sent at that time).\r\n* `HaveBytesToSend` is gone (the caller can just call `GetBytesToSend`, which will report an empty span if nothing is to be sent).\r\n* `GetBytesToSend` now takes a `have_next_message` as input, which lets its prediction for whether there are more bytes to send afterwards be more accurate (letting it take into account a future `SetMessageToSend`). This prediction is also tested now, through an `Assume` in the net code directly, and inside the transport simulation fuzz test.\r\n* A lot more comments and documentation.\r\n* More sanity checks in the added fuzz test.",
      "created_at" : "2023-08-15T22:47:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1679726704",
      "id" : 1679726704,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585kHphw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1679726704/reactions"
      },
      "updated_at" : "2023-08-15T22:47:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1679726704",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295642780"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295642780"
         }
      },
      "author_association" : "MEMBER",
      "body" : "384c798cc3836558463e88ec7f563b236f50bf22\r\n\r\nThe `have_next_message` argument is confusing and seems contradictory to the goal of separating the bytes stream from messages.\r\n\r\n> It is set by the caller when they know they have\r\n>     * another message ready to send.\r\n\r\nIn this commit it's always `false`, so if we need it at all, maybe delay its introduction to 09972b518bed5809d37c79fb0ddef034dce27ba0? That's a better place to explain how it relates to setting `Sock::SEND` (if it can't be in its own commit).",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-16T09:40:02Z",
      "diff_hunk" : "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * The have_next_message value controls whether the \"more\" return value indicates more bytes to\n+     * be sent before (have_next_message=false) or after (have_next_message=true) a potential\n+     * SetMessageToSend immediately afterwards. It is set by the caller when they know they have\n+     * another message ready to send. The have_next_message argument only affects this \"more\"\n+     * return value and nothing else.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend(bool have_next_message) const noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295642780",
      "id" : 1295642780,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NOfCc",
      "original_commit_id" : "384c798cc3836558463e88ec7f563b236f50bf22",
      "original_line" : 306,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1580205899,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295642780/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-16T12:59:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295642780",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295649173"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295649173"
         }
      },
      "author_association" : "MEMBER",
      "body" : "384c798cc3836558463e88ec7f563b236f50bf22 could we annotate the tuple?\r\n\r\n```cpp\r\nstd::tuple<Span<const uint8_t> /*to_send*/, bool /*more*/, const std::string& /* m_type */>\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-16T09:45:31Z",
      "diff_hunk" : "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1295649173",
      "id" : 1295649173,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NOgmV",
      "original_commit_id" : "384c798cc3836558463e88ec7f563b236f50bf22",
      "original_line" : 292,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1580205899,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295649173/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-16T12:59:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1295649173",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296525115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525115"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-16T23:15:34Z",
      "diff_hunk" : "@@ -2931,23 +2936,12 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        assert(pnode->m_transport->DoneSendingMessage());\n-        pnode->m_transport->SetMessageToSend(std::move(msg));\n+        bool optimisticSend{pnode->vSendMsg.empty() && pnode->m_transport->DoneSendingMessage()};\n \n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n+        pnode->m_send_memusage += msg.GetMemoryUsage();\n+        pnode->vSendMsg.push_back(std::move(msg));\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\n \n-        assert(pnode->m_transport->DoneSendingMessage());\n-\n         // If write queue empty, attempt \"optimistic write\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296525115",
      "id" : 1296525115,
      "in_reply_to_id" : 1283427444,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NR2c7",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 2945,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1581555151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525115/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-16T23:15:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525115",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296525550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525550"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually just the second condition suffices (the entire expected message is moved to the transport). I've simplified the code accordingly.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-16T23:16:22Z",
      "diff_hunk" : "@@ -87,8 +87,15 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n \n     {\n         LOCK(dummyNode1.cs_vSend);\n-        BOOST_CHECK(dummyNode1.vSendMsg.size() > 0);\n+        BOOST_CHECK(!dummyNode1.vSendMsg.empty() || dummyNode1.m_transport->HaveBytesToSend());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296525550",
      "id" : 1296525550,
      "in_reply_to_id" : 1293749015,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NR2ju",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 90,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/test/denialofservice_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1581555848,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525550/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-16T23:16:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296525550",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296526306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296526306"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've moved the introduction of `have_next_message` to (a separate commit in) #28196, as it's not really necessary in this PR yet.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-16T23:17:22Z",
      "diff_hunk" : "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * The have_next_message value controls whether the \"more\" return value indicates more bytes to\n+     * be sent before (have_next_message=false) or after (have_next_message=true) a potential\n+     * SetMessageToSend immediately afterwards. It is set by the caller when they know they have\n+     * another message ready to send. The have_next_message argument only affects this \"more\"\n+     * return value and nothing else.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend(bool have_next_message) const noexcept = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296526306",
      "id" : 1296526306,
      "in_reply_to_id" : 1295642780,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NR2vi",
      "original_commit_id" : "384c798cc3836558463e88ec7f563b236f50bf22",
      "original_line" : 306,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1581557041,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296526306/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-16T23:17:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296526306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296528645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296528645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-16T23:22:34Z",
      "diff_hunk" : "@@ -270,10 +270,48 @@ class Transport {\n     // decomposes a message from the context\n     virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n \n-    // 2. Sending side functions:\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n \n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const = 0;\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<Span<const uint8_t>, bool, const std::string&>;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1296528645",
      "id" : 1296528645,
      "in_reply_to_id" : 1295649173,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NR3UF",
      "original_commit_id" : "384c798cc3836558463e88ec7f563b236f50bf22",
      "original_line" : 292,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1581560290,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296528645/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-16T23:22:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1296528645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297229209"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297229209"
         }
      },
      "author_association" : "MEMBER",
      "body" : "58cb50cdc60df5d7e42466213f213cf7ab54db45: IIUC in v1 `&& pnode->vSendMsg.empty()` is always `true` when `GetBytesToSend()` just told us there's nothing to send? But in v2 we might be waiting for a handshake.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-17T13:32:45Z",
      "diff_hunk" : "@@ -2989,42 +2999,19 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        const bool queue_was_empty{pnode->vSendMsg.empty()};\n-\n-        // Give the message to the transport, and add all bytes it wants us to send out as byte\n-        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n-        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n-        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n-        // will disappear.\n-        bool queued = pnode->m_transport->SetMessageToSend(msg);\n-        assert(queued);\n-        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n-        // and then the payload data (if any), necessitating a loop.\n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            // Update statistics per message type.\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            // Update memory usage of send buffer. For now, use static + dynamic memory usage of\n-            // byte vectors in vSendMsg as send memory. In a future commit, vSendMsg will be\n-            // replaced with a queue of CSerializedNetMsg objects, and we'll use their memory usage\n-            // instead.\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            // Notify transport that bytes have been processed (they're not actually sent yet,\n-            // but pushed onto the vSendMsg queue of bytes to send).\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n-        // At this point, m_transport->GetSendMemoryUsage() isn't very interesting as the\n-        // transport's message is fully flushed (and converted to byte arrays). It's still included\n-        // here for correctness, and will become relevant in a future commit when a queued message\n-        // inside the transport may survive PushMessage calls.\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297229209",
      "id" : 1297229209,
      "line" : 3010,
      "node_id" : "PRRC_kwDOABII585NUiWZ",
      "original_commit_id" : "58cb50cdc60df5d7e42466213f213cf7ab54db45",
      "original_line" : 3010,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 313,
      "pull_request_review_id" : 1582634664,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297229209/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-17T15:00:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297229209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297349342"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297349342"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think `!node.m_sock` can only happen when when we've disconnected in another thread, using `CloseSocketDisconnect()` (and during tests). That's also what the documentation of `m_sock_mutex` says. cc @vasild ",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-17T14:57:31Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297349342",
      "id" : 1297349342,
      "in_reply_to_id" : 1283461349,
      "line" : 938,
      "node_id" : "PRRC_kwDOABII585NU_re",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 938,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 217,
      "pull_request_review_id" : 1582634664,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297349342/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-17T15:00:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297349342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297598582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297598582"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe that's true, though only due to optimistic send itself (which guarantees that as soon as something is added to `vSendMsg`, it's immediately at least attempted to be moved to the transport). Without it, if there were two consecutive `PushMessage` without intervening `SocketSendData`, `vSendMsg` would already have something in it on the second one.\r\n\r\nBecause of that, I think it's more \"obviously correct\" to do the full check here.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-17T18:32:53Z",
      "diff_hunk" : "@@ -2989,42 +2999,19 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        const bool queue_was_empty{pnode->vSendMsg.empty()};\n-\n-        // Give the message to the transport, and add all bytes it wants us to send out as byte\n-        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n-        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n-        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n-        // will disappear.\n-        bool queued = pnode->m_transport->SetMessageToSend(msg);\n-        assert(queued);\n-        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n-        // and then the payload data (if any), necessitating a loop.\n-        while (true) {\n-            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();\n-            if (bytes.empty()) break;\n-            // Update statistics per message type.\n-            pnode->AccountForSentBytes(msg_type, bytes.size());\n-            pnode->vSendMsg.push_back({bytes.begin(), bytes.end()});\n-            // Update memory usage of send buffer. For now, use static + dynamic memory usage of\n-            // byte vectors in vSendMsg as send memory. In a future commit, vSendMsg will be\n-            // replaced with a queue of CSerializedNetMsg objects, and we'll use their memory usage\n-            // instead.\n-            pnode->m_send_memusage += sizeof(pnode->vSendMsg.back()) + memusage::DynamicUsage(pnode->vSendMsg.back());\n-            // Notify transport that bytes have been processed (they're not actually sent yet,\n-            // but pushed onto the vSendMsg queue of bytes to send).\n-            pnode->m_transport->MarkBytesSent(bytes.size());\n-        }\n-        // At this point, m_transport->GetSendMemoryUsage() isn't very interesting as the\n-        // transport's message is fully flushed (and converted to byte arrays). It's still included\n-        // here for correctness, and will become relevant in a future commit when a queued message\n-        // inside the transport may survive PushMessage calls.\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297598582",
      "id" : 1297598582,
      "in_reply_to_id" : 1297229209,
      "line" : 3010,
      "node_id" : "PRRC_kwDOABII585NV8h2",
      "original_commit_id" : "58cb50cdc60df5d7e42466213f213cf7ab54db45",
      "original_line" : 3010,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 313,
      "pull_request_review_id" : 1583240845,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297598582/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-17T18:32:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297598582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297627349"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297627349"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, so I think `!node.m_sock` only happens when the node is already disconnected, or will never actually be connected to anything (in tests). I've added the following comment:\r\n\r\n> There is no socket in case we've already disconnected, or in test cases without real connections. In these cases, we bail out immediately and just leave things in the send queue and transport.\r\n\r\nFurther up, above the `SetMessageToSend` call, I've added:\r\n\r\n> This fails when there is an existing message still being sent.\r\n\r\nwhich in #28196 is extended to say:\r\n\r\n> This fails when there is an existing message still being sent, or (for v2 transports) when the\r\nhandshake has not yet completed.\r\n\r\n",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-17T19:04:02Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1297627349",
      "id" : 1297627349,
      "in_reply_to_id" : 1283461349,
      "line" : 938,
      "node_id" : "PRRC_kwDOABII585NWDjV",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 938,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 217,
      "pull_request_review_id" : 1583287057,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297627349/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-17T19:04:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1297627349",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK 07cb6c4\r\n\r\nThe rebase on #27981 looks good to me. I didn't look at the fuzzer changes. Otherwise it's just some extra comments.",
      "created_at" : "2023-08-18T14:02:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1683968332",
      "id" : 1683968332,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585kX1FM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1683968332/reactions"
      },
      "updated_at" : "2023-08-18T14:02:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1683968332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updates since a few days ago:\r\n* Moved the introduction of the `have_next_message` argument of `GetBytesToSend`, and testing thereof, to #28196.\r\n* Rebased after merge of #27981 (sorry @Sjors, the earlier rebase was incorrect, it only looked at `vSendMsg.empty()` for the returned `data_left` in `SocketSendData()`).\r\n* Added a few more comments.\r\n* Some performance improvements to the fuzz test.\r\n",
      "created_at" : "2023-08-18T14:07:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#issuecomment-1683975067",
      "id" : 1683975067,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/28165",
      "node_id" : "IC_kwDOABII585kX2ub",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1683975067/reactions"
      },
      "updated_at" : "2023-08-18T14:07:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1683975067",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298700651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298700651"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8d1a91f6394f00b880613268a9f2f3164ef914e2: `data_left` is more consistent with the header",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-18T17:38:25Z",
      "diff_hunk" : "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298700651",
      "id" : 1298700651,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NaJlr",
      "original_commit_id" : "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "original_line" : 918,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1584963289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298700651/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-18T17:57:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298700651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298709287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298709287"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8d1a91f6394f00b880613268a9f2f3164ef914e2: IIUC even though `!node.vSendMsg.empty()`, we don't want `else { have_unsent_data = true }` here because:\r\n\r\n1. `SetMessageToSend` _may_ return `false` for other reasons (though afaik it can't at the moment)\r\n2. If it does return `false`, then `GetBytesToSend` below populates `data`, tries to send it and then updates `have_unsent_data` appropriately.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-18T17:49:13Z",
      "diff_hunk" : "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298709287",
      "id" : 1298709287,
      "line" : 928,
      "node_id" : "PRRC_kwDOABII585NaLsn",
      "original_commit_id" : "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "original_line" : 928,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 206,
      "pull_request_review_id" : 1584963289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298709287/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-18T17:57:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298709287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298710893"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298710893"
         }
      },
      "author_association" : "MEMBER",
      "body" : "8d1a91f6394f00b880613268a9f2f3164ef914e2: technically `have_unsent_data` should be set to `true` here, but since we just disconnected it doesn't matter.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-18T17:51:23Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298710893",
      "id" : 1298710893,
      "in_reply_to_id" : 1283461349,
      "line" : 938,
      "node_id" : "PRRC_kwDOABII585NaMFt",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 938,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 217,
      "pull_request_review_id" : 1584963289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298710893/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-18T17:57:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298710893",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298717971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298717971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Or perhaps something like `return {nSentSize, !message_queue_empty || !transport_empty};`",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-18T18:00:08Z",
      "diff_hunk" : "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298717971",
      "id" : 1298717971,
      "in_reply_to_id" : 1298700651,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NaN0T",
      "original_commit_id" : "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "original_line" : 918,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1584991522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298717971/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-18T18:10:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298717971",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299172882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299172882"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is it not possible to use a single transport here?",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-19T11:10:03Z",
      "diff_hunk" : "@@ -24,9 +25,10 @@ void initialize_p2p_transport_serialization()\n \n FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serialization)\n {\n-    // Construct deserializer, with a dummy NodeId\n-    V1TransportDeserializer deserializer{Params(), NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n-    V1TransportSerializer serializer{};\n+    // Construct transports for both sides, with dummy NodeIds.\n+    V1Transport recv_transport{NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n+    V1Transport send_transport{NodeId{1}, SER_NETWORK, INIT_PROTO_VERSION};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299172882",
      "id" : 1299172882,
      "line" : 39,
      "node_id" : "PRRC_kwDOABII585Nb84S",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 39,
      "original_position" : 17,
      "original_start_line" : 29,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 33,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299172882/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 38,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299172882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299174503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299174503"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Aren't mutexes supposed to be named like `m_foo_mutex`, rather than `m_cs_foo` in new code? I don't think there is written convention, feel free to ignore.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-19T11:26:09Z",
      "diff_hunk" : "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+\n+    /** Report how many bytes returned by the last GetBytesToSend() have been sent.\n+     *\n+     * bytes_sent cannot exceed to_send.size() of the last GetBytesToSend() result.\n+     *\n+     * If bytes_sent=0, this call has no effect.\n+     */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;\n+\n+    /** Return the memory usage of this transport attributable to buffered data to send. */\n+    virtual size_t GetSendMemoryUsage() const noexcept = 0;\n };\n \n-class V1TransportDeserializer final : public TransportDeserializer\n+class V1Transport final : public Transport\n {\n private:\n-    const CChainParams& m_chain_params;\n+    CMessageHeader::MessageStartChars m_magic_bytes;\n     const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n-\n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n-\n-    void Reset() {\n+    mutable Mutex m_cs_recv; //!< Lock for receive state",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299174503",
      "id" : 1299174503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nb9Rn",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 326,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299174503/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299174503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299175706"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299175706"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "According to `developer-notes.md` annotations in function declaration (`EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)`) should be combined with run-time asserts in function definitions (`AssertLockNotHeld(m_cs_recv)`). So, this code should be:\r\n\r\n```cpp\r\nvoid SetReceiveVersion(int nVersionIn) override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\r\n{\r\n    AssertLockNotHeld(m_cs_recv);\r\n    LOCK(m_cs_recv);\r\n```\r\n\r\nI opened https://github.com/bitcoin/bitcoin/pull/27116 to relax that since it is redundant.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-19T11:38:28Z",
      "diff_hunk" : "@@ -299,52 +348,55 @@ class V1TransportDeserializer final : public TransportDeserializer\n         hasher.Reset();\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)\n     {\n-        Reset();\n+        if (!in_data) return false;\n+        return hdr.nMessageSize == nDataPos;\n     }\n \n-    bool Complete() const override\n+    /** Lock for sending state. */\n+    mutable Mutex m_cs_send;\n+    /** The header of the message currently being sent. */\n+    std::vector<uint8_t> m_header_to_send GUARDED_BY(m_cs_send);\n+    /** The data of the message currently being sent. */\n+    CSerializedNetMsg m_message_to_send GUARDED_BY(m_cs_send);\n+    /** Whether we're currently sending header bytes or message bytes. */\n+    bool m_sending_header GUARDED_BY(m_cs_send) {false};\n+    /** How many bytes have been sent so far (from m_header_to_send, or from m_message_to_send.data). */\n+    size_t m_bytes_sent GUARDED_BY(m_cs_send) {0};\n+\n+public:\n+    V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept;\n+\n+    bool ReceivedMessageComplete() const override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        return WITH_LOCK(m_cs_recv, return CompleteInternal());\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+    void SetReceiveVersion(int nVersionIn) override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n+        LOCK(m_cs_recv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299175706",
      "id" : 1299175706,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nb9ka",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 378,
      "original_position" : 170,
      "original_start_line" : 376,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299175706/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299175706",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299189317"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299189317"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe mention something about the lifetime of `to_send` and `msg_type` since they refer to data inside the transport. IIRC will be invalidated by the next `SetMessageToSend()` call.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-19T13:55:37Z",
      "diff_hunk" : "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299189317",
      "id" : 1299189317,
      "line" : 309,
      "node_id" : "PRRC_kwDOABII585NcA5F",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 309,
      "original_position" : 63,
      "original_start_line" : 286,
      "path" : "src/net.h",
      "position" : 78,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299189317/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 299,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299189317",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299996446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299996446"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is unbounded copy. Maybe check that it will not cause buffer overflow? E.g.\r\n\r\n```cpp\r\n    const auto& src = Params().MessageStart();\r\n    const auto& src_begin = std::begin(src);                             \r\n    const auto& src_end = std::end(src);\r\n    assert(std::distance(src_begin, src_end) <= std::distance(std::begin(m_magic_bytes), std::end(m_magic_bytes)));\r\n    std::copy(src_begin, src_end, m_magic_bytes);\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T11:41:47Z",
      "diff_hunk" : "@@ -717,7 +726,15 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     return true;\n }\n \n-int V1TransportDeserializer::readHeader(Span<const uint8_t> msg_bytes)\n+V1Transport::V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept :\n+    m_node_id(node_id), hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn)\n+{\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_magic_bytes);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1299996446",
      "id" : 1299996446,
      "line" : 732,
      "node_id" : "PRRC_kwDOABII585NfF8e",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 732,
      "original_position" : 52,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 53,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299996446/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1299996446",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300286463"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300286463"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Will address when I retouch.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T15:29:45Z",
      "diff_hunk" : "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300286463",
      "id" : 1300286463,
      "in_reply_to_id" : 1298700651,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NgMv_",
      "original_commit_id" : "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "original_line" : 918,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1587284906,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300286463/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T15:29:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300286463",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300299930"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300299930"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n\r\n```suggestion\r\n    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\r\n    std::array<std::vector<uint8_t>, 2> in_flight;\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T15:41:08Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300299930",
      "id" : 1300299930,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NgQCa",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 119,
      "original_position" : 74,
      "original_start_line" : 110,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300299930/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300299930",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300311165"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300311165"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this some form of locale independent `isprint(3)`?\r\n\r\nIf the purpose is to generate random (including invalid) message types then why not just `provider.ConsumeBytesAsString(CMessageHeader::COMMAND_SIZE)`,  or if the purpose is to generate only valid message types, then pick a random value from `getAllNetMessageTypes()`?",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T15:50:20Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300311165",
      "id" : 1300311165,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NgSx9",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 130,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300311165/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300311165",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300343322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300343322"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T16:14:37Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300343322",
      "id" : 1300343322,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Ngaoa",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 266,
      "original_position" : 229,
      "original_start_line" : 265,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300343322/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300343322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300352209"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300352209"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Given that `side` is `0` or `1`, then `side >> 1` will always be `0`, no? Did you mean `code >> 1`? I find this less cryptic:\r\n\r\n```cpp\r\nsize_t side = provider.ConsumeBool();\r\nswitch (provider.ConsumeIntegralInRange(0, 2)) {\r\n    case 0: ...\r\n    case 1: ...\r\n    case 2: ...\r\n}",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T16:21:22Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300352209",
      "id" : 1300352209,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NgczR",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 270,
      "original_position" : 233,
      "original_start_line" : 269,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300352209/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300352209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300362306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300362306"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is there a reason to use pointers? The following seems to be simpler:\r\n\r\n```cpp\r\n    V1Transport t0{NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\r\n    V1Transport t1{NodeId{1}, SER_NETWORK, INIT_PROTO_VERSION};\r\n    SimulationTest(t0, t1, rng, provider);\r\n```\r\nand remove `MakeV1Transport()`?\r\n",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T16:30:05Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {\n+        // The other bits (mod 3) identify the operation:\n+        case 0:\n+            // (Try to) give the next message to the transport.\n+            new_msg_fn(side);\n+            break;\n+        case 1:\n+            // (Try to) send some bytes from the transport to the network.\n+            send_fn(side);\n+            break;\n+        case 2:\n+            // (Try to) receive bytes from the network, converting to messages.\n+            recv_fn(side);\n+            break;\n+        }\n+        ++iter;\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;\n+        if (send_fn(1, true)) any = true;\n+        if (recv_fn(0, true)) any = true;\n+        if (recv_fn(1, true)) any = true;\n+        if (!any) break;\n     }\n+\n+    // Make sure nothing is left in flight.\n+    assert(in_flight[0].empty());\n+    assert(in_flight[1].empty());\n+\n+    // Make sure all expected messages were received.\n+    assert(expected[0].empty());\n+    assert(expected[1].empty());\n+}\n+\n+std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n+{\n+    return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(p2p_transport_bidirectional, .init = initialize_p2p_transport_serialization)\n+{\n+    // Test with two V1 transports talking to each other.\n+    FuzzedDataProvider provider{buffer.data(), buffer.size()};\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>());\n+    auto t1 = MakeV1Transport(NodeId{0});\n+    auto t2 = MakeV1Transport(NodeId{1});\n+    if (!t1 || !t2) return;\n+    SimulationTest(*t1, *t2, rng, provider);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300362306",
      "id" : 1300362306,
      "line" : 330,
      "node_id" : "PRRC_kwDOABII585NgfRC",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 330,
      "original_position" : 286,
      "original_start_line" : 320,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 300,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300362306/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 327,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300362306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300365030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300365030"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The return value of `new_msg_fn()` is ignored by the caller.\r\n```suggestion\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T16:32:40Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300365030",
      "id" : 1300365030,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Ngf7m",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 191,
      "original_position" : 154,
      "original_start_line" : 190,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1585628948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300365030/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300365030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300421324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300421324"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe so, though I think it's cleaner to use two (the test isn't actually trying to model a node talking to itself).",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T17:13:05Z",
      "diff_hunk" : "@@ -24,9 +25,10 @@ void initialize_p2p_transport_serialization()\n \n FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serialization)\n {\n-    // Construct deserializer, with a dummy NodeId\n-    V1TransportDeserializer deserializer{Params(), NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n-    V1TransportSerializer serializer{};\n+    // Construct transports for both sides, with dummy NodeIds.\n+    V1Transport recv_transport{NodeId{0}, SER_NETWORK, INIT_PROTO_VERSION};\n+    V1Transport send_transport{NodeId{1}, SER_NETWORK, INIT_PROTO_VERSION};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300421324",
      "id" : 1300421324,
      "in_reply_to_id" : 1299172882,
      "line" : 39,
      "node_id" : "PRRC_kwDOABII585NgtrM",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 39,
      "original_position" : 17,
      "original_start_line" : 29,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 33,
      "pull_request_review_id" : 1587510023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300421324/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 38,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T17:13:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300421324",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300560292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300560292"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:33:11Z",
      "diff_hunk" : "@@ -906,36 +906,50 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool have_unsent_data{false};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300560292",
      "id" : 1300560292,
      "in_reply_to_id" : 1298700651,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhPmk",
      "original_commit_id" : "8d1a91f6394f00b880613268a9f2f3164ef914e2",
      "original_line" : 918,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1587727302,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300560292/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:33:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300560292",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300562912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300562912"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, renamed to `m_send_mutex` and `m_recv_mutex`.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:34:26Z",
      "diff_hunk" : "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     */\n+    virtual BytesToSend GetBytesToSend() const noexcept = 0;\n+\n+    /** Report how many bytes returned by the last GetBytesToSend() have been sent.\n+     *\n+     * bytes_sent cannot exceed to_send.size() of the last GetBytesToSend() result.\n+     *\n+     * If bytes_sent=0, this call has no effect.\n+     */\n+    virtual void MarkBytesSent(size_t bytes_sent) noexcept = 0;\n+\n+    /** Return the memory usage of this transport attributable to buffered data to send. */\n+    virtual size_t GetSendMemoryUsage() const noexcept = 0;\n };\n \n-class V1TransportDeserializer final : public TransportDeserializer\n+class V1Transport final : public Transport\n {\n private:\n-    const CChainParams& m_chain_params;\n+    CMessageHeader::MessageStartChars m_magic_bytes;\n     const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n-\n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n-\n-    void Reset() {\n+    mutable Mutex m_cs_recv; //!< Lock for receive state",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300562912",
      "id" : 1300562912,
      "in_reply_to_id" : 1299174503,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhQPg",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 326,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1587732122,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300562912/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:34:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300562912",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563521"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563521"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added `AssertLockHeld` and `AssertLockNotHeld` everywhere. It's easy to delete some of them later if #27116 would get accepted.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:35:06Z",
      "diff_hunk" : "@@ -299,52 +348,55 @@ class V1TransportDeserializer final : public TransportDeserializer\n         hasher.Reset();\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    bool CompleteInternal() const noexcept EXCLUSIVE_LOCKS_REQUIRED(m_cs_recv)\n     {\n-        Reset();\n+        if (!in_data) return false;\n+        return hdr.nMessageSize == nDataPos;\n     }\n \n-    bool Complete() const override\n+    /** Lock for sending state. */\n+    mutable Mutex m_cs_send;\n+    /** The header of the message currently being sent. */\n+    std::vector<uint8_t> m_header_to_send GUARDED_BY(m_cs_send);\n+    /** The data of the message currently being sent. */\n+    CSerializedNetMsg m_message_to_send GUARDED_BY(m_cs_send);\n+    /** Whether we're currently sending header bytes or message bytes. */\n+    bool m_sending_header GUARDED_BY(m_cs_send) {false};\n+    /** How many bytes have been sent so far (from m_header_to_send, or from m_message_to_send.data). */\n+    size_t m_bytes_sent GUARDED_BY(m_cs_send) {0};\n+\n+public:\n+    V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept;\n+\n+    bool ReceivedMessageComplete() const override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        return WITH_LOCK(m_cs_recv, return CompleteInternal());\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+    void SetReceiveVersion(int nVersionIn) override EXCLUSIVE_LOCKS_REQUIRED(!m_cs_recv)\n     {\n+        LOCK(m_cs_recv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563521",
      "id" : 1300563521,
      "in_reply_to_id" : 1299175706,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhQZB",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 378,
      "original_position" : 170,
      "original_start_line" : 376,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1587733048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563521/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:35:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563521",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563612"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563612"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:35:13Z",
      "diff_hunk" : "@@ -253,42 +256,88 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563612",
      "id" : 1300563612,
      "in_reply_to_id" : 1299189317,
      "line" : 309,
      "node_id" : "PRRC_kwDOABII585NhQac",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 309,
      "original_position" : 63,
      "original_start_line" : 286,
      "path" : "src/net.h",
      "position" : 78,
      "pull_request_review_id" : 1587733194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563612/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 299,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:35:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563612",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563987"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added an assertion equivalent to this.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:35:42Z",
      "diff_hunk" : "@@ -717,7 +726,15 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     return true;\n }\n \n-int V1TransportDeserializer::readHeader(Span<const uint8_t> msg_bytes)\n+V1Transport::V1Transport(const NodeId node_id, int nTypeIn, int nVersionIn) noexcept :\n+    m_node_id(node_id), hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn)\n+{\n+    std::copy(std::begin(Params().MessageStart()), std::end(Params().MessageStart()), m_magic_bytes);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300563987",
      "id" : 1300563987,
      "in_reply_to_id" : 1299996446,
      "line" : 732,
      "node_id" : "PRRC_kwDOABII585NhQgT",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 732,
      "original_position" : 52,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 53,
      "pull_request_review_id" : 1587733769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563987/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:35:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300563987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300564065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:35:48Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300564065",
      "id" : 1300564065,
      "in_reply_to_id" : 1300299930,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhQhh",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 119,
      "original_position" : 74,
      "original_start_line" : 110,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1587733919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564065/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:35:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564065",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300564947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, it's matching the message type validity criteria from `CMessageHeader::IsCommandValid()`.\r\n\r\nI've reworked this a bit (making it also select from valid messages, which is useful for a follow-up PR anyway), and added comments.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:36:56Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300564947",
      "id" : 1300564947,
      "in_reply_to_id" : 1300311165,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhQvT",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 130,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1587735388,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564947/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:36:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300564947",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300565046"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565046"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:37:03Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300565046",
      "id" : 1300565046,
      "in_reply_to_id" : 1300343322,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhQw2",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 266,
      "original_position" : 229,
      "original_start_line" : 265,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1587735534,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565046/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:37:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565046",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300565964"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565964"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ouch, that was a serious problem with the fuzz test.\r\n\r\nI've instead replaced it with\r\n\r\n```c++\r\n    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\r\n        CallOneOf(provider,\r\n            // (Try to) give the next message to the transport.\r\n            [&] { new_msg_fn(0); },\r\n            [&] { new_msg_fn(1); },\r\n            // (Try to) send some bytes from the transport to the network.\r\n            [&] { send_fn(0); },\r\n            [&] { send_fn(1); },\r\n            // (Try to) receive bytes from the network, converting to messages.\r\n            [&] { recv_fn(0); },\r\n            [&] { recv_fn(1); }\r\n        );\r\n    }\r\n```\r\n\r\nwhich is hopefully as clear as your suggestion, but doesn't waste 2 bytes of input to pick one of 6 values.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:38:08Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300565964",
      "id" : 1300565964,
      "in_reply_to_id" : 1300352209,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhQ_M",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 270,
      "original_position" : 233,
      "original_start_line" : 269,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1587737089,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565964/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:38:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300565964",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300567446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567446"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I could do that here, but the test gets extended in #28196 with versions that let a V1 transport talk to a V2, and a V2 to a V2 (see https://github.com/bitcoin/bitcoin/blob/b23b1d0700e0cffc0d0d2c624222142f211e04be/src/test/fuzz/p2p_transport_serialization.cpp#L377L408). For consistency, I think the code here is better, though if you want I can delay the introduction to that PR.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:40:01Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {\n+        // The other bits (mod 3) identify the operation:\n+        case 0:\n+            // (Try to) give the next message to the transport.\n+            new_msg_fn(side);\n+            break;\n+        case 1:\n+            // (Try to) send some bytes from the transport to the network.\n+            send_fn(side);\n+            break;\n+        case 2:\n+            // (Try to) receive bytes from the network, converting to messages.\n+            recv_fn(side);\n+            break;\n+        }\n+        ++iter;\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;\n+        if (send_fn(1, true)) any = true;\n+        if (recv_fn(0, true)) any = true;\n+        if (recv_fn(1, true)) any = true;\n+        if (!any) break;\n     }\n+\n+    // Make sure nothing is left in flight.\n+    assert(in_flight[0].empty());\n+    assert(in_flight[1].empty());\n+\n+    // Make sure all expected messages were received.\n+    assert(expected[0].empty());\n+    assert(expected[1].empty());\n+}\n+\n+std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n+{\n+    return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(p2p_transport_bidirectional, .init = initialize_p2p_transport_serialization)\n+{\n+    // Test with two V1 transports talking to each other.\n+    FuzzedDataProvider provider{buffer.data(), buffer.size()};\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>());\n+    auto t1 = MakeV1Transport(NodeId{0});\n+    auto t2 = MakeV1Transport(NodeId{1});\n+    if (!t1 || !t2) return;\n+    SimulationTest(*t1, *t2, rng, provider);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300567446",
      "id" : 1300567446,
      "in_reply_to_id" : 1300362306,
      "line" : 330,
      "node_id" : "PRRC_kwDOABII585NhRWW",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 330,
      "original_position" : 286,
      "original_start_line" : 320,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 300,
      "pull_request_review_id" : 1587739350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567446/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 327,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:54:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567446",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300567550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567550"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-21T19:40:08Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1300567550",
      "id" : 1300567550,
      "in_reply_to_id" : 1300365030,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NhRX-",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 191,
      "original_position" : 154,
      "original_start_line" : 190,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1587739495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567550/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-21T19:40:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1300567550",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301151636"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301151636"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, if `CNode::m_sock` is empty `shared_ptr`, that means `CNode::CloseSocketDisconnect()` has been called and this is a one-way street, it is not coming back, so all communication structs and data for this peer can be dropped.\r\n\r\nOr, during tests an empty `shared_ptr` may be supplied to the `CNode` constructor. My understanding is that in those tests the code that uses the socket is not supposed to be reached/executed. Other tests provide a mocked socket, that returns either fuzzed data or static/hardcoded contents upon read in order to entertain the code that receives from the socket.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T07:30:45Z",
      "diff_hunk" : "@@ -897,37 +897,39 @@ size_t CConnman::SocketSendData(CNode& node) const\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n \n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    while (true) {\n+        bool progress = false;\n+        if (it != node.vSendMsg.end() && node.m_transport->DoneSendingMessage()) {\n+            // If possible, move one message from the send queue to the transport.\n+            node.m_send_memusage -= it->GetMemoryUsage();\n+            node.m_transport->SetMessageToSend(std::move(*it));\n+            ++it;\n+            progress = true;\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n             if (!node.m_sock) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301151636",
      "id" : 1301151636,
      "in_reply_to_id" : 1283461349,
      "line" : 938,
      "node_id" : "PRRC_kwDOABII585Njf-U",
      "original_commit_id" : "68e48a0185751d24eecb194b8efd7028c8b590f3",
      "original_line" : 938,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 217,
      "pull_request_review_id" : 1588656803,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301151636/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T07:30:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301151636",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301169095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301169095"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It is ok as it is - there is _some_ reason for using pointers.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T07:45:44Z",
      "diff_hunk" : "@@ -63,22 +65,260 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two deques representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        std::string ret;\n+        while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+            char c = provider.ConsumeIntegral<char>();\n+            if (c < ' ' || c > 0x7E) break;\n+            ret += c;\n+        }\n+        return ret;\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return false;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n         }\n+        // Return whether any message was added.\n+        return queued;\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    unsigned iter = 0;\n+    while (iter < 1000 && provider.remaining_bytes()) {\n+        uint8_t code = provider.ConsumeIntegral<uint8_t>();\n+        // Lowest bit identifies the sender side of the operation.\n+        int side = code & 1;\n+        switch ((side >> 1) % 3) {\n+        // The other bits (mod 3) identify the operation:\n+        case 0:\n+            // (Try to) give the next message to the transport.\n+            new_msg_fn(side);\n+            break;\n+        case 1:\n+            // (Try to) send some bytes from the transport to the network.\n+            send_fn(side);\n+            break;\n+        case 2:\n+            // (Try to) receive bytes from the network, converting to messages.\n+            recv_fn(side);\n+            break;\n+        }\n+        ++iter;\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;\n+        if (send_fn(1, true)) any = true;\n+        if (recv_fn(0, true)) any = true;\n+        if (recv_fn(1, true)) any = true;\n+        if (!any) break;\n     }\n+\n+    // Make sure nothing is left in flight.\n+    assert(in_flight[0].empty());\n+    assert(in_flight[1].empty());\n+\n+    // Make sure all expected messages were received.\n+    assert(expected[0].empty());\n+    assert(expected[1].empty());\n+}\n+\n+std::unique_ptr<Transport> MakeV1Transport(NodeId nodeid) noexcept\n+{\n+    return std::make_unique<V1Transport>(nodeid, SER_NETWORK, INIT_PROTO_VERSION);\n+}\n+\n+} // namespace\n+\n+FUZZ_TARGET(p2p_transport_bidirectional, .init = initialize_p2p_transport_serialization)\n+{\n+    // Test with two V1 transports talking to each other.\n+    FuzzedDataProvider provider{buffer.data(), buffer.size()};\n+    XoRoShiRo128PlusPlus rng(provider.ConsumeIntegral<uint64_t>());\n+    auto t1 = MakeV1Transport(NodeId{0});\n+    auto t2 = MakeV1Transport(NodeId{1});\n+    if (!t1 || !t2) return;\n+    SimulationTest(*t1, *t2, rng, provider);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301169095",
      "id" : 1301169095,
      "in_reply_to_id" : 1300362306,
      "line" : 330,
      "node_id" : "PRRC_kwDOABII585NjkPH",
      "original_commit_id" : "d99269058922af5fdc14d7fcc88f132060b4b57a",
      "original_line" : 330,
      "original_position" : 286,
      "original_start_line" : 320,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 300,
      "pull_request_review_id" : 1588684364,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301169095/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 327,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T07:45:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301169095",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301295281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301295281"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: and `to_send` too\r\n```suggestion\r\n     * Note that m_type and to_send refer to data that is internal to the transport, and calling any non-const function on\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T08:59:59Z",
      "diff_hunk" : "@@ -253,42 +256,92 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     *\n+     * Note that the m_type value returned is a reference, and calling any non-const function on",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301295281",
      "id" : 1301295281,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NkDCx",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 307,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301295281/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301295281",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301317614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301317614"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n        if (v <= CMessageHeader::COMMAND_SIZE) {\r\n            // If v is below the maximum command size, construct a valid (but possibly unknown) message type of\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T09:14:03Z",
      "diff_hunk" : "@@ -63,22 +74,258 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v <= 12) {\n+            // If v is in range 0..12, construct a valid (but possibly unknown) message type of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301317614",
      "id" : 1301317614,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NkIfu",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 138,
      "original_position" : 108,
      "original_start_line" : 137,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301317614/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301317614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301329839"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301329839"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I guess the following would achieve the same, no need to subtract 13?\r\n\r\n```suggestion\r\n            return g_all_messages[v % g_all_messages.size()];\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T09:20:31Z",
      "diff_hunk" : "@@ -63,22 +74,258 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v <= 12) {\n+            // If v is in range 0..12, construct a valid (but possibly unknown) message type of\n+            // that length from the fuzz data.\n+            std::string ret;\n+            while (ret.size() < v) {\n+                char c = provider.ConsumeIntegral<char>();\n+                // Match the allowed characters in CMessageHeader::IsCommandValid().\n+                if (c < ' ' || c > 0x7E) break;\n+                ret += c;\n+            }\n+            return ret;\n+        } else {\n+            // Otherwise, use it as index into the list of known messages.\n+            return g_all_messages[(v - 13) % g_all_messages.size()];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301329839",
      "id" : 1301329839,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NkLev",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 150,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301329839/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301329839",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301356016"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301356016"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In the old code it was really strange to check whether `nSendSize` is too big after _decrementing_ it. Good that this is gone now.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T09:35:20Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301356016",
      "id" : 1301356016,
      "line" : 866,
      "node_id" : "PRRC_kwDOABII585NkR3w",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 866,
      "original_position" : 244,
      "original_start_line" : 865,
      "path" : "src/net.cpp",
      "position" : 244,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301356016/reactions"
      },
      "side" : "LEFT",
      "start_line" : 865,
      "start_side" : "LEFT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301356016",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301442058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301442058"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n                // Don't set data_left here; we won't ever send anything anymore.\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T10:32:01Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301442058",
      "id" : 1301442058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nkm4K",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 939,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301442058/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301442058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301450436"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301450436"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`more` and `data_left` mean similar things and I find the names a bit confusing or difficult to distinguish which one means what. Maybe consider something like `more_in_transport` and `more_in_data`.\r\n\r\nEdit: wait, they mean the same thing. I thought that `data_left` would be used to retry with the remaining from the `data` variable, but this is not the case. Evey time we set `data_left` to `true` we break from the loop, getting `data` out of scope and losing it. In this case the data remains in the transport.\r\n\r\nIs it possible to use just one variable, something like the following?\r\n\r\n<details>\r\n<summary>[patch] just one variable to designate more data remains for sending</summary>\r\n\r\n```diff\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -925,13 +925,14 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n             if (node.m_transport->SetMessageToSend(*it)) {\r\n                 // Update memory usage of send buffer (as *it will be deleted).\r\n                 node.m_send_memusage -= memusage;\r\n                 ++it;\r\n             }\r\n         }\r\n-        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\r\n+        const auto& [data, _data_left, msg_type] = node.m_transport->GetBytesToSend();\r\n+        data_left = _data_left;\r\n         int nBytes = 0;\r\n         if (!data.empty()) {\r\n             LOCK(node.m_sock_mutex);\r\n             // There is no socket in case we've already disconnected, or in test cases without\r\n             // real connections. In these cases, we bail out immediately and just leave things\r\n             // in the send queue and transport.\r\n@@ -940,13 +941,13 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 break;\r\n             }\r\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\r\n #ifdef MSG_MORE\r\n             // We have more to send if either the transport itself has more, or if we have more\r\n             // messages to send.\r\n-            if (more || it != node.vSendMsg.end()) {\r\n+            if (data_left || it != node.vSendMsg.end()) {\r\n                 flags |= MSG_MORE;\r\n             }\r\n #endif\r\n             nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\r\n         }\r\n         if (nBytes > 0) {\r\n@@ -969,13 +970,15 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\r\n                     LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));\r\n                     node.CloseSocketDisconnect();\r\n                 }\r\n             }\r\n             // couldn't send anything at all\r\n-            data_left = !data.empty();\r\n+            if (!data.empty()) {\r\n+                data_left = true;\r\n+            }\r\n             break;\r\n         }\r\n     }\r\n \r\n     node.fPauseSend = node.m_send_memusage + node.m_transport->GetSendMemoryUsage() > nSendBufferMaxSize;\r\n \r\n```\r\n</details>",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T10:40:14Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301450436",
      "id" : 1301450436,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nko7E",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 962,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301450436/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301450436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301471895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301471895"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Since the last two seem to be irrelevant and unused, if there is no other reason to show some meaningful names, then:\r\n\r\n```suggestion\r\n            const auto& [to_send, std::ignore, std::ignore] = pnode->m_transport->GetBytesToSend();\r\n```\r\n\r\n(same in `CConnman::PushMessage()` and in the tests)",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T11:00:06Z",
      "diff_hunk" : "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301471895",
      "id" : 1301471895,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585NkuKX",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 1326,
      "original_position" : 285,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 283,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301471895/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301471895",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301566071"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301566071"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This logic is used also in `CConnman::GenerateWaitSockets()` but negated: `select_send = !to_send.empty() || !pnode->vSendMsg.empty();` is it worth introducing `bool CNode::SendQueueEmpty()` and using it in both places?\r\n\r\n<details>\r\n<summary>[patch] CNode::SendQueueEmpty()</summary>\r\n\r\n```diff\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -1319,20 +1319,13 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\r\n     for (const ListenSocket& hListenSocket : vhListenSocket) {\r\n         events_per_sock.emplace(hListenSocket.sock, Sock::Events{Sock::RECV});\r\n     }\r\n \r\n     for (CNode* pnode : nodes) {\r\n         bool select_recv = !pnode->fPauseRecv;\r\n-        bool select_send;\r\n-        {\r\n-            LOCK(pnode->cs_vSend);\r\n-            // Sending is possible if either there are bytes to send right now, or if there will be\r\n-            // once a potential message from vSendMsg is handed to the transport.\r\n-            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\r\n-            select_send = !to_send.empty() || !pnode->vSendMsg.empty();\r\n-        }\r\n+        bool select_send = WITH_LOCK(pnode->cs_vSend, !pnode->SendQueueEmpty());\r\n         if (!select_recv && !select_send) continue;\r\n \r\n         LOCK(pnode->m_sock_mutex);\r\n         if (pnode->m_sock) {\r\n             Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\r\n             events_per_sock.emplace(pnode->m_sock, Sock::Events{event});\r\n@@ -3007,14 +3000,13 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\r\n         msg.data.data()\r\n     );\r\n \r\n     size_t nBytesSent = 0;\r\n     {\r\n         LOCK(pnode->cs_vSend);\r\n-        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\r\n-        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};\r\n+        const bool queue_was_empty{pnode->SendQueueEmpty()};\r\n \r\n         // Update memory usage of send buffer.\r\n         pnode->m_send_memusage += msg.GetMemoryUsage();\r\n         if (pnode->m_send_memusage + pnode->m_transport->GetSendMemoryUsage() > nSendBufferMaxSize) pnode->fPauseSend = true;\r\n         // Move message to vSendMsg queue.\r\n         pnode->vSendMsg.push_back(std::move(msg));\r\n```\r\n</details>",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T12:25:13Z",
      "diff_hunk" : "@@ -2906,27 +3007,24 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_serializer->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301566071",
      "id" : 1301566071,
      "line" : 3010,
      "node_id" : "PRRC_kwDOABII585NlFJ3",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 3010,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 313,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301566071/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301566071",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301596054"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301596054"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Just a comment and a question.\r\n\r\nWrt the title of the commit message 69f4b340c068078cca7b68aa04360aaa7c0fd12b `net: move message serialization from PushMessage to SocketSendData`\r\n\r\nBy \"serialization\" you mean creating/serializing the header and concatenating it with the bytes of the already serialized payload? I find this a bit confusing as I would assume that once we have `CSerializedNetMsg` then serialization has already happened (both of the header and of the payload). It should be done by `CNetMsgMaker::Make()` which takes the high-level data and produces `CSerializedNetMsg`.\r\n\r\nWhy in the first place, even in `master` do we need to have the header bytes serialized in another place than the payload? Why was it not done so that `CNetMsgMaker::Make()` would produce both serialized header bytes plus serialized payload bytes, concatenate them and return a single byte array?",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T12:48:31Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301596054",
      "id" : 1301596054,
      "line" : 915,
      "node_id" : "PRRC_kwDOABII585NlMeW",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 915,
      "original_position" : 189,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 189,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301596054/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301596054",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301621484"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301621484"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`s/false is invalid/false if invalid/` or even better, tell doxygen about it:\r\n\r\n```suggestion\r\n    /**\r\n     * Read and deserialize data, advance msg_bytes data pointer.\r\n     * @return false if invalid.\r\n     */\r\n    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\r\n```",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T13:07:22Z",
      "diff_hunk" : "@@ -253,42 +256,92 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301621484",
      "id" : 1301621484,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NlSrs",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 278,
      "original_position" : 37,
      "original_start_line" : 271,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301621484/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301621484",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301625342"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301625342"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit (`handled` is not used afterwards):\r\n```suggestion\r\n        if (!m_transport->ReceivedBytes(msg_bytes)) {\r\n```\r\n(same in `p2p_transport_serialization.cpp`)",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T13:10:12Z",
      "diff_hunk" : "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301625342",
      "id" : 1301625342,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NlTn-",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 694,
      "original_position" : 30,
      "original_start_line" : 693,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1588883611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301625342/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T13:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301625342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301752779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301752779"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't mind keeping `handled` around, to make it more clear that receiving 0 bytes is also \"handled\".",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T14:38:11Z",
      "diff_hunk" : "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301752779",
      "id" : 1301752779,
      "in_reply_to_id" : 1301625342,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NlyvL",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 694,
      "original_position" : 30,
      "original_start_line" : 693,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1589613663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301752779/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T14:38:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301752779",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301776903"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301776903"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Didn't check, but that looks like a nice simplification indeed.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T14:54:17Z",
      "diff_hunk" : "@@ -2906,27 +3007,24 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_serializer->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301776903",
      "id" : 1301776903,
      "in_reply_to_id" : 1301566071,
      "line" : 3010,
      "node_id" : "PRRC_kwDOABII585Nl4oH",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 3010,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 313,
      "pull_request_review_id" : 1589654378,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301776903/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T14:54:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301776903",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301780539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301780539"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Optionally annotate the return values if the fact that we're ignoring them is potentially interesting / strange. `[to_send, /*more=*/std::ignore, /*msg_type=*/std::ignore] = pnode->â¦`",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T14:56:17Z",
      "diff_hunk" : "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301780539",
      "id" : 1301780539,
      "in_reply_to_id" : 1301471895,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585Nl5g7",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 1326,
      "original_position" : 285,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 283,
      "pull_request_review_id" : 1589659238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301780539/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T14:56:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301780539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301793247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301793247"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FWIW, this line is (was) for turning `fPauseSend` **off** again after the buffer level dropped.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T15:04:51Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301793247",
      "id" : 1301793247,
      "in_reply_to_id" : 1301356016,
      "line" : 866,
      "node_id" : "PRRC_kwDOABII585Nl8nf",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 866,
      "original_position" : 244,
      "original_start_line" : 865,
      "path" : "src/net.cpp",
      "position" : 244,
      "pull_request_review_id" : 1589679118,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301793247/reactions"
      },
      "side" : "LEFT",
      "start_line" : 865,
      "start_side" : "LEFT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T15:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301793247",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301796779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301796779"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would use `data_in_transport` instead of `_data_left` (see https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1298717971).\r\n\r\nAnd then drop `data_left = _data_left;`. \r\n\r\nThen below:\r\n\r\n```cpp\r\nbool message_queue_empty = it == node.vSendMsg.end()`\r\nif (data_in_transport || !message_queue_empty) {\r\n  flags |= MSG_MORE;\r\n```\r\n\r\nAnd:\r\n\r\n```\r\n// couldn't send anything at all\r\nif (!data.empty()) {\r\n  data_in_transport = true\r\n}\r\n```\r\n\r\nAnd then finally return `!message_queue_empty || data_in_transport` instead of `data_left`.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T15:07:29Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301796779",
      "id" : 1301796779,
      "in_reply_to_id" : 1301450436,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nl9er",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 962,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1589684797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301796779/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T15:07:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301796779",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301802100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301802100"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't find this easier to reason about, as the two variables do mean something different (one is whether more bytes follow *after* `to_send`, and the other is a return value saying whether `SocketSendData` didn't send everything).\r\n\r\nThere is another (even) shorter solution, I think:\r\n\r\n```diff\r\n\r\n--- i/src/net.cpp\r\n+++ w/src/net.cpp\r\n@@ -925,13 +925,14 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n             if (node.m_transport->SetMessageToSend(*it)) {\r\n                 // Update memory usage of send buffer (as *it will be deleted).\r\n                 node.m_send_memusage -= memusage;\r\n                 ++it;\r\n             }\r\n         }\r\n         const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\r\n+        data_left = !data.empty(); // will be overwritten on the next loop if we send data in full.\r\n         int nBytes = 0;\r\n         if (!data.empty()) {\r\n             LOCK(node.m_sock_mutex);\r\n             // There is no socket in case we've already disconnected, or in test cases without\r\n             // real connections. In these cases, we bail out immediately and just leave things\r\n             // in the send queue and transport.\r\n@@ -940,13 +941,13 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 break;\r\n             }\r\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\r\n #ifdef MSG_MORE\r\n             // We have more to send if either the transport itself has more, or if we have more\r\n             // messages to send.\r\n             if (more || it != node.vSendMsg.end()) {\r\n                 flags |= MSG_MORE;\r\n             }\r\n #endif\r\n             nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\r\n         }\r\n         if (nBytes > 0) {\r\n@@ -969,13 +970,15 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\r\n                 if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\r\n                     LogPrint(BCLog::NET, \"socket send error for peer=%d: %s\\n\", node.GetId(), NetworkErrorString(nErr));\r\n                     node.CloseSocketDisconnect();\r\n                 }\r\n             }\r\n             // couldn't send anything at all\r\n             break;\r\n         }\r\n     }\r\n \r\n     node.fPauseSend = node.m_send_memusage + node.m_transport->GetSendMemoryUsage() > nSendBufferMaxSize;\r\n```\r\n\r\nDo you think that's better?",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T15:11:18Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301802100",
      "id" : 1301802100,
      "in_reply_to_id" : 1301450436,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nl-x0",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 962,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1589692782,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301802100/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T15:11:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301802100",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301806332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301806332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is not valid C++. `std::ignore` can be used as an argument to `std::tie`, but not in structured bindings. The `_` in front is supposed to indicate the variables are unused, instead (which also documents their name).",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T15:14:29Z",
      "diff_hunk" : "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301806332",
      "id" : 1301806332,
      "in_reply_to_id" : 1301471895,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585Nl_z8",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 1326,
      "original_position" : 285,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 283,
      "pull_request_review_id" : 1589699419,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301806332/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T15:14:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301806332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301958961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301958961"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "tiny-indicate-unused-nit:\r\n```suggestion\r\n            const auto& [bytes, _more, msg_type] = pnode->m_transport->GetBytesToSend();\r\n```\r\n(probably not worth retouching as that code is replaced in a later commit anyways)",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T17:14:59Z",
      "diff_hunk" : "@@ -2910,27 +2957,40 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n-\n-        if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n-        pnode->vSendMsg.push_back(std::move(serializedHeader));\n-        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));\n-\n-        // If write queue empty, attempt \"optimistic write\"\n-        bool data_left;\n-        if (optimisticSend) std::tie(nBytesSent, data_left) = SocketSendData(*pnode);\n+        const bool queue_was_empty{pnode->vSendMsg.empty()};\n+\n+        // Give the message to the transport, and add all bytes it wants us to send out as byte\n+        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n+        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n+        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n+        // will disappear.\n+        bool queued = pnode->m_transport->SetMessageToSend(msg);\n+        assert(queued);\n+        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n+        // and then the payload data (if any), necessitating a loop.\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301958961",
      "id" : 1301958961,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NmlEx",
      "original_commit_id" : "319ceaa5c80951e6b454bf2f6367aac780689d2f",
      "original_line" : 2975,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1589955318,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301958961/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T17:57:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301958961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301992679"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301992679"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm only seeing an _extra_ line hereâ¦? But something along those lines could be worth a shot.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T17:48:19Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301992679",
      "id" : 1301992679,
      "in_reply_to_id" : 1301450436,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NmtTn",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 962,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1590009522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301992679/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T17:48:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301992679",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301998730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301998730"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: if `handled` is decided to be kept, it should be declared as `const`.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T17:54:45Z",
      "diff_hunk" : "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1301998730",
      "id" : 1301998730,
      "in_reply_to_id" : 1301625342,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NmuyK",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 694,
      "original_position" : 30,
      "original_start_line" : 693,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1589955318,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301998730/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T17:57:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301998730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302020559"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302020559"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This works, but in #28196 one of the two call sites would be replaced with other code anyway (or require more virtual function calls than needed), so my preference is not doing this.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T18:16:07Z",
      "diff_hunk" : "@@ -2906,27 +3007,24 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_serializer->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();\n+        const bool queue_was_empty{to_send.empty() && pnode->vSendMsg.empty()};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302020559",
      "id" : 1302020559,
      "in_reply_to_id" : 1301566071,
      "line" : 3010,
      "node_id" : "PRRC_kwDOABII585Nm0HP",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 3010,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 313,
      "pull_request_review_id" : 1590052837,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302020559/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T18:16:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302020559",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302100581"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302100581"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:29:13Z",
      "diff_hunk" : "@@ -253,42 +256,92 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;\n     // decomposes a message from the context\n-    virtual CNetMessage GetMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n-    virtual ~TransportDeserializer() {}\n+    virtual CNetMessage GetReceivedMessage(std::chrono::microseconds time, bool& reject_message) = 0;\n+\n+    // 2. Sending side functions, for serializing messages into bytes to be sent over the wire.\n+\n+    /** Set the next message to send.\n+     *\n+     * If no message can currently be set (perhaps because the previous one is not yet done being\n+     * sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and\n+     * possibly moved-from) and true is returned.\n+     */\n+    virtual bool SetMessageToSend(CSerializedNetMsg& msg) noexcept = 0;\n+\n+    /** Return type for GetBytesToSend, consisting of:\n+     *  - Span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty).\n+     *  - bool more: whether there will be more bytes to be sent after the ones in to_send are\n+     *    all sent (as signaled by MarkBytesSent()).\n+     *  - const std::string& m_type: message type on behalf of which this is being sent.\n+     */\n+    using BytesToSend = std::tuple<\n+        Span<const uint8_t> /*to_send*/,\n+        bool /*more*/,\n+        const std::string& /*m_type*/\n+    >;\n+\n+    /** Get bytes to send on the wire.\n+     *\n+     * As a const function, it does not modify the transport's observable state, and is thus safe\n+     * to be called multiple times.\n+     *\n+     * The bytes returned by this function act as a stream which can only be appended to. This\n+     * means that with the exception of MarkBytesSent, operations on the transport can only append\n+     * to what is being returned.\n+     *\n+     * Note that the m_type value returned is a reference, and calling any non-const function on",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302100581",
      "id" : 1302100581,
      "in_reply_to_id" : 1301295281,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnHpl",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 307,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1590179908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302100581/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:29:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302100581",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302101802"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302101802"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. I've also changed the encoding a bit further to simplify it:\r\n* Only v = 0xFF is now used for free-form commands (and the length is determined by the first invalid character).\r\n* `v % g_all_messages.size()` can be used as index without potentially confusing lack of subtraction.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:30:24Z",
      "diff_hunk" : "@@ -63,22 +74,258 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v <= 12) {\n+            // If v is in range 0..12, construct a valid (but possibly unknown) message type of",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302101802",
      "id" : 1302101802,
      "in_reply_to_id" : 1301317614,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnH8q",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 138,
      "original_position" : 108,
      "original_start_line" : 137,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1590182337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302101802/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T20:17:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302101802",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302101921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302101921"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:30:31Z",
      "diff_hunk" : "@@ -63,22 +74,258 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n     mutable_msg_bytes.insert(mutable_msg_bytes.end(), payload_bytes.begin(), payload_bytes.end());\n     Span<const uint8_t> msg_bytes{mutable_msg_bytes};\n     while (msg_bytes.size() > 0) {\n-        const int handled = deserializer.Read(msg_bytes);\n-        if (handled < 0) {\n+        const bool handled = recv_transport.ReceivedBytes(msg_bytes);\n+        if (!handled) {\n             break;\n         }\n-        if (deserializer.Complete()) {\n+        if (recv_transport.ReceivedMessageComplete()) {\n             const std::chrono::microseconds m_time{std::numeric_limits<int64_t>::max()};\n             bool reject_message{false};\n-            CNetMessage msg = deserializer.GetMessage(m_time, reject_message);\n+            CNetMessage msg = recv_transport.GetReceivedMessage(m_time, reject_message);\n             assert(msg.m_type.size() <= CMessageHeader::COMMAND_SIZE);\n             assert(msg.m_raw_message_size <= mutable_msg_bytes.size());\n             assert(msg.m_raw_message_size == CMessageHeader::HEADER_SIZE + msg.m_message_size);\n             assert(msg.m_time == m_time);\n \n             std::vector<unsigned char> header;\n             auto msg2 = CNetMsgMaker{msg.m_recv.GetVersion()}.Make(msg.m_type, Span{msg.m_recv});\n-            serializer.prepareForTransport(msg2, header);\n+            bool queued = send_transport.SetMessageToSend(msg2);\n+            assert(queued);\n+            std::optional<bool> known_more;\n+            while (true) {\n+                const auto& [to_send, more, _msg_type] = send_transport.GetBytesToSend();\n+                if (known_more) assert(!to_send.empty() == *known_more);\n+                if (to_send.empty()) break;\n+                send_transport.MarkBytesSent(to_send.size());\n+                known_more = more;\n+            }\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v <= 12) {\n+            // If v is in range 0..12, construct a valid (but possibly unknown) message type of\n+            // that length from the fuzz data.\n+            std::string ret;\n+            while (ret.size() < v) {\n+                char c = provider.ConsumeIntegral<char>();\n+                // Match the allowed characters in CMessageHeader::IsCommandValid().\n+                if (c < ' ' || c > 0x7E) break;\n+                ret += c;\n+            }\n+            return ret;\n+        } else {\n+            // Otherwise, use it as index into the list of known messages.\n+            return g_all_messages[(v - 13) % g_all_messages.size()];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302101921",
      "id" : 1302101921,
      "in_reply_to_id" : 1301329839,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnH-h",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 150,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1590182674,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302101921/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:30:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302101921",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302102030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302102030"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:30:39Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302102030",
      "id" : 1302102030,
      "in_reply_to_id" : 1301442058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnIAO",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 939,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1590183086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302102030/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:30:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302102030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302103172"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302103172"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@Sjors It was a diff w.r.t. the code that was there before, not w.r.t. the PR as it was then.\r\n\r\nIn either case, I've implemented it, please have a look.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:31:53Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();\n     size_t nSentSize = 0;\n-\n-    while (it != node.vSendMsg.end()) {\n-        const auto& data = *it;\n-        assert(data.size() > node.nSendOffset);\n+    bool data_left{false};\n+\n+    while (true) {\n+        if (it != node.vSendMsg.end()) {\n+            // If possible, move one message from the send queue to the transport. This fails when\n+            // there is an existing message still being sent.\n+            size_t memusage = it->GetMemoryUsage();\n+            if (node.m_transport->SetMessageToSend(*it)) {\n+                // Update memory usage of send buffer (as *it will be deleted).\n+                node.m_send_memusage -= memusage;\n+                ++it;\n+            }\n+        }\n+        const auto& [data, more, msg_type] = node.m_transport->GetBytesToSend();\n         int nBytes = 0;\n-        {\n+        if (!data.empty()) {\n             LOCK(node.m_sock_mutex);\n+            // There is no socket in case we've already disconnected, or in test cases without\n+            // real connections. In these cases, we bail out immediately and just leave things\n+            // in the send queue and transport.\n             if (!node.m_sock) {\n+                // Don't set data_left here here; we won't ever send anything anymore.\n                 break;\n             }\n             int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n #ifdef MSG_MORE\n-            if (it + 1 != node.vSendMsg.end()) {\n+            // We have more to send if either the transport itself has more, or if we have more\n+            // messages to send.\n+            if (more || it != node.vSendMsg.end()) {\n                 flags |= MSG_MORE;\n             }\n #endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()) + node.nSendOffset, data.size() - node.nSendOffset, flags);\n+            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n         }\n         if (nBytes > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n             node.nSendBytes += nBytes;\n-            node.nSendOffset += nBytes;\n+            // Notify transport that bytes have been processed.\n+            node.m_transport->MarkBytesSent(nBytes);\n+            // Update statistics per message type.\n+            node.AccountForSentBytes(msg_type, nBytes);\n             nSentSize += nBytes;\n-            if (node.nSendOffset == data.size()) {\n-                node.nSendOffset = 0;\n-                node.nSendSize -= data.size();\n-                node.fPauseSend = node.nSendSize > nSendBufferMaxSize;\n-                it++;\n-            } else {\n+            if ((size_t)nBytes != data.size()) {\n                 // could not send full message; stop sending more\n+                data_left = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302103172",
      "id" : 1302103172,
      "in_reply_to_id" : 1301450436,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnISE",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 962,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1590185104,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302103172/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:31:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302103172",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302106044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302106044"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, the \"serialization\" terminology here was weird. I think perhaps historically, the serialization (as in conversion from application objects to byte-serialized form) was perhaps done at the same time as the computation of message header for the v1 protocol, but that hasn't been the case for a while (probably since some form of abstraction was introduced with the prospect of having separate transports).\r\n\r\nI've tried to change some comments and commit titles to clarify this distinction.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:35:11Z",
      "diff_hunk" : "@@ -819,54 +842,124 @@ CNetMessage V1TransportDeserializer::GetMessage(const std::chrono::microseconds\n     return msg;\n }\n \n-void V1TransportSerializer::prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) const\n+bool V1Transport::SetMessageToSend(CSerializedNetMsg& msg) noexcept\n {\n+    AssertLockNotHeld(m_send_mutex);\n+    // Determine whether a new message can be set.\n+    LOCK(m_send_mutex);\n+    if (m_sending_header || m_bytes_sent < m_message_to_send.data.size()) return false;\n+\n     // create dbl-sha256 checksum\n     uint256 hash = Hash(msg.data);\n \n     // create header\n-    CMessageHeader hdr(Params().MessageStart(), msg.m_type.c_str(), msg.data.size());\n+    CMessageHeader hdr(m_magic_bytes, msg.m_type.c_str(), msg.data.size());\n     memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n     // serialize header\n-    header.reserve(CMessageHeader::HEADER_SIZE);\n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, header, 0, hdr};\n+    m_header_to_send.clear();\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, m_header_to_send, 0, hdr};\n+\n+    // update state\n+    m_message_to_send = std::move(msg);\n+    m_sending_header = true;\n+    m_bytes_sent = 0;\n+    return true;\n+}\n+\n+Transport::BytesToSend V1Transport::GetBytesToSend() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    if (m_sending_header) {\n+        return {Span{m_header_to_send}.subspan(m_bytes_sent),\n+                // We have more to send after the header if the message has payload.\n+                !m_message_to_send.data.empty(),\n+                m_message_to_send.m_type\n+               };\n+    } else {\n+        return {Span{m_message_to_send.data}.subspan(m_bytes_sent),\n+                // We never have more to send after this message's payload.\n+                false,\n+                m_message_to_send.m_type\n+               };\n+    }\n+}\n+\n+void V1Transport::MarkBytesSent(size_t bytes_sent) noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    m_bytes_sent += bytes_sent;\n+    if (m_sending_header && m_bytes_sent == m_header_to_send.size()) {\n+        // We're done sending a message's header. Switch to sending its data bytes.\n+        m_sending_header = false;\n+        m_bytes_sent = 0;\n+    } else if (!m_sending_header && m_bytes_sent == m_message_to_send.data.size()) {\n+        // We're done sending a message's data. Wipe the data vector to reduce memory consumption.\n+        m_message_to_send.data.clear();\n+        m_message_to_send.data.shrink_to_fit();\n+        m_bytes_sent = 0;\n+    }\n+}\n+\n+size_t V1Transport::GetSendMemoryUsage() const noexcept\n+{\n+    AssertLockNotHeld(m_send_mutex);\n+    LOCK(m_send_mutex);\n+    // Don't count sending-side fields besides m_message_to_send, as they're all small and bounded.\n+    return m_message_to_send.GetMemoryUsage();\n }\n \n std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n {\n     auto it = node.vSendMsg.begin();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302106044",
      "id" : 1302106044,
      "in_reply_to_id" : 1301596054,
      "line" : 915,
      "node_id" : "PRRC_kwDOABII585NnI-8",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 915,
      "original_position" : 189,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 189,
      "pull_request_review_id" : 1590189847,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302106044/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:35:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302106044",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302106698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302106698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (adding doxygen comments, a bit more elaborate than what you suggested).",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:35:57Z",
      "diff_hunk" : "@@ -253,42 +256,92 @@ class CNetMessage {\n     }\n };\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (message type & payload)\n- */\n-class TransportDeserializer {\n+/** The Transport deserializes received messages, and serializes sent messages. */\n+class Transport {\n public:\n+    virtual ~Transport() {}\n+\n+    // 1. Receiver side functions, for deserializing the network buffer into a transport protocol\n+    // agnostic CNetMessage (message type & payload).\n+\n     // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    virtual bool ReceivedMessageComplete() const = 0;\n+    // set the deserialization context version\n+    virtual void SetReceiveVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer. Return false is invalid. */\n+    virtual bool ReceivedBytes(Span<const uint8_t>& msg_bytes) = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302106698",
      "id" : 1302106698,
      "in_reply_to_id" : 1301621484,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnJJK",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 278,
      "original_position" : 37,
      "original_start_line" : 271,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1590190871,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302106698/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:35:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302106698",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302107501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302107501"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've dropped the handled, because it was outdated anyway. It used to be a variable that contained how many bytes were processed, but since the last commit in this PR, it doesn't have that meaning anymore at all. Just a branch with a comment is clearer.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:36:50Z",
      "diff_hunk" : "@@ -681,16 +690,16 @@ bool CNode::ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete)\n     nRecvBytes += msg_bytes.size();\n     while (msg_bytes.size() > 0) {\n         // absorb network data\n-        int handled = m_deserializer->Read(msg_bytes);\n-        if (handled < 0) {\n+        bool handled = m_transport->ReceivedBytes(msg_bytes);\n+        if (!handled) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302107501",
      "id" : 1302107501,
      "in_reply_to_id" : 1301625342,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnJVt",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 694,
      "original_position" : 30,
      "original_start_line" : 693,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1590192036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302107501/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:36:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302107501",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302107589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302107589"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-22T19:36:57Z",
      "diff_hunk" : "@@ -2910,27 +2957,40 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n         msg.data.data()\n     );\n \n-    // make sure we use the appropriate network transport format\n-    std::vector<unsigned char> serializedHeader;\n-    pnode->m_transport->prepareForTransport(msg, serializedHeader);\n-    size_t nTotalSize = nMessageSize + serializedHeader.size();\n-\n     size_t nBytesSent = 0;\n     {\n         LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n-\n-        //log total amount of bytes per message type\n-        pnode->AccountForSentBytes(msg.m_type, nTotalSize);\n-        pnode->nSendSize += nTotalSize;\n-\n-        if (pnode->nSendSize > nSendBufferMaxSize) pnode->fPauseSend = true;\n-        pnode->vSendMsg.push_back(std::move(serializedHeader));\n-        if (nMessageSize) pnode->vSendMsg.push_back(std::move(msg.data));\n-\n-        // If write queue empty, attempt \"optimistic write\"\n-        bool data_left;\n-        if (optimisticSend) std::tie(nBytesSent, data_left) = SocketSendData(*pnode);\n+        const bool queue_was_empty{pnode->vSendMsg.empty()};\n+\n+        // Give the message to the transport, and add all bytes it wants us to send out as byte\n+        // vectors to vSendMsg. This is temporary code that exists to support the new transport\n+        // sending interface using the old way of queueing data. In a future commit vSendMsg will\n+        // be replaced with a queue of CSerializedNetMsg objects to be sent instead, and this code\n+        // will disappear.\n+        bool queued = pnode->m_transport->SetMessageToSend(msg);\n+        assert(queued);\n+        // In the current transport (V1Transport), GetBytesToSend first returns a header to send,\n+        // and then the payload data (if any), necessitating a loop.\n+        while (true) {\n+            const auto& [bytes, more, msg_type] = pnode->m_transport->GetBytesToSend();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302107589",
      "id" : 1302107589,
      "in_reply_to_id" : 1301958961,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NnJXF",
      "original_commit_id" : "319ceaa5c80951e6b454bf2f6367aac780689d2f",
      "original_line" : 2975,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1590192187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302107589/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-22T19:36:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302107589",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302858154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302858154"
         }
      },
      "author_association" : "MEMBER",
      "body" : "89b220d44bca232a3dd7f25d839b2075b5a5d642 nit: dequeues (or add spelling exception)",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-23T11:08:35Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302858154",
      "id" : 1302858154,
      "line" : 121,
      "node_id" : "PRRC_kwDOABII585NqAmq",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 122,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 91,
      "pull_request_review_id" : 1591345951,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302858154/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T11:08:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302858154",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302965727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302965727"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ok, in C++27 then, sorry for the noise.",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-23T12:48:46Z",
      "diff_hunk" : "@@ -1227,7 +1322,14 @@ Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n \n     for (CNode* pnode : nodes) {\n         bool select_recv = !pnode->fPauseRecv;\n-        bool select_send = WITH_LOCK(pnode->cs_vSend, return !pnode->vSendMsg.empty());\n+        bool select_send;\n+        {\n+            LOCK(pnode->cs_vSend);\n+            // Sending is possible if either there are bytes to send right now, or if there will be\n+            // once a potential message from vSendMsg is handed to the transport.\n+            const auto& [to_send, _more, _msg_type] = pnode->m_transport->GetBytesToSend();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302965727",
      "id" : 1302965727,
      "in_reply_to_id" : 1301471895,
      "line" : 1326,
      "node_id" : "PRRC_kwDOABII585Nqa3f",
      "original_commit_id" : "678809e00178b33e273f0775eea9635fecaf386a",
      "original_line" : 1326,
      "original_position" : 285,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 283,
      "pull_request_review_id" : 1591514379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302965727/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T12:48:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302965727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302980547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302980547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://en.wikipedia.org/wiki/Double-ended_queue",
      "commit_id" : "41806a45d362636c6ffea6bdf39620c785b0edd8",
      "created_at" : "2023-08-23T13:00:00Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1302980547",
      "id" : 1302980547,
      "in_reply_to_id" : 1302858154,
      "line" : 121,
      "node_id" : "PRRC_kwDOABII585NqefD",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 122,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 91,
      "pull_request_review_id" : 1591539056,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302980547/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T13:00:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1302980547",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303035946"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303035946"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: named arguments at some places in the simulation test would be nice for improved readability\r\n```suggestion\r\n        if (send_fn(0, /*everything=*/true)) any = true;\r\n```\r\n(also for the boolean arguments of other `send_fn`, `recv_fn` and `make_msg_fn` calls).",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2023-08-23T13:37:21Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v == 0xFF) {\n+            // If v is 0xFF, construct a valid (but possibly unknown) message type from the fuzz\n+            // data.\n+            std::string ret;\n+            while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+                char c = provider.ConsumeIntegral<char>();\n+                // Match the allowed characters in CMessageHeader::IsCommandValid(). Any other\n+                // character is interpreted as end.\n+                if (c < ' ' || c > 0x7E) break;\n+                ret += c;\n+            }\n+            return ret;\n+        } else {\n+            // Otherwise, use it as index into the list of known messages.\n+            return g_all_messages[v % g_all_messages.size()];\n+        }\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n+        }\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\n+        CallOneOf(provider,\n+            // (Try to) give the next message to the transport.\n+            [&] { new_msg_fn(0); },\n+            [&] { new_msg_fn(1); },\n+            // (Try to) send some bytes from the transport to the network.\n+            [&] { send_fn(0); },\n+            [&] { send_fn(1); },\n+            // (Try to) receive bytes from the network, converting to messages.\n+            [&] { recv_fn(0); },\n+            [&] { recv_fn(1); }\n+        );\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303035946",
      "id" : 1303035946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NqsAq",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 300,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1591626400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303035946/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T14:03:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303035946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303077167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303077167"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Will do when I retouch.",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2023-08-23T14:05:27Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v == 0xFF) {\n+            // If v is 0xFF, construct a valid (but possibly unknown) message type from the fuzz\n+            // data.\n+            std::string ret;\n+            while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+                char c = provider.ConsumeIntegral<char>();\n+                // Match the allowed characters in CMessageHeader::IsCommandValid(). Any other\n+                // character is interpreted as end.\n+                if (c < ' ' || c > 0x7E) break;\n+                ret += c;\n+            }\n+            return ret;\n+        } else {\n+            // Otherwise, use it as index into the list of known messages.\n+            return g_all_messages[v % g_all_messages.size()];\n+        }\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n+        }\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\n+        CallOneOf(provider,\n+            // (Try to) give the next message to the transport.\n+            [&] { new_msg_fn(0); },\n+            [&] { new_msg_fn(1); },\n+            // (Try to) send some bytes from the transport to the network.\n+            [&] { send_fn(0); },\n+            [&] { send_fn(1); },\n+            // (Try to) receive bytes from the network, converting to messages.\n+            [&] { recv_fn(0); },\n+            [&] { recv_fn(1); }\n+        );\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303077167",
      "id" : 1303077167,
      "in_reply_to_id" : 1303035946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nq2Ev",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 300,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1591690863,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303077167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T14:05:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303077167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303300470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303300470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's fine by me but the spellcheck linter trips over it.",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2023-08-23T16:55:13Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303300470",
      "id" : 1303300470,
      "in_reply_to_id" : 1302858154,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Nrsl2",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 122,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1592035713,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303300470/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-23T16:55:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303300470",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303658001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303658001"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2023-08-24T00:15:09Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].\n+    std::array<std::deque<CSerializedNetMsg>, 2> expected;\n+\n+    // Vectors with bytes last returned by GetBytesToSend() on transport[i].\n+    std::array<std::vector<uint8_t>, 2> to_send;\n+\n+    // Last returned 'more' values (if still relevant) by transport[i]->GetBytesToSend().\n+    std::array<std::optional<bool>, 2> last_more;\n+\n+    // Whether more bytes to be sent are expected on transport[i].\n+    std::array<std::optional<bool>, 2> expect_more;\n+\n+    // Function to consume a message type.\n+    auto msg_type_fn = [&]() {\n+        uint8_t v = provider.ConsumeIntegral<uint8_t>();\n+        if (v == 0xFF) {\n+            // If v is 0xFF, construct a valid (but possibly unknown) message type from the fuzz\n+            // data.\n+            std::string ret;\n+            while (ret.size() < CMessageHeader::COMMAND_SIZE) {\n+                char c = provider.ConsumeIntegral<char>();\n+                // Match the allowed characters in CMessageHeader::IsCommandValid(). Any other\n+                // character is interpreted as end.\n+                if (c < ' ' || c > 0x7E) break;\n+                ret += c;\n+            }\n+            return ret;\n+        } else {\n+            // Otherwise, use it as index into the list of known messages.\n+            return g_all_messages[v % g_all_messages.size()];\n+        }\n+    };\n+\n+    // Function to construct a CSerializedNetMsg to send.\n+    auto make_msg_fn = [&](bool first) {\n+        CSerializedNetMsg msg;\n+        if (first) {\n+            // Always send a \"version\" message as first one.\n+            msg.m_type = \"version\";\n+        } else {\n+            msg.m_type = msg_type_fn();\n+        }\n+        // Determine size of message to send (limited to 75 kB for performance reasons).\n+        size_t size = provider.ConsumeIntegralInRange<uint32_t>(0, 75000);\n+        // Get payload of message from RNG.\n+        msg.data.resize(size);\n+        for (auto& v : msg.data) v = uint8_t(rng());\n+        // Return.\n+        return msg;\n+    };\n+\n+    // The next message to be sent (initially version messages, but will be replaced once sent).\n+    std::array<CSerializedNetMsg, 2> next_msg = {make_msg_fn(true), make_msg_fn(true)};\n+\n+    // Wrapper around transport[i]->GetBytesToSend() that performs sanity checks.\n+    auto bytes_to_send_fn = [&](int side) -> Transport::BytesToSend {\n+        const auto& [bytes, more, msg_type] = transports[side]->GetBytesToSend();\n+        // Compare with expected more.\n+        if (expect_more[side].has_value()) assert(!bytes.empty() == *expect_more[side]);\n+        // Compare with previously reported output.\n+        assert(to_send[side].size() <= bytes.size());\n+        assert(to_send[side] == Span{bytes}.first(to_send[side].size()));\n+        to_send[side].resize(bytes.size());\n+        std::copy(bytes.begin(), bytes.end(), to_send[side].begin());\n+        // Remember 'more' result.\n+        last_more[side] = {more};\n+        // Return.\n+        return {bytes, more, msg_type};\n+    };\n+\n+    // Function to make side send a new message.\n+    auto new_msg_fn = [&](int side) {\n+        // Don't do anything if there are too many unreceived messages already.\n+        if (expected[side].size() >= 16) return;\n+        // Try to send (a copy of) the message in next_msg[side].\n+        CSerializedNetMsg msg = next_msg[side].Copy();\n+        bool queued = transports[side]->SetMessageToSend(msg);\n+        // Update expected more data.\n+        expect_more[side] = std::nullopt;\n+        // Verify consistency of GetBytesToSend after SetMessageToSend\n+        bytes_to_send_fn(side);\n+        if (queued) {\n+            // Remember that this message is now expected by the receiver.\n+            expected[side].emplace_back(std::move(next_msg[side]));\n+            // Construct a new next message to send.\n+            next_msg[side] = make_msg_fn(false);\n+        }\n+    };\n+\n+    // Function to make side send out bytes (if any).\n+    auto send_fn = [&](int side, bool everything = false) {\n+        const auto& [bytes, more, msg_type] = bytes_to_send_fn(side);\n+        // Don't do anything if no bytes to send.\n+        if (bytes.empty()) return false;\n+        size_t send_now = everything ? bytes.size() : provider.ConsumeIntegralInRange<size_t>(0, bytes.size());\n+        if (send_now == 0) return false;\n+        // Add bytes to the in-flight queue, and mark those bytes as consumed.\n+        in_flight[side].insert(in_flight[side].end(), bytes.begin(), bytes.begin() + send_now);\n+        transports[side]->MarkBytesSent(send_now);\n+        // If all to-be-sent bytes were sent, move last_more data to expect_more data.\n+        if (send_now == bytes.size()) {\n+            expect_more[side] = last_more[side];\n+        }\n+        // Remove the bytes from the last reported to-be-sent vector.\n+        assert(to_send[side].size() >= send_now);\n+        to_send[side].erase(to_send[side].begin(), to_send[side].begin() + send_now);\n+        // Verify that GetBytesToSend gives a result consistent with earlier.\n+        bytes_to_send_fn(side);\n+        // Return whether anything was sent.\n+        return send_now > 0;\n+    };\n+\n+    // Function to make !side receive bytes (if any).\n+    auto recv_fn = [&](int side, bool everything = false) {\n+        // Don't do anything if no bytes in flight.\n+        if (in_flight[side].empty()) return false;\n+        // Decide span to receive\n+        size_t to_recv_len = in_flight[side].size();\n+        if (!everything) to_recv_len = provider.ConsumeIntegralInRange<size_t>(0, to_recv_len);\n+        Span<const uint8_t> to_recv = Span{in_flight[side]}.first(to_recv_len);\n+        // Process those bytes\n+        while (!to_recv.empty()) {\n+            size_t old_len = to_recv.size();\n+            bool ret = transports[!side]->ReceivedBytes(to_recv);\n+            // Bytes must always be accepted, as this test does not introduce any errors in\n+            // communication.\n+            assert(ret);\n+            // Clear cached expected 'more' information: if certainly no more data was to be sent\n+            // before, receiving bytes makes this uncertain.\n+            if (expect_more[!side] == false) expect_more[!side] = std::nullopt;\n+            // Verify consistency of GetBytesToSend after ReceivedBytes\n+            bytes_to_send_fn(!side);\n+            bool progress = to_recv.size() < old_len;\n+            if (transports[!side]->ReceivedMessageComplete()) {\n+                bool reject{false};\n+                auto received = transports[!side]->GetReceivedMessage({}, reject);\n+                // Receiving must succeed.\n+                assert(!reject);\n+                // There must be a corresponding expected message.\n+                assert(!expected[side].empty());\n+                // The m_message_size field must be correct.\n+                assert(received.m_message_size == received.m_recv.size());\n+                // The m_type must match what is expected.\n+                assert(received.m_type == expected[side].front().m_type);\n+                // The data must match what is expected.\n+                assert(MakeByteSpan(received.m_recv) == MakeByteSpan(expected[side].front().data));\n+                expected[side].pop_front();\n+                progress = true;\n+            }\n+            // Progress must be made (by processing incoming bytes and/or returning complete\n+            // messages) until all received bytes are processed.\n+            assert(progress);\n+        }\n+        // Remove the processed bytes from the in_flight buffer.\n+        in_flight[side].erase(in_flight[side].begin(), in_flight[side].begin() + to_recv_len);\n+        // Return whether anything was received.\n+        return to_recv_len > 0;\n+    };\n+\n+    // Main loop, interleaving new messages, sends, and receives.\n+    LIMITED_WHILE(provider.remaining_bytes(), 1000) {\n+        CallOneOf(provider,\n+            // (Try to) give the next message to the transport.\n+            [&] { new_msg_fn(0); },\n+            [&] { new_msg_fn(1); },\n+            // (Try to) send some bytes from the transport to the network.\n+            [&] { send_fn(0); },\n+            [&] { send_fn(1); },\n+            // (Try to) receive bytes from the network, converting to messages.\n+            [&] { recv_fn(0); },\n+            [&] { recv_fn(1); }\n+        );\n+    }\n+\n+    // When we're done, perform sends and receives of existing messages to flush anything already\n+    // in flight.\n+    while (true) {\n+        bool any = false;\n+        if (send_fn(0, true)) any = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303658001",
      "id" : 1303658001,
      "in_reply_to_id" : 1303035946,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NtD4R",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 300,
      "original_position" : 228,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1592573938,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303658001/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-24T00:15:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303658001",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303658085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303658085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed (replaced by `queues`).",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2023-08-24T00:15:20Z",
      "diff_hunk" : "@@ -92,3 +102,231 @@ FUZZ_TARGET(p2p_transport_serialization, .init = initialize_p2p_transport_serial\n         }\n     }\n }\n+\n+namespace {\n+\n+template<typename R>\n+void SimulationTest(Transport& initiator, Transport& responder, R& rng, FuzzedDataProvider& provider)\n+{\n+    // Simulation test with two Transport objects, which send messages to each other, with\n+    // sending and receiving fragmented into multiple pieces that may be interleaved. It primarily\n+    // verifies that the sending and receiving side are compatible with each other, plus a few\n+    // sanity checks. It does not attempt to introduce errors in the communicated data.\n+\n+    // Put the transports in an array for by-index access.\n+    const std::array<Transport*, 2> transports = {&initiator, &responder};\n+\n+    // Two vectors representing in-flight bytes. inflight[i] is from transport[i] to transport[!i].\n+    std::array<std::vector<uint8_t>, 2> in_flight;\n+\n+    // Two deques with expected messages. expected[i] is expected to arrive in transport[!i].",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1303658085",
      "id" : 1303658085,
      "in_reply_to_id" : 1302858154,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585NtD5l",
      "original_commit_id" : "89b220d44bca232a3dd7f25d839b2075b5a5d642",
      "original_line" : 122,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : null,
      "pull_request_review_id" : 1592574046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303658085/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-08-24T00:15:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1303658085",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1491029750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491029750"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why this sort here? Anybody remembers? It is only used like:\r\n\r\n```cpp\r\ng_all_messages[v % g_all_messages.size()]\r\n```\r\n\r\nwhere `v` is a random number. The sort seems unnecessary?\r\n\r\nThe question arised in: https://github.com/bitcoin/bitcoin/pull/29421#discussion_r1490653235",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2024-02-15T13:43:16Z",
      "diff_hunk" : "@@ -17,16 +19,25 @@\n #include <optional>\n #include <vector>\n \n+namespace {\n+\n+std::vector<std::string> g_all_messages;\n+\n void initialize_p2p_transport_serialization()\n {\n     SelectParams(ChainType::REGTEST);\n+    g_all_messages = getAllNetMessageTypes();\n+    std::sort(g_all_messages.begin(), g_all_messages.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1491029750",
      "id" : 1491029750,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII585Y3072",
      "original_commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "original_line" : 30,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 21,
      "pull_request_review_id" : 1882796958,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491029750/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-15T13:43:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491029750",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1491051732"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491051732"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Well it's not random, it's a fuzzer input. They're random in a way, but definitely not uniformly random.\n\nI think the sorting is there to make sure that just reorderings in the list don't affect fuzzer behavior.",
      "commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "created_at" : "2024-02-15T13:59:00Z",
      "diff_hunk" : "@@ -17,16 +19,25 @@\n #include <optional>\n #include <vector>\n \n+namespace {\n+\n+std::vector<std::string> g_all_messages;\n+\n void initialize_p2p_transport_serialization()\n {\n     SelectParams(ChainType::REGTEST);\n+    g_all_messages = getAllNetMessageTypes();\n+    std::sort(g_all_messages.begin(), g_all_messages.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/28165#discussion_r1491051732",
      "id" : 1491051732,
      "in_reply_to_id" : 1491029750,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII585Y36TU",
      "original_commit_id" : "8a3b6f33873a1075f932f5d9feb6d82e50d83c0c",
      "original_line" : 30,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/test/fuzz/p2p_transport_serialization.cpp",
      "position" : 21,
      "pull_request_review_id" : 1882843069,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/28165",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491051732/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-15T13:59:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1491051732",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
