[
   {
      "author_association" : "MEMBER",
      "body" : "Awesome work, concept ACK.",
      "created_at" : "2020-12-17T15:36:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747514698",
      "id" : 747514698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NzUxNDY5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-17T15:36:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747514698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20788 (net: add RAII socket and use it instead of bare SOCKET by vasild)\n* #20764 (cli -netinfo peer connections dashboard updates ð â¨ by jonatack)\n* #20757 (doc: tor.md and -onlynet help updates by jonatack)\n* #20582 ([doc] Fix documentation of options onlynet and listenonion by wodry)\n* #19415 (net: Make DNS lookup mockable, add fuzzing harness by practicalswift)\n* #19288 (fuzz: Add fuzzing harness for TorController by practicalswift)\n* #19203 (net: Add regression fuzz harness for CVE-2017-18350. Add FuzzedSocket. Add thin SOCKET wrapper. by practicalswift)\n* #19160 (multiprocess: Add basic spawn and IPC support by ryanofsky)\n* #16365 (Log RPC parameters (arguments) if -debug=rpcparams by LarryRuane)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-12-17T20:13:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747675535",
      "id" : 747675535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NzY3NTUzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T10:35:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747675535",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\n----------\r\n\r\nOnce this is enabled, we should clearly communicate that using a non-popular overlay has privacy/security side-effects",
      "created_at" : "2020-12-18T09:05:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747959538",
      "id" : 747959538,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0Nzk1OTUzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-18T09:05:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747959538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@vasild Nice work!\r\n\r\nI like the abstraction  (`Sock`) you've added on top of the socket API. I'm adding something similar in #19203 (see `MockableSocket` and `FuzzedSocket`) to allow for fuzzing the more low-level parts of our networking code (in this specific case a regression fuzz harness for CVE-2017-18350).\r\n\r\nIf you have time: please check that PR out. It would be great if your socket abstraction also covered the needs of the the \"fuzzed socket\" use case. Ideally I'd like to implement my low-level networking code fuzzers using your socket abstraction (something along the lines of `class FuzzedSock : public Sock`) :)\r\n\r\nAside from of the I2P work I think your socket abstraction would be valuable on a stand-alone PR basis :)",
      "created_at" : "2020-12-18T15:09:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-748139978",
      "id" : 748139978,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0ODEzOTk3OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-18T15:10:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/748139978",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549152178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549152178"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Q: in case `retval` contains the maximum allowed data shouldn't it get out of the loop?  I mean, I know this is how the previous version of this method worked but I would like to understand why is this how it is.  ",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-27T18:58:17Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549152178",
      "id" : 549152178,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1MjE3OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/readwritefile.cpp",
      "position" : 29,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549152178",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549154854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549154854"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Non-cpp programmer question: is this idiomatically valid?\r\n \r\n```suggestion\r\nbool WriteBinaryFile(const fs::path &filename, const std::string &data)\r\n{\r\n    FILE *f = fsbridge::fopen(filename, \"wb\");\r\n    if (f == nullptr)\r\n        return false;\r\n    if (fwrite(data.data(), 1, data.size(), f) == data.size()) {\r\n        return fclose(f) == 0;\r\n    }        \r\n    fclose(f);\r\n    return false;\r\n}\r\n```",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-27T19:26:46Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n+{\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n+    if (f == nullptr)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    if (fclose(f) != 0) {\n+        return false;\n+    }\n+    return true;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549154854",
      "id" : 549154854,
      "line" : 47,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1NDg1NA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : 34,
      "path" : "src/util/readwritefile.cpp",
      "position" : 47,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : 34,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549154854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549161698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549161698"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This makes `my`, `my=`, `my==` and so on until `my=====` all equivalent. Is this ok? I would have expected partial padding to be invalid.\r\n",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-27T20:43:01Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549161698",
      "id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE2MTY5OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549161698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549430723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549430723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Build warning here, logical AND of equal expressions [-Wlogical-op]\r\n",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-28T17:48:58Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549430723",
      "id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMDcyMw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559240653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549430723",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549475623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549475623"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Clarification: I am asking this because if this is allow then invalid addresses could be allowed by `SetSpecial`, I mean, something like `udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna=.b32.i2p` would be okay.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-28T20:20:53Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549475623",
      "id" : 549475623,
      "in_reply_to_id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3NTYyMw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 559290249,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549475623",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-12-28T23:05:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-751890774",
      "id" : 751890774,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MTg5MDc3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-28T23:05:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/751890774",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549614683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549614683"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, it should get out of the loop and it does due to `retval.size() <= maxsize`.\r\n\r\nIt is true that if `maxsize==10` and `fread()` returns 7 bytes and then 5 bytes, this function will return a `retval` that contains 12 bytes, exceeding `maxsize`. This is also how it works in `master` right now.\r\n\r\nFor the purposes of this PR it suffices to move `ReadBinaryFile()` out of `torcontrol.cpp` so that it can be reused by other code. So I tried to keep changes to the minimum - moved the function and only fixed a gross bug (commit `util: fix ReadBinaryFile() returning partial contents`).",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T08:27:05Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549614683",
      "id" : 549614683,
      "in_reply_to_id" : 549152178,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDY4Mw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/readwritefile.cpp",
      "position" : 29,
      "pull_request_review_id" : 559425900,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549614683",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549615177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549615177"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, those are the same. I guess, when writing new code, it would be a matter of taste which one to use.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T08:28:46Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n+{\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n+    if (f == nullptr)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    if (fclose(f) != 0) {\n+        return false;\n+    }\n+    return true;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549615177",
      "id" : 549615177,
      "in_reply_to_id" : 549154854,
      "line" : 47,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTE3Nw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : 34,
      "path" : "src/util/readwritefile.cpp",
      "position" : 47,
      "pull_request_review_id" : 559426489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : 34,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549615177",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "a0dc3a2d3...188ba34b4: rebased to resolve conflicts with `master`",
      "created_at" : "2020-12-29T09:40:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752013415",
      "id" : 752013415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjAxMzQxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T09:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752013415",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549640692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549640692"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this on Windows? Which compiler version? Is it upset that `WSAEAGAIN` equals to `WSAEWOULDBLOCK` and so we end up doing something like `err != 5 && err != 5`?\r\n\r\nI checked that gcc 10.2.1, 9.3.0 and 8.4.0 don't emit the warning if we do `err != 5 && err != 6 && err != 5`, so I just reordered the expressions as a simple fixup ro this. Will include in the next push.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T09:51:27Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549640692",
      "id" : 549640692,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY0MDY5Mg==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559456309,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549640692",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549650863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549650863"
         }
      },
      "author_association" : "MEMBER",
      "body" : "gcc Debian 10.2.1",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T10:22:54Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549650863",
      "id" : 549650863,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY1MDg2Mw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559468253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549650863",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "188ba34b4...f0577c4d7:\r\n* disallow partial padding when decoding `.b32.i2p` addresses\r\n* fix gcc warning ~~(hopefully)~~",
      "created_at" : "2020-12-29T12:59:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752066569",
      "id" : 752066569,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjA2NjU2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T18:00:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752066569",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549695916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549695916"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed in f0577c4?",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T13:00:49Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549695916",
      "id" : 549695916,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY5NTkxNg==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559522075,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549695916",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549699366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549699366"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hah, good catch! It occurred to me that we need not to support decoding base32 strings without padding in general and instead we can append `====` to the 52 chars before `.b32.i2p` and decode it as padded base32 string.\r\n\r\nThis simplifies this PR as I dropped one commit from it: `util: support DecodeBase32() without padding`. Also, added a check that the address is 52 base32 chars since we expect that adding 4 `=` symbols will make it multiple of 8. You suggested such a check [elsewhere](https://github.com/bitcoin/bitcoin/pull/20254#discussion_r543586946).",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T13:11:46Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549699366",
      "id" : 549699366,
      "in_reply_to_id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY5OTM2Ng==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 559525983,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549699366",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "f0577c4d7...2ae504c4b: allow uppercase and mixedcase I2P addresses, [suggestion](https://github.com/bitcoin/bitcoin/pull/20254#discussion_r544431918)",
      "created_at" : "2020-12-29T13:27:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752074602",
      "id" : 752074602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjA3NDYwMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T13:27:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752074602",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549765748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549765748"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, thank you -- tested that it is fixed in 188ba34 and in 2ae504c",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-29T16:23:46Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549765748",
      "id" : 549765748,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NTc0OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559605596,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549765748",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341889"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341889"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Time ago Winsock used to have problems with peeking from sockets. According to the KB article below (old) `recv` with `MSG_PEEK`:\r\n\r\n> The peek operation will report the number of bytes up until the first buffer boundary. The bytes remaining in the other boundaries might never be reported, resulting in an incorrect count of data **for code algorithms that depend upon the peek values to be accurate**. Subsequent peek attempts will not reveal the \"hidden\" data, which can still be received from the buffers.\r\n\r\nI don't know if this is still a problem with winsock2 but even in that case it is probably not a problem this algorithm doesn't depend on the accuracy of the `peek_ret` value. Anyway, something to have in mind.\r\n\r\nhttps://mskb.pkisolutions.com/kb/192599",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-30T22:14:44Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341889",
      "id" : 550341889,
      "line" : 1148,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTg4OQ==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1148,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 269,
      "pull_request_review_id" : 560216246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341889",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341913"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that in case it reaches the deadline it should throw because otherwise the timeout will be infringed.\r\n```c++\r\nif (now >= deadline)\r\n```",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-30T22:14:53Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = recv(socket, buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;\n+\n+            data.append(buf, buf + append_len);\n+\n+            if (terminator_found) {\n+                return data;\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now > deadline) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341913",
      "id" : 550341913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTkxMw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1186,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560216246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341913",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550496783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550496783"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, even if the behavior is still the same, we are fine with it.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-31T14:43:30Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550496783",
      "id" : 550496783,
      "in_reply_to_id" : 550341889,
      "line" : 1148,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5Njc4Mw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1148,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 269,
      "pull_request_review_id" : 560396665,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550496783",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550497443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550497443"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, and also `SendComplete()` uses `>=`. Changed.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2020-12-31T14:46:43Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = recv(socket, buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;\n+\n+            data.append(buf, buf + append_len);\n+\n+            if (terminator_found) {\n+                return data;\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now > deadline) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550497443",
      "id" : 550497443,
      "in_reply_to_id" : 550341913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5NzQ0Mw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1186,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560401527,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550497443",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "2ae504c4b...9445dd490: consider it a timeout if the current time is exactly equal to the deadline",
      "created_at" : "2020-12-31T14:47:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752978740",
      "id" : 752978740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1Mjk3ODc0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-31T14:47:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752978740",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-02T13:32:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-753474301",
      "id" : 753474301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MzQ3NDMwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-02T13:32:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/753474301",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Do we actually want to share our address, though? I would think an anonymous connection is strictly better?",
      "created_at" : "2021-01-03T00:22:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-753548139",
      "id" : 753548139,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MzU0ODEzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-03T00:22:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/753548139",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Do we actually want to share our address, though?\r\n\r\nIn I2P, like in IP, connections have \"source address\".\r\n\r\n> I would think an anonymous connection is strictly better?\r\n\r\nWhy? In a P2P network peers are supposed to connect to each other, right? Not hide from each other? If we don't want connections to us, then we don't listen on the I2P address (`-i2pacceptincoming=0`) and nobody can reach back.",
      "created_at" : "2021-01-08T13:39:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-756760413",
      "id" : 756760413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1Njc2MDQxMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-08T13:39:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/756760413",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "9445dd490...1cced4679: rebase due to conflicts",
      "created_at" : "2021-01-09T12:25:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-757141983",
      "id" : 757141983,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NzE0MTk4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-09T12:25:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/757141983",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nðµï¸ @harding @hebasto have been requested to review this pull request as specified in the REVIEWERS file.",
      "created_at" : "2021-01-13T11:46:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-759396675",
      "id" : 759396675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1OTM5NjY3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-13T11:46:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/759396675",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556654746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556654746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this is unnecessary.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-13T16:22:32Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556654746",
      "id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NDc0Ng==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556654746",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556661171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556661171"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What if no `VALUE` is received?",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-13T16:30:59Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556661171",
      "id" : 556661171,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY2MTE3MQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 227,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 227,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556661171",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556670261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556670261"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If there is some kind of `startsWith` function i think it would be better.  ",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-13T16:42:52Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556670261",
      "id" : 556670261,
      "line" : 285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3MDI2MQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 285,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 285,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556670261",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556675792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556675792"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems correct to assume that `RESULT` is always returned but in one place in the i2p code I can see this:\r\n\r\n```c++\r\n} else if (ARG_IS(0,\"NAMING\") &&\r\n           ARG_IS(1, \"REPLY\")) {\r\n    if(NULL == (arg = ARG_FIND(\"RESULT\"))) {\r\n        SAMLOGS(\"Naming reply with no result\");\r\n       return 0;\r\n   }\r\n```",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-13T16:50:23Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556675792",
      "id" : 556675792,
      "line" : 304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3NTc5Mg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 304,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 304,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556675792",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556676518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556676518"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The `Reply` class could have a `isOk()` function, what do you think?",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-13T16:51:28Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556676518",
      "id" : 556676518,
      "line" : 304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3NjUxOA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 304,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 304,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556676518",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558233662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558233662"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You mean the incremental wait time or just this line?",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-15T11:02:14Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558233662",
      "id" : 558233662,
      "in_reply_to_id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzMzY2Mg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 569162831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558233662",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558236009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558236009"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Then we will get an exception which is properly handled. Do you see any problems?",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-15T11:06:35Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558236009",
      "id" : 558236009,
      "in_reply_to_id" : 556661171,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIzNjAwOQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 227,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 227,
      "pull_request_review_id" : 569165674,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558236009",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558275516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558275516"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, if no `RESULT` is present then this function will throw an exception, which is ok. I think we should expect any reply from the I2P proxy, including malicious one.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-15T12:29:55Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558275516",
      "id" : 558275516,
      "in_reply_to_id" : 556675792,
      "line" : 304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI3NTUxNg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 304,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 304,
      "pull_request_review_id" : 569217931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558275516",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558276418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558276418"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it is not worth to add `isOk()` method because it would be used in just one place - here and `reply.Get(\"RESULT\") != \"OK\"` is readable enough.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-15T12:31:44Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558276418",
      "id" : 558276418,
      "in_reply_to_id" : 556676518,
      "line" : 304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODI3NjQxOA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 304,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 304,
      "pull_request_review_id" : 569219166,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558276418",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558332601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558332601"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, I don't see any problem, it is just that I didn't see the exception handling.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-15T14:13:59Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558332601",
      "id" : 558332601,
      "in_reply_to_id" : 556661171,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMzMjYwMQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 227,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 227,
      "pull_request_review_id" : 569293442,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558332601",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558335104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558335104"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Just this line because the next line is a `return true;` ",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-15T14:17:58Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r558335104",
      "id" : 558335104,
      "in_reply_to_id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODMzNTEwNA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 569296700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/558335104",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. This builds and runs cleanly. If anyone is running an i2p service, ping me on irc to try connecting to each other.",
      "created_at" : "2021-01-15T16:38:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761048965",
      "id" : 761048965,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTA0ODk2NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-15T16:38:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761048965",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559052032"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559052032"
         }
      },
      "author_association" : "MEMBER",
      "body" : "i'd use `default: 1`, not \"true\"",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-16T23:23:32Z",
      "diff_hunk" : "@@ -447,7 +447,9 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2psam=<ip:port>\", \"I2P SAM proxy to reach I2P peers and accept I2P connections (default: none)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Notice that listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: true)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559052032",
      "id" : 559052032,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA1MjAzMg==",
      "original_commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "original_line" : 451,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 569974581,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559052032",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "We have an I2P-to-I2P Bitcoin network connection up this Sunday morning. EDIT: 2 connections :tada: \r\n\r\n![Screenshot from 2021-01-17 13-40-57](https://user-images.githubusercontent.com/2415484/104843271-a380ed00-58c1-11eb-8052-cecc354fc6bc.png)\r\n\r\nIf helpful, I added the following setting to `~/.bitcoin/bitcoin.conf`\r\n```\r\ni2psam=127.0.0.1:7656\r\n```\r\n ",
      "created_at" : "2021-01-17T11:53:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761799484",
      "id" : 761799484,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTc5OTQ4NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:44:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761799484",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "It needs to be anonymous others wise i2p address will never work fully\nOn Sun, Jan 17, 2021 at 6:55 AM Jon Atack <notifications@github.com> wrote:\n\n> We have an I2P-to-I2P Bitcoin network connection up this Sunday morning.\n>\n> [image: Screenshot from 2021-01-17 11-41-47]\n> <https://user-images.githubusercontent.com/2415484/104839627-3027ad00-58ba-11eb-8cc6-8c572d222561.png>\n>\n> If helpful, I added the following settings to ~/.bitcoin/bitcoin.conf\n>\n> i2psam=127.0.0.1:7656\n> i2pacceptincoming=1\n>\n> â\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761799484>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ASPKBM7LRCYPKYZKNVKG6GLS2LF4RANCNFSM4U7TL45Q>\n> .\n>\n",
      "created_at" : "2021-01-17T12:01:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761800688",
      "id" : 761800688,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgwMDY4OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:01:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761800688",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/77504691?v=4",
         "events_url" : "https://api.github.com/users/mshalabi1990/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mshalabi1990/followers",
         "following_url" : "https://api.github.com/users/mshalabi1990/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mshalabi1990/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mshalabi1990",
         "id" : 77504691,
         "login" : "mshalabi1990",
         "node_id" : "MDQ6VXNlcjc3NTA0Njkx",
         "organizations_url" : "https://api.github.com/users/mshalabi1990/orgs",
         "received_events_url" : "https://api.github.com/users/mshalabi1990/received_events",
         "repos_url" : "https://api.github.com/users/mshalabi1990/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mshalabi1990/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mshalabi1990/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mshalabi1990"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "It needs to be annymous to full work or else it will never work fully decentralized ",
      "created_at" : "2021-01-17T12:03:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761800993",
      "id" : 761800993,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgwMDk5Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:03:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761800993",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/77504691?v=4",
         "events_url" : "https://api.github.com/users/mshalabi1990/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mshalabi1990/followers",
         "following_url" : "https://api.github.com/users/mshalabi1990/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mshalabi1990/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mshalabi1990",
         "id" : 77504691,
         "login" : "mshalabi1990",
         "node_id" : "MDQ6VXNlcjc3NTA0Njkx",
         "organizations_url" : "https://api.github.com/users/mshalabi1990/orgs",
         "received_events_url" : "https://api.github.com/users/mshalabi1990/received_events",
         "repos_url" : "https://api.github.com/users/mshalabi1990/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mshalabi1990/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mshalabi1990/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mshalabi1990"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559171894"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559171894"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "[`HasPrefix()`](https://github.com/bitcoin/bitcoin/blob/30e664dcce1a9adb9ba9a29e4f0cf809767870dd/src/util/string.h#L82-L88) is a good candidate, would need some enchanting.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T12:07:05Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559171894",
      "id" : 559171894,
      "in_reply_to_id" : 556670261,
      "line" : 285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MTg5NA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 285,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 285,
      "pull_request_review_id" : 570050987,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559171894",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172021"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ok :)",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T12:07:50Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172021",
      "id" : 559172021,
      "in_reply_to_id" : 556661171,
      "line" : 227,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MjAyMQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 227,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 227,
      "pull_request_review_id" : 570051048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172021",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172712"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You are right, removed!",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T12:13:45Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559172712",
      "id" : 559172712,
      "in_reply_to_id" : 556654746,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MjcxMg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : null,
      "pull_request_review_id" : 570051545,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559172712",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559173945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559173945"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Changed.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T12:24:09Z",
      "diff_hunk" : "@@ -447,7 +447,9 @@ void SetupServerArgs(NodeContext& node)\n     argsman.AddArg(\"-maxtimeadjustment\", strprintf(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\", DEFAULT_MAX_TIME_ADJUSTMENT), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-maxuploadtarget=<n>\", strprintf(\"Tries to keep outbound traffic under the given target (in MiB per 24h). Limit does not apply to peers with 'download' permission. 0 = no limit (default: %d)\", DEFAULT_MAX_UPLOAD_TARGET), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     argsman.AddArg(\"-onion=<ip:port>\", \"Use separate SOCKS5 proxy to reach peers via Tor onion services, set -noonion to disable (default: -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-    argsman.AddArg(\"-onlynet=<net>\", \"Make outgoing connections only through network <net> (ipv4, ipv6 or onion). Incoming connections are not affected by this option. This option can be specified multiple times to allow multiple networks.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2psam=<ip:port>\", \"I2P SAM proxy to reach I2P peers and accept I2P connections (default: none)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    argsman.AddArg(\"-i2pacceptincoming\", \"If set and -i2psam is also set then incoming I2P connections are accepted via the SAM proxy. If this is not set but -i2psam is set then only outgoing connections will be made to the I2P network. Ignored if -i2psam is not set. Notice that listening for incoming I2P connections is done through the SAM proxy, not by binding to a local address and port (default: true)\", ArgsManager::ALLOW_BOOL, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559173945",
      "id" : 559173945,
      "in_reply_to_id" : 559052032,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3Mzk0NQ==",
      "original_commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "original_line" : 451,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 570052304,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559173945",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "1cced4679...45e571315: rebase and address suggestions",
      "created_at" : "2021-01-17T12:24:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761803815",
      "id" : 761803815,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgwMzgxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T12:24:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761803815",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559199774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559199774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "clang formatting nit here and just above\r\n```suggestion\r\n        if (!(pollfd_entry.revents & (POLLERR | POLLHUP))) {\r\n```",
      "commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "created_at" : "2021-01-17T15:50:10Z",
      "diff_hunk" : "@@ -613,6 +616,120 @@ SOCKET CreateSocket(const CService &addrConnect)\n     return hSocket;\n }\n \n+#ifdef USE_POLL\n+void SocketEvents(Sockets& sockets,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    std::unordered_map<SOCKET, struct pollfd> pollfds;\n+\n+    for (SOCKET socket_id : sockets.recv) {\n+        pollfds[socket_id].fd = socket_id;\n+        pollfds[socket_id].events |= POLLIN;\n+    }\n+\n+    for (SOCKET socket_id : sockets.send) {\n+        pollfds[socket_id].fd = socket_id;\n+        pollfds[socket_id].events |= POLLOUT;\n+    }\n+\n+    for (SOCKET socket_id : sockets.err) {\n+        pollfds[socket_id].fd = socket_id;\n+        // These flags are ignored, but we set them for clarity\n+        pollfds[socket_id].events |= POLLERR|POLLHUP;\n+    }\n+\n+    std::vector<struct pollfd> vpollfds;\n+    vpollfds.reserve(pollfds.size());\n+    for (auto it : pollfds) {\n+        vpollfds.push_back(std::move(it.second));\n+    }\n+\n+    if (poll(vpollfds.data(), vpollfds.size(), timeout.count()) < 0) return;\n+\n+    if (interrupt) {\n+        return;\n+    }\n+\n+    for (struct pollfd pollfd_entry : vpollfds) {\n+        if (!(pollfd_entry.revents & POLLIN)) {\n+            sockets.recv.erase(pollfd_entry.fd);\n+        }\n+        if (!(pollfd_entry.revents & POLLOUT)) {\n+            sockets.send.erase(pollfd_entry.fd);\n+        }\n+        if (!(pollfd_entry.revents & (POLLERR|POLLHUP))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559199774",
      "id" : 559199774,
      "line" : 661,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE5OTc3NA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 661,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 120,
      "pull_request_review_id" : 570069439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-17T18:12:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559199774",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Stepping through the commits and building one-by-one.\r\n\r\nIn 87ebd74 `SocketEvents()` `interrupt` is used like an \"in\" param but it is passed by reference like an \"out\" param\r\n```diff\r\n+++ b/src/net.h\r\n@@ -1069,8 +1069,9 @@ private:\r\n      * @param[in,out] sockets When the function is called this is expected to contain the\r\n      * sockets that should be checked for readiness. Upon return only ready sockets are\r\n      * left in it (non-ready sockets are removed).\r\n+     * @param[in] interrupt Cancel the operation if this is signaled.\r\n      */\r\n-    void SocketEvents(Sockets& sockets);\r\n+    void SocketEvents(Sockets& sockets, CThreadInterrupt& interrupt);\r\n```\r\n",
      "created_at" : "2021-01-17T16:11:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761836549",
      "id" : 761836549,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTgzNjU0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T16:11:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761836549",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Starting from ad56288e9b2f, it seems the various `std::chrono::milliseconds timeout` params can be passed by value.",
      "created_at" : "2021-01-17T16:42:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761841535",
      "id" : 761841535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTg0MTUzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T16:42:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761841535",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559213448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559213448"
         }
      },
      "author_association" : "MEMBER",
      "body" : "782de68a7008a\r\n```suggestion\r\n    const CAddress addr_bind = GetBindAddress(socket);\r\n```",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T17:37:38Z",
      "diff_hunk" : "@@ -1013,26 +1028,44 @@ bool CConnman::AttemptToEvictConnection()\n void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    SOCKET socket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n     CAddress addr;\n-    int nInbound = 0;\n-    int nMaxInbound = nMaxConnections - m_max_outbound;\n \n-    if (hSocket != INVALID_SOCKET) {\n-        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-            LogPrintf(\"Warning: Unknown socket family\\n\");\n+    if (socket == INVALID_SOCKET) {\n+        const int nErr = WSAGetLastError();\n+        if (nErr != WSAEWOULDBLOCK) {\n+            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n         }\n+        return;\n+    }\n+\n+    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n+        LogPrintf(\"Warning: Unknown socket family\\n\");\n     }\n \n-    NetPermissionFlags permissionFlags = NetPermissionFlags::PF_NONE;\n-    hListenSocket.AddSocketPermissionFlags(permissionFlags);\n-    AddWhitelistPermissionFlags(permissionFlags, addr);\n-    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_ISIMPLICIT)) {\n-        NetPermissions::ClearFlag(permissionFlags, PF_ISIMPLICIT);\n-        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permissionFlags, PF_FORCERELAY);\n-        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permissionFlags, PF_RELAY);\n-        NetPermissions::AddFlag(permissionFlags, PF_MEMPOOL);\n-        NetPermissions::AddFlag(permissionFlags, PF_NOBAN);\n+    const CAddress& addr_bind = GetBindAddress(socket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559213448",
      "id" : 559213448,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIxMzQ0OA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 1046,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 570069439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559213448",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Consider dropping a3b33637f as the renaming is to a generic name that is less useful for searching for the variable in the code (false positives go from none to many), or renaming to a more unique name but the current one seems fine; this isn't new code.\r\n\r\nEdit: same feedback for ccc5966a; consider dropping the change or using a slightly less generic name, like `permission_flags`. This isn't new code, so you aren't required to rename the variables.",
      "created_at" : "2021-01-17T17:59:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-761852969",
      "id" : 761852969,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MTg1Mjk2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-17T18:11:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/761852969",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229369"
         }
      },
      "author_association" : "MEMBER",
      "body" : "484dc6559 suggest adding quotes and/or removing the trailing \".\" (if you add quotes here, maybe also line 298)\r\n```suggestion\r\n    // I2P addresses that we support consist of 52 base32 characters + \".b32.i2p\"\r\n```",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T19:48:42Z",
      "diff_hunk" : "@@ -275,6 +284,33 @@ bool CNetAddr::SetSpecial(const std::string& str)\n     return false;\n }\n \n+bool CNetAddr::SetI2P(const std::string& str)\n+{\n+    // I2P addresses that we support consist of 52 base32 characters + .b32.i2p.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229369",
      "id" : 559229369,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIyOTM2OQ==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 289,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/netaddress.cpp",
      "position" : null,
      "pull_request_review_id" : 570088398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229369",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "484dc65591b perhaps a few additional sanity checks\r\n```diff\r\n@@ -321,6 +321,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\r\n     BOOST_REQUIRE(addr.IsTor());\r\n \r\n+    BOOST_CHECK(!addr.IsI2P());\r\n     BOOST_CHECK(!addr.IsBindAny());\r\n     BOOST_CHECK(addr.IsAddrV1Compatible());\r\n     BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\r\n@@ -331,6 +332,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\r\n     BOOST_REQUIRE(addr.IsTor());\r\n \r\n+    BOOST_CHECK(!addr.IsI2P());\r\n     BOOST_CHECK(!addr.IsBindAny());\r\n     BOOST_CHECK(!addr.IsAddrV1Compatible());\r\n     BOOST_CHECK_EQUAL(addr.ToString(), torv3_addr);\r\n@@ -357,6 +359,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\r\n     BOOST_REQUIRE(addr.IsI2P());\r\n \r\n+    BOOST_CHECK(!addr.IsTor());\r\n     BOOST_CHECK(!addr.IsBindAny());\r\n     BOOST_CHECK(!addr.IsAddrV1Compatible());\r\n     BOOST_CHECK_EQUAL(addr.ToString(), ToLower(i2p_addr));\r\n```\r\n",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-17T19:52:18Z",
      "diff_hunk" : "@@ -351,6 +351,34 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     // TOR, invalid base32\n     BOOST_CHECK(!addr.SetSpecial(std::string{\"mf*g zak.onion\"}));\n \n+    // I2P\n+    const char* i2p_addr = \"UDHDrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.I2P\";\n+    BOOST_REQUIRE(addr.SetSpecial(i2p_addr));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsI2P());\n+\n+    BOOST_CHECK(!addr.IsBindAny());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559229820",
      "id" : 559229820,
      "line" : 363,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIyOTgyMA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 363,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 27,
      "pull_request_review_id" : 570088398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:04:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559229820",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK. Built and working with no major issues.",
      "created_at" : "2021-01-18T07:45:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762052790",
      "id" : 762052790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjA1Mjc5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-18T07:45:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762052790",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3072149?v=4",
         "events_url" : "https://api.github.com/users/duncandean/events{/privacy}",
         "followers_url" : "https://api.github.com/users/duncandean/followers",
         "following_url" : "https://api.github.com/users/duncandean/following{/other_user}",
         "gists_url" : "https://api.github.com/users/duncandean/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/duncandean",
         "id" : 3072149,
         "login" : "duncandean",
         "node_id" : "MDQ6VXNlcjMwNzIxNDk=",
         "organizations_url" : "https://api.github.com/users/duncandean/orgs",
         "received_events_url" : "https://api.github.com/users/duncandean/received_events",
         "repos_url" : "https://api.github.com/users/duncandean/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/duncandean/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/duncandean/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/duncandean"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "45e571315...b49a4a06e: address review suggestions\r\n\r\n> SocketEvents() interrupt is used like an \"in\" param but it is passed by reference like an \"out\" param\r\n\r\nThe `sleep_for()` method of `CThreadInterrupt` is not `const`, thus the variable is passed by non-`const` reference. I changed the comment to say `@param[in,out]`.\r\n\r\n> Starting from ad56288, it seems the various std::chrono::milliseconds timeout params can be passed by value.\r\n\r\nI am not sure those are trivial types like `int`, `double`, etc. Thus I pass them by `const` reference.\r\n\r\n> Consider dropping a3b3363 as the renaming...\r\n\r\nDropped the two renames, reducing the size of this PR.\r\n\r\nNote: if the above were posted as \"review comments\" attached to some line, then the replies would be next to them and also they could be hidden/collapsed once resolved.",
      "created_at" : "2021-01-18T16:04:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762340697",
      "id" : 762340697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjM0MDY5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-18T16:13:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762340697",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559673351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559673351"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added, thanks!",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-18T16:13:56Z",
      "diff_hunk" : "@@ -351,6 +351,34 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     // TOR, invalid base32\n     BOOST_CHECK(!addr.SetSpecial(std::string{\"mf*g zak.onion\"}));\n \n+    // I2P\n+    const char* i2p_addr = \"UDHDrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.I2P\";\n+    BOOST_REQUIRE(addr.SetSpecial(i2p_addr));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsI2P());\n+\n+    BOOST_CHECK(!addr.IsBindAny());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559673351",
      "id" : 559673351,
      "in_reply_to_id" : 559229820,
      "line" : 363,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3MzM1MQ==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 363,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/test/net_tests.cpp",
      "position" : 27,
      "pull_request_review_id" : 570629149,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:13:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559673351",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675066"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added quotes, but left the dot.\r\n\r\n```cpp\r\n// Comments start with a capital letter and end with a dot, like real sentences.\r\n```\r\n\r\n```cpp\r\n// Comments start with a capital letter and end with a dot, like real sentences. This\r\n// makes it easy to extend with another sentence.\r\n```",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-18T16:16:53Z",
      "diff_hunk" : "@@ -275,6 +284,33 @@ bool CNetAddr::SetSpecial(const std::string& str)\n     return false;\n }\n \n+bool CNetAddr::SetI2P(const std::string& str)\n+{\n+    // I2P addresses that we support consist of 52 base32 characters + .b32.i2p.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675066",
      "id" : 559675066,
      "in_reply_to_id" : 559229369,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NTA2Ng==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 289,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/netaddress.cpp",
      "position" : null,
      "pull_request_review_id" : 570631381,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:16:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675066",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675424"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675424"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "b49a4a06e3cac6ad65be9d394cf10b7d8153e1c3",
      "created_at" : "2021-01-18T16:17:27Z",
      "diff_hunk" : "@@ -1013,26 +1028,44 @@ bool CConnman::AttemptToEvictConnection()\n void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n-    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    SOCKET socket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n     CAddress addr;\n-    int nInbound = 0;\n-    int nMaxInbound = nMaxConnections - m_max_outbound;\n \n-    if (hSocket != INVALID_SOCKET) {\n-        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-            LogPrintf(\"Warning: Unknown socket family\\n\");\n+    if (socket == INVALID_SOCKET) {\n+        const int nErr = WSAGetLastError();\n+        if (nErr != WSAEWOULDBLOCK) {\n+            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n         }\n+        return;\n+    }\n+\n+    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n+        LogPrintf(\"Warning: Unknown socket family\\n\");\n     }\n \n-    NetPermissionFlags permissionFlags = NetPermissionFlags::PF_NONE;\n-    hListenSocket.AddSocketPermissionFlags(permissionFlags);\n-    AddWhitelistPermissionFlags(permissionFlags, addr);\n-    if (NetPermissions::HasFlag(permissionFlags, NetPermissionFlags::PF_ISIMPLICIT)) {\n-        NetPermissions::ClearFlag(permissionFlags, PF_ISIMPLICIT);\n-        if (gArgs.GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) NetPermissions::AddFlag(permissionFlags, PF_FORCERELAY);\n-        if (gArgs.GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)) NetPermissions::AddFlag(permissionFlags, PF_RELAY);\n-        NetPermissions::AddFlag(permissionFlags, PF_MEMPOOL);\n-        NetPermissions::AddFlag(permissionFlags, PF_NOBAN);\n+    const CAddress& addr_bind = GetBindAddress(socket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r559675424",
      "id" : 559675424,
      "in_reply_to_id" : 559213448,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTY3NTQyNA==",
      "original_commit_id" : "45e571315a87f4443b41a6c202144e20c3c75caa",
      "original_line" : 1046,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 570631811,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-18T16:17:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/559675424",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "A few notes:\r\n\r\n* We use SAM version 3.1 (`HELLO VERSION MIN=3.1 MAX=3.1`) because it is the maximum supported by the C++ i2p daemon (as of i2pd 2.35.0).\r\n\r\n* Ports seem to be ignored, so I default them to `8333`. [SAM 3.2](https://geti2p.net/en/docs/api/samv3) defines `FROM_PORT` and `TO_PORT`, but we use SAM 3.1. As a consequence we can connect to any port on a given I2P address - once we listen on `foo.b32.i2p`, a peer can connect to us on `foo.b32.i2p:8333`, `foo.b32.i2p:1234`, `foo.b32.i2p:80`, etc.\r\n\r\n* ~~`RemoveLocal()` is not called if the connection to the I2P daemon dies, e.g. the I2P daemon is shut down. In order to stop advertising our I2P address (via other connections, if we have such ones, e.g. IPv4) we need to do that. Probably `Session::Accept()` needs to be split to two methods: `Session:Listen()` and `Session::Accept()`.~~ [Fixed](https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765239583).",
      "created_at" : "2021-01-18T16:40:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762360140",
      "id" : 762360140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjM2MDE0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T08:59:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762360140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I am not sure those are trivial types like `int`, `double`, etc. Thus I pass them by `const` reference.\r\n\r\nIIUC according to https://en.cppreference.com/w/cpp/chrono/duration \"The only data stored in a duration is a tick count of type Rep\": `std::chrono::milliseconds | duration</*signed integer type of at least 45 bits*/, std::milli>`. If that is correct, it would be nice to avoid a situation like with CAmounts, which are a cheaply copied value but are passed around by reference to const all over this codebase, presumably because early on someone thought it wasn't cheap and then that style was replicated in code changes down the line. Not a huge issue but we may as well start off on the right foot.\r\n\r\n",
      "created_at" : "2021-01-18T23:53:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-762519047",
      "id" : 762519047,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MjUxOTA0Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-23T16:51:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762519047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yes, @leonardojobim connected to me and saw the addnode remove issue, thanks for confirming. @vasild and I encountered it as well.",
      "created_at" : "2021-01-20T10:23:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-763501409",
      "id" : 763501409,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2MzUwMTQwOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-20T10:23:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/763501409",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "b49a4a06e...39021d931:\r\n\r\n* Split the `Accept()` method to `Listen()` and `Accept()`, so that the caller from `net.cpp` can do `AddLocal()` when we are listening and `RemoveLocal()` when listening fails (e.g. the I2P proxy is shut down).\r\n\r\n* Do not `AddLocal()` after we connect to a I2P peer - should only do this when listening. As a result the newly added function `AddLocalIfNotKnown()` is not needed and thus dropped.\r\n\r\n* After a failure to listen, accept or connect - check whether the control socket is still connected and if not, then destroy the session. This is not strictly necessary, but makes us detect a possible I2P proxy shutdown earlier.\r\n\r\n* If `-listen=0` is given, then soft-flip `-i2pacceptincoming` from `1` to `0`. Still, if `-listen=0 -i2pacceptincoming=1` is explicitly given, then allow that as there is no technical reason it would not work as expected (listen for and accept only I2P connections).\r\n",
      "created_at" : "2021-01-22T08:41:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765239583",
      "id" : 765239583,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NTIzOTU4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T08:41:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/765239583",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "39021d931...7da1e29fc: rebase due to conflicts",
      "created_at" : "2021-01-22T13:25:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765393582",
      "id" : 765393582,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NTM5MzU4Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T13:25:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/765393582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-22T13:26:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-765394346",
      "id" : 765394346,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NTM5NDM0Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-22T13:26:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/765394346",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-26T11:12:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-767474130",
      "id" : 767474130,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzQ3NDEzMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T11:12:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767474130",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm still testing this on one of my nodes. It is working great. I've had a few connections to other I2P peers.\r\n\r\nI'm testing with the Java implementation of I2P, it has some typical java problems like high CPU and memory use. Compared to Tor at least. Of course, this is not the fault of this PR :slightly_smiling_face: \r\n\r\nAnother thing (that @jonatack) noted is that I2P has higher latency than Tor onion services. At least I suppose this is an inherent problem with I2P and not the code here. Network latency is not generally a problem for bitcoin but as eviction decisions are made based on (among other things) ping times. This might be something to look into, but not necessarily in this PR, as a first step *adding I2P support* at all is a good and self-contained change.\r\n",
      "created_at" : "2021-01-26T11:37:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-767486499",
      "id" : 767486499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzQ4NjQ5OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T11:44:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767486499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Another thing (that @jonatack) noted is that I2P has higher latency than Tor onion services. At least I suppose this is an inherent problem with I2P and not the code here. Network latency is not generally a problem for bitcoin but as eviction decisions are made based on (among other things) ping times. This might be something to look into, but not necessarily in this PR.\r\n\r\nWorking on this either for #20197 or a follow-up. \r\n",
      "created_at" : "2021-01-26T13:06:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-767529236",
      "id" : 767529236,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzUyOTIzNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T13:06:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767529236",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   }
]
