[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Strong concept ACK! Seems like a big improvement.\r\n\r\nCan you comment more on the 6 seconds claim? AFAIK each bench was supposed to target running for 1 second? Is this no longer required to reduce variance?\r\n\r\n\r\nSecondly -- and separately -- can you comment on how this might impact the need for something like #17375? Can we add better support for benchmarks where we want to run with different scaling params and output each trial to get a sense of the complexity? ",
      "created_at" : "2020-01-27T22:09:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-578978817",
      "id" : 578978817,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3ODk3ODgxNw==",
      "updated_at" : "2020-01-27T22:09:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/578978817",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I calculate a good number of iterations based on the clock accuracy, then perform these iterations a few times and use the median to get rid of outliers. I found it actually to be more reliable with shorter runs, because there is less chance for random fluctuations to interfer. It is necessary though to disable frequency scaling etc (but this should be done with the old framework too anyways). This can be easily done with e.g pyperf\r\n\r\nConcerning https://github.com/bitcoin/bitcoin/pull/17375, nanobench can estimate complexity, but it requires a bit of code change: https://github.com/martinus/nanobench/blob/master/docs/reference.md#asymptotic-complexity",
      "created_at" : "2020-01-27T22:21:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-578983430",
      "id" : 578983430,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3ODk4MzQzMA==",
      "updated_at" : "2020-01-27T22:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/578983430",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19377 (bench: Add OrphanTxPool benchmark by hebasto)\n* #19326 (Simplify hash.h interface using Spans by sipa)\n* #19280 (Verify the block filter hash when reading from disk. by pstratem)\n* #19181 (Add ASM optimizations for MuHash3072 by fjahr)\n* #19145 (Add hash_type MUHASH for gettxoutsetinfo by fjahr)\n* #19055 (Add MuHash3072 implementation by fjahr)\n* #18815 (bench: Add logging benchmark by MarcoFalke)\n* #18731 (refactor: Make CCheckQueue RAII-styled by hebasto)\n* #18710 (Add local thread pool to CCheckQueue by hebasto)\n* #18354 (Use shared pointers only in validation interface by bvbfan)\n* #18261 (Erlay: bandwidth-efficient transaction relay protocol by naumenkogs)\n* #18014 (lib: Optimizing siphash implementation by elichai)\n* #17526 (Use Single Random Draw In addition to knapsack as coin selection fallback by achow101)\n* #17331 (Use effective values throughout coin selection by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-01-28T01:49:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579041181",
      "id" : 579041181,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTA0MTE4MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T19:13:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579041181",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "The lint check currently fails with this error:\r\n\r\n> fatal: bad revision '8b138526b5dc...488d538cbf6f'\r\n\r\nI believe the reason is some key verification check at the end of ci/lint/06_script.sh, but I can't really say why this is failing",
      "created_at" : "2020-01-28T07:00:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579108323",
      "id" : 579108323,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTEwODMyMw==",
      "updated_at" : "2020-01-28T07:00:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579108323",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\n\r\n\r\nThe travis failure is\r\n\r\n```\r\nThe locale dependent function std::to_string(...) appears to be used:\r\n\r\nsrc/bench/nanobench.h:            auto sysCpu = \"/sys/devices/system/cpu/cpu\" + std::to_string(id);\r\n\r\nsrc/bench/nanobench.h:                warnings.emplace_back(\"CPU frequency scaling enabled: CPU \" + std::to_string(id) + \" between \" +\r\n\r\nUnnecessary locale dependence can cause bugs that are very\r\n\r\ntricky to isolate and fix. Please avoid using locale dependent\r\n\r\nfunctions if possible.\r\n\r\nAdvice not applicable in this specific case? Add an exception\r\n\r\nby updating the ignore list in test/lint/lint-locale-dependence.sh\r\n\r\n^---- failure generated from test/lint/lint-locale-dependence.sh",
      "created_at" : "2020-01-28T15:05:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579288765",
      "id" : 579288765,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTI4ODc2NQ==",
      "updated_at" : "2020-01-28T15:05:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579288765",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Would it be easy to hack in csv output that is somewhat similar to the existing output? The markdown table looks a little tricky to parse programmatically (though it could be done). For example, bitcoinperf (https://github.com/chaincodelabs/bitcoinperf) currently relies on this format. ",
      "created_at" : "2020-01-28T15:24:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579298846",
      "id" : 579298846,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTI5ODg0Ng==",
      "updated_at" : "2020-01-28T15:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579298846",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The locale dependent function std::to_string(...) appears to be used:\r\n\r\nAh, ok I'll fix this\r\n\r\n> Would it be easy to hack in csv output that is somewhat similar to the existing output?\r\n\r\nI think it should be easy, in nanobench I already have CSV & JSON output format using [mustache-like templates](https://github.com/martinus/nanobench/blob/master/docs/reference.md#processing-results), so it's possible to create a custom format. I have not exposed this feature yet though in this PR.",
      "created_at" : "2020-01-28T15:53:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579315933",
      "id" : 579315933,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTMxNTkzMw==",
      "updated_at" : "2020-01-28T15:53:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579315933",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Strong concept ACK\r\n\r\n@martinus, thanks for your great contributions! Please keep them coming :)",
      "created_at" : "2020-01-28T16:49:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579345876",
      "id" : 579345876,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTM0NTg3Ng==",
      "updated_at" : "2020-01-28T16:49:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579345876",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Does this library also does memory clobbers and barriers? (like google's `DoNotOptimize`[0], `ClobberMemory`[1], or Rust's `black_box`[2])\r\n\r\n[0] https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307\r\n[1] https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L326\r\n[2] https://doc.rust-lang.org/std/hint/fn.black_box.html",
      "created_at" : "2020-01-28T17:02:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579352138",
      "id" : 579352138,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTM1MjEzOA==",
      "updated_at" : "2020-01-28T17:02:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579352138",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Does this library also does memory clobbers and barriers? (like google's `DoNotOptimize`[0], `ClobberMemory`[1], or Rust's `black_box`[2])\r\n\r\nI currently have `doNotOptimizeAway`, which is based on [folly](https://github.com/facebook/folly/blob/master/folly/Benchmark.h)'s benchmark. I think folly's version is based on google benchmark. I have not added `doNotOptimizeAway` calls in the PR because I did not want to modify each benchmark too much\r\n\r\nI don't have clobberMemory yet, because I've never used it... What I'm also doing is I force the `run(...)` to be noinline to prevent some optimizations.",
      "created_at" : "2020-01-28T17:11:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579356379",
      "id" : 579356379,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTM1NjM3OQ==",
      "updated_at" : "2020-01-28T17:11:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579356379",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Is it possible to make the nanobench include a submodule (like secp256k1 or univalue) so that it's easier for us to pull in updates from upstream? If you plan on adding new features to nanobench, that should help streamline review potentially. If you think that there will be Bitcoin specific changes made to the header that you wouldn't want to upstream, then I would leave it as you've done.",
      "created_at" : "2020-01-28T20:11:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579433076",
      "id" : 579433076,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTQzMzA3Ng==",
      "updated_at" : "2020-01-28T20:11:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579433076",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Closed https://github.com/bitcoin/bitcoin/pull/17375 in favor of nanobench. When you have time would love assistance in making the asymptotic test introduced there nanobench compatible.\r\n\r\n\r\nBeing able to run asymptotic tests on the code is going to be a huge help with advocating for mempool policy changes in the future (e.g., loosening descendants limit) once the epoch mempool work is completed. This also impacts other parts of the code (e.g., wallet) where right now we don't have good insight into if we introduce a regression. I think the curve fitting is a bit less useful because we do care about the constant factors too (e.g., if we're a O(n log n) v.s. O(n) but c > log n for max n), but it's quite nifty nonetheless. ",
      "created_at" : "2020-01-28T20:21:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579437431",
      "id" : 579437431,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTQzNzQzMQ==",
      "updated_at" : "2020-01-28T20:21:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579437431",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Is it possible to make the nanobench include a submodule (like secp256k1 or univalue)\r\n\r\nI think it should be possible, I need to read up how git-subtree works... I prefer if nanobench stays generic, and try to implement bitcoin's requirement in a generic way so it's usable by others too. So no separate repository if possible.\r\n\r\n> When you have time would love assistance in making the asymptotic test introduced there nanobench compatible.\r\n\r\nSure, I'll have a look at https://github.com/bitcoin/bitcoin/pull/17375 when I have time! I can't predict how soon this is though.",
      "created_at" : "2020-01-29T09:46:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579675970",
      "id" : 579675970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTY3NTk3MA==",
      "updated_at" : "2020-01-29T09:46:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579675970",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Haven't looked at the library itself yet, but Concept ACK on replacing the current framework. (I really dislike it)\r\nPersonally I also would've been fine with dynamically linking against google's benchmarking library (https://github.com/google/benchmark)",
      "created_at" : "2020-01-29T09:52:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579678349",
      "id" : 579678349,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTY3ODM0OQ==",
      "updated_at" : "2020-01-29T09:53:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579678349",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : ">  Personally I also would've been fine with dynamically linking against google's benchmarking library (https://github.com/google/benchmark)\r\n\r\nI don't think google benchmark is viable here. It's a large dependency, and you also need to use the gtest framework for this. It would be quite a big change.",
      "created_at" : "2020-01-29T11:46:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-579719346",
      "id" : 579719346,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3OTcxOTM0Ng==",
      "updated_at" : "2020-01-29T11:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/579719346",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2020-01-30T03:16:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-580065007",
      "id" : 580065007,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MDA2NTAwNw==",
      "updated_at" : "2020-01-30T03:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/580065007",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "We discussed nanobench today in the IRC Meeting. There's seems to be general agreement that this is a nice idea, and that the current bench framework isn't perfect.\r\n\r\nOur current bench framework is actually based on Google's, and I think most people are opposed to linking google's whole thing.\r\n\r\nWith respect to the question of if to subtree or not: let's ignore that for now, copied in is fine, and we can deal with that in the future if we require changes to nanobench or if there are new features in nanobench we want to incorporate.\r\n\r\nThere's some concern about maintaining compatibility with existing tools. I think given that the output is fundamentally different from before (no longer reporting iterations and things like that) we can't have perfect parity. But perhaps we could:\r\n\r\n1. \"backport\" on top of the last few releases (no new release) so that we have a bit more history to compare with\r\n2. Add a compatibility mode which emits something similar to the previous output with NaN subsituted where nanobench has no equivalent value. \r\n3. Ignore compatibility, but do support output into a nice machine-readable format.\r\n\r\nI think most people would be satisfied with 3, as 2 can be done a script on 3's output and 1 can be done if someone has the itch for it.",
      "created_at" : "2020-01-30T20:15:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-580440077",
      "id" : 580440077,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MDQ0MDA3Nw==",
      "updated_at" : "2020-01-30T20:15:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/580440077",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the summary! I just read through the log [here](http://www.erisian.com.au/meetbot/bitcoin-core-dev/2020/bitcoin-core-dev.2020-01-30-19.00.log.html) and think I can add a few clarifications:\r\n\r\n> I think if we can do a cursory check it's not actually malware\r\n\r\nIt's not malware, not sure how I can help here :) I've created nanobench because I was annoyed at how difficult other benchmarking frameworks were to integrate into existing codebase because I don't like google test.\r\n\r\n> For example, a lot of tools rely on the output format of the current bench framework\r\n\r\nI have templating support in nanobench, and I can relatively easily add another output format that resembles the current output format closely. I need to do some improvements to the available data in nanobench, then I can use a template liks this to produce practically the same output as before:\r\n\r\n```\r\n# Benchmark, evals, iterations, total, min, max, median\r\n{{#benchmarks}} {{name}}, {{num_measurements}}, {{total_iters}}, {{total_runtime}}, {{min}}, {{max}}, {{median}}\r\n{{/benchmarks}}\r\n```\r\n\r\nThen I can e.g. print the markdown tables to stdout, and create e.g. `benchmarkresults.csv` along with it based on the template format. \r\n\r\n> <jeremyrubin> I beleive nanobench autodetects variance or something\r\n\r\nGoogle benchmark is quite simple: it has a fixed runtime that it wants to achieve, then finds out the number of iterations it needs to do to get there, then it measures the time for that.\r\n\r\nIn nanobench I try to be a bit smarter: I find out the clocks accuracy first, and base the target runtime on that. Since clocks are nowadays very accurate (18ns or so on my machine), I can easily perform the measurement multiple times and use the median to get rid of outliers.\r\n\r\nThe fast runtimes gives very repeatable measurements for stuff that's deterministic (e.g. SHA hashing).  There I believe nanobench has a clear advantage over all other bencharking frameworks that I've tried.\r\n\r\nWhen the code under test has fluctuations (e.g. because it allocates stuff, or has some randomness or lots of cache misses / branch misspredictions in it), nanobench's runtime measurement probably isn't better than google benchmark. In that case it helps to also show the numbers for branch misses and retired instruction count to get a better feeling.\r\n\r\n",
      "created_at" : "2020-01-30T21:50:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-580477347",
      "id" : 580477347,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MDQ3NzM0Nw==",
      "updated_at" : "2020-01-30T21:52:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/580477347",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2020-02-10T12:03:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-584090585",
      "id" : 584090585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDA5MDU4NQ==",
      "updated_at" : "2020-02-10T12:03:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584090585",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've rebased & pushed a big update to the code. In addition to the markdown output, I also generate a file `benchmarkresults.csv` which has practically the same content as the output had previously. This should can be used by any tools that rely on the benchmark output. On my computer, the file has this output:\r\n\r\n```\r\n# Benchmark, evals, iterations, total, min, max, median\r\nAssembleBlock, 11, 1, 0.006106585, 0.000538949, 0.000643127, 0.000545681\r\nBase58CheckEncode, 11, 9.81818181818182, 0.000240226, 2.06e-06, 3.02745454545455e-06, 2.07709090909091e-06\r\nBase58Decode, 11, 27.2727272727273, 0.000245003, 8.11689655172414e-07, 8.1968e-07, 8.166e-07\r\nBase58Encode, 11, 18.5454545454545, 0.000244574, 1.19615e-06, 1.2115e-06, 1.19763157894737e-06\r\nBech32Decode, 11, 42.3636363636364, 0.000250479, 4.27466666666667e-07, 1.32740740740741e-06, 4.35666666666667e-07\r\nBech32Encode, 11, 34.6363636363636, 0.000248104, 6.29258064516129e-07, 8.0896875e-07, 6.36314285714286e-07\r\nBenchLockedPool, 11, 167.363636363636, 0.000264967, 1.08922651933702e-07, 1.73769662921348e-07, 1.46138888888889e-07\r\nBenchTimeDeprecated, 11, 4587.81818181818, 0.00024425, 4.38138264341248e-09, 5.01115472009915e-09, 5.0051077059738e-09\r\nBenchTimeMillis, 11, 237.363636363636, 0.00024483, 9.26184738955823e-08, 9.43307086614173e-08, 9.3963963963964e-08\r\nBenchTimeMillisSys, 11, 243.272727272727, 0.000244799, 9.1088122605364e-08, 9.19113924050633e-08, 9.15038461538462e-08\r\nBenchTimeMock, 11, 10562.9090909091, 0.000246826, 2.08633681343622e-09, 2.29533626901521e-09, 2.08746447742343e-09\r\nBlockToJsonVerbose, 11, 1, 0.812951704, 0.072167457, 0.085656596, 0.072707134\r\nCCheckQueueSpeedPrevectorJob, 11, 11.1818181818182, 0.199323679, 0.00153634016666667, 0.00172734963636364, 0.0016258129\r\nCCoinsCaching, 11, 36.5454545454545, 0.000227408, 5.422e-07, 7.69351351351351e-07, 5.44605263157895e-07\r\nCHACHA20_1MB, 11, 1, 0.023085774, 0.00201953, 0.002240195, 0.002090533\r\nCHACHA20_256BYTES, 11, 44.5454545454545, 0.000245398, 4.99659574468085e-07, 5.02047619047619e-07, 5.00717391304348e-07\r\nCHACHA20_64BYTES, 11, 168.363636363636, 0.000245097, 1.32019736842105e-07, 1.32545454545455e-07, 1.32360759493671e-07\r\nCHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT, 11, 1, 0.063083902, 0.005614908, 0.006009997, 0.005679771\r\nCHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT, 11, 1, 0.031591654, 0.002799809, 0.003083797, 0.002855794\r\nCHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT, 11, 11.2727272727273, 0.000236947, 1.89941666666667e-06, 1.92533333333333e-06, 1.90981818181818e-06\r\nCHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT, 11, 21.5454545454545, 0.000233245, 9.55045454545455e-07, 1.23718181818182e-06, 9.5747619047619e-07\r\nCHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT, 11, 25, 0.000247072, 8.81333333333333e-07, 1.015125e-06, 8.87961538461539e-07\r\nCHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT, 11, 48.9090909090909, 0.00024602, 4.42068181818182e-07, 5.63777777777778e-07, 4.45867924528302e-07\r\nComplexMemPool, 11, 1, 3.457592325, 0.313054487, 0.316239363, 0.313548617\r\nConstructGCSFilter, 11, 1, 0.018953542, 0.001667658, 0.001879675, 0.001676587\r\nDeserializeAndCheckBlockTest, 11, 1, 0.068399757, 0.006003952, 0.006412799, 0.00618906\r\nDeserializeBlockTest, 11, 1, 0.057322626, 0.005100356, 0.00547949, 0.005164525\r\nDuplicateInputs, 11, 1, 0.082094071, 0.007329521, 0.007526674, 0.007472722\r\nFastRandom_1bit, 11, 14773.0909090909, 0.000239545, 1.46252213259886e-09, 1.47889590295829e-09, 1.47590446579989e-09\r\nFastRandom_32bit, 11, 2285.45454545455, 0.000242346, 9.26413255360624e-09, 1.2139653815893e-08, 9.36415362731152e-09\r\nHASH_1MB, 11, 1, 0.037448639, 0.00333361, 0.003531469, 0.003387306\r\nHASH_256BYTES, 11, 17.2727272727273, 0.000244883, 1.28611764705882e-06, 1.291e-06, 1.28872222222222e-06\r\nHASH_64BYTES, 11, 32.8181818181818, 0.000244595, 6.75885714285714e-07, 6.79625e-07, 6.77514285714286e-07\r\nMatchGCSFilter, 11, 1, 0.000303108, 2.6787e-05, 3.0751e-05, 2.7047e-05\r\nMempoolEviction, 11, 1, 0.00035951, 2.6216e-05, 4.4312e-05, 3.0276e-05\r\nMerkleRoot, 11, 1, 0.013989533, 0.001220381, 0.001462655, 0.001242791\r\nPOLY1305_1MB, 11, 1, 0.008822394, 0.000778289, 0.000909028, 0.000782461\r\nPOLY1305_256BYTES, 11, 106.272727272727, 0.000243963, 2.07696428571429e-07, 2.09357142857143e-07, 2.088e-07\r\nPOLY1305_64BYTES, 11, 328.636363636364, 0.000248855, 6.70127795527157e-08, 8.63612040133779e-08, 6.72832369942197e-08\r\nPrevectorClearNontrivial, 11, 791.454545454545, 0.000372666, 2.59770491803279e-08, 1.94881395348837e-07, 2.60037735849057e-08\r\nPrevectorClearTrivial, 11, 2630.54545454545, 0.000244958, 8.46212395795578e-09, 8.47009966777409e-09, 8.46505271378368e-09\r\nPrevectorDeserializeNontrivial, 11, 1, 0.001192481, 0.000105425, 0.000123912, 0.00010568\r\nPrevectorDeserializeTrivial, 11, 2, 0.000255826, 1.1333e-05, 1.2048e-05, 1.1635e-05\r\nPrevectorDestructorNontrivial, 11, 415.272727272727, 0.000358251, 5.15516483516484e-08, 3.43633971291866e-07, 5.15764966740576e-08\r\nPrevectorDestructorTrivial, 11, 1590.36363636364, 0.000237761, 1.31619407687461e-08, 1.39810235767683e-08, 1.3519e-08\r\nPrevectorResizeNontrivial, 11, 811.272727272727, 0.000273009, 2.46290155440415e-08, 8.05017709563164e-08, 2.46548295454545e-08\r\nPrevectorResizeTrivial, 11, 2536.54545454545, 0.000244927, 8.77334809892949e-09, 8.78255578093306e-09, 8.77719528178244e-09\r\nRIPEMD160, 11, 1, 0.028423992, 0.002516573, 0.002757947, 0.00255517\r\nRollingBloom, 11, 44.3636363636364, 0.000245064, 4.99872340425532e-07, 5.05348837209302e-07, 5.02531914893617e-07\r\nRollingBloomReset, 11, 1, 0.000696645, 6.2348e-05, 6.9429e-05, 6.2588e-05\r\nRpcMempool, 11, 1, 0.121633853, 0.010798163, 0.011604045, 0.010929157\r\nSHA1, 11, 1, 0.021057291, 0.001862186, 0.002103509, 0.001878588\r\nSHA256, 11, 1, 0.035631576, 0.00317911, 0.003383292, 0.003233048\r\nSHA256D64_1024, 11, 1, 0.001464103, 0.000132135, 0.000138764, 0.000132205\r\nSHA256_32b, 11, 95.6363636363636, 0.000244411, 2.31903225806452e-07, 2.32772727272727e-07, 2.32415841584158e-07\r\nSHA512, 11, 1, 0.034134625, 0.00303295, 0.003282536, 0.003086899\r\nSipHash_32b, 11, 776.181818181818, 0.000244754, 2.85349500713267e-08, 2.88179581795818e-08, 2.86630872483221e-08\r\nTrig, 11, 4313.81818181818, 0.000238146, 5.01395348837209e-09, 5.03433333333333e-09, 5.01748251748252e-09\r\nVerifyScriptBench, 11, 1, 0.001860283, 0.000155127, 0.000299556, 0.000155384\r\n```\r\n\r\nNote that \"number of iterations\" is now a double value, because in nanobench I automatically determine the number of iterations, and the value is the average number of iterations over the 11 evaluations. (so e.g. `Base58CheckEncode` as 11 evaluations and 9.81818181818182 iterations, so 11*9.818 = 108 iterations in total)",
      "created_at" : "2020-02-20T16:17:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-589162113",
      "id" : 589162113,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTE2MjExMw==",
      "updated_at" : "2020-02-20T16:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589162113",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "utACK 83a7839\r\n\r\nVerified that only benchmarks are effected, checked that the high level design seems reasonable & an improvement over what we do presently.",
      "created_at" : "2020-02-20T18:55:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-589251617",
      "id" : 589251617,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTI1MTYxNw==",
      "updated_at" : "2020-02-20T18:55:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589251617",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "In bf5ae5e I've added some support for asymptotes. I hope that's somewhat similar to what you did in #17375, @JeremyRubin?\r\n\r\nUsage is e.g. like this:\r\n\r\n```\r\n./bench_bitcoin -filter=ComplexMemPool -asymptote=25,50,100,200,400,600,800\r\n```\r\n\r\nThis runs the benchmark `ComplexMemPool` several times but with  different complexityN settings. The benchmark can extract that number and use it accordingly. Here, it's used for `childTxs`. The output is this:\r\n\r\n| complexityN |               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |     total | benchmark\r\n|------------:|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|----------:|:----------\r\n|          25 |        1,064,241.00 |              939.64 |    1.4% |    3,960,279.00 |    2,829,708.00 |  1.400 |      0.01 | `ComplexMemPool`\r\n|          50 |        1,579,530.00 |              633.10 |    1.0% |    6,231,810.00 |    4,412,674.00 |  1.412 |      0.02 | `ComplexMemPool`\r\n|         100 |        4,022,774.00 |              248.58 |    0.6% |   16,544,406.00 |   11,889,535.00 |  1.392 |      0.04 | `ComplexMemPool`\r\n|         200 |       15,390,986.00 |               64.97 |    0.2% |   63,904,254.00 |   47,731,705.00 |  1.339 |      0.17 | `ComplexMemPool`\r\n|         400 |       69,394,711.00 |               14.41 |    0.1% |  272,602,461.00 |  219,014,691.00 |  1.245 |      0.76 | `ComplexMemPool`\r\n|         600 |      168,977,165.00 |                5.92 |    0.1% |  639,108,082.00 |  535,316,887.00 |  1.194 |      1.86 | `ComplexMemPool`\r\n|         800 |      310,109,077.00 |                3.22 |    0.1% |1,149,134,246.00 |  984,620,812.00 |  1.167 |      3.41 | `ComplexMemPool`\r\n\r\n|   coefficient |   err% | complexity\r\n|--------------:|-------:|------------\r\n|   4.78486e-07 |   4.5% | O(n^2)\r\n|   6.38557e-10 |  21.7% | O(n^3)\r\n|   3.42338e-05 |  38.0% | O(n log n)\r\n|   0.000313914 |  46.9% | O(n)\r\n|     0.0129823 | 114.4% | O(log n)\r\n|     0.0815055 | 133.8% | O(1)\r\n\r\nThe best fitting curve is O(n^2), so the algorithm seems to scale quadratic with `childTxs` in the range 25 to 800.",
      "created_at" : "2020-02-20T21:47:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-589335251",
      "id" : 589335251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTMzNTI1MQ==",
      "updated_at" : "2020-02-20T21:47:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589335251",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "utACK bf5ae5e\r\n\r\nbravo!",
      "created_at" : "2020-02-20T22:51:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-589392669",
      "id" : 589392669,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTM5MjY2OQ==",
      "updated_at" : "2020-02-20T22:51:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589392669",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r385845065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/385845065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: How about:\r\n```cpp\r\nnamespace nanobench { using namespace ankerl::nanobench; }\r\n```\r\nSo that all the external nanobench members are more explicitly identified?",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-02-28T18:11:45Z",
      "diff_hunk" : "@@ -9,136 +9,48 @@\n #include <map>\n #include <string>\n #include <vector>\n-#include <chrono>\n \n+#include <bench/nanobench.h>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n struct RegTestingSetup;\n extern const RegTestingSetup* g_testing_setup; //!< A pointer to the current testing setup\n-\n-// Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n-// framework (see https://github.com/google/benchmark)\n-// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n-// (that uses cmake as its build system and has lots of features we don't need) isn't\n-// worth it.\n-\n /*\n  * Usage:\n \n-static void CODE_TO_TIME(benchmark::State& state)\n+static void CODE_TO_TIME(benchmark::Bench& bench)\n {\n     ... do any setup needed...\n-    while (state.KeepRunning()) {\n+    nanobench::Config().run([&] {\n        ... do stuff you want to time...\n-    }\n+    });\n     ... do any cleanup needed...\n }\n \n-// default to running benchmark for 5000 iterations\n-BENCHMARK(CODE_TO_TIME, 5000);\n+BENCHMARK(CODE_TO_TIME);\n \n  */\n \n namespace benchmark {\n-// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n-    using hi_res_clock = std::chrono::high_resolution_clock;\n-    using steady_clock = std::chrono::steady_clock;\n-    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n-using clock = best_clock::type;\n-using time_point = clock::time_point;\n-using duration = clock::duration;\n-\n-class Printer;\n-\n-class State\n-{\n-public:\n-    std::string m_name;\n-    uint64_t m_num_iters_left;\n-    const uint64_t m_num_iters;\n-    const uint64_t m_num_evals;\n-    std::vector<double> m_elapsed_results;\n-    time_point m_start_time;\n \n-    bool UpdateTimer(time_point finish_time);\n+using namespace ankerl::nanobench;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r385845065",
      "id" : 385845065,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NTA2NQ==",
      "original_commit_id" : "bf5ae5ed0f3f02051a14069d311d98ab6628a213",
      "original_position" : 64,
      "path" : "src/bench/bench.h",
      "position" : null,
      "pull_request_review_id" : 366588035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/385845065",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386024046"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386024046"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Sure I can do that. Would you do that inside the benchmark namespace? then all benchmark arguments would become e.g. \r\n```cpp\r\nstatic void Base58Encode(benchmark::nanobench::Bench& bench)\r\n```\r\nWhich is a bit long. ",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-02-29T12:11:22Z",
      "diff_hunk" : "@@ -9,136 +9,48 @@\n #include <map>\n #include <string>\n #include <vector>\n-#include <chrono>\n \n+#include <bench/nanobench.h>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n struct RegTestingSetup;\n extern const RegTestingSetup* g_testing_setup; //!< A pointer to the current testing setup\n-\n-// Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n-// framework (see https://github.com/google/benchmark)\n-// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n-// (that uses cmake as its build system and has lots of features we don't need) isn't\n-// worth it.\n-\n /*\n  * Usage:\n \n-static void CODE_TO_TIME(benchmark::State& state)\n+static void CODE_TO_TIME(benchmark::Bench& bench)\n {\n     ... do any setup needed...\n-    while (state.KeepRunning()) {\n+    nanobench::Config().run([&] {\n        ... do stuff you want to time...\n-    }\n+    });\n     ... do any cleanup needed...\n }\n \n-// default to running benchmark for 5000 iterations\n-BENCHMARK(CODE_TO_TIME, 5000);\n+BENCHMARK(CODE_TO_TIME);\n \n  */\n \n namespace benchmark {\n-// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n-    using hi_res_clock = std::chrono::high_resolution_clock;\n-    using steady_clock = std::chrono::steady_clock;\n-    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n-using clock = best_clock::type;\n-using time_point = clock::time_point;\n-using duration = clock::duration;\n-\n-class Printer;\n-\n-class State\n-{\n-public:\n-    std::string m_name;\n-    uint64_t m_num_iters_left;\n-    const uint64_t m_num_iters;\n-    const uint64_t m_num_evals;\n-    std::vector<double> m_elapsed_results;\n-    time_point m_start_time;\n \n-    bool UpdateTimer(time_point finish_time);\n+using namespace ankerl::nanobench;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386024046",
      "id" : 386024046,
      "in_reply_to_id" : 385845065,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyNDA0Ng==",
      "original_commit_id" : "bf5ae5ed0f3f02051a14069d311d98ab6628a213",
      "original_position" : 64,
      "path" : "src/bench/bench.h",
      "position" : null,
      "pull_request_review_id" : 366794924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386024046",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386051798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386051798"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How about doing individual assignments for the classes in use, e.g.:\r\n\r\n```cpp\r\nnamespace benchmark { using ankerl::nanobench::Bench; }\r\n```",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-02-29T19:58:04Z",
      "diff_hunk" : "@@ -9,136 +9,48 @@\n #include <map>\n #include <string>\n #include <vector>\n-#include <chrono>\n \n+#include <bench/nanobench.h>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n struct RegTestingSetup;\n extern const RegTestingSetup* g_testing_setup; //!< A pointer to the current testing setup\n-\n-// Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n-// framework (see https://github.com/google/benchmark)\n-// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n-// (that uses cmake as its build system and has lots of features we don't need) isn't\n-// worth it.\n-\n /*\n  * Usage:\n \n-static void CODE_TO_TIME(benchmark::State& state)\n+static void CODE_TO_TIME(benchmark::Bench& bench)\n {\n     ... do any setup needed...\n-    while (state.KeepRunning()) {\n+    nanobench::Config().run([&] {\n        ... do stuff you want to time...\n-    }\n+    });\n     ... do any cleanup needed...\n }\n \n-// default to running benchmark for 5000 iterations\n-BENCHMARK(CODE_TO_TIME, 5000);\n+BENCHMARK(CODE_TO_TIME);\n \n  */\n \n namespace benchmark {\n-// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n-    using hi_res_clock = std::chrono::high_resolution_clock;\n-    using steady_clock = std::chrono::steady_clock;\n-    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n-using clock = best_clock::type;\n-using time_point = clock::time_point;\n-using duration = clock::duration;\n-\n-class Printer;\n-\n-class State\n-{\n-public:\n-    std::string m_name;\n-    uint64_t m_num_iters_left;\n-    const uint64_t m_num_iters;\n-    const uint64_t m_num_evals;\n-    std::vector<double> m_elapsed_results;\n-    time_point m_start_time;\n \n-    bool UpdateTimer(time_point finish_time);\n+using namespace ankerl::nanobench;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386051798",
      "id" : 386051798,
      "in_reply_to_id" : 385845065,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA1MTc5OA==",
      "original_commit_id" : "bf5ae5ed0f3f02051a14069d311d98ab6628a213",
      "original_position" : 64,
      "path" : "src/bench/bench.h",
      "position" : null,
      "pull_request_review_id" : 366816897,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386051798",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386081966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386081966"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that's better, `Bench` is the only thing that's needed in the benchmarks anyway. I've commited c2e924f which does that",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-01T06:45:21Z",
      "diff_hunk" : "@@ -9,136 +9,48 @@\n #include <map>\n #include <string>\n #include <vector>\n-#include <chrono>\n \n+#include <bench/nanobench.h>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n struct RegTestingSetup;\n extern const RegTestingSetup* g_testing_setup; //!< A pointer to the current testing setup\n-\n-// Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n-// framework (see https://github.com/google/benchmark)\n-// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n-// (that uses cmake as its build system and has lots of features we don't need) isn't\n-// worth it.\n-\n /*\n  * Usage:\n \n-static void CODE_TO_TIME(benchmark::State& state)\n+static void CODE_TO_TIME(benchmark::Bench& bench)\n {\n     ... do any setup needed...\n-    while (state.KeepRunning()) {\n+    nanobench::Config().run([&] {\n        ... do stuff you want to time...\n-    }\n+    });\n     ... do any cleanup needed...\n }\n \n-// default to running benchmark for 5000 iterations\n-BENCHMARK(CODE_TO_TIME, 5000);\n+BENCHMARK(CODE_TO_TIME);\n \n  */\n \n namespace benchmark {\n-// In case high_resolution_clock is steady, prefer that, otherwise use steady_clock.\n-struct best_clock {\n-    using hi_res_clock = std::chrono::high_resolution_clock;\n-    using steady_clock = std::chrono::steady_clock;\n-    using type = std::conditional<hi_res_clock::is_steady, hi_res_clock, steady_clock>::type;\n-};\n-using clock = best_clock::type;\n-using time_point = clock::time_point;\n-using duration = clock::duration;\n-\n-class Printer;\n-\n-class State\n-{\n-public:\n-    std::string m_name;\n-    uint64_t m_num_iters_left;\n-    const uint64_t m_num_iters;\n-    const uint64_t m_num_evals;\n-    std::vector<double> m_elapsed_results;\n-    time_point m_start_time;\n \n-    bool UpdateTimer(time_point finish_time);\n+using namespace ankerl::nanobench;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386081966",
      "id" : 386081966,
      "in_reply_to_id" : 385845065,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA4MTk2Ng==",
      "original_commit_id" : "bf5ae5ed0f3f02051a14069d311d98ab6628a213",
      "original_position" : 64,
      "path" : "src/bench/bench.h",
      "position" : null,
      "pull_request_review_id" : 366838590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386081966",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK https://github.com/bitcoin/bitcoin/pull/18011/commits/c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "created_at" : "2020-03-01T09:44:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-593076531",
      "id" : 593076531,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5MzA3NjUzMQ==",
      "updated_at" : "2020-03-01T09:44:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/593076531",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386124056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386124056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "can remove `#include <util/time.h>`",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-01T17:08:42Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386124056",
      "id" : 386124056,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEyNDA1Ng==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 2,
      "path" : "src/bench/examples.cpp",
      "position" : null,
      "pull_request_review_id" : 366872789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386124056",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386125092"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386125092"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit here and L::1056: s/that/that is/",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-01T17:24:17Z",
      "diff_hunk" : "@@ -0,0 +1,2491 @@\n+//  __   _ _______ __   _  _____  ______  _______ __   _ _______ _     _\n+//  | \\  | |_____| | \\  | |     | |_____] |______ | \\  | |       |_____|\n+//  |  \\_| |     | |  \\_| |_____| |_____] |______ |  \\_| |_____  |     |\n+//\n+// Microbenchmark framework for C++11/14/17/20\n+// https://github.com/martinus/nanobench\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2019-2020 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ANKERL_NANOBENCH_H_INCLUDED\n+#define ANKERL_NANOBENCH_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ANKERL_NANOBENCH_VERSION_MAJOR 4 // incompatible API changes\n+#define ANKERL_NANOBENCH_VERSION_MINOR 0 // backwards-compatible changes\n+#define ANKERL_NANOBENCH_VERSION_PATCH 0 // backwards-compatible bug fixes\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// public facing api - as minimal as possible\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#include <chrono>           // high_resolution_clock\n+#include <cstring>          // memcpy\n+#include <initializer_list> // for doNotOptimizeAway\n+#include <iosfwd>           // for std::ostream* custom output target in Config\n+#include <string>           // all names\n+#include <unordered_map>    // used by Result\n+#include <vector>           // holds all results\n+\n+#define ANKERL_NANOBENCH(x) ANKERL_NANOBENCH_PRIVATE_##x()\n+\n+#define ANKERL_NANOBENCH_PRIVATE_CXX() __cplusplus\n+#define ANKERL_NANOBENCH_PRIVATE_CXX98() 199711L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX11() 201103L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX14() 201402L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX17() 201703L\n+\n+#if ANKERL_NANOBENCH(CXX) >= ANKERL_NANOBENCH(CXX17)\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD() [[nodiscard]]\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD()\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH() \\\n+        _Pragma(\"clang diagnostic push\") _Pragma(\"clang diagnostic ignored \\\"-Wpadded\\\"\")\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP() _Pragma(\"clang diagnostic pop\")\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH()\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP()\n+#endif\n+\n+#if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n+#    include <iostream>\n+#    define ANKERL_NANOBENCH_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ANKERL_NANOBENCH_LOG(x)\n+#endif\n+\n+#if defined(__linux__)\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 1\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 0\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...) __attribute__((no_sanitize(__VA_ARGS__)))\n+#else\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...)\n+#endif\n+\n+#if defined(_MSC_VER)\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __declspec(noinline)\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+using Clock = std::chrono::high_resolution_clock;\n+class Bench;\n+struct Config;\n+class Result;\n+class Rng;\n+class BigO;\n+\n+// Contains mustache-like templates\n+namespace templates {\n+\n+// CSV file from the benchmark results.\n+char const* csv() noexcept;\n+\n+// HTML graphic using plotly.js\n+char const* htmlBoxplot() noexcept;\n+\n+// JSON that contains all result data\n+char const* json() noexcept;\n+\n+// Generates output from the template and results into the given stream\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n+\n+} // namespace templates\n+\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet;\n+\n+class IterationLogic;\n+class PerformanceCounters;\n+\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+class LinuxPerformanceCounters;\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet {\n+    T pageFaults{};\n+    T cpuCycles{};\n+    T contextSwitches{};\n+    T instructions{};\n+    T branchInstructions{};\n+    T branchMisses{};\n+};\n+\n+} // namespace detail\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Config {\n+    // actual benchmark config\n+    std::string mBenchmarkTitle = \"benchmark\";\n+    std::string mBenchmarkName = \"noname\";\n+    std::string mUnit = \"op\";\n+    double mBatch = 1.0;\n+    double mComplexityN = -1.0;\n+    size_t mNumEpochs = 11;\n+    size_t mClockResolutionMultiple = static_cast<size_t>(1000);\n+    std::chrono::nanoseconds mMaxEpochTime = std::chrono::milliseconds(100);\n+    std::chrono::nanoseconds mMinEpochTime{};\n+    uint64_t mMinEpochIterations{1};\n+    uint64_t mWarmup = 0;\n+    std::ostream* mOut = nullptr;\n+    bool mShowPerformanceCounters = true;\n+    bool mIsRelative = false;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Result returned after a benchmark has finished. Can be used as a baseline for relative().\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Result {\n+public:\n+    Result(Config const& benchmarkConfig);\n+\n+    // adds new measurement results\n+    // all values are scaled by iters (except iters...)\n+    void add(Clock::duration totalElapsed, uint64_t iters, detail::PerformanceCounters const& pc);\n+\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) double median(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double medianAbsolutePercentError(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double average(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double sum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double sumProduct(std::string const& query1, std::string const& query2) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double minimum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double maximum(std::string const& query) const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) bool has(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double get(size_t idx, std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool empty() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t size() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+    std::unordered_map<std::string, std::vector<double>> mNameToMeasurements{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Sfc64, V4 - Small Fast Counting RNG, version 4\n+// Based on code from http://pracrand.sourceforge.net\n+class Rng final {\n+public:\n+    using result_type = uint64_t;\n+\n+    static constexpr uint64_t(min)();\n+    static constexpr uint64_t(max)();\n+\n+    Rng();\n+\n+    // don't allow copying, it's dangerous\n+    Rng(Rng const&) = delete;\n+    Rng& operator=(Rng const&) = delete;\n+\n+    // moving is ok\n+    Rng(Rng&&) noexcept = default;\n+    Rng& operator=(Rng&&) noexcept = default;\n+    ~Rng() noexcept = default;\n+\n+    explicit Rng(uint64_t seed) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Rng copy() const noexcept;\n+    void assign(Rng const& other) noexcept;\n+\n+    // that one's inline so it is fast\n+    inline uint64_t operator()() noexcept;\n+\n+    // random double in range [0, 1(\n+    inline double uniform01() noexcept;\n+\n+private:\n+    static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;\n+\n+    uint64_t mA;\n+    uint64_t mB;\n+    uint64_t mC;\n+    uint64_t mCounter;\n+};\n+\n+// Main entry class for the microbenchmark framework.\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Bench {\n+public:\n+    Bench();\n+\n+    Bench(Bench&& other);\n+    Bench& operator=(Bench&& other);\n+    Bench(Bench const& other);\n+    Bench& operator=(Bench const& other);\n+\n+    ~Bench() noexcept;\n+\n+    // Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+    // Best used in combination with `unit`. Any argument is cast to double.\n+    template <typename T>\n+    Bench& batch(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double batch() const noexcept;\n+\n+    // Marks the next run as the baseline. The following runs will be compared to this run. 100% will mean it is exactly as fast as the\n+    // baseline, >100% means it is faster than the baseline. It is calculated by `100% * runtime_baseline / runtime`. So e.g. 200%\n+    // means the current run is twice as fast as the baseline.\n+    Bench& relative(bool isRelativeEnabled) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool relative() const noexcept;\n+\n+    Bench& performanceCounters(bool showPerformanceCounters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool performanceCounters() const noexcept;\n+\n+    // Operation unit. Defaults to \"op\", could be e.g. \"byte\" for string processing. This is used for the table header, e.g. to show\n+    // `ns/byte`. Use singular (byte, not bytes). A change clears the currently collected results.\n+    Bench& unit(std::string unit);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& unit() const noexcept;\n+\n+    // Title of the benchmark, will be shown in the table header. A change clears the currently collected results.\n+    Bench& title(std::string benchmarkTitle);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& title() const noexcept;\n+\n+    // Name of the benchmark, will be shown in the table row.\n+    Bench& name(std::string benchmarkName);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+\n+    // Set the output stream where the resulting markdown table will be printed to. The default is `&std::cout`. You can disable all\n+    // output by setting `nullptr`.\n+    Bench& output(std::ostream* outstream) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::ostream* output() const noexcept;\n+\n+    // Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch. Defaults to 11. The higher you\n+    // choose this, the more deterministic will the result be and outliers will be more easily removed. The default is already quite\n+    // high to be able to filter most outliers.\n+    //\n+    // For slow benchmarks you might want to reduce this number.\n+    Bench& epochs(size_t numEpochs) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t epochs() const noexcept;\n+\n+    // Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This allows nanobech to be so\n+    // fast: we only run the benchmark sufficiently often so that the clock's accuracy is good enough. The default is to run one epoch\n+    // for 2000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of `20ns * 8000 * 11 ~\n+    // 2ms` for a benchmark to get accurate results.\n+    Bench& clockResolutionMultiple(size_t multiple) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t clockResolutionMultiple() const noexcept;\n+\n+    // As a safety precausion if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch.\n+    // Default is 100ms.\n+    Bench& maxEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds maxEpochTime() const noexcept;\n+\n+    // Sets the minimum time each epoch should take. Default is zero, so clockResolutionMultiple() can do it's best guess. You can\n+    // increase this if you have the time and results are not accurate enough.\n+    Bench& minEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds minEpochTime() const noexcept;\n+\n+    // Sets the minimum number of iterations each epoch should take. Default is 1. For high median average percentage error (MdAPE),\n+    // which happens when your benchmark is unstable, you might want to increase the minimum number to get more accurate reslts.\n+    Bench& minEpochIterations(uint64_t numIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t minEpochIterations() const noexcept;\n+\n+    // Set a number of iterations that are initially performed without any measurements, to warmup caches / database / whatever.\n+    // Normally this is not needed, since we show the median result so initial outliers will be filtered away automatically.\n+    Bench& warmup(uint64_t numWarmupIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t warmup() const noexcept;\n+\n+    // Gets all benchmark results\n+    ANKERL_NANOBENCH(NODISCARD) std::vector<Result> const& results() const noexcept;\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(std::string const& benchmarkName, Op op);\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements. Uses previously set name.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(Op op);\n+\n+    // Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+    template <typename... Args>\n+    Bench& doNotOptimizeAway(Args&&... args);\n+\n+    // Parses the mustache-like template and renders the output into os.\n+    Bench& render(char const* templateContent, std::ostream& os);\n+\n+    // Set the length of N for the next benchmark run, so it is possible to calculate bigO.\n+    template <typename T>\n+    Bench& complexityN(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double complexityN() const noexcept;\n+\n+    // calculates bigO of the results with all preconfigured complexity functions\n+    std::vector<BigO> complexityBigO() const;\n+\n+    // calculates bigO for a custom function\n+    template <typename Op>\n+    BigO complexityBigO(std::string const& name, Op op) const;\n+\n+    // Set all the configuration.\n+    Bench& config(Config const& benchmarkConfig);\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+\n+    // results\n+    std::vector<Result> mResults{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args);\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+void doNotOptimizeAwaySink(void const*);\n+\n+template <typename T>\n+void doNotOptimizeAway(T const& val);\n+\n+#else\n+\n+// see folly's Benchmark.h\n+template <typename T>\n+constexpr bool doNotOptimizeNeedsIndirect() {\n+    using Decayed = typename std::decay<T>::type;\n+    return !ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(Decayed) || sizeof(Decayed) > sizeof(long) || std::is_pointer<Decayed>::value;\n+}\n+\n+template <typename T>\n+typename std::enable_if<!doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"r\"(val));\n+}\n+\n+template <typename T>\n+typename std::enable_if<doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"m\"(val) : \"memory\");\n+}\n+#endif\n+\n+// internally used, but visible because run() is templated\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class IterationLogic {\n+public:\n+    IterationLogic(Bench const& config) noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t numIters() const noexcept;\n+    void add(std::chrono::nanoseconds elapsed, PerformanceCounters const& pc) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Result& result();\n+\n+private:\n+    enum class State { warmup, upscaling_runtime, measuring, endless };\n+\n+    void showResult(std::string const& errorMessage) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool isCloseEnoughForMeasurements(std::chrono::nanoseconds elapsed) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t calcBestNumIters(std::chrono::nanoseconds elapsed, uint64_t iters) noexcept;\n+    void upscale(std::chrono::nanoseconds elapsed);\n+\n+    uint64_t mNumIters = 1;\n+    Bench const& mBench;\n+    std::chrono::nanoseconds mTargetRuntimePerEpoch{};\n+    Result mResult;\n+    Rng mRng{};\n+    std::chrono::nanoseconds mTotalElapsed{};\n+    uint64_t mTotalNumIters = 0;\n+\n+    State mState = State::upscaling_runtime;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class PerformanceCounters {\n+public:\n+    PerformanceCounters(PerformanceCounters const&) = delete;\n+    PerformanceCounters& operator=(PerformanceCounters const&) = delete;\n+\n+    PerformanceCounters();\n+    ~PerformanceCounters();\n+\n+    void beginMeasure();\n+    void endMeasure();\n+    void updateResults(uint64_t numIters);\n+\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<uint64_t> const& val() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<bool> const& has() const noexcept;\n+\n+private:\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+    LinuxPerformanceCounters* mPc = nullptr;\n+#endif\n+    PerfCountSet<uint64_t> mVal;\n+    PerfCountSet<bool> mHas;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Gets the singleton\n+PerformanceCounters& performanceCounters();\n+\n+} // namespace detail\n+\n+class BigO {\n+public:\n+    using RangeMeasure = std::vector<std::pair<double, double>>;\n+\n+    template <typename Op>\n+    static RangeMeasure mapRangeMeasure(RangeMeasure data, Op op) {\n+        for (auto& rangeMeasure : data) {\n+            rangeMeasure.first = op(rangeMeasure.first);\n+        }\n+        return data;\n+    }\n+\n+    static RangeMeasure collectRangeMeasure(std::vector<Result> const& results);\n+\n+    template <typename Op>\n+    BigO(std::string const& bigOName, RangeMeasure const& rangeMeasure, Op rangeToN)\n+        : BigO(bigOName, mapRangeMeasure(rangeMeasure, rangeToN)) {}\n+\n+    BigO(std::string const& bigOName, RangeMeasure const& scaledRangeMeasure);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double constant() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double normalizedRootMeanSquare() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool operator<(BigO const& other) const noexcept;\n+\n+private:\n+    std::string mName{};\n+    double mConstant{};\n+    double mNormalizedRootMeanSquare{};\n+};\n+std::ostream& operator<<(std::ostream& os, BigO const& bigO);\n+std::ostream& operator<<(std::ostream& os, std::vector<ankerl::nanobench::BigO> const& bigOs);\n+\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// Small Fast Counting RNG, version 4\n+constexpr uint64_t(Rng::min)() {\n+    return 0;\n+}\n+\n+constexpr uint64_t(Rng::max)() {\n+    return (std::numeric_limits<uint64_t>::max)();\n+}\n+\n+// Mark this as no_sanitize, otherwise UBSAN will say we got an unsigned integer overflow. Which is not a undefined behavior, but often\n+// a bug. Not here though.\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+uint64_t Rng::operator()() noexcept {\n+    uint64_t tmp = mA + mB + mCounter++;\n+    mA = mB ^ (mB >> 11U);\n+    mB = mC + (mC << 3U);\n+    mC = rotl(mC, 24U) + tmp;\n+    return tmp;\n+}\n+\n+// see http://prng.di.unimi.it/\n+double Rng::uniform01() noexcept {\n+    auto i = (UINT64_C(0x3ff) << 52U) | (operator()() >> 12U);\n+    // can't use union in c++ here for type puning, it's undefined behavior.\n+    // std::memcpy is optimized away anyways.\n+    double d;\n+    std::memcpy(&d, &i, sizeof(double));\n+    return d - 1.0;\n+}\n+\n+constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {\n+    return (x << k) | (x >> (64U - k));\n+}\n+\n+template <typename Op>\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+Bench& Bench::run(Op op) {\n+    // It is important that this method is kept short so the compiler can do better optimizations/ inlining of op()\n+    detail::IterationLogic iterationLogic(*this);\n+    auto& pc = detail::performanceCounters();\n+\n+    while (auto n = iterationLogic.numIters()) {\n+        pc.beginMeasure();\n+        Clock::time_point before = Clock::now();\n+        while (n-- > 0) {\n+            op();\n+        }\n+        Clock::time_point after = Clock::now();\n+        pc.endMeasure();\n+        pc.updateResults(iterationLogic.numIters());\n+        iterationLogic.add(after - before, pc);\n+    }\n+    mResults.emplace_back(std::move(iterationLogic.result()));\n+    return *this;\n+}\n+\n+// Performs all evaluations.\n+template <typename Op>\n+Bench& Bench::run(std::string const& benchmarkName, Op op) {\n+    name(benchmarkName);\n+    return run(std::move(op));\n+}\n+\n+template <typename Op>\n+BigO Bench::complexityBigO(std::string const& benchmarkName, Op op) const {\n+    return BigO(benchmarkName, BigO::collectRangeMeasure(mResults), op);\n+}\n+\n+// Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+// Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::batch(T b) noexcept {\n+    mConfig.mBatch = static_cast<double>(b);\n+    return *this;\n+}\n+\n+// Sets the computation complexity of the next run. Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::complexityN(T n) noexcept {\n+    mConfig.mComplexityN = static_cast<double>(n);\n+    return *this;\n+}\n+\n+// Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+Bench& Bench::doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+    return *this;\n+}\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+}\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+template <typename T>\n+void doNotOptimizeAway(T const& val) {\n+    doNotOptimizeAwaySink(&val);\n+}\n+\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+#if defined(ANKERL_NANOBENCH_IMPLEMENT)\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// implementation part\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#    include <algorithm> // sort, reverse\n+#    include <atomic>    // compare_exchange_strong in loop overhead\n+#    include <cstdlib>   // getenv\n+#    include <cstring>   // strstr, strncmp\n+#    include <fstream>   // ifstream to parse proc files\n+#    include <iomanip>   // setw, setprecision\n+#    include <iostream>  // cout\n+#    include <numeric>   // accumulate\n+#    include <random>    // random_device\n+#    include <sstream>   // to_s in Number\n+#    include <stdexcept> // throw for rendering templates\n+#    include <tuple>     // std::tie\n+#    if defined(__linux__)\n+#        include <unistd.h> //sysconf\n+#    endif\n+#    if ANKERL_NANOBENCH(PERF_COUNTERS)\n+#        include <map> // map\n+\n+#        include <linux/perf_event.h>\n+#        include <sys/ioctl.h>\n+#        include <sys/syscall.h>\n+#        include <unistd.h>\n+#    endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// helper stuff that only intended to be used internally",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386125092",
      "id" : 386125092,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEyNTA5Mg==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 665,
      "path" : "src/bench/nanobench.h",
      "position" : null,
      "pull_request_review_id" : 366872789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386125092",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386125344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386125344"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: of?",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-01T17:28:21Z",
      "diff_hunk" : "@@ -0,0 +1,2491 @@\n+//  __   _ _______ __   _  _____  ______  _______ __   _ _______ _     _\n+//  | \\  | |_____| | \\  | |     | |_____] |______ | \\  | |       |_____|\n+//  |  \\_| |     | |  \\_| |_____| |_____] |______ |  \\_| |_____  |     |\n+//\n+// Microbenchmark framework for C++11/14/17/20\n+// https://github.com/martinus/nanobench\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2019-2020 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ANKERL_NANOBENCH_H_INCLUDED\n+#define ANKERL_NANOBENCH_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ANKERL_NANOBENCH_VERSION_MAJOR 4 // incompatible API changes\n+#define ANKERL_NANOBENCH_VERSION_MINOR 0 // backwards-compatible changes\n+#define ANKERL_NANOBENCH_VERSION_PATCH 0 // backwards-compatible bug fixes\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// public facing api - as minimal as possible\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#include <chrono>           // high_resolution_clock\n+#include <cstring>          // memcpy\n+#include <initializer_list> // for doNotOptimizeAway\n+#include <iosfwd>           // for std::ostream* custom output target in Config\n+#include <string>           // all names\n+#include <unordered_map>    // used by Result\n+#include <vector>           // holds all results\n+\n+#define ANKERL_NANOBENCH(x) ANKERL_NANOBENCH_PRIVATE_##x()\n+\n+#define ANKERL_NANOBENCH_PRIVATE_CXX() __cplusplus\n+#define ANKERL_NANOBENCH_PRIVATE_CXX98() 199711L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX11() 201103L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX14() 201402L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX17() 201703L\n+\n+#if ANKERL_NANOBENCH(CXX) >= ANKERL_NANOBENCH(CXX17)\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD() [[nodiscard]]\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD()\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH() \\\n+        _Pragma(\"clang diagnostic push\") _Pragma(\"clang diagnostic ignored \\\"-Wpadded\\\"\")\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP() _Pragma(\"clang diagnostic pop\")\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH()\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP()\n+#endif\n+\n+#if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n+#    include <iostream>\n+#    define ANKERL_NANOBENCH_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ANKERL_NANOBENCH_LOG(x)\n+#endif\n+\n+#if defined(__linux__)\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 1\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 0\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...) __attribute__((no_sanitize(__VA_ARGS__)))\n+#else\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...)\n+#endif\n+\n+#if defined(_MSC_VER)\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __declspec(noinline)\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+using Clock = std::chrono::high_resolution_clock;\n+class Bench;\n+struct Config;\n+class Result;\n+class Rng;\n+class BigO;\n+\n+// Contains mustache-like templates\n+namespace templates {\n+\n+// CSV file from the benchmark results.\n+char const* csv() noexcept;\n+\n+// HTML graphic using plotly.js\n+char const* htmlBoxplot() noexcept;\n+\n+// JSON that contains all result data\n+char const* json() noexcept;\n+\n+// Generates output from the template and results into the given stream\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n+\n+} // namespace templates\n+\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet;\n+\n+class IterationLogic;\n+class PerformanceCounters;\n+\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+class LinuxPerformanceCounters;\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet {\n+    T pageFaults{};\n+    T cpuCycles{};\n+    T contextSwitches{};\n+    T instructions{};\n+    T branchInstructions{};\n+    T branchMisses{};\n+};\n+\n+} // namespace detail\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Config {\n+    // actual benchmark config\n+    std::string mBenchmarkTitle = \"benchmark\";\n+    std::string mBenchmarkName = \"noname\";\n+    std::string mUnit = \"op\";\n+    double mBatch = 1.0;\n+    double mComplexityN = -1.0;\n+    size_t mNumEpochs = 11;\n+    size_t mClockResolutionMultiple = static_cast<size_t>(1000);\n+    std::chrono::nanoseconds mMaxEpochTime = std::chrono::milliseconds(100);\n+    std::chrono::nanoseconds mMinEpochTime{};\n+    uint64_t mMinEpochIterations{1};\n+    uint64_t mWarmup = 0;\n+    std::ostream* mOut = nullptr;\n+    bool mShowPerformanceCounters = true;\n+    bool mIsRelative = false;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Result returned after a benchmark has finished. Can be used as a baseline for relative().\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Result {\n+public:\n+    Result(Config const& benchmarkConfig);\n+\n+    // adds new measurement results\n+    // all values are scaled by iters (except iters...)\n+    void add(Clock::duration totalElapsed, uint64_t iters, detail::PerformanceCounters const& pc);\n+\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) double median(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double medianAbsolutePercentError(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double average(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double sum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double sumProduct(std::string const& query1, std::string const& query2) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double minimum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double maximum(std::string const& query) const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) bool has(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double get(size_t idx, std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool empty() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t size() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+    std::unordered_map<std::string, std::vector<double>> mNameToMeasurements{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Sfc64, V4 - Small Fast Counting RNG, version 4\n+// Based on code from http://pracrand.sourceforge.net\n+class Rng final {\n+public:\n+    using result_type = uint64_t;\n+\n+    static constexpr uint64_t(min)();\n+    static constexpr uint64_t(max)();\n+\n+    Rng();\n+\n+    // don't allow copying, it's dangerous\n+    Rng(Rng const&) = delete;\n+    Rng& operator=(Rng const&) = delete;\n+\n+    // moving is ok\n+    Rng(Rng&&) noexcept = default;\n+    Rng& operator=(Rng&&) noexcept = default;\n+    ~Rng() noexcept = default;\n+\n+    explicit Rng(uint64_t seed) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Rng copy() const noexcept;\n+    void assign(Rng const& other) noexcept;\n+\n+    // that one's inline so it is fast\n+    inline uint64_t operator()() noexcept;\n+\n+    // random double in range [0, 1(\n+    inline double uniform01() noexcept;\n+\n+private:\n+    static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;\n+\n+    uint64_t mA;\n+    uint64_t mB;\n+    uint64_t mC;\n+    uint64_t mCounter;\n+};\n+\n+// Main entry class for the microbenchmark framework.\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Bench {\n+public:\n+    Bench();\n+\n+    Bench(Bench&& other);\n+    Bench& operator=(Bench&& other);\n+    Bench(Bench const& other);\n+    Bench& operator=(Bench const& other);\n+\n+    ~Bench() noexcept;\n+\n+    // Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+    // Best used in combination with `unit`. Any argument is cast to double.\n+    template <typename T>\n+    Bench& batch(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double batch() const noexcept;\n+\n+    // Marks the next run as the baseline. The following runs will be compared to this run. 100% will mean it is exactly as fast as the\n+    // baseline, >100% means it is faster than the baseline. It is calculated by `100% * runtime_baseline / runtime`. So e.g. 200%\n+    // means the current run is twice as fast as the baseline.\n+    Bench& relative(bool isRelativeEnabled) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool relative() const noexcept;\n+\n+    Bench& performanceCounters(bool showPerformanceCounters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool performanceCounters() const noexcept;\n+\n+    // Operation unit. Defaults to \"op\", could be e.g. \"byte\" for string processing. This is used for the table header, e.g. to show\n+    // `ns/byte`. Use singular (byte, not bytes). A change clears the currently collected results.\n+    Bench& unit(std::string unit);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& unit() const noexcept;\n+\n+    // Title of the benchmark, will be shown in the table header. A change clears the currently collected results.\n+    Bench& title(std::string benchmarkTitle);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& title() const noexcept;\n+\n+    // Name of the benchmark, will be shown in the table row.\n+    Bench& name(std::string benchmarkName);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+\n+    // Set the output stream where the resulting markdown table will be printed to. The default is `&std::cout`. You can disable all\n+    // output by setting `nullptr`.\n+    Bench& output(std::ostream* outstream) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::ostream* output() const noexcept;\n+\n+    // Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch. Defaults to 11. The higher you\n+    // choose this, the more deterministic will the result be and outliers will be more easily removed. The default is already quite\n+    // high to be able to filter most outliers.\n+    //\n+    // For slow benchmarks you might want to reduce this number.\n+    Bench& epochs(size_t numEpochs) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t epochs() const noexcept;\n+\n+    // Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This allows nanobech to be so\n+    // fast: we only run the benchmark sufficiently often so that the clock's accuracy is good enough. The default is to run one epoch\n+    // for 2000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of `20ns * 8000 * 11 ~\n+    // 2ms` for a benchmark to get accurate results.\n+    Bench& clockResolutionMultiple(size_t multiple) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t clockResolutionMultiple() const noexcept;\n+\n+    // As a safety precausion if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch.\n+    // Default is 100ms.\n+    Bench& maxEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds maxEpochTime() const noexcept;\n+\n+    // Sets the minimum time each epoch should take. Default is zero, so clockResolutionMultiple() can do it's best guess. You can\n+    // increase this if you have the time and results are not accurate enough.\n+    Bench& minEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds minEpochTime() const noexcept;\n+\n+    // Sets the minimum number of iterations each epoch should take. Default is 1. For high median average percentage error (MdAPE),\n+    // which happens when your benchmark is unstable, you might want to increase the minimum number to get more accurate reslts.\n+    Bench& minEpochIterations(uint64_t numIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t minEpochIterations() const noexcept;\n+\n+    // Set a number of iterations that are initially performed without any measurements, to warmup caches / database / whatever.\n+    // Normally this is not needed, since we show the median result so initial outliers will be filtered away automatically.\n+    Bench& warmup(uint64_t numWarmupIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t warmup() const noexcept;\n+\n+    // Gets all benchmark results\n+    ANKERL_NANOBENCH(NODISCARD) std::vector<Result> const& results() const noexcept;\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(std::string const& benchmarkName, Op op);\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements. Uses previously set name.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(Op op);\n+\n+    // Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+    template <typename... Args>\n+    Bench& doNotOptimizeAway(Args&&... args);\n+\n+    // Parses the mustache-like template and renders the output into os.\n+    Bench& render(char const* templateContent, std::ostream& os);\n+\n+    // Set the length of N for the next benchmark run, so it is possible to calculate bigO.\n+    template <typename T>\n+    Bench& complexityN(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double complexityN() const noexcept;\n+\n+    // calculates bigO of the results with all preconfigured complexity functions\n+    std::vector<BigO> complexityBigO() const;\n+\n+    // calculates bigO for a custom function\n+    template <typename Op>\n+    BigO complexityBigO(std::string const& name, Op op) const;\n+\n+    // Set all the configuration.\n+    Bench& config(Config const& benchmarkConfig);\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+\n+    // results\n+    std::vector<Result> mResults{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args);\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+void doNotOptimizeAwaySink(void const*);\n+\n+template <typename T>\n+void doNotOptimizeAway(T const& val);\n+\n+#else\n+\n+// see folly's Benchmark.h\n+template <typename T>\n+constexpr bool doNotOptimizeNeedsIndirect() {\n+    using Decayed = typename std::decay<T>::type;\n+    return !ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(Decayed) || sizeof(Decayed) > sizeof(long) || std::is_pointer<Decayed>::value;\n+}\n+\n+template <typename T>\n+typename std::enable_if<!doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"r\"(val));\n+}\n+\n+template <typename T>\n+typename std::enable_if<doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"m\"(val) : \"memory\");\n+}\n+#endif\n+\n+// internally used, but visible because run() is templated\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class IterationLogic {\n+public:\n+    IterationLogic(Bench const& config) noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t numIters() const noexcept;\n+    void add(std::chrono::nanoseconds elapsed, PerformanceCounters const& pc) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Result& result();\n+\n+private:\n+    enum class State { warmup, upscaling_runtime, measuring, endless };\n+\n+    void showResult(std::string const& errorMessage) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool isCloseEnoughForMeasurements(std::chrono::nanoseconds elapsed) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t calcBestNumIters(std::chrono::nanoseconds elapsed, uint64_t iters) noexcept;\n+    void upscale(std::chrono::nanoseconds elapsed);\n+\n+    uint64_t mNumIters = 1;\n+    Bench const& mBench;\n+    std::chrono::nanoseconds mTargetRuntimePerEpoch{};\n+    Result mResult;\n+    Rng mRng{};\n+    std::chrono::nanoseconds mTotalElapsed{};\n+    uint64_t mTotalNumIters = 0;\n+\n+    State mState = State::upscaling_runtime;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class PerformanceCounters {\n+public:\n+    PerformanceCounters(PerformanceCounters const&) = delete;\n+    PerformanceCounters& operator=(PerformanceCounters const&) = delete;\n+\n+    PerformanceCounters();\n+    ~PerformanceCounters();\n+\n+    void beginMeasure();\n+    void endMeasure();\n+    void updateResults(uint64_t numIters);\n+\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<uint64_t> const& val() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<bool> const& has() const noexcept;\n+\n+private:\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+    LinuxPerformanceCounters* mPc = nullptr;\n+#endif\n+    PerfCountSet<uint64_t> mVal;\n+    PerfCountSet<bool> mHas;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Gets the singleton\n+PerformanceCounters& performanceCounters();\n+\n+} // namespace detail\n+\n+class BigO {\n+public:\n+    using RangeMeasure = std::vector<std::pair<double, double>>;\n+\n+    template <typename Op>\n+    static RangeMeasure mapRangeMeasure(RangeMeasure data, Op op) {\n+        for (auto& rangeMeasure : data) {\n+            rangeMeasure.first = op(rangeMeasure.first);\n+        }\n+        return data;\n+    }\n+\n+    static RangeMeasure collectRangeMeasure(std::vector<Result> const& results);\n+\n+    template <typename Op>\n+    BigO(std::string const& bigOName, RangeMeasure const& rangeMeasure, Op rangeToN)\n+        : BigO(bigOName, mapRangeMeasure(rangeMeasure, rangeToN)) {}\n+\n+    BigO(std::string const& bigOName, RangeMeasure const& scaledRangeMeasure);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double constant() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double normalizedRootMeanSquare() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool operator<(BigO const& other) const noexcept;\n+\n+private:\n+    std::string mName{};\n+    double mConstant{};\n+    double mNormalizedRootMeanSquare{};\n+};\n+std::ostream& operator<<(std::ostream& os, BigO const& bigO);\n+std::ostream& operator<<(std::ostream& os, std::vector<ankerl::nanobench::BigO> const& bigOs);\n+\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// Small Fast Counting RNG, version 4\n+constexpr uint64_t(Rng::min)() {\n+    return 0;\n+}\n+\n+constexpr uint64_t(Rng::max)() {\n+    return (std::numeric_limits<uint64_t>::max)();\n+}\n+\n+// Mark this as no_sanitize, otherwise UBSAN will say we got an unsigned integer overflow. Which is not a undefined behavior, but often\n+// a bug. Not here though.\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+uint64_t Rng::operator()() noexcept {\n+    uint64_t tmp = mA + mB + mCounter++;\n+    mA = mB ^ (mB >> 11U);\n+    mB = mC + (mC << 3U);\n+    mC = rotl(mC, 24U) + tmp;\n+    return tmp;\n+}\n+\n+// see http://prng.di.unimi.it/\n+double Rng::uniform01() noexcept {\n+    auto i = (UINT64_C(0x3ff) << 52U) | (operator()() >> 12U);\n+    // can't use union in c++ here for type puning, it's undefined behavior.\n+    // std::memcpy is optimized away anyways.\n+    double d;\n+    std::memcpy(&d, &i, sizeof(double));\n+    return d - 1.0;\n+}\n+\n+constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {\n+    return (x << k) | (x >> (64U - k));\n+}\n+\n+template <typename Op>\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+Bench& Bench::run(Op op) {\n+    // It is important that this method is kept short so the compiler can do better optimizations/ inlining of op()\n+    detail::IterationLogic iterationLogic(*this);\n+    auto& pc = detail::performanceCounters();\n+\n+    while (auto n = iterationLogic.numIters()) {\n+        pc.beginMeasure();\n+        Clock::time_point before = Clock::now();\n+        while (n-- > 0) {\n+            op();\n+        }\n+        Clock::time_point after = Clock::now();\n+        pc.endMeasure();\n+        pc.updateResults(iterationLogic.numIters());\n+        iterationLogic.add(after - before, pc);\n+    }\n+    mResults.emplace_back(std::move(iterationLogic.result()));\n+    return *this;\n+}\n+\n+// Performs all evaluations.\n+template <typename Op>\n+Bench& Bench::run(std::string const& benchmarkName, Op op) {\n+    name(benchmarkName);\n+    return run(std::move(op));\n+}\n+\n+template <typename Op>\n+BigO Bench::complexityBigO(std::string const& benchmarkName, Op op) const {\n+    return BigO(benchmarkName, BigO::collectRangeMeasure(mResults), op);\n+}\n+\n+// Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+// Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::batch(T b) noexcept {\n+    mConfig.mBatch = static_cast<double>(b);\n+    return *this;\n+}\n+\n+// Sets the computation complexity of the next run. Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::complexityN(T n) noexcept {\n+    mConfig.mComplexityN = static_cast<double>(n);\n+    return *this;\n+}\n+\n+// Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+Bench& Bench::doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+    return *this;\n+}\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+}\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+template <typename T>\n+void doNotOptimizeAway(T const& val) {\n+    doNotOptimizeAwaySink(&val);\n+}\n+\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+#if defined(ANKERL_NANOBENCH_IMPLEMENT)\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// implementation part\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#    include <algorithm> // sort, reverse\n+#    include <atomic>    // compare_exchange_strong in loop overhead\n+#    include <cstdlib>   // getenv\n+#    include <cstring>   // strstr, strncmp\n+#    include <fstream>   // ifstream to parse proc files\n+#    include <iomanip>   // setw, setprecision\n+#    include <iostream>  // cout\n+#    include <numeric>   // accumulate\n+#    include <random>    // random_device\n+#    include <sstream>   // to_s in Number\n+#    include <stdexcept> // throw for rendering templates\n+#    include <tuple>     // std::tie\n+#    if defined(__linux__)\n+#        include <unistd.h> //sysconf\n+#    endif\n+#    if ANKERL_NANOBENCH(PERF_COUNTERS)\n+#        include <map> // map\n+\n+#        include <linux/perf_event.h>\n+#        include <sys/ioctl.h>\n+#        include <sys/syscall.h>\n+#        include <unistd.h>\n+#    endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+struct TableInfo;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+class NumSep;\n+class StreamStateRestorer;\n+class Number;\n+class MarkDownColumn;\n+class MarkDownCode;\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+// helpers to get double values\n+template <typename T>\n+inline double d(T t) noexcept {\n+    return static_cast<double>(t);\n+}\n+inline double d(Clock::duration dur) noexcept {\n+    return std::chrono::duration_cast<std::chrono::duration<double>>(dur).count();\n+}\n+\n+} // namespace detail\n+\n+namespace templates {\n+\n+char const* csv() noexcept {\n+    return R\"DELIM(\"title\"; \"name\"; \"unit\"; \"batch\"; \"elapsed\"; \"error %\"; \"instructions\"; \"branches\"; \"branch misses\"; \"total\"\n+{{#result}}\"{{title}}\"; \"{{name}}\"; \"{{unit}}\"; {{batch}}; {{median(elapsed)}}; {{medianAbsolutePercentError(elapsed)}}; {{median(instructions)}}; {{median(branchinstructions)}}; {{median(branchmisses)}}; {{sumProduct(iterations, elapsed)}}\n+{{/result}}\n+)DELIM\";\n+}\n+//\n+char const* htmlBoxplot() noexcept {\n+    return R\"DELIM(<html>\n+\n+<head>\n+    <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n+</head>\n+\n+<body>\n+    <div id=\"myDiv\" style=\"width:1024px; height:768px\"></div>\n+    <script>\n+        var data = [\n+            {{#result}}{\n+                name: '{{name}}',\n+                y: [{{#measurement}}{{elapsed}}{{^-last}}, {{/last}}{{/measurement}}],\n+            },\n+            {{/result}}\n+        ];\n+        var title = 'benchmark';\n+\n+        data = data.map(a => Object.assign(a, { boxpoints: 'all', pointpos: 0, type: 'box' }));\n+        var layout = { title: { text: title }, showlegend: false, yaxis: { title: 'time per unit', rangemode: 'tozero', autorange: true } }; Plotly.newPlot('myDiv', data, layout, {responsive: true});\n+    </script>\n+</body>\n+\n+</html>)DELIM\";\n+}\n+\n+char const* json() noexcept {\n+    return R\"DELIM({\n+    \"results\": [\n+{{#result}}        {\n+            \"title\": \"{{title}}\",\n+            \"name\": \"{{name}}\",\n+            \"unit\": \"{{unit}}\",\n+            \"batch\": {{batch}},\n+            \"complexityN\": {{complexityN}},\n+            \"epochs\": {{epochs}},\n+            \"clockResolutionMultiple\": {{clockResolutionMultiple}},\n+            \"maxEpochTime\": {{maxEpochTime}},\n+            \"minEpochTime\": {{minEpochTime}},\n+            \"minEpochIterations\": {{minEpochIterations}},\n+            \"warmup\": {{warmup}},\n+            \"relative\": {{relative}},\n+            \"median(elapsed)\": {{median(elapsed)}},\n+            \"medianAbsolutePercentError(elapsed)\": {{medianAbsolutePercentError(elapsed)}},\n+            \"median(instructions)\": {{median(instructions)}},\n+            \"medianAbsolutePercentError(instructions)\": {{medianAbsolutePercentError(instructions)}},\n+            \"median(cpucycles)\": {{median(cpucycles)}},\n+            \"median(contextswitches)\": {{median(contextswitches)}},\n+            \"median(pagefaults)\": {{median(pagefaults)}},\n+            \"median(branchinstructions)\": {{median(branchinstructions)}},\n+            \"median(branchmisses)\": {{median(branchmisses)}},\n+            \"totalTime\": {{sumProduct(iterations, elapsed)}},\n+            \"measurements\": [\n+{{#measurement}}                {\n+                    \"iterations\": {{iterations}},\n+                    \"elapsed\": {{elapsed}},\n+                    \"pagefaults\": {{pagefaults}},\n+                    \"cpucycles\": {{cpucycles}},\n+                    \"contextswitches\": {{contextswitches}},\n+                    \"instructions\": {{instructions}},\n+                    \"branchinstructions\": {{branchinstructions}},\n+                    \"branchmisses\": {{branchmisses}}\n+                }{{^-last}},{{/-last}}\n+{{/measurement}}            ]\n+        }{{^-last}},{{/-last}}\n+{{/result}}    ]\n+})DELIM\";\n+}\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Node {\n+    enum class Type { tag, content, section, inverted_section };\n+\n+    char const* begin;\n+    char const* end;\n+    std::vector<Node> children;\n+    Type type;\n+\n+    template <size_t N>\n+    // NOLINTNEXTLINE(hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)\n+    bool operator==(char const (&str)[N]) const noexcept {\n+        return static_cast<size_t>(std::distance(begin, end) + 1) == N && 0 == strncmp(str, begin, N - 1);\n+    }\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+static std::vector<Node> parseMustacheTemplate(char const** tpl) {\n+    std::vector<Node> nodes;\n+\n+    while (true) {\n+        auto begin = std::strstr(*tpl, \"{{\");\n+        auto end = begin;\n+        if (begin != nullptr) {\n+            begin += 2;\n+            end = std::strstr(begin, \"}}\");\n+        }\n+\n+        if (begin == nullptr || end == nullptr) {\n+            // nothing found, finish node\n+            nodes.emplace_back(Node{*tpl, *tpl + std::strlen(*tpl), std::vector<Node>{}, Node::Type::content});\n+            return nodes;\n+        }\n+\n+        nodes.emplace_back(Node{*tpl, begin - 2, std::vector<Node>{}, Node::Type::content});\n+\n+        // we found a tag\n+        *tpl = end + 2;\n+        switch (*begin) {\n+        case '/':\n+            // finished! bail out\n+            return nodes;\n+\n+        case '#':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::section});\n+            break;\n+\n+        case '^':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::inverted_section});\n+            break;\n+\n+        default:\n+            nodes.emplace_back(Node{begin, end, std::vector<Node>{}, Node::Type::tag});\n+            break;\n+        }\n+    }\n+}\n+\n+static bool generateFirstLast(Node const& n, size_t idx, size_t size, std::ostream& out) {\n+    bool matchFirst = n == \"-first\";\n+    bool matchLast = n == \"-last\";\n+    if (!matchFirst && !matchLast) {\n+        return false;\n+    }\n+\n+    bool doWrite = false;\n+    if (n.type == Node::Type::section) {\n+        doWrite = (matchFirst && idx == 0) || (matchLast && idx == size - 1);\n+    } else if (n.type == Node::Type::inverted_section) {\n+        doWrite = (matchFirst && idx != 0) || (matchLast && idx != size - 1);\n+    }\n+\n+    if (doWrite) {\n+        for (auto const& child : n.children) {\n+            if (child.type == Node::Type::content) {\n+                out.write(child.begin, std::distance(child.begin, child.end));\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+static bool matchCmdArgs(std::string const& str, std::vector<std::string>& matchResult) {\n+    matchResult.clear();\n+    auto idxOpen = str.find('(');\n+    auto idxClose = str.find(')', idxOpen);\n+    if (idxClose == std::string::npos) {\n+        return false;\n+    }\n+\n+    matchResult.emplace_back(str.substr(0, idxOpen));\n+\n+    // split by comma\n+    matchResult.emplace_back(std::string{});\n+    for (size_t i = idxOpen + 1; i != idxClose; ++i) {\n+        if (str[i] == ' ' || str[i] == '\\t') {\n+            // skip whitespace\n+            continue;\n+        }\n+        if (str[i] == ',') {\n+            // got a comma => new string\n+            matchResult.emplace_back(std::string{});\n+            continue;\n+        }\n+        // no whitespace no comma, append\n+        matchResult.back() += str[i];\n+    }\n+    return true;\n+}\n+\n+static std::ostream& generateResultTag(Node const& n, Result const& r, std::ostream& out) {\n+    using detail::d;\n+\n+    if (n == \"title\") {\n+        return out << r.config().mBenchmarkTitle;\n+    }\n+    if (n == \"name\") {\n+        return out << r.config().mBenchmarkName;\n+    }\n+    if (n == \"unit\") {\n+        return out << r.config().mUnit;\n+    }\n+    if (n == \"batch\") {\n+        return out << r.config().mBatch;\n+    }\n+    if (n == \"complexityN\") {\n+        return out << r.config().mComplexityN;\n+    }\n+    if (n == \"epochs\") {\n+        return out << r.config().mNumEpochs;\n+    }\n+    if (n == \"clockResolutionMultiple\") {\n+        return out << r.config().mClockResolutionMultiple;\n+    }\n+    if (n == \"maxEpochTime\") {\n+        return out << d(r.config().mMaxEpochTime);\n+    }\n+    if (n == \"minEpochTime\") {\n+        return out << d(r.config().mMinEpochTime);\n+    }\n+    if (n == \"minEpochIterations\") {\n+        return out << r.config().mMinEpochIterations;\n+    }\n+    if (n == \"warmup\") {\n+        return out << r.config().mWarmup;\n+    }\n+    if (n == \"relative\") {\n+        return out << r.config().mIsRelative;\n+    }\n+\n+    // match e.g. \"median(elapsed)\"\n+    // g++ 4.8 doesn't implement std::regex :(\n+    // static std::regex const regOpArg1(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\)$\");\n+    // std::cmatch matchResult;\n+    // if (std::regex_match(n.begin, n.end, matchResult, regOpArg1)) {\n+    std::vector<std::string> matchResult;\n+    if (matchCmdArgs(std::string(n.begin, n.end), matchResult)) {\n+        if (matchResult.size() == 2) {\n+            if (matchResult[0] == \"median\") {\n+                return out << r.median(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"average\") {\n+                return out << r.average(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"medianAbsolutePercentError\") {\n+                return out << r.medianAbsolutePercentError(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"sum\") {\n+                return out << r.sum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"minimum\") {\n+                return out << r.minimum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"maximum\") {\n+                return out << r.maximum(matchResult[1]);\n+            }\n+        } else if (matchResult.size() == 3) {\n+            if (matchResult[0] == \"sumProduct\") {\n+                return out << r.sumProduct(matchResult[1], matchResult[2]);\n+            }\n+        }\n+    }\n+\n+    // match e.g. \"sumProduct(elapsed, iterations)\"\n+    // static std::regex const regOpArg2(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\s*,\\\\s+([a-zA-Z]*)\\\\)$\");\n+\n+    // nothing matches :(\n+    throw std::runtime_error(\"command '\" + std::string(n.begin, n.end) + \"' not understood\");\n+}\n+\n+static void generateResultMeasurement(std::vector<Node> const& nodes, size_t idx, Result const& r, std::ostream& out) {\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, r.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside measurement\");\n+\n+            case Node::Type::section:\n+                throw std::runtime_error(\"got a section inside measurement\");\n+\n+            case Node::Type::tag: {\n+                out << r.get(idx, std::string(n.begin, n.end));\n+                break;\n+            }\n+            }\n+        }\n+    }\n+}\n+\n+static void generateResult(std::vector<Node> const& nodes, size_t idx, std::vector<Result> const& results, std::ostream& out) {\n+    auto const& r = results[idx];\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, results.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside result\");\n+\n+            case Node::Type::section:\n+                if (n == \"measurement\") {\n+                    for (size_t i = 0; i < r.size(); ++i) {\n+                        generateResultMeasurement(n.children, i, r, out);\n+                    }\n+                } else {\n+                    throw std::runtime_error(\"got a section inside result\");\n+                }\n+                break;\n+\n+            case Node::Type::tag:\n+                generateResultTag(n, r, out);\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out) {\n+    // TODO(martinus) save & restore stream status\n+    out.precision(std::numeric_limits<double>::digits10);\n+    auto nodes = parseMustacheTemplate(&mustacheTemplate);\n+\n+    for (auto const& n : nodes) {\n+        switch (n.type) {\n+        case Node::Type::content:\n+            out.write(n.begin, std::distance(n.begin, n.end));\n+            break;\n+\n+        case Node::Type::inverted_section:\n+            throw std::runtime_error(\"unknown list '\" + std::string(n.begin, n.end) + \"'\");\n+\n+        case Node::Type::section:\n+            if (n == \"result\") {\n+                for (size_t i = 0; i < results.size(); ++i) {\n+                    generateResult(n.children, i, results, out);\n+                }\n+            } else {\n+                throw std::runtime_error(\"unknown section '\" + std::string(n.begin, n.end) + \"'\");\n+            }\n+            break;\n+\n+        case Node::Type::tag:\n+            throw std::runtime_error(\"unknown tag '\" + std::string(n.begin, n.end) + \"'\");\n+            break;\n+        }\n+    }\n+}\n+\n+} // namespace templates\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+char const* getEnv(char const* name);\n+bool isEndlessRunning(std::string const& name);\n+\n+template <typename T>\n+T parseFile(std::string const& filename);\n+\n+void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<std::string>& recommendations);\n+void printStabilityInformationOnce(std::ostream* os);\n+\n+// remembers the last table settings used. When it changes, a new table header is automatically written for the new entry.\n+uint64_t& singletonHeaderHash() noexcept;\n+\n+// determines resolution of the given clock. This is done by measuring multiple times and returning the minimum time difference.\n+Clock::duration calcClockResolution(size_t numEvaluations) noexcept;\n+\n+// Calculates clock resolution once, and remembers the result\n+inline Clock::duration clockResolution() noexcept;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+// adds thousands separator to numbers\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class NumSep : public std::numpunct<char> {\n+public:\n+    explicit NumSep(char sep);\n+    char do_thousands_sep() const override;\n+    std::string do_grouping() const override;\n+\n+private:\n+    char mSep;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// RAII to save & restore a stream's state\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class StreamStateRestorer {\n+public:\n+    explicit StreamStateRestorer(std::ostream& s);\n+    ~StreamStateRestorer();\n+\n+    // sets back all stream info that we remembered at construction\n+    void restore();\n+\n+    // don't allow copying / moving\n+    StreamStateRestorer(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer(StreamStateRestorer&&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer&&) = delete;\n+\n+private:\n+    std::ostream& mStream;\n+    std::locale mLocale;\n+    std::streamsize const mPrecision;\n+    std::streamsize const mWidth;\n+    std::ostream::char_type const mFill;\n+    std::ostream::fmtflags const mFmtFlags;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Number formatter\n+class Number {\n+public:\n+    Number(int width, int precision, double value);\n+    Number(int width, int precision, int64_t value);\n+    std::string to_s() const;\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, Number const& n);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    int mWidth;\n+    int mPrecision;\n+    double mValue;\n+};\n+\n+// helper replacement for std::to_string of signed/unsigned numbers so we are locale independent\n+std::string to_s(uint64_t s);\n+\n+std::ostream& operator<<(std::ostream& os, Number const& n);\n+\n+class MarkDownColumn {\n+public:\n+    MarkDownColumn(int w, int prec, std::string const& tit, std::string const& suff, double val);\n+    std::string title() const;\n+    std::string separator() const;\n+    std::string invalid() const;\n+    std::string value() const;\n+\n+private:\n+    int mWidth;\n+    int mPrecision;\n+    std::string mTitle;\n+    std::string mSuffix;\n+    double mValue;\n+};\n+\n+// Formats any text as markdown code, escaping backticks.\n+class MarkDownCode {\n+public:\n+    explicit MarkDownCode(std::string const& what);\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    std::string mWhat{};\n+};\n+\n+std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+PerformanceCounters& performanceCounters() {\n+#    if defined(__clang__)\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n+#    endif\n+    static PerformanceCounters pc;\n+#    if defined(__clang__)\n+#        pragma clang diagnostic pop\n+#    endif\n+    return pc;\n+}\n+\n+// Windows version of do not optimize away",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386125344",
      "id" : 386125344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEyNTM0NA==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 1193,
      "path" : "src/bench/nanobench.h",
      "position" : null,
      "pull_request_review_id" : 366872789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386125344",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386128046"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386128046"
         }
      },
      "author_association" : "MEMBER",
      "body" : "remove \"-scaling and\"... as the option is now removed",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-01T18:08:09Z",
      "diff_hunk" : "@@ -9,26 +9,28 @@\n \n #include <memory>\n \n-static const int64_t DEFAULT_BENCH_EVALUATIONS = 5;\n static const char* DEFAULT_BENCH_FILTER = \".*\";\n-static const char* DEFAULT_BENCH_SCALING = \"1.0\";\n-static const char* DEFAULT_BENCH_PRINTER = \"console\";\n-static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.min.js\";\n-static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n-static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n static void SetupBenchArgs()\n {\n     SetupHelpOptions(gArgs);\n \n     gArgs.AddArg(\"-list\", \"List benchmarks without executing them. Can be combined with -scaling and -filter\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386128046",
      "id" : 386128046,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEyODA0Ng==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 16,
      "path" : "src/bench/bench_bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 366872789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386128046",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386128767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386128767"
         }
      },
      "author_association" : "MEMBER",
      "body" : "thought: would `benchmark_results.csv` be more consistent with the project file naming (I'm not sure and won't bikeshed further)",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-01T18:18:01Z",
      "diff_hunk" : "@@ -125,37 +50,29 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n             assert(witness_enabled);\n         }\n \n-        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n-             g_testing_setup = nullptr;\n-            continue;\n-        }\n-\n-        uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n-        if (0 == num_iters) {\n-            num_iters = 1;\n+        Bench bench;\n+        bench.name(p.first);\n+        if (asymptote.empty()) {\n+            p.second(bench);\n+        } else {\n+            for (auto n : asymptote) {\n+                bench.complexityN(n);\n+                p.second(bench);\n+            }\n+            std::cout << bench.complexityBigO() << std::endl;\n         }\n-        State state(p.first, num_evals, num_iters, printer);\n-        if (!is_list_only) {\n-            p.second.func(state);\n-        }\n-        printer.result(state);\n+        benchmarkResults.push_back(bench.results().back());\n         g_testing_setup = nullptr;\n     }\n \n-    printer.footer();\n-}\n-\n-bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)\n-{\n-    if (m_start_time != time_point()) {\n-        std::chrono::duration<double> diff = current_time - m_start_time;\n-        m_elapsed_results.push_back(diff.count() / m_num_iters);\n-\n-        if (m_elapsed_results.size() == m_num_evals) {\n-            return false;\n+    if (!benchmarkResults.empty()) {\n+        // Generate legacy CSV data to \"benchmarkresults.csv\"\n+        std::ofstream fout(\"benchmarkresults.csv\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386128767",
      "id" : 386128767,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEyODc2Nw==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 173,
      "path" : "src/bench/bench.cpp",
      "position" : null,
      "pull_request_review_id" : 366872789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386128767",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386431558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386431558"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "it should say `Windows version of doNotOptimizeAway`",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-02T14:41:13Z",
      "diff_hunk" : "@@ -0,0 +1,2491 @@\n+//  __   _ _______ __   _  _____  ______  _______ __   _ _______ _     _\n+//  | \\  | |_____| | \\  | |     | |_____] |______ | \\  | |       |_____|\n+//  |  \\_| |     | |  \\_| |_____| |_____] |______ |  \\_| |_____  |     |\n+//\n+// Microbenchmark framework for C++11/14/17/20\n+// https://github.com/martinus/nanobench\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2019-2020 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ANKERL_NANOBENCH_H_INCLUDED\n+#define ANKERL_NANOBENCH_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ANKERL_NANOBENCH_VERSION_MAJOR 4 // incompatible API changes\n+#define ANKERL_NANOBENCH_VERSION_MINOR 0 // backwards-compatible changes\n+#define ANKERL_NANOBENCH_VERSION_PATCH 0 // backwards-compatible bug fixes\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// public facing api - as minimal as possible\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#include <chrono>           // high_resolution_clock\n+#include <cstring>          // memcpy\n+#include <initializer_list> // for doNotOptimizeAway\n+#include <iosfwd>           // for std::ostream* custom output target in Config\n+#include <string>           // all names\n+#include <unordered_map>    // used by Result\n+#include <vector>           // holds all results\n+\n+#define ANKERL_NANOBENCH(x) ANKERL_NANOBENCH_PRIVATE_##x()\n+\n+#define ANKERL_NANOBENCH_PRIVATE_CXX() __cplusplus\n+#define ANKERL_NANOBENCH_PRIVATE_CXX98() 199711L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX11() 201103L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX14() 201402L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX17() 201703L\n+\n+#if ANKERL_NANOBENCH(CXX) >= ANKERL_NANOBENCH(CXX17)\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD() [[nodiscard]]\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD()\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH() \\\n+        _Pragma(\"clang diagnostic push\") _Pragma(\"clang diagnostic ignored \\\"-Wpadded\\\"\")\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP() _Pragma(\"clang diagnostic pop\")\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH()\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP()\n+#endif\n+\n+#if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n+#    include <iostream>\n+#    define ANKERL_NANOBENCH_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ANKERL_NANOBENCH_LOG(x)\n+#endif\n+\n+#if defined(__linux__)\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 1\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 0\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...) __attribute__((no_sanitize(__VA_ARGS__)))\n+#else\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...)\n+#endif\n+\n+#if defined(_MSC_VER)\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __declspec(noinline)\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+using Clock = std::chrono::high_resolution_clock;\n+class Bench;\n+struct Config;\n+class Result;\n+class Rng;\n+class BigO;\n+\n+// Contains mustache-like templates\n+namespace templates {\n+\n+// CSV file from the benchmark results.\n+char const* csv() noexcept;\n+\n+// HTML graphic using plotly.js\n+char const* htmlBoxplot() noexcept;\n+\n+// JSON that contains all result data\n+char const* json() noexcept;\n+\n+// Generates output from the template and results into the given stream\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n+\n+} // namespace templates\n+\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet;\n+\n+class IterationLogic;\n+class PerformanceCounters;\n+\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+class LinuxPerformanceCounters;\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet {\n+    T pageFaults{};\n+    T cpuCycles{};\n+    T contextSwitches{};\n+    T instructions{};\n+    T branchInstructions{};\n+    T branchMisses{};\n+};\n+\n+} // namespace detail\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Config {\n+    // actual benchmark config\n+    std::string mBenchmarkTitle = \"benchmark\";\n+    std::string mBenchmarkName = \"noname\";\n+    std::string mUnit = \"op\";\n+    double mBatch = 1.0;\n+    double mComplexityN = -1.0;\n+    size_t mNumEpochs = 11;\n+    size_t mClockResolutionMultiple = static_cast<size_t>(1000);\n+    std::chrono::nanoseconds mMaxEpochTime = std::chrono::milliseconds(100);\n+    std::chrono::nanoseconds mMinEpochTime{};\n+    uint64_t mMinEpochIterations{1};\n+    uint64_t mWarmup = 0;\n+    std::ostream* mOut = nullptr;\n+    bool mShowPerformanceCounters = true;\n+    bool mIsRelative = false;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Result returned after a benchmark has finished. Can be used as a baseline for relative().\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Result {\n+public:\n+    Result(Config const& benchmarkConfig);\n+\n+    // adds new measurement results\n+    // all values are scaled by iters (except iters...)\n+    void add(Clock::duration totalElapsed, uint64_t iters, detail::PerformanceCounters const& pc);\n+\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) double median(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double medianAbsolutePercentError(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double average(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double sum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double sumProduct(std::string const& query1, std::string const& query2) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double minimum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double maximum(std::string const& query) const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) bool has(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double get(size_t idx, std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool empty() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t size() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+    std::unordered_map<std::string, std::vector<double>> mNameToMeasurements{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Sfc64, V4 - Small Fast Counting RNG, version 4\n+// Based on code from http://pracrand.sourceforge.net\n+class Rng final {\n+public:\n+    using result_type = uint64_t;\n+\n+    static constexpr uint64_t(min)();\n+    static constexpr uint64_t(max)();\n+\n+    Rng();\n+\n+    // don't allow copying, it's dangerous\n+    Rng(Rng const&) = delete;\n+    Rng& operator=(Rng const&) = delete;\n+\n+    // moving is ok\n+    Rng(Rng&&) noexcept = default;\n+    Rng& operator=(Rng&&) noexcept = default;\n+    ~Rng() noexcept = default;\n+\n+    explicit Rng(uint64_t seed) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Rng copy() const noexcept;\n+    void assign(Rng const& other) noexcept;\n+\n+    // that one's inline so it is fast\n+    inline uint64_t operator()() noexcept;\n+\n+    // random double in range [0, 1(\n+    inline double uniform01() noexcept;\n+\n+private:\n+    static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;\n+\n+    uint64_t mA;\n+    uint64_t mB;\n+    uint64_t mC;\n+    uint64_t mCounter;\n+};\n+\n+// Main entry class for the microbenchmark framework.\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Bench {\n+public:\n+    Bench();\n+\n+    Bench(Bench&& other);\n+    Bench& operator=(Bench&& other);\n+    Bench(Bench const& other);\n+    Bench& operator=(Bench const& other);\n+\n+    ~Bench() noexcept;\n+\n+    // Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+    // Best used in combination with `unit`. Any argument is cast to double.\n+    template <typename T>\n+    Bench& batch(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double batch() const noexcept;\n+\n+    // Marks the next run as the baseline. The following runs will be compared to this run. 100% will mean it is exactly as fast as the\n+    // baseline, >100% means it is faster than the baseline. It is calculated by `100% * runtime_baseline / runtime`. So e.g. 200%\n+    // means the current run is twice as fast as the baseline.\n+    Bench& relative(bool isRelativeEnabled) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool relative() const noexcept;\n+\n+    Bench& performanceCounters(bool showPerformanceCounters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool performanceCounters() const noexcept;\n+\n+    // Operation unit. Defaults to \"op\", could be e.g. \"byte\" for string processing. This is used for the table header, e.g. to show\n+    // `ns/byte`. Use singular (byte, not bytes). A change clears the currently collected results.\n+    Bench& unit(std::string unit);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& unit() const noexcept;\n+\n+    // Title of the benchmark, will be shown in the table header. A change clears the currently collected results.\n+    Bench& title(std::string benchmarkTitle);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& title() const noexcept;\n+\n+    // Name of the benchmark, will be shown in the table row.\n+    Bench& name(std::string benchmarkName);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+\n+    // Set the output stream where the resulting markdown table will be printed to. The default is `&std::cout`. You can disable all\n+    // output by setting `nullptr`.\n+    Bench& output(std::ostream* outstream) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::ostream* output() const noexcept;\n+\n+    // Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch. Defaults to 11. The higher you\n+    // choose this, the more deterministic will the result be and outliers will be more easily removed. The default is already quite\n+    // high to be able to filter most outliers.\n+    //\n+    // For slow benchmarks you might want to reduce this number.\n+    Bench& epochs(size_t numEpochs) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t epochs() const noexcept;\n+\n+    // Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This allows nanobech to be so\n+    // fast: we only run the benchmark sufficiently often so that the clock's accuracy is good enough. The default is to run one epoch\n+    // for 2000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of `20ns * 8000 * 11 ~\n+    // 2ms` for a benchmark to get accurate results.\n+    Bench& clockResolutionMultiple(size_t multiple) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t clockResolutionMultiple() const noexcept;\n+\n+    // As a safety precausion if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch.\n+    // Default is 100ms.\n+    Bench& maxEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds maxEpochTime() const noexcept;\n+\n+    // Sets the minimum time each epoch should take. Default is zero, so clockResolutionMultiple() can do it's best guess. You can\n+    // increase this if you have the time and results are not accurate enough.\n+    Bench& minEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds minEpochTime() const noexcept;\n+\n+    // Sets the minimum number of iterations each epoch should take. Default is 1. For high median average percentage error (MdAPE),\n+    // which happens when your benchmark is unstable, you might want to increase the minimum number to get more accurate reslts.\n+    Bench& minEpochIterations(uint64_t numIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t minEpochIterations() const noexcept;\n+\n+    // Set a number of iterations that are initially performed without any measurements, to warmup caches / database / whatever.\n+    // Normally this is not needed, since we show the median result so initial outliers will be filtered away automatically.\n+    Bench& warmup(uint64_t numWarmupIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t warmup() const noexcept;\n+\n+    // Gets all benchmark results\n+    ANKERL_NANOBENCH(NODISCARD) std::vector<Result> const& results() const noexcept;\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(std::string const& benchmarkName, Op op);\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements. Uses previously set name.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(Op op);\n+\n+    // Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+    template <typename... Args>\n+    Bench& doNotOptimizeAway(Args&&... args);\n+\n+    // Parses the mustache-like template and renders the output into os.\n+    Bench& render(char const* templateContent, std::ostream& os);\n+\n+    // Set the length of N for the next benchmark run, so it is possible to calculate bigO.\n+    template <typename T>\n+    Bench& complexityN(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double complexityN() const noexcept;\n+\n+    // calculates bigO of the results with all preconfigured complexity functions\n+    std::vector<BigO> complexityBigO() const;\n+\n+    // calculates bigO for a custom function\n+    template <typename Op>\n+    BigO complexityBigO(std::string const& name, Op op) const;\n+\n+    // Set all the configuration.\n+    Bench& config(Config const& benchmarkConfig);\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+\n+    // results\n+    std::vector<Result> mResults{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args);\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+void doNotOptimizeAwaySink(void const*);\n+\n+template <typename T>\n+void doNotOptimizeAway(T const& val);\n+\n+#else\n+\n+// see folly's Benchmark.h\n+template <typename T>\n+constexpr bool doNotOptimizeNeedsIndirect() {\n+    using Decayed = typename std::decay<T>::type;\n+    return !ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(Decayed) || sizeof(Decayed) > sizeof(long) || std::is_pointer<Decayed>::value;\n+}\n+\n+template <typename T>\n+typename std::enable_if<!doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"r\"(val));\n+}\n+\n+template <typename T>\n+typename std::enable_if<doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"m\"(val) : \"memory\");\n+}\n+#endif\n+\n+// internally used, but visible because run() is templated\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class IterationLogic {\n+public:\n+    IterationLogic(Bench const& config) noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t numIters() const noexcept;\n+    void add(std::chrono::nanoseconds elapsed, PerformanceCounters const& pc) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Result& result();\n+\n+private:\n+    enum class State { warmup, upscaling_runtime, measuring, endless };\n+\n+    void showResult(std::string const& errorMessage) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool isCloseEnoughForMeasurements(std::chrono::nanoseconds elapsed) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t calcBestNumIters(std::chrono::nanoseconds elapsed, uint64_t iters) noexcept;\n+    void upscale(std::chrono::nanoseconds elapsed);\n+\n+    uint64_t mNumIters = 1;\n+    Bench const& mBench;\n+    std::chrono::nanoseconds mTargetRuntimePerEpoch{};\n+    Result mResult;\n+    Rng mRng{};\n+    std::chrono::nanoseconds mTotalElapsed{};\n+    uint64_t mTotalNumIters = 0;\n+\n+    State mState = State::upscaling_runtime;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class PerformanceCounters {\n+public:\n+    PerformanceCounters(PerformanceCounters const&) = delete;\n+    PerformanceCounters& operator=(PerformanceCounters const&) = delete;\n+\n+    PerformanceCounters();\n+    ~PerformanceCounters();\n+\n+    void beginMeasure();\n+    void endMeasure();\n+    void updateResults(uint64_t numIters);\n+\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<uint64_t> const& val() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<bool> const& has() const noexcept;\n+\n+private:\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+    LinuxPerformanceCounters* mPc = nullptr;\n+#endif\n+    PerfCountSet<uint64_t> mVal;\n+    PerfCountSet<bool> mHas;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Gets the singleton\n+PerformanceCounters& performanceCounters();\n+\n+} // namespace detail\n+\n+class BigO {\n+public:\n+    using RangeMeasure = std::vector<std::pair<double, double>>;\n+\n+    template <typename Op>\n+    static RangeMeasure mapRangeMeasure(RangeMeasure data, Op op) {\n+        for (auto& rangeMeasure : data) {\n+            rangeMeasure.first = op(rangeMeasure.first);\n+        }\n+        return data;\n+    }\n+\n+    static RangeMeasure collectRangeMeasure(std::vector<Result> const& results);\n+\n+    template <typename Op>\n+    BigO(std::string const& bigOName, RangeMeasure const& rangeMeasure, Op rangeToN)\n+        : BigO(bigOName, mapRangeMeasure(rangeMeasure, rangeToN)) {}\n+\n+    BigO(std::string const& bigOName, RangeMeasure const& scaledRangeMeasure);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double constant() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double normalizedRootMeanSquare() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool operator<(BigO const& other) const noexcept;\n+\n+private:\n+    std::string mName{};\n+    double mConstant{};\n+    double mNormalizedRootMeanSquare{};\n+};\n+std::ostream& operator<<(std::ostream& os, BigO const& bigO);\n+std::ostream& operator<<(std::ostream& os, std::vector<ankerl::nanobench::BigO> const& bigOs);\n+\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// Small Fast Counting RNG, version 4\n+constexpr uint64_t(Rng::min)() {\n+    return 0;\n+}\n+\n+constexpr uint64_t(Rng::max)() {\n+    return (std::numeric_limits<uint64_t>::max)();\n+}\n+\n+// Mark this as no_sanitize, otherwise UBSAN will say we got an unsigned integer overflow. Which is not a undefined behavior, but often\n+// a bug. Not here though.\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+uint64_t Rng::operator()() noexcept {\n+    uint64_t tmp = mA + mB + mCounter++;\n+    mA = mB ^ (mB >> 11U);\n+    mB = mC + (mC << 3U);\n+    mC = rotl(mC, 24U) + tmp;\n+    return tmp;\n+}\n+\n+// see http://prng.di.unimi.it/\n+double Rng::uniform01() noexcept {\n+    auto i = (UINT64_C(0x3ff) << 52U) | (operator()() >> 12U);\n+    // can't use union in c++ here for type puning, it's undefined behavior.\n+    // std::memcpy is optimized away anyways.\n+    double d;\n+    std::memcpy(&d, &i, sizeof(double));\n+    return d - 1.0;\n+}\n+\n+constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {\n+    return (x << k) | (x >> (64U - k));\n+}\n+\n+template <typename Op>\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+Bench& Bench::run(Op op) {\n+    // It is important that this method is kept short so the compiler can do better optimizations/ inlining of op()\n+    detail::IterationLogic iterationLogic(*this);\n+    auto& pc = detail::performanceCounters();\n+\n+    while (auto n = iterationLogic.numIters()) {\n+        pc.beginMeasure();\n+        Clock::time_point before = Clock::now();\n+        while (n-- > 0) {\n+            op();\n+        }\n+        Clock::time_point after = Clock::now();\n+        pc.endMeasure();\n+        pc.updateResults(iterationLogic.numIters());\n+        iterationLogic.add(after - before, pc);\n+    }\n+    mResults.emplace_back(std::move(iterationLogic.result()));\n+    return *this;\n+}\n+\n+// Performs all evaluations.\n+template <typename Op>\n+Bench& Bench::run(std::string const& benchmarkName, Op op) {\n+    name(benchmarkName);\n+    return run(std::move(op));\n+}\n+\n+template <typename Op>\n+BigO Bench::complexityBigO(std::string const& benchmarkName, Op op) const {\n+    return BigO(benchmarkName, BigO::collectRangeMeasure(mResults), op);\n+}\n+\n+// Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+// Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::batch(T b) noexcept {\n+    mConfig.mBatch = static_cast<double>(b);\n+    return *this;\n+}\n+\n+// Sets the computation complexity of the next run. Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::complexityN(T n) noexcept {\n+    mConfig.mComplexityN = static_cast<double>(n);\n+    return *this;\n+}\n+\n+// Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+Bench& Bench::doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+    return *this;\n+}\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+}\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+template <typename T>\n+void doNotOptimizeAway(T const& val) {\n+    doNotOptimizeAwaySink(&val);\n+}\n+\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+#if defined(ANKERL_NANOBENCH_IMPLEMENT)\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// implementation part\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#    include <algorithm> // sort, reverse\n+#    include <atomic>    // compare_exchange_strong in loop overhead\n+#    include <cstdlib>   // getenv\n+#    include <cstring>   // strstr, strncmp\n+#    include <fstream>   // ifstream to parse proc files\n+#    include <iomanip>   // setw, setprecision\n+#    include <iostream>  // cout\n+#    include <numeric>   // accumulate\n+#    include <random>    // random_device\n+#    include <sstream>   // to_s in Number\n+#    include <stdexcept> // throw for rendering templates\n+#    include <tuple>     // std::tie\n+#    if defined(__linux__)\n+#        include <unistd.h> //sysconf\n+#    endif\n+#    if ANKERL_NANOBENCH(PERF_COUNTERS)\n+#        include <map> // map\n+\n+#        include <linux/perf_event.h>\n+#        include <sys/ioctl.h>\n+#        include <sys/syscall.h>\n+#        include <unistd.h>\n+#    endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+struct TableInfo;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+class NumSep;\n+class StreamStateRestorer;\n+class Number;\n+class MarkDownColumn;\n+class MarkDownCode;\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+// helpers to get double values\n+template <typename T>\n+inline double d(T t) noexcept {\n+    return static_cast<double>(t);\n+}\n+inline double d(Clock::duration dur) noexcept {\n+    return std::chrono::duration_cast<std::chrono::duration<double>>(dur).count();\n+}\n+\n+} // namespace detail\n+\n+namespace templates {\n+\n+char const* csv() noexcept {\n+    return R\"DELIM(\"title\"; \"name\"; \"unit\"; \"batch\"; \"elapsed\"; \"error %\"; \"instructions\"; \"branches\"; \"branch misses\"; \"total\"\n+{{#result}}\"{{title}}\"; \"{{name}}\"; \"{{unit}}\"; {{batch}}; {{median(elapsed)}}; {{medianAbsolutePercentError(elapsed)}}; {{median(instructions)}}; {{median(branchinstructions)}}; {{median(branchmisses)}}; {{sumProduct(iterations, elapsed)}}\n+{{/result}}\n+)DELIM\";\n+}\n+//\n+char const* htmlBoxplot() noexcept {\n+    return R\"DELIM(<html>\n+\n+<head>\n+    <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n+</head>\n+\n+<body>\n+    <div id=\"myDiv\" style=\"width:1024px; height:768px\"></div>\n+    <script>\n+        var data = [\n+            {{#result}}{\n+                name: '{{name}}',\n+                y: [{{#measurement}}{{elapsed}}{{^-last}}, {{/last}}{{/measurement}}],\n+            },\n+            {{/result}}\n+        ];\n+        var title = 'benchmark';\n+\n+        data = data.map(a => Object.assign(a, { boxpoints: 'all', pointpos: 0, type: 'box' }));\n+        var layout = { title: { text: title }, showlegend: false, yaxis: { title: 'time per unit', rangemode: 'tozero', autorange: true } }; Plotly.newPlot('myDiv', data, layout, {responsive: true});\n+    </script>\n+</body>\n+\n+</html>)DELIM\";\n+}\n+\n+char const* json() noexcept {\n+    return R\"DELIM({\n+    \"results\": [\n+{{#result}}        {\n+            \"title\": \"{{title}}\",\n+            \"name\": \"{{name}}\",\n+            \"unit\": \"{{unit}}\",\n+            \"batch\": {{batch}},\n+            \"complexityN\": {{complexityN}},\n+            \"epochs\": {{epochs}},\n+            \"clockResolutionMultiple\": {{clockResolutionMultiple}},\n+            \"maxEpochTime\": {{maxEpochTime}},\n+            \"minEpochTime\": {{minEpochTime}},\n+            \"minEpochIterations\": {{minEpochIterations}},\n+            \"warmup\": {{warmup}},\n+            \"relative\": {{relative}},\n+            \"median(elapsed)\": {{median(elapsed)}},\n+            \"medianAbsolutePercentError(elapsed)\": {{medianAbsolutePercentError(elapsed)}},\n+            \"median(instructions)\": {{median(instructions)}},\n+            \"medianAbsolutePercentError(instructions)\": {{medianAbsolutePercentError(instructions)}},\n+            \"median(cpucycles)\": {{median(cpucycles)}},\n+            \"median(contextswitches)\": {{median(contextswitches)}},\n+            \"median(pagefaults)\": {{median(pagefaults)}},\n+            \"median(branchinstructions)\": {{median(branchinstructions)}},\n+            \"median(branchmisses)\": {{median(branchmisses)}},\n+            \"totalTime\": {{sumProduct(iterations, elapsed)}},\n+            \"measurements\": [\n+{{#measurement}}                {\n+                    \"iterations\": {{iterations}},\n+                    \"elapsed\": {{elapsed}},\n+                    \"pagefaults\": {{pagefaults}},\n+                    \"cpucycles\": {{cpucycles}},\n+                    \"contextswitches\": {{contextswitches}},\n+                    \"instructions\": {{instructions}},\n+                    \"branchinstructions\": {{branchinstructions}},\n+                    \"branchmisses\": {{branchmisses}}\n+                }{{^-last}},{{/-last}}\n+{{/measurement}}            ]\n+        }{{^-last}},{{/-last}}\n+{{/result}}    ]\n+})DELIM\";\n+}\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Node {\n+    enum class Type { tag, content, section, inverted_section };\n+\n+    char const* begin;\n+    char const* end;\n+    std::vector<Node> children;\n+    Type type;\n+\n+    template <size_t N>\n+    // NOLINTNEXTLINE(hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)\n+    bool operator==(char const (&str)[N]) const noexcept {\n+        return static_cast<size_t>(std::distance(begin, end) + 1) == N && 0 == strncmp(str, begin, N - 1);\n+    }\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+static std::vector<Node> parseMustacheTemplate(char const** tpl) {\n+    std::vector<Node> nodes;\n+\n+    while (true) {\n+        auto begin = std::strstr(*tpl, \"{{\");\n+        auto end = begin;\n+        if (begin != nullptr) {\n+            begin += 2;\n+            end = std::strstr(begin, \"}}\");\n+        }\n+\n+        if (begin == nullptr || end == nullptr) {\n+            // nothing found, finish node\n+            nodes.emplace_back(Node{*tpl, *tpl + std::strlen(*tpl), std::vector<Node>{}, Node::Type::content});\n+            return nodes;\n+        }\n+\n+        nodes.emplace_back(Node{*tpl, begin - 2, std::vector<Node>{}, Node::Type::content});\n+\n+        // we found a tag\n+        *tpl = end + 2;\n+        switch (*begin) {\n+        case '/':\n+            // finished! bail out\n+            return nodes;\n+\n+        case '#':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::section});\n+            break;\n+\n+        case '^':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::inverted_section});\n+            break;\n+\n+        default:\n+            nodes.emplace_back(Node{begin, end, std::vector<Node>{}, Node::Type::tag});\n+            break;\n+        }\n+    }\n+}\n+\n+static bool generateFirstLast(Node const& n, size_t idx, size_t size, std::ostream& out) {\n+    bool matchFirst = n == \"-first\";\n+    bool matchLast = n == \"-last\";\n+    if (!matchFirst && !matchLast) {\n+        return false;\n+    }\n+\n+    bool doWrite = false;\n+    if (n.type == Node::Type::section) {\n+        doWrite = (matchFirst && idx == 0) || (matchLast && idx == size - 1);\n+    } else if (n.type == Node::Type::inverted_section) {\n+        doWrite = (matchFirst && idx != 0) || (matchLast && idx != size - 1);\n+    }\n+\n+    if (doWrite) {\n+        for (auto const& child : n.children) {\n+            if (child.type == Node::Type::content) {\n+                out.write(child.begin, std::distance(child.begin, child.end));\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+static bool matchCmdArgs(std::string const& str, std::vector<std::string>& matchResult) {\n+    matchResult.clear();\n+    auto idxOpen = str.find('(');\n+    auto idxClose = str.find(')', idxOpen);\n+    if (idxClose == std::string::npos) {\n+        return false;\n+    }\n+\n+    matchResult.emplace_back(str.substr(0, idxOpen));\n+\n+    // split by comma\n+    matchResult.emplace_back(std::string{});\n+    for (size_t i = idxOpen + 1; i != idxClose; ++i) {\n+        if (str[i] == ' ' || str[i] == '\\t') {\n+            // skip whitespace\n+            continue;\n+        }\n+        if (str[i] == ',') {\n+            // got a comma => new string\n+            matchResult.emplace_back(std::string{});\n+            continue;\n+        }\n+        // no whitespace no comma, append\n+        matchResult.back() += str[i];\n+    }\n+    return true;\n+}\n+\n+static std::ostream& generateResultTag(Node const& n, Result const& r, std::ostream& out) {\n+    using detail::d;\n+\n+    if (n == \"title\") {\n+        return out << r.config().mBenchmarkTitle;\n+    }\n+    if (n == \"name\") {\n+        return out << r.config().mBenchmarkName;\n+    }\n+    if (n == \"unit\") {\n+        return out << r.config().mUnit;\n+    }\n+    if (n == \"batch\") {\n+        return out << r.config().mBatch;\n+    }\n+    if (n == \"complexityN\") {\n+        return out << r.config().mComplexityN;\n+    }\n+    if (n == \"epochs\") {\n+        return out << r.config().mNumEpochs;\n+    }\n+    if (n == \"clockResolutionMultiple\") {\n+        return out << r.config().mClockResolutionMultiple;\n+    }\n+    if (n == \"maxEpochTime\") {\n+        return out << d(r.config().mMaxEpochTime);\n+    }\n+    if (n == \"minEpochTime\") {\n+        return out << d(r.config().mMinEpochTime);\n+    }\n+    if (n == \"minEpochIterations\") {\n+        return out << r.config().mMinEpochIterations;\n+    }\n+    if (n == \"warmup\") {\n+        return out << r.config().mWarmup;\n+    }\n+    if (n == \"relative\") {\n+        return out << r.config().mIsRelative;\n+    }\n+\n+    // match e.g. \"median(elapsed)\"\n+    // g++ 4.8 doesn't implement std::regex :(\n+    // static std::regex const regOpArg1(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\)$\");\n+    // std::cmatch matchResult;\n+    // if (std::regex_match(n.begin, n.end, matchResult, regOpArg1)) {\n+    std::vector<std::string> matchResult;\n+    if (matchCmdArgs(std::string(n.begin, n.end), matchResult)) {\n+        if (matchResult.size() == 2) {\n+            if (matchResult[0] == \"median\") {\n+                return out << r.median(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"average\") {\n+                return out << r.average(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"medianAbsolutePercentError\") {\n+                return out << r.medianAbsolutePercentError(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"sum\") {\n+                return out << r.sum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"minimum\") {\n+                return out << r.minimum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"maximum\") {\n+                return out << r.maximum(matchResult[1]);\n+            }\n+        } else if (matchResult.size() == 3) {\n+            if (matchResult[0] == \"sumProduct\") {\n+                return out << r.sumProduct(matchResult[1], matchResult[2]);\n+            }\n+        }\n+    }\n+\n+    // match e.g. \"sumProduct(elapsed, iterations)\"\n+    // static std::regex const regOpArg2(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\s*,\\\\s+([a-zA-Z]*)\\\\)$\");\n+\n+    // nothing matches :(\n+    throw std::runtime_error(\"command '\" + std::string(n.begin, n.end) + \"' not understood\");\n+}\n+\n+static void generateResultMeasurement(std::vector<Node> const& nodes, size_t idx, Result const& r, std::ostream& out) {\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, r.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside measurement\");\n+\n+            case Node::Type::section:\n+                throw std::runtime_error(\"got a section inside measurement\");\n+\n+            case Node::Type::tag: {\n+                out << r.get(idx, std::string(n.begin, n.end));\n+                break;\n+            }\n+            }\n+        }\n+    }\n+}\n+\n+static void generateResult(std::vector<Node> const& nodes, size_t idx, std::vector<Result> const& results, std::ostream& out) {\n+    auto const& r = results[idx];\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, results.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside result\");\n+\n+            case Node::Type::section:\n+                if (n == \"measurement\") {\n+                    for (size_t i = 0; i < r.size(); ++i) {\n+                        generateResultMeasurement(n.children, i, r, out);\n+                    }\n+                } else {\n+                    throw std::runtime_error(\"got a section inside result\");\n+                }\n+                break;\n+\n+            case Node::Type::tag:\n+                generateResultTag(n, r, out);\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out) {\n+    // TODO(martinus) save & restore stream status\n+    out.precision(std::numeric_limits<double>::digits10);\n+    auto nodes = parseMustacheTemplate(&mustacheTemplate);\n+\n+    for (auto const& n : nodes) {\n+        switch (n.type) {\n+        case Node::Type::content:\n+            out.write(n.begin, std::distance(n.begin, n.end));\n+            break;\n+\n+        case Node::Type::inverted_section:\n+            throw std::runtime_error(\"unknown list '\" + std::string(n.begin, n.end) + \"'\");\n+\n+        case Node::Type::section:\n+            if (n == \"result\") {\n+                for (size_t i = 0; i < results.size(); ++i) {\n+                    generateResult(n.children, i, results, out);\n+                }\n+            } else {\n+                throw std::runtime_error(\"unknown section '\" + std::string(n.begin, n.end) + \"'\");\n+            }\n+            break;\n+\n+        case Node::Type::tag:\n+            throw std::runtime_error(\"unknown tag '\" + std::string(n.begin, n.end) + \"'\");\n+            break;\n+        }\n+    }\n+}\n+\n+} // namespace templates\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+char const* getEnv(char const* name);\n+bool isEndlessRunning(std::string const& name);\n+\n+template <typename T>\n+T parseFile(std::string const& filename);\n+\n+void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<std::string>& recommendations);\n+void printStabilityInformationOnce(std::ostream* os);\n+\n+// remembers the last table settings used. When it changes, a new table header is automatically written for the new entry.\n+uint64_t& singletonHeaderHash() noexcept;\n+\n+// determines resolution of the given clock. This is done by measuring multiple times and returning the minimum time difference.\n+Clock::duration calcClockResolution(size_t numEvaluations) noexcept;\n+\n+// Calculates clock resolution once, and remembers the result\n+inline Clock::duration clockResolution() noexcept;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+// adds thousands separator to numbers\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class NumSep : public std::numpunct<char> {\n+public:\n+    explicit NumSep(char sep);\n+    char do_thousands_sep() const override;\n+    std::string do_grouping() const override;\n+\n+private:\n+    char mSep;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// RAII to save & restore a stream's state\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class StreamStateRestorer {\n+public:\n+    explicit StreamStateRestorer(std::ostream& s);\n+    ~StreamStateRestorer();\n+\n+    // sets back all stream info that we remembered at construction\n+    void restore();\n+\n+    // don't allow copying / moving\n+    StreamStateRestorer(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer(StreamStateRestorer&&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer&&) = delete;\n+\n+private:\n+    std::ostream& mStream;\n+    std::locale mLocale;\n+    std::streamsize const mPrecision;\n+    std::streamsize const mWidth;\n+    std::ostream::char_type const mFill;\n+    std::ostream::fmtflags const mFmtFlags;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Number formatter\n+class Number {\n+public:\n+    Number(int width, int precision, double value);\n+    Number(int width, int precision, int64_t value);\n+    std::string to_s() const;\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, Number const& n);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    int mWidth;\n+    int mPrecision;\n+    double mValue;\n+};\n+\n+// helper replacement for std::to_string of signed/unsigned numbers so we are locale independent\n+std::string to_s(uint64_t s);\n+\n+std::ostream& operator<<(std::ostream& os, Number const& n);\n+\n+class MarkDownColumn {\n+public:\n+    MarkDownColumn(int w, int prec, std::string const& tit, std::string const& suff, double val);\n+    std::string title() const;\n+    std::string separator() const;\n+    std::string invalid() const;\n+    std::string value() const;\n+\n+private:\n+    int mWidth;\n+    int mPrecision;\n+    std::string mTitle;\n+    std::string mSuffix;\n+    double mValue;\n+};\n+\n+// Formats any text as markdown code, escaping backticks.\n+class MarkDownCode {\n+public:\n+    explicit MarkDownCode(std::string const& what);\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    std::string mWhat{};\n+};\n+\n+std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+PerformanceCounters& performanceCounters() {\n+#    if defined(__clang__)\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n+#    endif\n+    static PerformanceCounters pc;\n+#    if defined(__clang__)\n+#        pragma clang diagnostic pop\n+#    endif\n+    return pc;\n+}\n+\n+// Windows version of do not optimize away",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386431558",
      "id" : 386431558,
      "in_reply_to_id" : 386125344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzMTU1OA==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 1193,
      "path" : "src/bench/nanobench.h",
      "position" : null,
      "pull_request_review_id" : 367249240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386431558",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386435113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386435113"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "maybe I should add an option like `-csv=<filename>` that enables writing the .csv to the given file, if the option is present. Currently I always write a \"benchmarkresults.csv\", which can be a bit annoying when not wanted",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-02T14:46:58Z",
      "diff_hunk" : "@@ -125,37 +50,29 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n             assert(witness_enabled);\n         }\n \n-        if (!std::regex_match(p.first, baseMatch, reFilter)) {\n-             g_testing_setup = nullptr;\n-            continue;\n-        }\n-\n-        uint64_t num_iters = static_cast<uint64_t>(p.second.num_iters_for_one_second * scaling);\n-        if (0 == num_iters) {\n-            num_iters = 1;\n+        Bench bench;\n+        bench.name(p.first);\n+        if (asymptote.empty()) {\n+            p.second(bench);\n+        } else {\n+            for (auto n : asymptote) {\n+                bench.complexityN(n);\n+                p.second(bench);\n+            }\n+            std::cout << bench.complexityBigO() << std::endl;\n         }\n-        State state(p.first, num_evals, num_iters, printer);\n-        if (!is_list_only) {\n-            p.second.func(state);\n-        }\n-        printer.result(state);\n+        benchmarkResults.push_back(bench.results().back());\n         g_testing_setup = nullptr;\n     }\n \n-    printer.footer();\n-}\n-\n-bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)\n-{\n-    if (m_start_time != time_point()) {\n-        std::chrono::duration<double> diff = current_time - m_start_time;\n-        m_elapsed_results.push_back(diff.count() / m_num_iters);\n-\n-        if (m_elapsed_results.size() == m_num_evals) {\n-            return false;\n+    if (!benchmarkResults.empty()) {\n+        // Generate legacy CSV data to \"benchmarkresults.csv\"\n+        std::ofstream fout(\"benchmarkresults.csv\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r386435113",
      "id" : 386435113,
      "in_reply_to_id" : 386128767,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzNTExMw==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 173,
      "path" : "src/bench/bench.cpp",
      "position" : null,
      "pull_request_review_id" : 367253840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/386435113",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2020-03-06T08:21:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-595656276",
      "id" : 595656276,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NTY1NjI3Ng==",
      "updated_at" : "2020-03-06T08:21:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/595656276",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've pushed a few updates:\r\n\r\n* updated `nanobench.h` with a (bit) faster RNG, and explicit constructors so `extended-lint-all.h` doesn't complain any more\r\n* add command line options `-output_csv` to enable creation of legacy CSV file\r\n* add command line optoin `-output_json` to create a big JSON with all data\r\n\r\nNot sure if I should squash all the changes into a single commit or leave the separately?\r\n\r\nHere is console output, .CSV file, and .json file of one run (click RAW):\r\n\r\nhttps://gist.github.com/martinus/d5e596b7802199737ef38399ef749d51 ",
      "created_at" : "2020-03-08T07:22:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-596175247",
      "id" : 596175247,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NjE3NTI0Nw==",
      "updated_at" : "2020-03-08T07:32:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596175247",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Perhaps the `gArgs.AddArg(\"-list\")` fix and the \"comment nits\" changes ought to be in 79fd93a where they are first changed rather than 51b83e1 and 9d6eb72. Alternatively, with 2 ACKs it may have been good to rebase with no changes to preserve existing review and do the rest in a follow-up PR (I'm not sure).",
      "created_at" : "2020-03-08T09:55:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-596186855",
      "id" : 596186855,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NjE4Njg1NQ==",
      "updated_at" : "2020-03-08T09:57:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596186855",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389356113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389356113"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why did you remove this test? (should probably move to tests though)",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T10:33:58Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389356113",
      "id" : 389356113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NjExMw==",
      "original_commit_id" : "79fd93ae7da64aa6d7532aa46734623d0824098d",
      "original_position" : 6,
      "path" : "src/bench/examples.cpp",
      "position" : 8,
      "pull_request_review_id" : 370819863,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389356113",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389356343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389356343"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems to have been added here: https://github.com/bitcoin/bitcoin/commit/535ed9223dcb32bf90ead5b2c95052838b780620#diff-5f8387aba8e5e6c0c871e093c9145085R9\r\nSo I guess it is somewhat a useless test",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T10:37:34Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389356343",
      "id" : 389356343,
      "in_reply_to_id" : 389356113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NjM0Mw==",
      "original_commit_id" : "79fd93ae7da64aa6d7532aa46734623d0824098d",
      "original_position" : 6,
      "path" : "src/bench/examples.cpp",
      "position" : 8,
      "pull_request_review_id" : 370819863,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389356343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389357673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389357673"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I removed this test because it's rather useless, it would uselessly slow down the whole benchmark run quite a bit compared to the others, and since it's in `examples.cpp` I assumed that it's just an example anyways",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T10:55:22Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389357673",
      "id" : 389357673,
      "in_reply_to_id" : 389356113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NzY3Mw==",
      "original_commit_id" : "79fd93ae7da64aa6d7532aa46734623d0824098d",
      "original_position" : 6,
      "path" : "src/bench/examples.cpp",
      "position" : 8,
      "pull_request_review_id" : 370821000,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389357673",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389366619"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389366619"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unless I was missing something, if you remove this test then the `#include <util/time.h>` can be removed with it.",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T12:52:50Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389366619",
      "id" : 389366619,
      "in_reply_to_id" : 389356113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2NjYxOQ==",
      "original_commit_id" : "79fd93ae7da64aa6d7532aa46734623d0824098d",
      "original_position" : 6,
      "path" : "src/bench/examples.cpp",
      "position" : 8,
      "pull_request_review_id" : 370827858,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389366619",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389378976"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389378976"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah right I totally forgot removing the include",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T15:19:46Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389378976",
      "id" : 389378976,
      "in_reply_to_id" : 389356113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3ODk3Ng==",
      "original_commit_id" : "79fd93ae7da64aa6d7532aa46734623d0824098d",
      "original_position" : 6,
      "path" : "src/bench/examples.cpp",
      "position" : 8,
      "pull_request_review_id" : 370837796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389378976",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389379424"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389379424"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done in https://github.com/bitcoin/bitcoin/pull/18011/commits/5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T15:24:43Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389379424",
      "id" : 389379424,
      "in_reply_to_id" : 386124056,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3OTQyNA==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 2,
      "path" : "src/bench/examples.cpp",
      "position" : null,
      "pull_request_review_id" : 370838162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:24:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389379424",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389379453"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389379453"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've reworded it a bit in rebase with new version of nanobench.h  in https://github.com/bitcoin/bitcoin/pull/18011/commits/79fd93ae7da64aa6d7532aa46734623d0824098d",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T15:25:16Z",
      "diff_hunk" : "@@ -0,0 +1,2491 @@\n+//  __   _ _______ __   _  _____  ______  _______ __   _ _______ _     _\n+//  | \\  | |_____| | \\  | |     | |_____] |______ | \\  | |       |_____|\n+//  |  \\_| |     | |  \\_| |_____| |_____] |______ |  \\_| |_____  |     |\n+//\n+// Microbenchmark framework for C++11/14/17/20\n+// https://github.com/martinus/nanobench\n+//\n+// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n+// SPDX-License-Identifier: MIT\n+// Copyright (c) 2019-2020 Martin Ankerl <http://martin.ankerl.com>\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in all\n+// copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+// SOFTWARE.\n+\n+#ifndef ANKERL_NANOBENCH_H_INCLUDED\n+#define ANKERL_NANOBENCH_H_INCLUDED\n+\n+// see https://semver.org/\n+#define ANKERL_NANOBENCH_VERSION_MAJOR 4 // incompatible API changes\n+#define ANKERL_NANOBENCH_VERSION_MINOR 0 // backwards-compatible changes\n+#define ANKERL_NANOBENCH_VERSION_PATCH 0 // backwards-compatible bug fixes\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// public facing api - as minimal as possible\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#include <chrono>           // high_resolution_clock\n+#include <cstring>          // memcpy\n+#include <initializer_list> // for doNotOptimizeAway\n+#include <iosfwd>           // for std::ostream* custom output target in Config\n+#include <string>           // all names\n+#include <unordered_map>    // used by Result\n+#include <vector>           // holds all results\n+\n+#define ANKERL_NANOBENCH(x) ANKERL_NANOBENCH_PRIVATE_##x()\n+\n+#define ANKERL_NANOBENCH_PRIVATE_CXX() __cplusplus\n+#define ANKERL_NANOBENCH_PRIVATE_CXX98() 199711L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX11() 201103L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX14() 201402L\n+#define ANKERL_NANOBENCH_PRIVATE_CXX17() 201703L\n+\n+#if ANKERL_NANOBENCH(CXX) >= ANKERL_NANOBENCH(CXX17)\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD() [[nodiscard]]\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NODISCARD()\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH() \\\n+        _Pragma(\"clang diagnostic push\") _Pragma(\"clang diagnostic ignored \\\"-Wpadded\\\"\")\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP() _Pragma(\"clang diagnostic pop\")\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH()\n+#    define ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP()\n+#endif\n+\n+#if defined(ANKERL_NANOBENCH_LOG_ENABLED)\n+#    include <iostream>\n+#    define ANKERL_NANOBENCH_LOG(x) std::cout << __FUNCTION__ << \"@\" << __LINE__ << \": \" << x << std::endl\n+#else\n+#    define ANKERL_NANOBENCH_LOG(x)\n+#endif\n+\n+#if defined(__linux__)\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 1\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS() 0\n+#endif\n+\n+#if defined(__clang__)\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...) __attribute__((no_sanitize(__VA_ARGS__)))\n+#else\n+#    define ANKERL_NANOBENCH_NO_SANITIZE(...)\n+#endif\n+\n+#if defined(_MSC_VER)\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __declspec(noinline)\n+#else\n+#    define ANKERL_NANOBENCH_PRIVATE_NOINLINE() __attribute__((noinline))\n+#endif\n+\n+// workaround missing \"is_trivially_copyable\" in g++ < 5.0\n+// See https://stackoverflow.com/a/31798726/48181\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) __has_trivial_copy(__VA_ARGS__)\n+#else\n+#    define ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(...) std::is_trivially_copyable<__VA_ARGS__>::value\n+#endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+using Clock = std::chrono::high_resolution_clock;\n+class Bench;\n+struct Config;\n+class Result;\n+class Rng;\n+class BigO;\n+\n+// Contains mustache-like templates\n+namespace templates {\n+\n+// CSV file from the benchmark results.\n+char const* csv() noexcept;\n+\n+// HTML graphic using plotly.js\n+char const* htmlBoxplot() noexcept;\n+\n+// JSON that contains all result data\n+char const* json() noexcept;\n+\n+// Generates output from the template and results into the given stream\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out);\n+\n+} // namespace templates\n+\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet;\n+\n+class IterationLogic;\n+class PerformanceCounters;\n+\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+class LinuxPerformanceCounters;\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+template <typename T>\n+struct PerfCountSet {\n+    T pageFaults{};\n+    T cpuCycles{};\n+    T contextSwitches{};\n+    T instructions{};\n+    T branchInstructions{};\n+    T branchMisses{};\n+};\n+\n+} // namespace detail\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Config {\n+    // actual benchmark config\n+    std::string mBenchmarkTitle = \"benchmark\";\n+    std::string mBenchmarkName = \"noname\";\n+    std::string mUnit = \"op\";\n+    double mBatch = 1.0;\n+    double mComplexityN = -1.0;\n+    size_t mNumEpochs = 11;\n+    size_t mClockResolutionMultiple = static_cast<size_t>(1000);\n+    std::chrono::nanoseconds mMaxEpochTime = std::chrono::milliseconds(100);\n+    std::chrono::nanoseconds mMinEpochTime{};\n+    uint64_t mMinEpochIterations{1};\n+    uint64_t mWarmup = 0;\n+    std::ostream* mOut = nullptr;\n+    bool mShowPerformanceCounters = true;\n+    bool mIsRelative = false;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Result returned after a benchmark has finished. Can be used as a baseline for relative().\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Result {\n+public:\n+    Result(Config const& benchmarkConfig);\n+\n+    // adds new measurement results\n+    // all values are scaled by iters (except iters...)\n+    void add(Clock::duration totalElapsed, uint64_t iters, detail::PerformanceCounters const& pc);\n+\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) double median(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double medianAbsolutePercentError(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double average(std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) double sum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double sumProduct(std::string const& query1, std::string const& query2) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double minimum(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double maximum(std::string const& query) const noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) bool has(std::string const& query) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double get(size_t idx, std::string const& query) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool empty() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t size() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+    std::unordered_map<std::string, std::vector<double>> mNameToMeasurements{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Sfc64, V4 - Small Fast Counting RNG, version 4\n+// Based on code from http://pracrand.sourceforge.net\n+class Rng final {\n+public:\n+    using result_type = uint64_t;\n+\n+    static constexpr uint64_t(min)();\n+    static constexpr uint64_t(max)();\n+\n+    Rng();\n+\n+    // don't allow copying, it's dangerous\n+    Rng(Rng const&) = delete;\n+    Rng& operator=(Rng const&) = delete;\n+\n+    // moving is ok\n+    Rng(Rng&&) noexcept = default;\n+    Rng& operator=(Rng&&) noexcept = default;\n+    ~Rng() noexcept = default;\n+\n+    explicit Rng(uint64_t seed) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Rng copy() const noexcept;\n+    void assign(Rng const& other) noexcept;\n+\n+    // that one's inline so it is fast\n+    inline uint64_t operator()() noexcept;\n+\n+    // random double in range [0, 1(\n+    inline double uniform01() noexcept;\n+\n+private:\n+    static constexpr uint64_t rotl(uint64_t x, unsigned k) noexcept;\n+\n+    uint64_t mA;\n+    uint64_t mB;\n+    uint64_t mC;\n+    uint64_t mCounter;\n+};\n+\n+// Main entry class for the microbenchmark framework.\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class Bench {\n+public:\n+    Bench();\n+\n+    Bench(Bench&& other);\n+    Bench& operator=(Bench&& other);\n+    Bench(Bench const& other);\n+    Bench& operator=(Bench const& other);\n+\n+    ~Bench() noexcept;\n+\n+    // Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+    // Best used in combination with `unit`. Any argument is cast to double.\n+    template <typename T>\n+    Bench& batch(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double batch() const noexcept;\n+\n+    // Marks the next run as the baseline. The following runs will be compared to this run. 100% will mean it is exactly as fast as the\n+    // baseline, >100% means it is faster than the baseline. It is calculated by `100% * runtime_baseline / runtime`. So e.g. 200%\n+    // means the current run is twice as fast as the baseline.\n+    Bench& relative(bool isRelativeEnabled) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool relative() const noexcept;\n+\n+    Bench& performanceCounters(bool showPerformanceCounters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool performanceCounters() const noexcept;\n+\n+    // Operation unit. Defaults to \"op\", could be e.g. \"byte\" for string processing. This is used for the table header, e.g. to show\n+    // `ns/byte`. Use singular (byte, not bytes). A change clears the currently collected results.\n+    Bench& unit(std::string unit);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& unit() const noexcept;\n+\n+    // Title of the benchmark, will be shown in the table header. A change clears the currently collected results.\n+    Bench& title(std::string benchmarkTitle);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& title() const noexcept;\n+\n+    // Name of the benchmark, will be shown in the table row.\n+    Bench& name(std::string benchmarkName);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+\n+    // Set the output stream where the resulting markdown table will be printed to. The default is `&std::cout`. You can disable all\n+    // output by setting `nullptr`.\n+    Bench& output(std::ostream* outstream) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::ostream* output() const noexcept;\n+\n+    // Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch. Defaults to 11. The higher you\n+    // choose this, the more deterministic will the result be and outliers will be more easily removed. The default is already quite\n+    // high to be able to filter most outliers.\n+    //\n+    // For slow benchmarks you might want to reduce this number.\n+    Bench& epochs(size_t numEpochs) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t epochs() const noexcept;\n+\n+    // Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This allows nanobech to be so\n+    // fast: we only run the benchmark sufficiently often so that the clock's accuracy is good enough. The default is to run one epoch\n+    // for 2000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of `20ns * 8000 * 11 ~\n+    // 2ms` for a benchmark to get accurate results.\n+    Bench& clockResolutionMultiple(size_t multiple) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) size_t clockResolutionMultiple() const noexcept;\n+\n+    // As a safety precausion if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch.\n+    // Default is 100ms.\n+    Bench& maxEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds maxEpochTime() const noexcept;\n+\n+    // Sets the minimum time each epoch should take. Default is zero, so clockResolutionMultiple() can do it's best guess. You can\n+    // increase this if you have the time and results are not accurate enough.\n+    Bench& minEpochTime(std::chrono::nanoseconds t) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) std::chrono::nanoseconds minEpochTime() const noexcept;\n+\n+    // Sets the minimum number of iterations each epoch should take. Default is 1. For high median average percentage error (MdAPE),\n+    // which happens when your benchmark is unstable, you might want to increase the minimum number to get more accurate reslts.\n+    Bench& minEpochIterations(uint64_t numIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t minEpochIterations() const noexcept;\n+\n+    // Set a number of iterations that are initially performed without any measurements, to warmup caches / database / whatever.\n+    // Normally this is not needed, since we show the median result so initial outliers will be filtered away automatically.\n+    Bench& warmup(uint64_t numWarmupIters) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t warmup() const noexcept;\n+\n+    // Gets all benchmark results\n+    ANKERL_NANOBENCH(NODISCARD) std::vector<Result> const& results() const noexcept;\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(std::string const& benchmarkName, Op op);\n+\n+    // Repeatedly calls op() based on the configuration, and performs measurements. Uses previously set name.\n+    // Make sure this is noinline to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect\n+    template <typename Op>\n+    ANKERL_NANOBENCH(NOINLINE)\n+    Bench& run(Op op);\n+\n+    // Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+    template <typename... Args>\n+    Bench& doNotOptimizeAway(Args&&... args);\n+\n+    // Parses the mustache-like template and renders the output into os.\n+    Bench& render(char const* templateContent, std::ostream& os);\n+\n+    // Set the length of N for the next benchmark run, so it is possible to calculate bigO.\n+    template <typename T>\n+    Bench& complexityN(T b) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double complexityN() const noexcept;\n+\n+    // calculates bigO of the results with all preconfigured complexity functions\n+    std::vector<BigO> complexityBigO() const;\n+\n+    // calculates bigO for a custom function\n+    template <typename Op>\n+    BigO complexityBigO(std::string const& name, Op op) const;\n+\n+    // Set all the configuration.\n+    Bench& config(Config const& benchmarkConfig);\n+    ANKERL_NANOBENCH(NODISCARD) Config const& config() const noexcept;\n+\n+private:\n+    Config mConfig{};\n+\n+    // results\n+    std::vector<Result> mResults{};\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args);\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+void doNotOptimizeAwaySink(void const*);\n+\n+template <typename T>\n+void doNotOptimizeAway(T const& val);\n+\n+#else\n+\n+// see folly's Benchmark.h\n+template <typename T>\n+constexpr bool doNotOptimizeNeedsIndirect() {\n+    using Decayed = typename std::decay<T>::type;\n+    return !ANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(Decayed) || sizeof(Decayed) > sizeof(long) || std::is_pointer<Decayed>::value;\n+}\n+\n+template <typename T>\n+typename std::enable_if<!doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"r\"(val));\n+}\n+\n+template <typename T>\n+typename std::enable_if<doNotOptimizeNeedsIndirect<T>()>::type doNotOptimizeAway(T const& val) {\n+    // NOLINTNEXTLINE(hicpp-no-assembler)\n+    asm volatile(\"\" ::\"m\"(val) : \"memory\");\n+}\n+#endif\n+\n+// internally used, but visible because run() is templated\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class IterationLogic {\n+public:\n+    IterationLogic(Bench const& config) noexcept;\n+\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t numIters() const noexcept;\n+    void add(std::chrono::nanoseconds elapsed, PerformanceCounters const& pc) noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) Result& result();\n+\n+private:\n+    enum class State { warmup, upscaling_runtime, measuring, endless };\n+\n+    void showResult(std::string const& errorMessage) const;\n+    ANKERL_NANOBENCH(NODISCARD) bool isCloseEnoughForMeasurements(std::chrono::nanoseconds elapsed) const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) uint64_t calcBestNumIters(std::chrono::nanoseconds elapsed, uint64_t iters) noexcept;\n+    void upscale(std::chrono::nanoseconds elapsed);\n+\n+    uint64_t mNumIters = 1;\n+    Bench const& mBench;\n+    std::chrono::nanoseconds mTargetRuntimePerEpoch{};\n+    Result mResult;\n+    Rng mRng{};\n+    std::chrono::nanoseconds mTotalElapsed{};\n+    uint64_t mTotalNumIters = 0;\n+\n+    State mState = State::upscaling_runtime;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class PerformanceCounters {\n+public:\n+    PerformanceCounters(PerformanceCounters const&) = delete;\n+    PerformanceCounters& operator=(PerformanceCounters const&) = delete;\n+\n+    PerformanceCounters();\n+    ~PerformanceCounters();\n+\n+    void beginMeasure();\n+    void endMeasure();\n+    void updateResults(uint64_t numIters);\n+\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<uint64_t> const& val() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) PerfCountSet<bool> const& has() const noexcept;\n+\n+private:\n+#if ANKERL_NANOBENCH(PERF_COUNTERS)\n+    LinuxPerformanceCounters* mPc = nullptr;\n+#endif\n+    PerfCountSet<uint64_t> mVal;\n+    PerfCountSet<bool> mHas;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Gets the singleton\n+PerformanceCounters& performanceCounters();\n+\n+} // namespace detail\n+\n+class BigO {\n+public:\n+    using RangeMeasure = std::vector<std::pair<double, double>>;\n+\n+    template <typename Op>\n+    static RangeMeasure mapRangeMeasure(RangeMeasure data, Op op) {\n+        for (auto& rangeMeasure : data) {\n+            rangeMeasure.first = op(rangeMeasure.first);\n+        }\n+        return data;\n+    }\n+\n+    static RangeMeasure collectRangeMeasure(std::vector<Result> const& results);\n+\n+    template <typename Op>\n+    BigO(std::string const& bigOName, RangeMeasure const& rangeMeasure, Op rangeToN)\n+        : BigO(bigOName, mapRangeMeasure(rangeMeasure, rangeToN)) {}\n+\n+    BigO(std::string const& bigOName, RangeMeasure const& scaledRangeMeasure);\n+    ANKERL_NANOBENCH(NODISCARD) std::string const& name() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double constant() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) double normalizedRootMeanSquare() const noexcept;\n+    ANKERL_NANOBENCH(NODISCARD) bool operator<(BigO const& other) const noexcept;\n+\n+private:\n+    std::string mName{};\n+    double mConstant{};\n+    double mNormalizedRootMeanSquare{};\n+};\n+std::ostream& operator<<(std::ostream& os, BigO const& bigO);\n+std::ostream& operator<<(std::ostream& os, std::vector<ankerl::nanobench::BigO> const& bigOs);\n+\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// Small Fast Counting RNG, version 4\n+constexpr uint64_t(Rng::min)() {\n+    return 0;\n+}\n+\n+constexpr uint64_t(Rng::max)() {\n+    return (std::numeric_limits<uint64_t>::max)();\n+}\n+\n+// Mark this as no_sanitize, otherwise UBSAN will say we got an unsigned integer overflow. Which is not a undefined behavior, but often\n+// a bug. Not here though.\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+uint64_t Rng::operator()() noexcept {\n+    uint64_t tmp = mA + mB + mCounter++;\n+    mA = mB ^ (mB >> 11U);\n+    mB = mC + (mC << 3U);\n+    mC = rotl(mC, 24U) + tmp;\n+    return tmp;\n+}\n+\n+// see http://prng.di.unimi.it/\n+double Rng::uniform01() noexcept {\n+    auto i = (UINT64_C(0x3ff) << 52U) | (operator()() >> 12U);\n+    // can't use union in c++ here for type puning, it's undefined behavior.\n+    // std::memcpy is optimized away anyways.\n+    double d;\n+    std::memcpy(&d, &i, sizeof(double));\n+    return d - 1.0;\n+}\n+\n+constexpr uint64_t Rng::rotl(uint64_t x, unsigned k) noexcept {\n+    return (x << k) | (x >> (64U - k));\n+}\n+\n+template <typename Op>\n+ANKERL_NANOBENCH_NO_SANITIZE(\"integer\")\n+Bench& Bench::run(Op op) {\n+    // It is important that this method is kept short so the compiler can do better optimizations/ inlining of op()\n+    detail::IterationLogic iterationLogic(*this);\n+    auto& pc = detail::performanceCounters();\n+\n+    while (auto n = iterationLogic.numIters()) {\n+        pc.beginMeasure();\n+        Clock::time_point before = Clock::now();\n+        while (n-- > 0) {\n+            op();\n+        }\n+        Clock::time_point after = Clock::now();\n+        pc.endMeasure();\n+        pc.updateResults(iterationLogic.numIters());\n+        iterationLogic.add(after - before, pc);\n+    }\n+    mResults.emplace_back(std::move(iterationLogic.result()));\n+    return *this;\n+}\n+\n+// Performs all evaluations.\n+template <typename Op>\n+Bench& Bench::run(std::string const& benchmarkName, Op op) {\n+    name(benchmarkName);\n+    return run(std::move(op));\n+}\n+\n+template <typename Op>\n+BigO Bench::complexityBigO(std::string const& benchmarkName, Op op) const {\n+    return BigO(benchmarkName, BigO::collectRangeMeasure(mResults), op);\n+}\n+\n+// Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.\n+// Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::batch(T b) noexcept {\n+    mConfig.mBatch = static_cast<double>(b);\n+    return *this;\n+}\n+\n+// Sets the computation complexity of the next run. Any argument is cast to double.\n+template <typename T>\n+Bench& Bench::complexityN(T n) noexcept {\n+    mConfig.mComplexityN = static_cast<double>(n);\n+    return *this;\n+}\n+\n+// Convenience: makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+Bench& Bench::doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+    return *this;\n+}\n+\n+// Makes sure none of the given arguments are optimized away by the compiler.\n+template <typename... Args>\n+void doNotOptimizeAway(Args&&... args) {\n+    (void)std::initializer_list<int>{(detail::doNotOptimizeAway(std::forward<Args>(args)), 0)...};\n+}\n+\n+namespace detail {\n+\n+#if defined(_MSC_VER)\n+template <typename T>\n+void doNotOptimizeAway(T const& val) {\n+    doNotOptimizeAwaySink(&val);\n+}\n+\n+#endif\n+\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+#if defined(ANKERL_NANOBENCH_IMPLEMENT)\n+\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+// implementation part\n+///////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+#    include <algorithm> // sort, reverse\n+#    include <atomic>    // compare_exchange_strong in loop overhead\n+#    include <cstdlib>   // getenv\n+#    include <cstring>   // strstr, strncmp\n+#    include <fstream>   // ifstream to parse proc files\n+#    include <iomanip>   // setw, setprecision\n+#    include <iostream>  // cout\n+#    include <numeric>   // accumulate\n+#    include <random>    // random_device\n+#    include <sstream>   // to_s in Number\n+#    include <stdexcept> // throw for rendering templates\n+#    include <tuple>     // std::tie\n+#    if defined(__linux__)\n+#        include <unistd.h> //sysconf\n+#    endif\n+#    if ANKERL_NANOBENCH(PERF_COUNTERS)\n+#        include <map> // map\n+\n+#        include <linux/perf_event.h>\n+#        include <sys/ioctl.h>\n+#        include <sys/syscall.h>\n+#        include <unistd.h>\n+#    endif\n+\n+// declarations ///////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+struct TableInfo;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+class NumSep;\n+class StreamStateRestorer;\n+class Number;\n+class MarkDownColumn;\n+class MarkDownCode;\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// definitions ////////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+// helpers to get double values\n+template <typename T>\n+inline double d(T t) noexcept {\n+    return static_cast<double>(t);\n+}\n+inline double d(Clock::duration dur) noexcept {\n+    return std::chrono::duration_cast<std::chrono::duration<double>>(dur).count();\n+}\n+\n+} // namespace detail\n+\n+namespace templates {\n+\n+char const* csv() noexcept {\n+    return R\"DELIM(\"title\"; \"name\"; \"unit\"; \"batch\"; \"elapsed\"; \"error %\"; \"instructions\"; \"branches\"; \"branch misses\"; \"total\"\n+{{#result}}\"{{title}}\"; \"{{name}}\"; \"{{unit}}\"; {{batch}}; {{median(elapsed)}}; {{medianAbsolutePercentError(elapsed)}}; {{median(instructions)}}; {{median(branchinstructions)}}; {{median(branchmisses)}}; {{sumProduct(iterations, elapsed)}}\n+{{/result}}\n+)DELIM\";\n+}\n+//\n+char const* htmlBoxplot() noexcept {\n+    return R\"DELIM(<html>\n+\n+<head>\n+    <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n+</head>\n+\n+<body>\n+    <div id=\"myDiv\" style=\"width:1024px; height:768px\"></div>\n+    <script>\n+        var data = [\n+            {{#result}}{\n+                name: '{{name}}',\n+                y: [{{#measurement}}{{elapsed}}{{^-last}}, {{/last}}{{/measurement}}],\n+            },\n+            {{/result}}\n+        ];\n+        var title = 'benchmark';\n+\n+        data = data.map(a => Object.assign(a, { boxpoints: 'all', pointpos: 0, type: 'box' }));\n+        var layout = { title: { text: title }, showlegend: false, yaxis: { title: 'time per unit', rangemode: 'tozero', autorange: true } }; Plotly.newPlot('myDiv', data, layout, {responsive: true});\n+    </script>\n+</body>\n+\n+</html>)DELIM\";\n+}\n+\n+char const* json() noexcept {\n+    return R\"DELIM({\n+    \"results\": [\n+{{#result}}        {\n+            \"title\": \"{{title}}\",\n+            \"name\": \"{{name}}\",\n+            \"unit\": \"{{unit}}\",\n+            \"batch\": {{batch}},\n+            \"complexityN\": {{complexityN}},\n+            \"epochs\": {{epochs}},\n+            \"clockResolutionMultiple\": {{clockResolutionMultiple}},\n+            \"maxEpochTime\": {{maxEpochTime}},\n+            \"minEpochTime\": {{minEpochTime}},\n+            \"minEpochIterations\": {{minEpochIterations}},\n+            \"warmup\": {{warmup}},\n+            \"relative\": {{relative}},\n+            \"median(elapsed)\": {{median(elapsed)}},\n+            \"medianAbsolutePercentError(elapsed)\": {{medianAbsolutePercentError(elapsed)}},\n+            \"median(instructions)\": {{median(instructions)}},\n+            \"medianAbsolutePercentError(instructions)\": {{medianAbsolutePercentError(instructions)}},\n+            \"median(cpucycles)\": {{median(cpucycles)}},\n+            \"median(contextswitches)\": {{median(contextswitches)}},\n+            \"median(pagefaults)\": {{median(pagefaults)}},\n+            \"median(branchinstructions)\": {{median(branchinstructions)}},\n+            \"median(branchmisses)\": {{median(branchmisses)}},\n+            \"totalTime\": {{sumProduct(iterations, elapsed)}},\n+            \"measurements\": [\n+{{#measurement}}                {\n+                    \"iterations\": {{iterations}},\n+                    \"elapsed\": {{elapsed}},\n+                    \"pagefaults\": {{pagefaults}},\n+                    \"cpucycles\": {{cpucycles}},\n+                    \"contextswitches\": {{contextswitches}},\n+                    \"instructions\": {{instructions}},\n+                    \"branchinstructions\": {{branchinstructions}},\n+                    \"branchmisses\": {{branchmisses}}\n+                }{{^-last}},{{/-last}}\n+{{/measurement}}            ]\n+        }{{^-last}},{{/-last}}\n+{{/result}}    ]\n+})DELIM\";\n+}\n+\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+struct Node {\n+    enum class Type { tag, content, section, inverted_section };\n+\n+    char const* begin;\n+    char const* end;\n+    std::vector<Node> children;\n+    Type type;\n+\n+    template <size_t N>\n+    // NOLINTNEXTLINE(hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)\n+    bool operator==(char const (&str)[N]) const noexcept {\n+        return static_cast<size_t>(std::distance(begin, end) + 1) == N && 0 == strncmp(str, begin, N - 1);\n+    }\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+static std::vector<Node> parseMustacheTemplate(char const** tpl) {\n+    std::vector<Node> nodes;\n+\n+    while (true) {\n+        auto begin = std::strstr(*tpl, \"{{\");\n+        auto end = begin;\n+        if (begin != nullptr) {\n+            begin += 2;\n+            end = std::strstr(begin, \"}}\");\n+        }\n+\n+        if (begin == nullptr || end == nullptr) {\n+            // nothing found, finish node\n+            nodes.emplace_back(Node{*tpl, *tpl + std::strlen(*tpl), std::vector<Node>{}, Node::Type::content});\n+            return nodes;\n+        }\n+\n+        nodes.emplace_back(Node{*tpl, begin - 2, std::vector<Node>{}, Node::Type::content});\n+\n+        // we found a tag\n+        *tpl = end + 2;\n+        switch (*begin) {\n+        case '/':\n+            // finished! bail out\n+            return nodes;\n+\n+        case '#':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::section});\n+            break;\n+\n+        case '^':\n+            nodes.emplace_back(Node{begin + 1, end, parseMustacheTemplate(tpl), Node::Type::inverted_section});\n+            break;\n+\n+        default:\n+            nodes.emplace_back(Node{begin, end, std::vector<Node>{}, Node::Type::tag});\n+            break;\n+        }\n+    }\n+}\n+\n+static bool generateFirstLast(Node const& n, size_t idx, size_t size, std::ostream& out) {\n+    bool matchFirst = n == \"-first\";\n+    bool matchLast = n == \"-last\";\n+    if (!matchFirst && !matchLast) {\n+        return false;\n+    }\n+\n+    bool doWrite = false;\n+    if (n.type == Node::Type::section) {\n+        doWrite = (matchFirst && idx == 0) || (matchLast && idx == size - 1);\n+    } else if (n.type == Node::Type::inverted_section) {\n+        doWrite = (matchFirst && idx != 0) || (matchLast && idx != size - 1);\n+    }\n+\n+    if (doWrite) {\n+        for (auto const& child : n.children) {\n+            if (child.type == Node::Type::content) {\n+                out.write(child.begin, std::distance(child.begin, child.end));\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+static bool matchCmdArgs(std::string const& str, std::vector<std::string>& matchResult) {\n+    matchResult.clear();\n+    auto idxOpen = str.find('(');\n+    auto idxClose = str.find(')', idxOpen);\n+    if (idxClose == std::string::npos) {\n+        return false;\n+    }\n+\n+    matchResult.emplace_back(str.substr(0, idxOpen));\n+\n+    // split by comma\n+    matchResult.emplace_back(std::string{});\n+    for (size_t i = idxOpen + 1; i != idxClose; ++i) {\n+        if (str[i] == ' ' || str[i] == '\\t') {\n+            // skip whitespace\n+            continue;\n+        }\n+        if (str[i] == ',') {\n+            // got a comma => new string\n+            matchResult.emplace_back(std::string{});\n+            continue;\n+        }\n+        // no whitespace no comma, append\n+        matchResult.back() += str[i];\n+    }\n+    return true;\n+}\n+\n+static std::ostream& generateResultTag(Node const& n, Result const& r, std::ostream& out) {\n+    using detail::d;\n+\n+    if (n == \"title\") {\n+        return out << r.config().mBenchmarkTitle;\n+    }\n+    if (n == \"name\") {\n+        return out << r.config().mBenchmarkName;\n+    }\n+    if (n == \"unit\") {\n+        return out << r.config().mUnit;\n+    }\n+    if (n == \"batch\") {\n+        return out << r.config().mBatch;\n+    }\n+    if (n == \"complexityN\") {\n+        return out << r.config().mComplexityN;\n+    }\n+    if (n == \"epochs\") {\n+        return out << r.config().mNumEpochs;\n+    }\n+    if (n == \"clockResolutionMultiple\") {\n+        return out << r.config().mClockResolutionMultiple;\n+    }\n+    if (n == \"maxEpochTime\") {\n+        return out << d(r.config().mMaxEpochTime);\n+    }\n+    if (n == \"minEpochTime\") {\n+        return out << d(r.config().mMinEpochTime);\n+    }\n+    if (n == \"minEpochIterations\") {\n+        return out << r.config().mMinEpochIterations;\n+    }\n+    if (n == \"warmup\") {\n+        return out << r.config().mWarmup;\n+    }\n+    if (n == \"relative\") {\n+        return out << r.config().mIsRelative;\n+    }\n+\n+    // match e.g. \"median(elapsed)\"\n+    // g++ 4.8 doesn't implement std::regex :(\n+    // static std::regex const regOpArg1(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\)$\");\n+    // std::cmatch matchResult;\n+    // if (std::regex_match(n.begin, n.end, matchResult, regOpArg1)) {\n+    std::vector<std::string> matchResult;\n+    if (matchCmdArgs(std::string(n.begin, n.end), matchResult)) {\n+        if (matchResult.size() == 2) {\n+            if (matchResult[0] == \"median\") {\n+                return out << r.median(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"average\") {\n+                return out << r.average(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"medianAbsolutePercentError\") {\n+                return out << r.medianAbsolutePercentError(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"sum\") {\n+                return out << r.sum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"minimum\") {\n+                return out << r.minimum(matchResult[1]);\n+            }\n+            if (matchResult[0] == \"maximum\") {\n+                return out << r.maximum(matchResult[1]);\n+            }\n+        } else if (matchResult.size() == 3) {\n+            if (matchResult[0] == \"sumProduct\") {\n+                return out << r.sumProduct(matchResult[1], matchResult[2]);\n+            }\n+        }\n+    }\n+\n+    // match e.g. \"sumProduct(elapsed, iterations)\"\n+    // static std::regex const regOpArg2(\"^([a-zA-Z]+)\\\\(([a-zA-Z]*)\\\\s*,\\\\s+([a-zA-Z]*)\\\\)$\");\n+\n+    // nothing matches :(\n+    throw std::runtime_error(\"command '\" + std::string(n.begin, n.end) + \"' not understood\");\n+}\n+\n+static void generateResultMeasurement(std::vector<Node> const& nodes, size_t idx, Result const& r, std::ostream& out) {\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, r.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside measurement\");\n+\n+            case Node::Type::section:\n+                throw std::runtime_error(\"got a section inside measurement\");\n+\n+            case Node::Type::tag: {\n+                out << r.get(idx, std::string(n.begin, n.end));\n+                break;\n+            }\n+            }\n+        }\n+    }\n+}\n+\n+static void generateResult(std::vector<Node> const& nodes, size_t idx, std::vector<Result> const& results, std::ostream& out) {\n+    auto const& r = results[idx];\n+    for (auto const& n : nodes) {\n+        if (!generateFirstLast(n, idx, results.size(), out)) {\n+            switch (n.type) {\n+            case Node::Type::content:\n+                out.write(n.begin, std::distance(n.begin, n.end));\n+                break;\n+\n+            case Node::Type::inverted_section:\n+                throw std::runtime_error(\"got a inverted section inside result\");\n+\n+            case Node::Type::section:\n+                if (n == \"measurement\") {\n+                    for (size_t i = 0; i < r.size(); ++i) {\n+                        generateResultMeasurement(n.children, i, r, out);\n+                    }\n+                } else {\n+                    throw std::runtime_error(\"got a section inside result\");\n+                }\n+                break;\n+\n+            case Node::Type::tag:\n+                generateResultTag(n, r, out);\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+void generate(char const* mustacheTemplate, std::vector<Result> const& results, std::ostream& out) {\n+    // TODO(martinus) save & restore stream status\n+    out.precision(std::numeric_limits<double>::digits10);\n+    auto nodes = parseMustacheTemplate(&mustacheTemplate);\n+\n+    for (auto const& n : nodes) {\n+        switch (n.type) {\n+        case Node::Type::content:\n+            out.write(n.begin, std::distance(n.begin, n.end));\n+            break;\n+\n+        case Node::Type::inverted_section:\n+            throw std::runtime_error(\"unknown list '\" + std::string(n.begin, n.end) + \"'\");\n+\n+        case Node::Type::section:\n+            if (n == \"result\") {\n+                for (size_t i = 0; i < results.size(); ++i) {\n+                    generateResult(n.children, i, results, out);\n+                }\n+            } else {\n+                throw std::runtime_error(\"unknown section '\" + std::string(n.begin, n.end) + \"'\");\n+            }\n+            break;\n+\n+        case Node::Type::tag:\n+            throw std::runtime_error(\"unknown tag '\" + std::string(n.begin, n.end) + \"'\");\n+            break;\n+        }\n+    }\n+}\n+\n+} // namespace templates\n+\n+// helper stuff that only intended to be used internally\n+namespace detail {\n+\n+char const* getEnv(char const* name);\n+bool isEndlessRunning(std::string const& name);\n+\n+template <typename T>\n+T parseFile(std::string const& filename);\n+\n+void gatherStabilityInformation(std::vector<std::string>& warnings, std::vector<std::string>& recommendations);\n+void printStabilityInformationOnce(std::ostream* os);\n+\n+// remembers the last table settings used. When it changes, a new table header is automatically written for the new entry.\n+uint64_t& singletonHeaderHash() noexcept;\n+\n+// determines resolution of the given clock. This is done by measuring multiple times and returning the minimum time difference.\n+Clock::duration calcClockResolution(size_t numEvaluations) noexcept;\n+\n+// Calculates clock resolution once, and remembers the result\n+inline Clock::duration clockResolution() noexcept;\n+\n+// formatting utilities\n+namespace fmt {\n+\n+// adds thousands separator to numbers\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class NumSep : public std::numpunct<char> {\n+public:\n+    explicit NumSep(char sep);\n+    char do_thousands_sep() const override;\n+    std::string do_grouping() const override;\n+\n+private:\n+    char mSep;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// RAII to save & restore a stream's state\n+ANKERL_NANOBENCH(IGNORE_PADDED_PUSH)\n+class StreamStateRestorer {\n+public:\n+    explicit StreamStateRestorer(std::ostream& s);\n+    ~StreamStateRestorer();\n+\n+    // sets back all stream info that we remembered at construction\n+    void restore();\n+\n+    // don't allow copying / moving\n+    StreamStateRestorer(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer const&) = delete;\n+    StreamStateRestorer(StreamStateRestorer&&) = delete;\n+    StreamStateRestorer& operator=(StreamStateRestorer&&) = delete;\n+\n+private:\n+    std::ostream& mStream;\n+    std::locale mLocale;\n+    std::streamsize const mPrecision;\n+    std::streamsize const mWidth;\n+    std::ostream::char_type const mFill;\n+    std::ostream::fmtflags const mFmtFlags;\n+};\n+ANKERL_NANOBENCH(IGNORE_PADDED_POP)\n+\n+// Number formatter\n+class Number {\n+public:\n+    Number(int width, int precision, double value);\n+    Number(int width, int precision, int64_t value);\n+    std::string to_s() const;\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, Number const& n);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    int mWidth;\n+    int mPrecision;\n+    double mValue;\n+};\n+\n+// helper replacement for std::to_string of signed/unsigned numbers so we are locale independent\n+std::string to_s(uint64_t s);\n+\n+std::ostream& operator<<(std::ostream& os, Number const& n);\n+\n+class MarkDownColumn {\n+public:\n+    MarkDownColumn(int w, int prec, std::string const& tit, std::string const& suff, double val);\n+    std::string title() const;\n+    std::string separator() const;\n+    std::string invalid() const;\n+    std::string value() const;\n+\n+private:\n+    int mWidth;\n+    int mPrecision;\n+    std::string mTitle;\n+    std::string mSuffix;\n+    double mValue;\n+};\n+\n+// Formats any text as markdown code, escaping backticks.\n+class MarkDownCode {\n+public:\n+    explicit MarkDownCode(std::string const& what);\n+\n+private:\n+    friend std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+    std::ostream& write(std::ostream& os) const;\n+\n+    std::string mWhat{};\n+};\n+\n+std::ostream& operator<<(std::ostream& os, MarkDownCode const& mdCode);\n+\n+} // namespace fmt\n+} // namespace detail\n+} // namespace nanobench\n+} // namespace ankerl\n+\n+// implementation /////////////////////////////////////////////////////////////////////////////////\n+\n+namespace ankerl {\n+namespace nanobench {\n+namespace detail {\n+\n+PerformanceCounters& performanceCounters() {\n+#    if defined(__clang__)\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n+#    endif\n+    static PerformanceCounters pc;\n+#    if defined(__clang__)\n+#        pragma clang diagnostic pop\n+#    endif\n+    return pc;\n+}\n+\n+// Windows version of do not optimize away",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389379453",
      "id" : 389379453,
      "in_reply_to_id" : 386125344,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3OTQ1Mw==",
      "original_commit_id" : "c2e924fc046110eb7ac5ab7bf19cfaf6daf1c44b",
      "original_position" : 1193,
      "path" : "src/bench/nanobench.h",
      "position" : null,
      "pull_request_review_id" : 370838194,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:25:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389379453",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389379530"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389379530"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done in https://github.com/bitcoin/bitcoin/pull/18011/commits/5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "commit_id" : "5bd582bbadb90970f631a7c4c4d793689584ca4e",
      "created_at" : "2020-03-08T15:25:59Z",
      "diff_hunk" : "@@ -5,29 +5,18 @@\n #include <bench/bench.h>\n #include <util/time.h>\n \n-// Sanity test: this should loop ten times, and\n-// min/max/average should be close to 100ms.\n-static void Sleep100ms(benchmark::State& state)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#discussion_r389379530",
      "id" : 389379530,
      "in_reply_to_id" : 389356113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3OTUzMA==",
      "original_commit_id" : "79fd93ae7da64aa6d7532aa46734623d0824098d",
      "original_position" : 6,
      "path" : "src/bench/examples.cpp",
      "position" : 8,
      "pull_request_review_id" : 370838240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18011",
      "updated_at" : "2020-03-08T15:25:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389379530",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-03-14T21:46:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-599138510",
      "id" : 599138510,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5OTEzODUxMA==",
      "updated_at" : "2020-03-14T21:46:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/599138510",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "rebased",
      "created_at" : "2020-03-28T07:32:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-605408603",
      "id" : 605408603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTQwODYwMw==",
      "updated_at" : "2020-03-28T07:32:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605408603",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-04-09T13:38:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-611532983",
      "id" : 611532983,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxMTUzMjk4Mw==",
      "updated_at" : "2020-04-09T13:38:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/611532983",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I tried running this locally, and it seems I am getting varying results:\r\n\r\n```\r\nmac-mini:bitcoin-core marco$ git log -1 && make -j 9 && ./src/bench/bench_bitcoin --filter=VerifyNestedIfScript\r\ncommit a841d1e25b1b26b6381f36e14307c2549a79edb4 (HEAD)\r\nAuthor: Martin Ankerl <martin.ankerl@gmail.com>\r\nDate:   Sun Mar 8 16:20:55 2020 +0100\r\n\r\n    remove unnecessary include util/time.h\r\nMaking all in src\r\nMaking all in doc/man\r\nmake[1]: Nothing to be done for `all'.\r\nmake[1]: Nothing to be done for `all-am'.\r\nWarning, results might be unstable:\r\n* NDEBUG not defined, assert() macros are evaluated\r\n\r\nRecommendations\r\n* Make sure you compile for Release\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          303,061.00 |            3,299.67 |    2.6% |      0.00 | `VerifyNestedIfScript`\r\nmac-mini:bitcoin-core marco$ git log -1 && make -j 9 && ./src/bench/bench_bitcoin --filter=VerifyNestedIfScript\r\ncommit a841d1e25b1b26b6381f36e14307c2549a79edb4 (HEAD)\r\nAuthor: Martin Ankerl <martin.ankerl@gmail.com>\r\nDate:   Sun Mar 8 16:20:55 2020 +0100\r\n\r\n    remove unnecessary include util/time.h\r\nMaking all in src\r\nMaking all in doc/man\r\nmake[1]: Nothing to be done for `all'.\r\nmake[1]: Nothing to be done for `all-am'.\r\nWarning, results might be unstable:\r\n* NDEBUG not defined, assert() macros are evaluated\r\n\r\nRecommendations\r\n* Make sure you compile for Release\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          155,083.00 |            6,448.16 |    9.4% |      0.00 | :wavy_dash: `VerifyNestedIfScript` (Unstable with ~1.0 iters. Increase `minEpochIterations` to e.g. 10)\r\n",
      "created_at" : "2020-04-09T14:55:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-611573379",
      "id" : 611573379,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxMTU3MzM3OQ==",
      "updated_at" : "2020-04-09T14:55:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/611573379",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Notably:\r\n\r\n* Consecutive runs are off by a factor of 2\r\n* There is a warning `Warning, results might be unstable: NDEBUG not defined, assert() macros are evaluated`, but I think it is impossible to compile Bitcoin Core with assert disabled\r\n* There is a warning from the framework itself: `:wavy_dash: `VerifyNestedIfScript` (Unstable with ~1.0 iters. Increase `minEpochIterations` to e.g. 10)`",
      "created_at" : "2020-04-09T14:57:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-611574488",
      "id" : 611574488,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxMTU3NDQ4OA==",
      "updated_at" : "2020-04-09T14:57:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/611574488",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've finally found the time to rebased my branch with a major update of nanobench, and updated the new benchmarks too.\r\n\r\n@MarcoFalke, I am pretty sure your instability comes from CPU frequency scaling / turbo mode. For nanobench to be able to have accurate runtime results it needs a CPU locked to fixed frequency. Under Linux I print warnings & suggestions if I detect this, but I don't have such a logic in place for other operating systems (yet).\r\n\r\nWhen I run the benchmark `VerifyNestedIfScript` a few times I get these results:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|           63,447.00 |           15,761.19 |    0.9% |      677,018.00 |      201,628.00 |  3.358 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n|           63,094.00 |           15,849.37 |    0.8% |      677,018.00 |      201,495.00 |  3.360 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n|           63,548.00 |           15,736.14 |    0.7% |      677,018.00 |      201,894.00 |  3.353 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n|           63,340.00 |           15,787.81 |    0.9% |      677,018.00 |      201,894.00 |  3.353 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n|           63,288.00 |           15,800.78 |    1.0% |      677,018.00 |      201,096.00 |  3.367 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n|           63,261.00 |           15,807.53 |    0.9% |      677,018.00 |      201,894.00 |  3.353 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n|           63,309.00 |           15,795.54 |    0.7% |      677,018.00 |      202,027.00 |  3.351 |     143,829.00 |    0.2% |      0.00 | `VerifyNestedIfScript`\r\n\r\nSo it is a very stable benchmark for me, with locked frequency scaling. When I don't lock the CPU my results too fluctuate, and the benchmark prints these warnings (I've removed the NDEBUG warning):\r\n\r\n```\r\nWarning, results might be unstable:\r\n* CPU frequency scaling enabled: CPU 0 between 800.0 and 4,600.0 MHz\r\n* CPU governor is 'powersave' but should be 'performance'\r\n* Turbo is enabled, CPU frequency will fluctuate\r\n\r\nRecommendations\r\n* Use 'pyperf system tune' before benchmarking. See https://github.com/vstinner/pyperf\r\n```",
      "created_at" : "2020-06-13T11:03:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-643607657",
      "id" : 643607657,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MzYwNzY1Nw==",
      "updated_at" : "2020-06-13T11:03:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/643607657",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "utack 78c312c.\r\n\r\n@MarcoFalke can you repeat your benchmark after running pyperf system tune?",
      "created_at" : "2020-06-13T18:33:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-643660924",
      "id" : 643660924,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MzY2MDkyNA==",
      "updated_at" : "2020-06-13T18:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/643660924",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@martinus While going thru this in July 2nd, 2020's meeting, I believe people were wondering what the support is like for non x86 architectures. Would it fail to compile? Have limited functionality? Or fail at runtime?",
      "created_at" : "2020-07-02T19:37:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-653187037",
      "id" : 653187037,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MzE4NzAzNw==",
      "updated_at" : "2020-07-02T19:37:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/653187037",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3445290?v=4",
         "events_url" : "https://api.github.com/users/dongcarl/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dongcarl/followers",
         "following_url" : "https://api.github.com/users/dongcarl/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dongcarl/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dongcarl",
         "id" : 3445290,
         "login" : "dongcarl",
         "node_id" : "MDQ6VXNlcjM0NDUyOTA=",
         "organizations_url" : "https://api.github.com/users/dongcarl/orgs",
         "received_events_url" : "https://api.github.com/users/dongcarl/received_events",
         "repos_url" : "https://api.github.com/users/dongcarl/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dongcarl/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dongcarl"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "FWIW, I could compile and run this PR (as merged on master) on RV64. It doesn't seem there is any compatibility issue as was implied by the travis run.\r\n\r\nConcept ACK.",
      "created_at" : "2020-07-02T21:37:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-653230966",
      "id" : 653230966,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MzIzMDk2Ng==",
      "updated_at" : "2020-07-02T22:16:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/653230966",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> @martinus While going thru this in July 2nd, 2020's meeting, I believe people were wondering what the support is like for non x86 architectures. Would it fail to compile? Have limited functionality? Or fail at runtime?\r\n\r\nThe CPU statistics like instructions, cycles, branch misspredictions are only available on Linux through perf events. But it should compile on any platform with C++11 support, then I'm only relying on the `std::chrono` timers.\r\n\r\nI have now a relatively comprehensive documentation of nanobench available here: https://nanobench.ankerl.com/",
      "created_at" : "2020-07-03T07:10:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-653390772",
      "id" : 653390772,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MzM5MDc3Mg==",
      "updated_at" : "2020-07-03T07:10:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/653390772",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK\r\n\r\nSo far I have built the PR and run some tests without any problems.",
      "created_at" : "2020-07-10T20:51:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-656884602",
      "id" : 656884602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njg4NDYwMg==",
      "updated_at" : "2020-07-10T20:51:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656884602",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 78c312c983255e15fc274de2368a2ec13ce81cbf",
      "created_at" : "2020-07-30T13:33:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-666367610",
      "id" : 666367610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjM2NzYxMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T13:33:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666367610",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've merged this because there was unanimous agreement that we want the new benchmark framework and it works as expected here (as well as for @fjahr and @JeremyRubin ). If @MarcoFalke's issue, is still a problem we should look into it, please open a github issue for it.",
      "created_at" : "2020-07-30T13:45:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-666374177",
      "id" : 666374177,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjM3NDE3Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T13:45:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666374177",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : " per my ACK a few months ago https://github.com/bitcoin/bitcoin/pull/18011#pullrequestreview-366872789",
      "created_at" : "2020-07-30T14:17:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-666393224",
      "id" : 666393224,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjM5MzIyNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T14:17:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666393224",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for merging! If anyone has any questions or issue with nanobench please notify me",
      "created_at" : "2020-07-30T17:43:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-666556750",
      "id" : 666556750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjU1Njc1MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T17:43:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666556750",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@martinus Mind looking into #18710 if it has any performance regression on supported platforms? ",
      "created_at" : "2020-07-31T18:27:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-667287740",
      "id" : 667287740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NzI4Nzc0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-31T18:27:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/667287740",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@martinus How to conditionally skip a benchmark in nanobench framework (wrt https://github.com/bitcoin/bitcoin/pull/19710#issuecomment-673547482 and https://github.com/bitcoin/bitcoin/pull/19710#issuecomment-674016320)?",
      "created_at" : "2020-08-14T11:04:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-674020807",
      "id" : 674020807,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDAyMDgwNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T11:04:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674020807",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "You can use `-filter` to specify a regular expression for which tests to run",
      "created_at" : "2020-08-14T11:07:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-674021899",
      "id" : 674021899,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDAyMTg5OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T11:07:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674021899",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> You can use `-filter` to specify a regular expression for which tests to run\r\n\r\nI mean in the code, e.g., skip `CCheckQueueSpeedPrevectorJob` if `GetNumCores() < 2`",
      "created_at" : "2020-08-14T11:08:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-674022527",
      "id" : 674022527,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDAyMjUyNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T11:08:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674022527",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> > You can use `-filter` to specify a regular expression for which tests to run\r\n> \r\n> I mean in the code, e.g., skip `CCheckQueueSpeedPrevectorJob` if `GetNumCores() < 2`\r\n\r\nAh, of course\r\n\r\nBefore benchmark is run you can do a check and then simply return, e.g. like so:\r\n\r\n```cpp\r\nstatic void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)\r\n{\r\n    if (GetNumCores() < 2) {\r\n        return;\r\n    }\r\n```\r\n\r\nBut that needs a little update in `bench.cpp`, because then the benchmark doesn't have any results:\r\n\r\n```cpp\r\n        if (!bench.results().empty()) {\r\n            benchmarkResults.push_back(bench.results().back());\r\n        }\r\n```",
      "created_at" : "2020-08-14T11:20:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-674026621",
      "id" : 674026621,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDAyNjYyMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T11:20:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674026621",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@martinus Thanks! I've submitted a commit (ce3e6a7cb21d1aa455513970846e1f70c01472a4) in #19710.",
      "created_at" : "2020-08-14T12:26:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-674049619",
      "id" : 674049619,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDA0OTYxOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T12:26:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674049619",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Not sure if this is caused by this pull, but some benchmarks changed performance quite significantly:\r\n\r\n* `BenchLockedPool` went down almost 100% to approx 0 compared to before: https://codespeed.bitcoinperf.com/timeline/#/?exe=3,4,2,1,5&base=1+23&ben=micro.clang.BenchLockedPool&env=1&revs=200&equid=off&quarts=on&extr=on\r\n* All the prevector ones as well (except the serialization one): https://codespeed.bitcoinperf.com/timeline/#/?exe=3,4,2,1,5&base=1+23&ben=micro.clang.PrevectorClearNontrivial&env=1&revs=200&equid=off&quarts=on&extr=on\r\n\r\nIs this due to compiler optimizations or something else?\r\n\r\nFunnily the trig dummy bench went up by ~100%: https://codespeed.bitcoinperf.com/timeline/#/?exe=3,4,2,1,5&base=1+23&ben=micro.clang.Trig&env=1&revs=200&equid=off&quarts=on&extr=on",
      "created_at" : "2020-08-24T09:25:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18011#issuecomment-679015075",
      "id" : 679015075,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18011",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3OTAxNTA3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-24T09:25:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/679015075",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   }
]
