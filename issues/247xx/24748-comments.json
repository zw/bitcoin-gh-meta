[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/24748).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [jonatack](https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1091152739), [brunoerg](https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1092829016), [mzumsande](https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1663408774), [theStack](https://github.com/bitcoin/bitcoin/pull/24748#pullrequestreview-1730319269) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#28538](https://github.com/bitcoin/bitcoin/pull/28538) (p2p: attempt to fill full outbound connection slots with peers that support tx relay by mzumsande)\n* [#28463](https://github.com/bitcoin/bitcoin/pull/28463) (p2p: Increase inbound capacity for block-relay only connections by mzumsande)\n* [#26728](https://github.com/bitcoin/bitcoin/pull/26728) (wallet: Have the wallet store the key for automatically generated descriptors by achow101)\n* [#25907](https://github.com/bitcoin/bitcoin/pull/25907) (wallet: rpc to add automatically generated descriptors by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2022-04-05T01:31:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1088181500",
      "id" : 1088181500,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585A3FT8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1088181500/reactions"
      },
      "updated_at" : "2023-11-29T05:49:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1088181500",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2022-04-07T07:03:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1091152739",
      "id" : 1091152739,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585BCatj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1091152739/reactions"
      },
      "updated_at" : "2022-04-07T07:03:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1091152739",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-04-08T12:54:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1092829016",
      "id" : 1092829016,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585BIz9Y",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092829016/reactions"
      },
      "updated_at" : "2022-04-08T12:54:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092829016",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19480819?v=4",
         "events_url" : "https://api.github.com/users/brunoerg/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brunoerg/followers",
         "following_url" : "https://api.github.com/users/brunoerg/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brunoerg/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brunoerg",
         "id" : 19480819,
         "login" : "brunoerg",
         "node_id" : "MDQ6VXNlcjE5NDgwODE5",
         "organizations_url" : "https://api.github.com/users/brunoerg/orgs",
         "received_events_url" : "https://api.github.com/users/brunoerg/received_events",
         "repos_url" : "https://api.github.com/users/brunoerg/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brunoerg/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brunoerg/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brunoerg"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-04-08T14:33:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1092927324",
      "id" : 1092927324,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585BJL9c",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092927324/reactions"
      },
      "updated_at" : "2022-04-08T14:33:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092927324",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "converting this PR into a draft. I'll push the updated version which includes the new spec changes in BIP 324 soon.",
      "created_at" : "2022-10-03T17:24:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1265788740",
      "id" : 1265788740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585LcmdE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1265788740/reactions"
      },
      "updated_at" : "2022-10-03T17:24:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1265788740",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've updated the PR to reflect the new spec changes in the BIP. It's built on top of #24545's 78c3ccc. Only the last 19 commits belong to this PR.\r\n\r\nUPDATE:\r\n- rebased on  #24545's f97a1a8\r\n- rebased on #24545's  a7fdbf6",
      "created_at" : "2022-12-16T16:09:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1355151959",
      "id" : 1355151959,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585QxfpX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1355151959/reactions"
      },
      "updated_at" : "2023-02-21T21:06:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1355151959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-12-19T09:35:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1357360284",
      "id" : 1357360284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585Q56yc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1357360284/reactions"
      },
      "updated_at" : "2022-12-19T09:35:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1357360284",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-15T15:50:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1431585008",
      "id" : 1431585008,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585VVEDw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431585008/reactions"
      },
      "updated_at" : "2023-02-15T15:50:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431585008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Moved to draft given it's based on multiple other PRs.",
      "created_at" : "2023-02-16T15:22:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1433257883",
      "id" : 1433257883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585Vbceb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433257883/reactions"
      },
      "updated_at" : "2023-02-16T15:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433257883",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-22T18:47:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1440611717",
      "id" : 1440611717,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585V3f2F",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1440611717/reactions"
      },
      "updated_at" : "2023-02-22T18:47:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1440611717",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--13523179cfe9479db18ec6c5d236f789-->\nThere hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? â¡ï¸ Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? â¡ï¸ Please close.\n* Did the author lose interest or time to work on this? â¡ï¸ Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
      "created_at" : "2023-07-02T01:11:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1616250559",
      "id" : 1616250559,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585gVga_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1616250559/reactions"
      },
      "updated_at" : "2023-07-02T01:11:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1616250559",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@stratospher Rebasing on #28331 would let you revive this.",
      "created_at" : "2023-08-01T18:07:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1660838322",
      "id" : 1660838322,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585i_mGy",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660838322/reactions"
      },
      "updated_at" : "2023-08-29T21:12:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1660838322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased on #28331. 2 things which affected the tests when rebasing were:\r\n1. `TestNode` can send garbage now\r\n2. since v1 reconnections are now attempted in a queue instead of immediately, there was a latency issue introduced in the tests in `add_outbound_p2p_connection()`",
      "created_at" : "2023-09-10T06:04:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1712724420",
      "id" : 1712724420,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585mFhnE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1712724420/reactions"
      },
      "updated_at" : "2023-09-10T06:04:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1712724420",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320700971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320700971"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "e18b22d: in an outbound connection, `TestNode` -----> `P2PConnection` where `P2PConnection` doesn't actually support v2 P2P but is advertised to support v2 P2P (false advertisement), we need to wait for the `TestNode` to reconnect using v1 P2P.\r\n\r\nThis `wait_for_reconnect()` function won't work always since race conditions are possible. Anyone has a better idea on how this can be done? ",
      "commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "created_at" : "2023-09-10T06:13:21Z",
      "diff_hunk" : "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320700971",
      "id" : 1320700971,
      "line" : 601,
      "node_id" : "PRRC_kwDOABII585OuEwr",
      "original_commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "original_line" : 601,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 4,
      "pull_request_review_id" : 1618745079,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320700971/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-10T06:13:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320700971",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320788959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320788959"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What is the race condition? I expect you should always still observe a v2 connection, a v2 disconnect, and a v1 connect.\r\n\r\nFWIW, the reason why the reconnect is done asynchronously is to avoid making a P2P connection (which can take seconds, or up to a minute) inside the normal network thread (as that'd prevent us from receiving anything from any other peer at the same time).",
      "commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "created_at" : "2023-09-10T15:26:39Z",
      "diff_hunk" : "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320788959",
      "id" : 1320788959,
      "in_reply_to_id" : 1320700971,
      "line" : 601,
      "node_id" : "PRRC_kwDOABII585OuaPf",
      "original_commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "original_line" : 601,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 4,
      "pull_request_review_id" : 1618844751,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320788959/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-10T15:26:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320788959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320795432"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320795432"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ideally, first `wait_for_connect` waits on v2 connection and the `wait_for_connect` a few lines below waits for v1 connection.\r\n\r\nit's possible that the v2 reconnection happens quickly and the first `wait_for_connect` detects a v2 connection directly. Then we'd be stuck waiting for disconnect and connect (in the lines below) to happen (even though it has already happened).",
      "commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "created_at" : "2023-09-10T16:13:14Z",
      "diff_hunk" : "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1320795432",
      "id" : 1320795432,
      "in_reply_to_id" : 1320700971,
      "line" : 601,
      "node_id" : "PRRC_kwDOABII585Oub0o",
      "original_commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "original_line" : 601,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 4,
      "pull_request_review_id" : 1618850256,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320795432/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-09-10T16:13:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1320795432",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-09-11T09:31:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1713517605",
      "id" : 1713517605,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585mIjQl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713517605/reactions"
      },
      "updated_at" : "2023-09-11T09:31:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1713517605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-09-21T10:57:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1729335625",
      "id" : 1729335625,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585nE5FJ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729335625/reactions"
      },
      "updated_at" : "2023-09-21T10:57:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729335625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349750146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349750146"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Updating the address is no longer necessary with the latest `net` code, just passing the bool should be enough.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-08T17:29:06Z",
      "diff_hunk" : "@@ -1913,7 +1913,11 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\n     CSemaphoreGrant grant(*semOutbound, true);\n     if (!grant) return false;\n \n-    OpenNetworkConnection(CAddress(), false, std::move(grant), address.c_str(), conn_type, /*use_v2transport=*/false);\n+    CAddress addr(CService(), NODE_NONE);\n+    if (use_v2transport) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349750146",
      "id" : 1349750146,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Qc42C",
      "original_commit_id" : "4084fe0c4c95aa4385e91512291ea756cec73c71",
      "original_line" : 1917,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1663408774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349750146/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-09T04:10:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349750146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349828896"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349828896"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Here, and in `respond_v2_handshake`: This should probably be something like\r\n\r\n```\r\ndef initiate_v2_handshake(self, garbage_len=None):\r\n    if garbage_len is None:\r\n        garbage_len = random.randrange(4096)\r\n```\r\nBecause default args are determined when the function is defined (and not when it's called), otherwise \r\n1) the provided `--randomseed` isn't used, making runs non-deterministic.\r\n2) multiple calls to `initiate_v2_handshake` within one program run will all use the same `garbage_len`.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-09T02:50:41Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349828896",
      "id" : 1349828896,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585QdMEg",
      "original_commit_id" : "a7478eab51c156519885673aff9efeaa95504bd3",
      "original_line" : 101,
      "original_position" : 96,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1663408774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349828896/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-09T04:10:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349828896",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349847429"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349847429"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe it would work just not checking for the racy intermediate states, but instead waiting until we have received the \"version\" message via v1? Something like\r\n\r\n ```\r\ndef test_function():\r\n     if not (self.is_connected and self.last_message.get('version') and self.v2_state is None):\r\n         return False\r\n     return True\r\nself.wait_until(test_function, timeout=timeout, check_connected=False  )\r\n```",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-09T04:05:43Z",
      "diff_hunk" : "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1349847429",
      "id" : 1349847429,
      "in_reply_to_id" : 1320700971,
      "line" : 601,
      "node_id" : "PRRC_kwDOABII585QdQmF",
      "original_commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "original_line" : 601,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 302,
      "pull_request_review_id" : 1663408774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349847429/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-09T04:10:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1349847429",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350368094"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368094"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks! done.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-09T14:15:20Z",
      "diff_hunk" : "@@ -1913,7 +1913,11 @@ bool CConnman::AddConnection(const std::string& address, ConnectionType conn_typ\n     CSemaphoreGrant grant(*semOutbound, true);\n     if (!grant) return false;\n \n-    OpenNetworkConnection(CAddress(), false, std::move(grant), address.c_str(), conn_type, /*use_v2transport=*/false);\n+    CAddress addr(CService(), NODE_NONE);\n+    if (use_v2transport) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350368094",
      "id" : 1350368094,
      "in_reply_to_id" : 1349750146,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585QfPte",
      "original_commit_id" : "4084fe0c4c95aa4385e91512291ea756cec73c71",
      "original_line" : 1917,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1664551055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368094/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-09T14:15:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368094",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350368582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368582"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "interesting, done. i've removed `garbage_len` from the function parameter list since the call sites wouldn't need to set `garbage_len` value.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-09T14:15:46Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350368582",
      "id" : 1350368582,
      "in_reply_to_id" : 1349828896,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585QfP1G",
      "original_commit_id" : "a7478eab51c156519885673aff9efeaa95504bd3",
      "original_line" : 101,
      "original_position" : 96,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1664551886,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368582/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-09T14:15:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350368582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350370031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350370031"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good idea! that should work.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-09T14:17:00Z",
      "diff_hunk" : "@@ -598,6 +598,11 @@ def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.is_connected\n         self.wait_until(test_function, timeout=timeout, check_connected=False)\n \n+    def wait_for_reconnect(self, timeout=60):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350370031",
      "id" : 1350370031,
      "in_reply_to_id" : 1320700971,
      "line" : 601,
      "node_id" : "PRRC_kwDOABII585QfQLv",
      "original_commit_id" : "e18b22d34e5b2c56c2ca7717ce15158b3d519a41",
      "original_line" : 601,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 302,
      "pull_request_review_id" : 1664554329,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350370031/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-09T14:17:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350370031",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350924659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350924659"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that all the decoy packets should pass `ignore=True` as an arg to `v2_enc_packet`.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-09T22:40:31Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1350924659",
      "id" : 1350924659,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585QhXlz",
      "original_commit_id" : "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "original_line" : 138,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 140,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350924659/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1350924659",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353141062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353141062"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'd prefer to explain what it actually does - (attempt to) connect using the v2 transport protocol.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-10T18:46:50Z",
      "diff_hunk" : "@@ -1209,13 +1209,14 @@ class CConnman\n      * @param[in]   address     Address of node to try connecting to\n      * @param[in]   conn_type   ConnectionType::OUTBOUND, ConnectionType::BLOCK_RELAY,\n      *                          ConnectionType::ADDR_FETCH or ConnectionType::FEELER\n+     * @param[in]   use_v2transport  Set to true if node supports BIP324 v2 transport protocol",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353141062",
      "id" : 1353141062,
      "line" : 1212,
      "node_id" : "PRRC_kwDOABII585Qp0tG",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 1212,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 4,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353141062/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353141062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353143252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353143252"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "same here: connect with v2 transport protocol; we might choose to not pass `v2transport=True` with this rpc even if the node supports v2 transport.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-10T18:47:26Z",
      "diff_hunk" : "@@ -357,6 +357,7 @@ static RPCHelpMan addconnection()\n         {\n             {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address and port to attempt connecting to.\"},\n             {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open (\\\"outbound-full-relay\\\", \\\"block-relay-only\\\", \\\"addr-fetch\\\" or \\\"feeler\\\").\"},\n+            {\"v2transport\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Node supports BIP324 v2 transport protocol\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353143252",
      "id" : 1353143252,
      "line" : 360,
      "node_id" : "PRRC_kwDOABII585Qp1PU",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 360,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/rpc/net.cpp",
      "position" : 4,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353143252/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353143252",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353156113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353156113"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "could return an error if `-v2transport` for the node is not enabled but `use_v2transport` is chosen (similar to the way it's done in `addnode`).",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-10T18:50:31Z",
      "diff_hunk" : "@@ -388,11 +389,12 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353156113",
      "id" : 1353156113,
      "line" : 392,
      "node_id" : "PRRC_kwDOABII585Qp4YR",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 392,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/rpc/net.cpp",
      "position" : 23,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353156113/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353156113",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353183494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353183494"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "9810e96c74380a3087b2b576508581380019872f:\r\nCommit message needs an update (remove the service bit flags part)",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-10T18:59:49Z",
      "diff_hunk" : "@@ -1880,7 +1880,7 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n     RandAddEvent((uint32_t)id);\n }\n \n-bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type)\n+bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type, bool use_v2transport = false)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353183494",
      "id" : 1353183494,
      "line" : 1883,
      "node_id" : "PRRC_kwDOABII585Qp_EG",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 1883,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 5,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353183494/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353183494",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353263820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353263820"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks! The fix made it into the wrong commit (should be in \"Construct class to handle v2 P2P protocol functions\", it's one commit later).",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-10T20:03:42Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353263820",
      "id" : 1353263820,
      "in_reply_to_id" : 1349828896,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585QqSrM",
      "original_commit_id" : "a7478eab51c156519885673aff9efeaa95504bd3",
      "original_line" : 101,
      "original_position" : 96,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353263820/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353263820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353384798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353384798"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: this function doesn't return anything, it sets the `peer` class member.",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-10T20:56:28Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1353384798",
      "id" : 1353384798,
      "line" : 185,
      "node_id" : "PRRC_kwDOABII585QqwNe",
      "original_commit_id" : "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "original_line" : 183,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 185,
      "pull_request_review_id" : 1665480038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353384798/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-10T22:27:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1353384798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1355307964"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1355307964"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I have little knowledge of cryptography, but I think that something is wrong here.\r\nDoesn't `crypt` change the internal state of the stream cipher, so if we abort below because we haven't received the message in full, but then call `crypt` again on the same first 3 bytes of the now larger response, we will get an incorrect result?",
      "commit_id" : "e996ea537af9b651a7470e352dcd4f6037ba5c9f",
      "created_at" : "2023-10-11T16:03:53Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[\"regtest\"]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.\n+        \"\"\"\n+        if len(response) < LENGTH_FIELD_LEN:\n+            return 0, b\"\"\n+        enc_contents_len = response[:LENGTH_FIELD_LEN]\n+        response = response[LENGTH_FIELD_LEN:]\n+        contents_len = int.from_bytes(self.peer['recv_L'].crypt(enc_contents_len), 'little')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1355307964",
      "id" : 1355307964,
      "line" : 232,
      "node_id" : "PRRC_kwDOABII585QyFu8",
      "original_commit_id" : "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "original_line" : 230,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 232,
      "pull_request_review_id" : 1671747731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1355307964/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-11T16:03:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1355307964",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549582"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done. true! logs had lines like these: `[net] non-version message before version handshake. Message \"\" from peer=0`.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:27:27Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549582",
      "id" : 1356549582,
      "in_reply_to_id" : 1350924659,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Q203O",
      "original_commit_id" : "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "original_line" : 138,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1673715969,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549582/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:27:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549582",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549683"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:27:31Z",
      "diff_hunk" : "@@ -1209,13 +1209,14 @@ class CConnman\n      * @param[in]   address     Address of node to try connecting to\n      * @param[in]   conn_type   ConnectionType::OUTBOUND, ConnectionType::BLOCK_RELAY,\n      *                          ConnectionType::ADDR_FETCH or ConnectionType::FEELER\n+     * @param[in]   use_v2transport  Set to true if node supports BIP324 v2 transport protocol",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549683",
      "id" : 1356549683,
      "in_reply_to_id" : 1353141062,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Q204z",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 1212,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : null,
      "pull_request_review_id" : 1673716109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549683/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:27:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549683",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549798"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:27:36Z",
      "diff_hunk" : "@@ -357,6 +357,7 @@ static RPCHelpMan addconnection()\n         {\n             {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The IP address and port to attempt connecting to.\"},\n             {\"connection_type\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Type of connection to open (\\\"outbound-full-relay\\\", \\\"block-relay-only\\\", \\\"addr-fetch\\\" or \\\"feeler\\\").\"},\n+            {\"v2transport\", RPCArg::Type::BOOL, RPCArg::Default{false}, \"Node supports BIP324 v2 transport protocol\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549798",
      "id" : 1356549798,
      "in_reply_to_id" : 1353143252,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Q206m",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 360,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/rpc/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1673716273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549798/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:27:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549916"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:27:41Z",
      "diff_hunk" : "@@ -388,11 +389,12 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356549916",
      "id" : 1356549916,
      "in_reply_to_id" : 1353156113,
      "line" : 392,
      "node_id" : "PRRC_kwDOABII585Q208c",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 392,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/rpc/net.cpp",
      "position" : 23,
      "pull_request_review_id" : 1673716458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549916/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:27:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356549916",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550097"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550097"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:27:46Z",
      "diff_hunk" : "@@ -1880,7 +1880,7 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n     RandAddEvent((uint32_t)id);\n }\n \n-bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type)\n+bool CConnman::AddConnection(const std::string& address, ConnectionType conn_type, bool use_v2transport = false)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550097",
      "id" : 1356550097,
      "in_reply_to_id" : 1353183494,
      "line" : 1883,
      "node_id" : "PRRC_kwDOABII585Q20_R",
      "original_commit_id" : "9810e96c74380a3087b2b576508581380019872f",
      "original_line" : 1883,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : 5,
      "pull_request_review_id" : 1673716731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550097/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:27:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550097",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550296"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "oops, fixed.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:27:52Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550296",
      "id" : 1356550296,
      "in_reply_to_id" : 1349828896,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Q21CY",
      "original_commit_id" : "a7478eab51c156519885673aff9efeaa95504bd3",
      "original_line" : 101,
      "original_position" : 96,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1673717025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550296/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:27:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550774"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:28:16Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356550774",
      "id" : 1356550774,
      "in_reply_to_id" : 1353384798,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Q21J2",
      "original_commit_id" : "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "original_line" : 183,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1673717719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550774/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:28:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356550774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356583257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356583257"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice catch. you're right!\r\n\r\ni've stored `contents_len` in a class variable so as to not perform the decryption of 3 bytes length again. initially, `contents_len` is -1, after the 3 bytes length gets processed - `contents_len` is updated, when the whole packet is processed `contents_len` is reset to -1 again.\r\n\r\ni'm open to other solutions.\r\n\r\ni wish there was a cleaner way for writing this function with reads like [this](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki?plain=1#L500-L513) but we're working with `P2PConnection`(subclass of `asyncio.Protocol`) where no read is possible(no \"waiting\" for data to be ready) and we just have a [`data_received()`](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received) callback when data is received.",
      "commit_id" : "32836c6fec4cbb2624176daf7fd769856025c426",
      "created_at" : "2023-10-12T09:56:00Z",
      "diff_hunk" : "@@ -18,3 +97,143 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response, garbage_len=random.randrange(4096)):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Return a peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[\"regtest\"]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.\n+        \"\"\"\n+        if len(response) < LENGTH_FIELD_LEN:\n+            return 0, b\"\"\n+        enc_contents_len = response[:LENGTH_FIELD_LEN]\n+        response = response[LENGTH_FIELD_LEN:]\n+        contents_len = int.from_bytes(self.peer['recv_L'].crypt(enc_contents_len), 'little')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1356583257",
      "id" : 1356583257,
      "in_reply_to_id" : 1355307964,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Q29FZ",
      "original_commit_id" : "5f851714cf5fa7a31bb423c20035f7b44deed25d",
      "original_line" : 230,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1673768690,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356583257/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-10-12T09:56:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1356583257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-11-01T11:56:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1788832394",
      "id" : 1788832394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585qn2qK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1788832394/reactions"
      },
      "updated_at" : "2023-11-01T11:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1788832394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased on master.",
      "created_at" : "2023-11-03T10:32:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1792201473",
      "id" : 1792201473,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585q0tMB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1792201473/reactions"
      },
      "updated_at" : "2023-11-03T10:32:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1792201473",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated since #28374 is merged.",
      "created_at" : "2023-11-08T04:39:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1801073913",
      "id" : 1801073913,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585rWjT5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801073913/reactions"
      },
      "updated_at" : "2023-11-08T04:39:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801073913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "CI:\r\n\r\n```\r\nï¿½[0mï¿½[0;31mp2p_v2_earlykeyresponse.py                             | â Failed  | 1 s",
      "created_at" : "2023-11-08T09:35:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1801417208",
      "id" : 1801417208,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585rX3H4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801417208/reactions"
      },
      "updated_at" : "2023-11-08T09:35:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801417208",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/maflcko/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maflcko/followers",
         "following_url" : "https://api.github.com/users/maflcko/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maflcko/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maflcko",
         "id" : 6399679,
         "login" : "maflcko",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/maflcko/orgs",
         "received_events_url" : "https://api.github.com/users/maflcko/received_events",
         "repos_url" : "https://api.github.com/users/maflcko/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maflcko/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maflcko/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maflcko"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-11-08T11:15:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1801682355",
      "id" : 1801682355,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585rY32z",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801682355/reactions"
      },
      "updated_at" : "2023-11-08T11:15:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1801682355",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388268045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388268045"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: could avoid `kwargs` here (unless there is a good reason to also allow other keyword arguments)\r\n```suggestion\r\n    def __init__(self, *, initiating):\r\n        self.initiating = initiating  # True if initiator\r\n```",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T16:37:53Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+TRANSPORT_VERSION = b''\n+V1_PREFIX = MAGIC_BYTES[\"regtest\"] + b'version\\x00\\x00\\x00\\x00\\x00'\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"\n+\n+\n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:\n+    - `initiating` defines whether the P2PConnection is an initiator or responder.\n+        - `initiating` = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+        - `initiating` = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+    - perform initial v2 handshake to instantiate the encrypted transport.\n+        - initial v2 handshakes is performed by:\n+            1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+        - see section #overall-handshake-pseudocode in BIP 324\n+    - encrypt/decrypt v2 P2P messages.\n+        - see section #overall_packet_encryption_and_decryption_pseudocode in BIP 324\n+    \"\"\"\n+    def __init__(self, **kwargs):\n+        self.initiating = kwargs['initiating']  # True if initiator",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388268045",
      "id" : 1388268045,
      "line" : 81,
      "node_id" : "PRRC_kwDOABII585Sv0oN",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 81,
      "original_position" : 79,
      "original_start_line" : 80,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 81,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388268045/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 80,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388268045",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388276157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388276157"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: there's already a `MAGIC_BYTES` dictionary in p2p.py, could use that? (though it seems there's some circular inclusion going on, not sure how to properly resolve that....)",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T16:44:19Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388276157",
      "id" : 1388276157,
      "line" : 21,
      "node_id" : "PRRC_kwDOABII585Sv2m9",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 21,
      "original_position" : 19,
      "original_start_line" : 19,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 21,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388276157/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 19,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388276157",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388279451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388279451"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: could deduplicate code by using a helper method like `generate_garbage` (or even `generate_keypair_and_garbage`) that is used both in `initiate_v2_handshake` and `respond_v2_handshake`? Could also put the magic number in a `MAX_GARBAGE_LEN` constant (that's the naming we use in the C++ codebase), though that's one less than the number passed to randrange here.",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T16:46:41Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388279451",
      "id" : 1388279451,
      "line" : 108,
      "node_id" : "PRRC_kwDOABII585Sv3ab",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 108,
      "original_position" : 103,
      "original_start_line" : 107,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 108,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388279451/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 107,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388279451",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388285003"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388285003"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Since we are only in test land here, it's probably fine to also use seed-determined randomness for garbage as well (i.e. `random.randrange`)? (I've used `os.urandom` in the past for a PR and got critical feedback about that: https://github.com/bitcoin/bitcoin/pull/25625#discussion_r924540431, which I agree with)\r\n```suggestion\r\n                self.sent_garbage = random.randrange(garbage_len)\r\n```",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T16:51:05Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388285003",
      "id" : 1388285003,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII585Sv4xL",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 124,
      "original_position" : 119,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 124,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388285003/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388285003",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388307652"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388307652"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: as `received_garbage` is ensured to have a maximum size of 16 bytes a few lines above, the slicing isn't needed here.\r\n```suggestion\r\n            if received_garbage == self.peer['recv_garbage_terminator']:\r\n                # Receive, decode, and ignore version packet.\r\n                # This includes skipping decoys and authenticating the received garbage.\r\n                aad = received_garbage\r\n```",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T17:05:41Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388307652",
      "id" : 1388307652,
      "line" : 163,
      "node_id" : "PRRC_kwDOABII585Sv-TE",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 163,
      "original_position" : 158,
      "original_start_line" : 160,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 163,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388307652/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 160,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388307652",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388337105"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388337105"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "readability nit:\r\n```suggestion\r\n            kwargs['services'] = (kwargs['services']|NODE_P2P_V2) if 'services' in kwargs else (P2P_SERVICES|NODE_P2P_V2)\r\n```",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T17:25:54Z",
      "diff_hunk" : "@@ -689,14 +700,34 @@ def add_outbound_p2p_connection(self, p2p_conn, *, wait_for_verack=True, p2p_idx\n         p2p_idx must be different for simultaneously connected peers. When reusing it for the next peer\n         after disconnecting the previous one, it is necessary to wait for the disconnect to finish to avoid\n         a race condition.\n+\n+        Parameters:\n+            supports_v2_p2p: whether p2p_conn supports v2 P2P or not\n+            advertise_v2_p2p: whether p2p_conn is advertised to support v2 P2P or not\n+\n+        An outbound connection is made from TestNode -------> P2PConnection\n+            - if P2PConnection doesn't advertise_v2_p2p, TestNode sends version message and v1 P2P is followed\n+            - if P2PConnection both supports_v2_p2p and advertise_v2_p2p, TestNode sends ellswift bytes and v2 P2P is followed\n+            - if P2PConnection doesn't supports_v2_p2p but advertise_v2_p2p,\n+                TestNode sends ellswift bytes and P2PConnection disconnects,\n+                TestNode reconnects by sending version message and v1 P2P is followed\n         \"\"\"\n \n         def addconnection_callback(address, port):\n             self.log.debug(\"Connecting to %s:%d %s\" % (address, port, connection_type))\n-            self.addconnection('%s:%d' % (address, port), connection_type)\n+            self.addconnection('%s:%d' % (address, port), connection_type, advertise_v2_p2p)\n \n         p2p_conn.p2p_connected_to_node = False\n-        p2p_conn.peer_accept_connection(connect_cb=addconnection_callback, connect_id=p2p_idx + 1, net=self.chain, timeout_factor=self.timeout_factor, **kwargs)()\n+        if advertise_v2_p2p:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388337105",
      "id" : 1388337105,
      "line" : 722,
      "node_id" : "PRRC_kwDOABII585SwFfR",
      "original_commit_id" : "1b656a1cf69ff573a23437431c8650729d9fa95a",
      "original_line" : 722,
      "original_position" : 76,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : 95,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388337105/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388337105",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388344334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388344334"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n            if is_decoy:  # since decoy messages are ignored by the recipient - no need to wait for response\r\n```\r\n(or \"don't get processed\" or something like that?)",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T17:30:55Z",
      "diff_hunk" : "@@ -853,9 +855,11 @@ def send_blocks_and_test(self, blocks, node, *, success=True, force_send=False,\n \n         reject_reason = [reject_reason] if reject_reason else []\n         with node.assert_debug_log(expected_msgs=reject_reason):\n+            if is_decoy:  # since decoy messages don't get sent - no need to wait for response",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388344334",
      "id" : 1388344334,
      "line" : 865,
      "node_id" : "PRRC_kwDOABII585SwHQO",
      "original_commit_id" : "09638be021c6d928002f0a7fe1ff4fc3d4dbb89a",
      "original_line" : 858,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 348,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388344334/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388344334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388353134"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388353134"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: could import this constant from test_framework.crypto",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-09T17:36:20Z",
      "diff_hunk" : "@@ -0,0 +1,116 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+\n+REKEY_INTERVAL = 224",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1388353134",
      "id" : 1388353134,
      "line" : 23,
      "node_id" : "PRRC_kwDOABII585SwJZu",
      "original_commit_id" : "f9a34e333592fc37151f9d5867ced762910e3730",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 23,
      "pull_request_review_id" : 1723019604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388353134/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-09T17:39:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1388353134",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1389838929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1389838929"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I agree that would be nice, in particular so that we can enable `p2p_dos_header_tree.py` (which uses testnet instead of regtest) in combination with v2 transport. One possibility would be to move the `MAGIC_BYTES` constants from `p2p.py` into another file (e.g. `test_framework/messages.py`), change all includes, pass `net` to `EncryptedP2PState`, and change `V1_PREFIX` into a local variable using it)",
      "commit_id" : "aa275a6a4d9d4a1340b0be9ec0b65512a8164779",
      "created_at" : "2023-11-10T19:45:16Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1389838929",
      "id" : 1389838929,
      "in_reply_to_id" : 1388276157,
      "line" : 21,
      "node_id" : "PRRC_kwDOABII585S10JR",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 21,
      "original_position" : 19,
      "original_start_line" : 19,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 21,
      "pull_request_review_id" : 1725507560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1389838929/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 19,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-10T19:45:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1389838929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149591"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:27:19Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+TRANSPORT_VERSION = b''\n+V1_PREFIX = MAGIC_BYTES[\"regtest\"] + b'version\\x00\\x00\\x00\\x00\\x00'\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"\n+\n+\n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:\n+    - `initiating` defines whether the P2PConnection is an initiator or responder.\n+        - `initiating` = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+        - `initiating` = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+    - perform initial v2 handshake to instantiate the encrypted transport.\n+        - initial v2 handshakes is performed by:\n+            1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+        - see section #overall-handshake-pseudocode in BIP 324\n+    - encrypt/decrypt v2 P2P messages.\n+        - see section #overall_packet_encryption_and_decryption_pseudocode in BIP 324\n+    \"\"\"\n+    def __init__(self, **kwargs):\n+        self.initiating = kwargs['initiating']  # True if initiator",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149591",
      "id" : 1390149591,
      "in_reply_to_id" : 1388268045,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S2__X",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 81,
      "original_position" : 79,
      "original_start_line" : 80,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1725972058,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:27:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149597"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice! included `MAGIC_BYTES` in messages.py",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:27:28Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149597",
      "id" : 1390149597,
      "in_reply_to_id" : 1388276157,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S2__d",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 21,
      "original_position" : 19,
      "original_start_line" : 19,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1725972065,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149597/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149597",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149601"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "true! done.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:27:32Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149601",
      "id" : 1390149601,
      "in_reply_to_id" : 1388279451,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S2__h",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 108,
      "original_position" : 103,
      "original_start_line" : 107,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1725972070,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149601/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:27:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149609"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "makes sense. done.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:27:37Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149609",
      "id" : 1390149609,
      "in_reply_to_id" : 1388285003,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S2__p",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 124,
      "original_position" : 119,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1725972078,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149609/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:27:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149609",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149630"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149630"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "but there's also an else condition below where if the `received_garbage` doesn't match the garbage terminator, we keep appending 1 byte to `received_garbage` until there's a match with garbage terminator/we've exceed max garbage limit. so even though initially `received_garbage` length is 16 bytes, it can take values from 17 bytes, ..., 17 + 4095 bytes.  ",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:27:52Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149630",
      "id" : 1390149630,
      "in_reply_to_id" : 1388307652,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII585S2__-",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 162,
      "original_position" : 158,
      "original_start_line" : 160,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 162,
      "pull_request_review_id" : 1725972107,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149630/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 159,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:27:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149630",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149640"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149640"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:28:06Z",
      "diff_hunk" : "@@ -689,14 +700,34 @@ def add_outbound_p2p_connection(self, p2p_conn, *, wait_for_verack=True, p2p_idx\n         p2p_idx must be different for simultaneously connected peers. When reusing it for the next peer\n         after disconnecting the previous one, it is necessary to wait for the disconnect to finish to avoid\n         a race condition.\n+\n+        Parameters:\n+            supports_v2_p2p: whether p2p_conn supports v2 P2P or not\n+            advertise_v2_p2p: whether p2p_conn is advertised to support v2 P2P or not\n+\n+        An outbound connection is made from TestNode -------> P2PConnection\n+            - if P2PConnection doesn't advertise_v2_p2p, TestNode sends version message and v1 P2P is followed\n+            - if P2PConnection both supports_v2_p2p and advertise_v2_p2p, TestNode sends ellswift bytes and v2 P2P is followed\n+            - if P2PConnection doesn't supports_v2_p2p but advertise_v2_p2p,\n+                TestNode sends ellswift bytes and P2PConnection disconnects,\n+                TestNode reconnects by sending version message and v1 P2P is followed\n         \"\"\"\n \n         def addconnection_callback(address, port):\n             self.log.debug(\"Connecting to %s:%d %s\" % (address, port, connection_type))\n-            self.addconnection('%s:%d' % (address, port), connection_type)\n+            self.addconnection('%s:%d' % (address, port), connection_type, advertise_v2_p2p)\n \n         p2p_conn.p2p_connected_to_node = False\n-        p2p_conn.peer_accept_connection(connect_cb=addconnection_callback, connect_id=p2p_idx + 1, net=self.chain, timeout_factor=self.timeout_factor, **kwargs)()\n+        if advertise_v2_p2p:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149640",
      "id" : 1390149640,
      "in_reply_to_id" : 1388337105,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S3AAI",
      "original_commit_id" : "1b656a1cf69ff573a23437431c8650729d9fa95a",
      "original_line" : 722,
      "original_position" : 76,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1725972133,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149640/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:28:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149640",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149641"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:28:11Z",
      "diff_hunk" : "@@ -853,9 +855,11 @@ def send_blocks_and_test(self, blocks, node, *, success=True, force_send=False,\n \n         reject_reason = [reject_reason] if reject_reason else []\n         with node.assert_debug_log(expected_msgs=reject_reason):\n+            if is_decoy:  # since decoy messages don't get sent - no need to wait for response",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149641",
      "id" : 1390149641,
      "in_reply_to_id" : 1388344334,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S3AAJ",
      "original_commit_id" : "09638be021c6d928002f0a7fe1ff4fc3d4dbb89a",
      "original_line" : 858,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1725972136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149641/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:28:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149641",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149646"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149646"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T06:28:15Z",
      "diff_hunk" : "@@ -0,0 +1,116 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+\n+REKEY_INTERVAL = 224",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390149646",
      "id" : 1390149646,
      "in_reply_to_id" : 1388353134,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S3AAO",
      "original_commit_id" : "f9a34e333592fc37151f9d5867ced762910e3730",
      "original_line" : 23,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1725972145,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149646/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-11T06:28:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390149646",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@theStack, @mzumsande thank you for the reviews! I've rebased and addressed your comments.\r\n\r\n> It seems like the newly introduced functional test p2p_v2_encrypted.py could be merged with the already existing p2p_v2_transport.py (here or in a follow-up), or is it fundamentally different?\r\n\r\nyes! can be done in a follow up. only difference is `p2p_v2_encrypted.py` tests `TestNode` <--> `P2PInterface` behaviour and `p2p_v2_transport.py` tests `TestNode` <--> `TestNode` behaviour. So maybe in separate functions within `p2p_v2_transport.py`?\r\n\r\n@maflcko, I still need to address the CI failure. https://api.cirrus-ci.com/v1/task/6171895557521408/logs/ci.log",
      "created_at" : "2023-11-11T06:32:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1806715075",
      "id" : 1806715075,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585rsEjD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1806715075/reactions"
      },
      "updated_at" : "2023-11-11T06:34:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1806715075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390234612"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390234612"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh right, I missed the else-branch and assumed `received_garbage` wouldn't change in the loop (which wouldn't make much sense), nevermind.",
      "commit_id" : "50a30f6394335b7c8ed32ade1c86a69502857012",
      "created_at" : "2023-11-11T14:23:50Z",
      "diff_hunk" : "@@ -18,3 +100,147 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(4096)\n+        self.sent_garbage = os.urandom(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte V1_PREFIX.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != V1_PREFIX[len(self.received_prefix) - 1]:\n+                self.privkey_ours, self.ellswift_ours = ellswift_create()\n+                garbage_len = random.randrange(4096)\n+                self.sent_garbage = os.urandom(garbage_len)\n+                logger.debug(\"sending %d bytes of garbage data\" % garbage_len)\n+                return self.ellswift_ours + self.sent_garbage\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(4096):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390234612",
      "id" : 1390234612,
      "in_reply_to_id" : 1388307652,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII585S3Uv0",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 162,
      "original_position" : 158,
      "original_start_line" : 160,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 162,
      "pull_request_review_id" : 1726071399,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390234612/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 159,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-11T14:23:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390234612",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390623656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390623656"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks! \r\nI think you should actually use `net` by making both callers from `p2p.py`  pass it to `EncryptedP2PState`, the default value of 'regtest' should be dropped in my opinion. \r\nCould also change all existing imports for MAGIC_BYTES (there are a few in other tests) to avoid indirect imports.",
      "commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "created_at" : "2023-11-13T04:52:32Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1390623656",
      "id" : 1390623656,
      "in_reply_to_id" : 1388276157,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585S4zuo",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 21,
      "original_position" : 19,
      "original_start_line" : 19,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1726545195,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390623656/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-13T06:56:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1390623656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1393801774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1393801774"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "sounds much better! added a [new commit](https://github.com/bitcoin/bitcoin/pull/24748/commits/7f0e797dc9524c03f650f60a028cb46852877284).",
      "commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "created_at" : "2023-11-15T08:06:44Z",
      "diff_hunk" : "@@ -4,10 +4,92 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import os\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n \n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+MAGIC_BYTES = {\n+    \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"   # regtest\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1393801774",
      "id" : 1393801774,
      "in_reply_to_id" : 1388276157,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585TE7ou",
      "original_commit_id" : "63463aa9be20fbb93a73be3638a61041b792decd",
      "original_line" : 21,
      "original_position" : 19,
      "original_start_line" : 19,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1731446070,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1393801774/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-15T08:06:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1393801774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I've noticed that the test p2p_v2_encrypted.py fails if the node under test sends a small amount of garbage (in the range of 0-19 bytes).\r\n\r\nthanks for catching that @theStack! before the drop garbage authentication packet change in #28525, `recvbuf` needed 16+20+20 bytes to authenticate the handshake. now it only needs 16+20 bytes. i've fixed it now.",
      "created_at" : "2023-11-15T08:07:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1811980868",
      "id" : 1811980868,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585sAKJE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1811980868/reactions"
      },
      "updated_at" : "2023-11-15T08:07:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1811980868",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : ">  https://api.cirrus-ci.com/v1/task/6171895557521408/logs/ci.log\r\n\r\ni wasn't able to reproduce this error - tried it locally on the docker container, setting randomseed and running it in loop. also confused how it could have happened.\r\n\r\nthis is what happens inside `p2p_v2_earlykeyresponse.py` test\r\n- we start an inbound connection to the TestNode (`TestNode` <---- `P2PInterface`). \r\n- v2 connection starts by sending 64 bytes ellswift (`TestNode` <--64 bytes-- `P2PInterface`). this is sent in 2 parts:\r\n\t- `TestNode` <--4 bytes magic bytes-- `P2PInterface` - `TestNode` doesn't send us a response\r\n\t- `TestNode` <--remaining 60 bytes-- `P2PInterface` - `TestNode` responds back since there's a mismatch from V1_PREFIX. \r\n\r\nWhat usually happens:\r\n1. During inbound connection creation, `TestNode::add_p2p_connection()` calls `P2PConnection::peer_connect()` where an object of `EncryptedP2PState` class is created - this object `v2_state` contains the function `EncryptedP2PState::initiate_v2_handshake()` to send ellswift bytes\r\n2. then the asyncio code to create a connection happens and `connection_made()` is called when the connection is opened\r\n\t- inside `connection_made()`, 64 bytes ellswift is sent using `EncryptedP2PState::initiate_v2_handshake()`\r\n3. When the `TestNode` sends a response, `P2PConnection::data_received()` callback will detect it\r\n\r\n\r\nWhat happens in test:\r\n- there are 2 variables:\r\n1. `send_net_magic` - initially true. after we send magic bytes, `send_net_magic_bytes` is set to false (basically just a switch to send 64 bytes in 2 parts)\r\n2. `can_data_be_received` - initally false - data can't be received until mismatch from V1_PREFIX occurs. after we send remaining mismatched 60 bytes, `can_data_be_received` is set to true.\r\n- since response will be detected on `TestNode`, we add an assertion to make sure `send_net_magic` = false (meaning magic bytes already sent) and `can_data_be_received` = true (meaning mismatched 60 bytes also sent). `TestNode` wouldn't send a response in the intermediate states.\r\n- so the possible states are:\r\n1. initially\r\n\t`send_net_magic` = true, `can_data_be_received` = false (Assertion would fail in `data_received()` but shouldn't happen)\r\n2. after `connection_made()`'s `custom EncryptedP2PState::initiate_v2_handshake()` (TestNode <--4 bytes magic bytes-- P2PInterface)\r\n\t`send_net_magic` = false, `can_data_be_received` = false (Assertion would fail in `data_received()` but shouldn't happen)\r\n3. after `p2p_v2_earlykeyresponse.py` test when we call `custom EncryptedP2PState::initiate_v2_handshake()` explicitly (TestNode <--remaining 60 bytes-- P2PInterface)\r\n\t`send_net_magic` = false, `can_data_be_received` = true (Assertion passes in `data_received()`)",
      "created_at" : "2023-11-15T08:26:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1812003580",
      "id" : 1812003580,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585sAPr8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1812003580/reactions"
      },
      "updated_at" : "2023-11-15T08:26:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1812003580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1394911231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394911231"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is it on purpose to use `super()` above and provide args here and below? Not an expert on this kind of stuff, but [this](https://stackoverflow.com/questions/59538746/when-do-you-need-to-pass-arguments-to-python-super) suggests that providing args is not necessary in python3.",
      "commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "created_at" : "2023-11-15T22:30:14Z",
      "diff_hunk" : "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)\n+            self.send_net_magic = False\n+            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        else:\n+            self.can_data_be_received = True\n+            return self.ellswift_ours[4:] + self.sent_garbage\n+\n+\n+class PeerEarlyKey(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.v2_state = None\n+\n+    def connection_made(self, *args, **kwargs):\n+        \"\"\"Custom implementation so that 64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n+        self.v2_state = TestEncryptedP2PState()\n+        super(PeerEarlyKey, self).connection_made(*args, **kwargs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1394911231",
      "id" : 1394911231,
      "line" : 55,
      "node_id" : "PRRC_kwDOABII585TJKf_",
      "original_commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "original_line" : 55,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_earlykeyresponse.py",
      "position" : 55,
      "pull_request_review_id" : 1733127844,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394911231/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-15T23:38:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394911231",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1394961498"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394961498"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "one more instance of os.urandom (`random.randbytes(garbage_len)` should work)\r\n",
      "commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "created_at" : "2023-11-15T23:04:32Z",
      "diff_hunk" : "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1394961498",
      "id" : 1394961498,
      "line" : 39,
      "node_id" : "PRRC_kwDOABII585TJWxa",
      "original_commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_earlykeyresponse.py",
      "position" : 39,
      "pull_request_review_id" : 1733127844,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394961498/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-15T23:38:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1394961498",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah, I think if we have an unhandled exception like in my previous post, running the test directly (`python3 p2p_v2_earlykeyresponse.py`) will show success, but if we use the test_runner (`python3 test_runner.py p2p_v2_earlykeyresponse.py`) it will show failure, probably because things were written to stderr. So we need to do something about the case I mentioned above.",
      "created_at" : "2023-11-16T04:44:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1813782523",
      "id" : 1813782523,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585sHB_7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1813782523/reactions"
      },
      "updated_at" : "2023-11-16T04:44:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1813782523",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> But it seems confusing to fail with a stack trace / uncaught exception in this case (\"Fatal error: protocol.data_received() call failed.\") when this is actually expected to happen.\r\n\r\n\r\n<details>\r\n<summary> is this the test log you observed? </summary>\r\n<br>\r\n\r\n```\r\n2023-11-18T13:52:32.976000Z TestFramework (INFO): PRNG seed is: 8699047777059301467\r\n2023-11-18T13:52:32.977000Z TestFramework (INFO): Initializing test directory /tmp/bitcoin_func_test_70zlmcgr\r\n2023-11-18T13:52:33.535000Z TestFramework (INFO): Sending ellswift bytes in parts to ensure that response from responder is received only when\r\n2023-11-18T13:52:33.536000Z TestFramework (INFO): ellswift bytes have a mismatch from the 16 bytes(network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\")\r\n2023-11-18T13:52:33.536000Z TestFramework (INFO): Sending first 4 bytes of ellswift which match network magic\r\n2023-11-18T13:52:33.536000Z TestFramework (INFO): If a response is received, assertion failure would happen in our custom data_received() function\r\n2023-11-18T13:52:33.587000Z TestFramework (INFO): Sending remaining ellswift and garbage which are different from V1_PREFIX. Since a response is\r\n2023-11-18T13:52:33.587000Z TestFramework (INFO): expected now, our custom data_received() function wouldn't result in assertion failure\r\nFatal error: protocol.data_received() call failed.\r\nprotocol: <__main__.PeerEarlyKey object at 0x7f0d6f6c1060>\r\ntransport: <_SelectorSocketTransport fd=10 read=polling write=<idle, bufsize=0>>\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.10/asyncio/selector_events.py\", line 876, in _read_ready__data_received\r\n    self._protocol.data_received(data)\r\n  File \"/home/stratospher/code/bitcoin/test/functional/p2p_v2_earlykeyresponse.py\", line 60, in data_received\r\n    super(PeerEarlyKey, self).data_received(t)\r\n  File \"/home/stratospher/code/bitcoin/test/functional/test_framework/p2p.py\", line 297, in data_received\r\n    self.v2_handshake()\r\n  File \"/home/stratospher/code/bitcoin/test/functional/test_framework/p2p.py\", line 284, in v2_handshake\r\n    raise ValueError(\"invalid v2 mac tag in handshake authentication\")\r\nValueError: invalid v2 mac tag in handshake authentication\r\n2023-11-18T13:52:33.673000Z TestFramework.p2p (WARNING): Connection lost to 127.0.0.1:13882 due to invalid v2 mac tag in handshake authentication\r\n2023-11-18T13:52:33.693000Z TestFramework (INFO): successful disconnection when MITM happens in the key exchange phase\r\n2023-11-18T13:52:33.744000Z TestFramework (INFO): Stopping nodes\r\n2023-11-18T13:52:33.948000Z TestFramework (INFO): Cleaning up /tmp/bitcoin_func_test_70zlmcgr on exit\r\n2023-11-18T13:52:33.948000Z TestFramework (INFO): Tests successful\r\n```\r\n</details>\r\n\r\n\r\nthis happened because of the mac tag mismatch in the v2 handshake's authentication. it only got displayed sometimes because the test would finish before the v2 handshake authentication happened.  since we don't need to do v2 handshake authentication/v2 handshake for this test, and just be able to detect when data is received, i've removed the `P2PInterface::data_received()` call which performs the handshake. whenever data is received, `PeerEarlyKey::data_received()` would detect it and do nothing with the received bytes.\r\n\r\n\r\n> I could reproduce it by changing GenerateRandomGarbage() similar to TheStack above, but this time to large values:\r\nret.resize(V2Transport::MAX_GARBAGE_LEN-19); or larger.\r\n\r\noh! i'm not able to reproduce this by changing to large values. Could this be related to the above test log?",
      "created_at" : "2023-11-20T04:29:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1818210163",
      "id" : 1818210163,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585sX69z",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1818210163/reactions"
      },
      "updated_at" : "2023-11-20T04:29:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1818210163",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1398651836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651836"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "you're right! done.",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-20T04:29:57Z",
      "diff_hunk" : "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)\n+            self.send_net_magic = False\n+            return b\"\\xfa\\xbf\\xb5\\xda\"\n+        else:\n+            self.can_data_be_received = True\n+            return self.ellswift_ours[4:] + self.sent_garbage\n+\n+\n+class PeerEarlyKey(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.v2_state = None\n+\n+    def connection_made(self, *args, **kwargs):\n+        \"\"\"Custom implementation so that 64 bytes ellswift is sent in 2 parts during `initial_v2_handshake()`\"\"\"\n+        self.v2_state = TestEncryptedP2PState()\n+        super(PeerEarlyKey, self).connection_made(*args, **kwargs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1398651836",
      "id" : 1398651836,
      "in_reply_to_id" : 1394911231,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585TXbu8",
      "original_commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "original_line" : 55,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_earlykeyresponse.py",
      "position" : null,
      "pull_request_review_id" : 1738944298,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651836/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-20T04:29:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651836",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1398651878"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651878"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-20T04:30:06Z",
      "diff_hunk" : "@@ -0,0 +1,86 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+import random\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.crypto.ellswift import ellswift_create\n+from test_framework.p2p import P2PInterface\n+from test_framework.v2_p2p import EncryptedP2PState\n+\n+\n+class TestEncryptedP2PState(EncryptedP2PState):\n+    \"\"\" Custom implementation of class EncryptedP2PState for testing purposes:\n+\n+    - if `send_net_magic` is True, send first 4 bytes of ellswift(match network magic) else send remaining 60 bytes\n+    - `can_data_be_received` is a variable used to assert if data is received on recvbuf.\n+            - v2 TestNode shouldn't respond back if we send V1_PREFIX and data shouldn't be received on recvbuf.\n+              This state is represented using `can_data_be_received` = False.\n+            - v2 TestNode responds back when mismatch from V1_PREFIX happens and data can be received on recvbuf.\n+              This state is represented using `can_data_be_received` = True.\n+    \"\"\"\n+\n+    def __init__(self):\n+        super().__init__(initiating=True, net='regtest')\n+        self.send_net_magic = True\n+        self.can_data_be_received = False\n+\n+    def initiate_v2_handshake(self, garbage_len=random.randrange(4096)):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage.\n+        Here, the 64 bytes ellswift is assumed to have it's 4 bytes match network magic bytes. It is sent in 2 phases:\n+            1. when `send_network_magic` = True, send first 4 bytes of ellswift (matches network magic bytes)\n+            2. when `send_network_magic` = False, send remaining 60 bytes of ellswift\n+        \"\"\"\n+        if self.send_net_magic:\n+            self.privkey_ours, self.ellswift_ours = ellswift_create()\n+            self.sent_garbage = os.urandom(garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1398651878",
      "id" : 1398651878,
      "in_reply_to_id" : 1394961498,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585TXbvm",
      "original_commit_id" : "b3c0a54085703932e57369f5b1315b516c172dc4",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_earlykeyresponse.py",
      "position" : null,
      "pull_request_review_id" : 1738944376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651878/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-20T04:30:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398651878",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> is this the test log you observed?\r\n\r\nYes. Only in ~1% of runs with the previous version, but after changing the garbage size in `net.cpp` to the max I would get it consistently.\r\nI think the reason is that usually bitcoind would terminate the connection (because the python side would wait for more bytes that wouldn't come), but when the garbage was close to the max, the python side would terminate it and throwing the exception.\r\n\r\n> i've removed the P2PInterface::data_received() call which performs the handshake\r\n\r\nThanks, that should fix this issue.",
      "created_at" : "2023-11-20T18:46:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1819618919",
      "id" : 1819618919,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585sdS5n",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1819618919/reactions"
      },
      "updated_at" : "2023-11-20T18:46:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1819618919",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1399855267"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1399855267"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "One possible problem I encountered when running the `p2p_invalid_messages.py` `test_resource_exhaustion` subtest with v2 that but could affect many tests intermittently, also this spot:\r\n\r\nI think that there could be a race between the python main thread of functional tests and the p2p thread:\r\nFor example, this command 1) builds messages, 2) encrypts them and 3) sends them, all within the main thread.\r\nIf during step 2) the bitcoind node would decide to send out a ping, the p2p thread will also encrypt a message (the pong answer) and send it. It doesn't wait for the other thread. This isn't a problem with v1 (if the messages are sent in different orders, nothing may break),  but with v2 I think the connection would break down because the ChaCha stream cipher is stateful.\r\n\r\nSo I think that maybe we need some kind of synchronization / locking mechanism?\r\n\r\nI haven't though much about a solution yet, just wanted to share this problem.",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-20T23:13:40Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1399855267",
      "id" : 1399855267,
      "line" : 96,
      "node_id" : "PRRC_kwDOABII585TcBij",
      "original_commit_id" : "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 96,
      "pull_request_review_id" : 1740854829,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1399855267/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-20T23:17:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1399855267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404207499"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404207499"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good point indeed. To execute the steps build/encrypt/send-message atomically, I think introducing a new lock and acquiring it in the `send_message` method should do the trick? I.e.\r\n```diff\r\ndiff --git a/test/functional/test_framework/p2p.py b/test/functional/test_framework/p2p.py\r\nindex a70682a768..59707471a6 100755\r\n--- a/test/functional/test_framework/p2p.py\r\n+++ b/test/functional/test_framework/p2p.py\r\n@@ -164,6 +164,7 @@ class P2PConnection(asyncio.Protocol):\r\n         # The underlying transport of the connection.\r\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\r\n         self._transport = None\r\n+        self._send_lock = threading.Lock()\r\n         self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\r\n         self.supports_v2_p2p = False  # set if the connection supports v2 p2p\r\n         self.reconnect = False  # set if reconnection needs to happen\r\n@@ -371,9 +372,10 @@ class P2PConnection(asyncio.Protocol):\r\n \r\n         This method takes a P2P payload, builds the P2P header and adds\r\n         the message to the send buffer to be sent over the socket.\"\"\"\r\n-        tmsg = self.build_message(message, is_decoy)\r\n-        self._log_message(\"send\", message)\r\n-        return self.send_raw_message(tmsg)\r\n+        with self._send_lock:\r\n+            tmsg = self.build_message(message, is_decoy)\r\n+            self._log_message(\"send\", message)\r\n+            return self.send_raw_message(tmsg)\r\n \r\n     def send_raw_message(self, raw_message_bytes):\r\n         if not self.is_connected:\r\n```\r\nIt might be also good to classify the methods `build_message` and `send_raw_message` as private then (that is, prefixing them with an underscore) to express that they shouldn't be called from the outside anymore, as this would cause problems for v2 connections after handshake completion. Currently only `p2p_invalid_messages.py` is calling those methods, so that test needs to be reworked for v2 support (didn't look deeper yet though, can maybe also done in a follow-up).",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-24T10:41:06Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404207499",
      "id" : 1404207499,
      "in_reply_to_id" : 1399855267,
      "line" : 96,
      "node_id" : "PRRC_kwDOABII585TsoGL",
      "original_commit_id" : "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 96,
      "pull_request_review_id" : 1747722826,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404207499/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-24T10:41:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404207499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404234919"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404234919"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "+1, good catch! when i tried this, just running `self.test_resource_exhaustion()` in `p2p_invalid messages.py` took too much time. \r\n1. in v1, without locks - 0m22.265s\r\n2. in v2, without locks - won't work\r\n3. in v1, with locks - 0m22.101s\r\n4. in v2, with locks - 8m45.916s",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-24T11:09:16Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404234919",
      "id" : 1404234919,
      "in_reply_to_id" : 1399855267,
      "line" : 96,
      "node_id" : "PRRC_kwDOABII585Tsuyn",
      "original_commit_id" : "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 96,
      "pull_request_review_id" : 1747764579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404234919/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-24T11:09:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404234919",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404392341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404392341"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@stratospher: Seems like the long run-time in case 4. is primarily caused by the slow ChaCha20 implementation in Python. On my machine, encrypting 4MB of data (as done in `test_resource_exhaustion`, but repeated 80 times) takes already more than half a minute:\r\n```\r\n$ ipython \r\nPython 3.10.13 (main, Oct  5 2023, 16:21:31) [Clang 13.0.0 ]\r\nType 'copyright', 'credits' or 'license' for more information\r\nIPython 8.13.2 -- An enhanced Interactive Python. Type '?' for help.\r\n\r\nIn [1]: from test.functional.test_framework.crypto.bip324_cipher import aead_chacha20_poly1305_encrypt\r\n\r\nIn [2]: %time _ = aead_chacha20_poly1305_encrypt(key=bytes([1]*32), nonce=bytes([2]*12), aad=bytes(), plaintext=bytes([0xcc]*4000000))\r\nCPU times: user 35.9 s, sys: 40 ms, total: 36 s\r\nWall time: 35.8 s\r\n```\r\nI guess we can't do that much about that (unless someone sees a way to optimize our python cryptography, without introducing new dependencies like `numpy` or calling an external library?), other than reducing the number of loops in `test_resource_exhaustion` if p2p-v2 is used.",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-24T14:08:55Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404392341",
      "id" : 1404392341,
      "in_reply_to_id" : 1399855267,
      "line" : 96,
      "node_id" : "PRRC_kwDOABII585TtVOV",
      "original_commit_id" : "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 96,
      "pull_request_review_id" : 1748012511,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404392341/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-24T14:08:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404392341",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404533791"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404533791"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> so that test needs to be reworked for v2 support (didn't look deeper yet though, can maybe also done in a follow-up)\r\n\r\nYes, multiple tests need an adjustment for running with python v2 P2P. I have a WIP branch at \r\nhttps://github.com/mzumsande/bitcoin/tree/tmp_bip324_fixalltests for that which has helped me find this concurrency issue and other issues I mentioned above, but will only open a PR after this PR is merged.\r\n\r\n> Seems like the long run-time in case 4. is primarily caused by the slow ChaCha20 implementation in Python.\r\n\r\nI agree. I think that his particular subtest maybe could be skipped with v2 because its goal is to stress the node by bombarding it with lots of messages in a short time, not the test framework. But also,  `feature_block.py` and `feature_maxuploadtarget.py`, become very slow on my computer for the same reason and we might have to only run them with v1 transport.",
      "commit_id" : "3cfdced3e9ce66de59557972da98e5a2cae809ed",
      "created_at" : "2023-11-24T16:48:29Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404533791",
      "id" : 1404533791,
      "in_reply_to_id" : 1399855267,
      "line" : 96,
      "node_id" : "PRRC_kwDOABII585Tt3wf",
      "original_commit_id" : "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 96,
      "pull_request_review_id" : 1748231287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404533791/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-24T16:48:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404533791",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404599389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404599389"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> I guess we can't do that much about that (unless someone sees a way to optimize our python cryptography, without introducing new dependencies like numpy or calling an external library?), other than reducing the number of loops in test_resource_exhaustion if p2p-v2 is used.\r\n\r\nmakes sense.\r\n\r\ni've introduced a new lock in [this commit](https://github.com/bitcoin/bitcoin/pull/24748/commits/99f162f3abfe5f76f914a20169743cd151d6c14e).",
      "commit_id" : "b0965e4d1f1b1f7f585a2a2bf78f116f241d5735",
      "created_at" : "2023-11-24T19:10:24Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1404599389",
      "id" : 1404599389,
      "in_reply_to_id" : 1399855267,
      "line" : 96,
      "node_id" : "PRRC_kwDOABII585TuHxd",
      "original_commit_id" : "7eac63705b376d5d8d7f3f1a2d86452412b4e371",
      "original_line" : 96,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 96,
      "pull_request_review_id" : 1748347506,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404599389/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-24T19:10:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1404599389",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408124460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408124460"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Now that #28805 is merged, `self.use_v2transport` from test_node could be used instead of introducing `self.advertise_v2_p2p`.",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-28T17:21:41Z",
      "diff_hunk" : "@@ -197,6 +198,10 @@ def start(self, extra_args=None, *, cwd=None, stdout=None, stderr=None, env=None\n         \"\"\"Start the node.\"\"\"\n         if extra_args is None:\n             extra_args = self.extra_args\n+        if \"-v2transport=1\" in extra_args:\n+            self.advertise_v2_p2p = True",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408124460",
      "id" : 1408124460,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585T7kYs",
      "original_commit_id" : "b9538c706742444a41c9e9d906baedc40f5aa91e",
      "original_line" : 202,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1753471883,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408124460/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-28T21:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408124460",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408222484"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408222484"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why `64 - length` here instead of `64`? I realize that we have already read some bytes in `respond_v2_handshake` but I think we haven't removed these from `self.recvbuf` yet, so wouldn't this need to be at least 64 bytes to proceed?",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-28T18:32:06Z",
      "diff_hunk" : "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408222484",
      "id" : 1408222484,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585T78UU",
      "original_commit_id" : "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "original_line" : 262,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1753471883,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408222484/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-28T21:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408222484",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408245400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408245400"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is there a way we could get to this spot without `self.v2_state.peer`? I think not (it should have been present from the beginning or created in `complete_handshake`), so this line could be dropped or changed to an assert?",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-28T18:52:15Z",
      "diff_hunk" : "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408245400",
      "id" : 1408245400,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585T8B6Y",
      "original_commit_id" : "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "original_line" : 273,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1753471883,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408245400/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-28T21:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408245400",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408269092"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408269092"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "could add a comment about the meaning of the magic numbers",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-28T19:10:53Z",
      "diff_hunk" : "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:\n+            # authenticate v2 handshake\n+            if len(self.recvbuf) < 16 + 20:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408269092",
      "id" : 1408269092,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585T8Hsk",
      "original_commit_id" : "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "original_line" : 275,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1753471883,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408269092/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-28T21:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408269092",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408382994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408382994"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should we at some point set `self.reconnect` to `False` again (maybe here?), so that future possible disconnections that would be unrelated will be handled correctly?",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-28T20:29:23Z",
      "diff_hunk" : "@@ -553,6 +560,11 @@ def on_verack(self, message):\n \n     def on_version(self, message):\n         assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+        # reconnection using v1 P2P has happened since version message can be processed, previously queued messages are sent using v1 P2P here\n+        if self.reconnect:\n+            while self.queue_messages:\n+                message = self.queue_messages.pop(0)\n+                self.send_message(message)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1408382994",
      "id" : 1408382994,
      "line" : 570,
      "node_id" : "PRRC_kwDOABII585T8jgS",
      "original_commit_id" : "ae8070c58f628a76d25d15eece1f9ffdd5002e26",
      "original_line" : 570,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 323,
      "pull_request_review_id" : 1753471883,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408382994/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-28T21:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1408382994",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409537266"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409537266"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yay! done.",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:18:41Z",
      "diff_hunk" : "@@ -197,6 +198,10 @@ def start(self, extra_args=None, *, cwd=None, stdout=None, stderr=None, env=None\n         \"\"\"Start the node.\"\"\"\n         if extra_args is None:\n             extra_args = self.extra_args\n+        if \"-v2transport=1\" in extra_args:\n+            self.advertise_v2_p2p = True",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409537266",
      "id" : 1409537266,
      "in_reply_to_id" : 1408124460,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UA9Ty",
      "original_commit_id" : "b9538c706742444a41c9e9d906baedc40f5aa91e",
      "original_line" : 202,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1755680506,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409537266/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T16:18:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409537266",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409538169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409538169"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good catch! done.",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:19:00Z",
      "diff_hunk" : "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409538169",
      "id" : 1409538169,
      "in_reply_to_id" : 1408222484,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UA9h5",
      "original_commit_id" : "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "original_line" : 262,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1755682114,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409538169/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T16:19:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409538169",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409539941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409539941"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "you're right! i've made it an assert.\r\n\r\ni vaguely remember adding this in some older version of the branch because when `TestNode` sends transport layer packets(64 bytes ellswift, x bytes garbage, 16 bytes garbage terminator, optional decoy packets, 20 bytes transport version packet) to our python `P2PInterface`, it's not necessary that we receive all these bytes at once on the wire/have access to these bytes at once on `self.recvbuf`. Looking at this again - even without the \"`if self.v2_state.peer`\", the code paths for when 64 + 16 + 20 bytes is received or when 64 bytes, delay, 16 + 20 bytes is received works fine!",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:19:35Z",
      "diff_hunk" : "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409539941",
      "id" : 1409539941,
      "in_reply_to_id" : 1408245400,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UA99l",
      "original_commit_id" : "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "original_line" : 273,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1755685348,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409539941/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T16:19:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409539941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409540454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540454"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "added!",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:19:47Z",
      "diff_hunk" : "@@ -231,12 +231,65 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged(see BIP 324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                ellswift_and_garbage_data = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if ellswift_and_garbage_data == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif ellswift_and_garbage_data:\n+                    self.send_raw_message(ellswift_and_garbage_data)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64 - length:\n+                return\n+            # `complete_handshake()` computes garbage terminator + authentication packet + version packet to be sent as\n+            # response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        if self.v2_state.peer:\n+            # authenticate v2 handshake\n+            if len(self.recvbuf) < 16 + 20:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409540454",
      "id" : 1409540454,
      "in_reply_to_id" : 1408269092,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UA-Fm",
      "original_commit_id" : "9a6b684becbffd02f24a686b965ada257fa7bfd9",
      "original_line" : 275,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1755686399,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540454/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T16:19:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540454",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409540710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540710"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good point! done.",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:19:52Z",
      "diff_hunk" : "@@ -553,6 +560,11 @@ def on_verack(self, message):\n \n     def on_version(self, message):\n         assert message.nVersion >= MIN_P2P_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_P2P_VERSION_SUPPORTED)\n+        # reconnection using v1 P2P has happened since version message can be processed, previously queued messages are sent using v1 P2P here\n+        if self.reconnect:\n+            while self.queue_messages:\n+                message = self.queue_messages.pop(0)\n+                self.send_message(message)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409540710",
      "id" : 1409540710,
      "in_reply_to_id" : 1408382994,
      "line" : 570,
      "node_id" : "PRRC_kwDOABII585UA-Jm",
      "original_commit_id" : "ae8070c58f628a76d25d15eece1f9ffdd5002e26",
      "original_line" : 570,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 323,
      "pull_request_review_id" : 1755686870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540710/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T16:19:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409540710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks @mzumsande for the really great feedback! Iâve rebased on master since #28805 is merged and updated the PR to address your comments.",
      "created_at" : "2023-11-29T16:20:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1832239855",
      "id" : 1832239855,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585tNcLv",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1832239855/reactions"
      },
      "updated_at" : "2023-11-29T16:20:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1832239855",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409600332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409600332"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: as this dictionary is only dependent on the constant `SHORTID` dict, could place it in the global namespace (e.g. as `MSGTYPE_TO_SHORTID` directly below `SHORTID`), so it only has to be calculated once if the module is loaded, and not on each `GetShortIDFromMessageType` call again",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:55:09Z",
      "diff_hunk" : "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409600332",
      "id" : 1409600332,
      "line" : 60,
      "node_id" : "PRRC_kwDOABII585UBMtM",
      "original_commit_id" : "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "original_line" : 60,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 60,
      "pull_request_review_id" : 1755780494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409600332/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409600332",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409605417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409605417"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "a little more pythonic (see https://docs.python.org/3/library/stdtypes.html#dict.get):\r\n```suggestion\r\n    return msgtype_to_shortid.get(msgtype, 0).to_bytes(1, 'big')\r\n```",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T16:58:55Z",
      "diff_hunk" : "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409605417",
      "id" : 1409605417,
      "line" : 61,
      "node_id" : "PRRC_kwDOABII585UBN8p",
      "original_commit_id" : "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "original_line" : 61,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 61,
      "pull_request_review_id" : 1755780494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409605417/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409605417",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409620992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409620992"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit:\r\n```suggestion\r\n        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\r\n```",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T17:11:19Z",
      "diff_hunk" : "@@ -18,3 +98,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409620992",
      "id" : 1409620992,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585UBRwA",
      "original_commit_id" : "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "original_line" : 107,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 107,
      "pull_request_review_id" : 1755780494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409620992/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409620992",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409649019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409649019"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: shorter, using dict's `.get` method again:\r\n```suggestion\r\n                        msgtype = SHORTID.get(shortid, f\"unknown-{shortid}\")\r\n```",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T17:35:08Z",
      "diff_hunk" : "@@ -301,23 +302,47 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:] # msg is set to be payload\n+                    else:\n+                        # a short id\n+                        if shortid in SHORTID:\n+                            msgtype = SHORTID[shortid]\n+                        else:\n+                            msgtype = \"unknown-\" + str(shortid)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409649019",
      "id" : 1409649019,
      "line" : 332,
      "node_id" : "PRRC_kwDOABII585UBYl7",
      "original_commit_id" : "07be9af55860b447edbb7069114881abdd1d85a4",
      "original_line" : 325,
      "original_position" : 49,
      "original_start_line" : 322,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 205,
      "pull_request_review_id" : 1755780494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409649019/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 329,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409649019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409654837"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409654837"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: to deduplicate, could move these two assignments above the `if`, as they are identical in both branches",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T17:40:40Z",
      "diff_hunk" : "@@ -387,17 +388,29 @@ def maybe_write():\n \n     def build_message(self, message):\n         \"\"\"Build a serialized P2P message\"\"\"\n-        msgtype = message.msgtype\n-        data = message.serialize()\n-        tmsg = self.magic_bytes\n-        tmsg += msgtype\n-        tmsg += b\"\\x00\" * (12 - len(msgtype))\n-        tmsg += struct.pack(\"<I\", len(data))\n-        th = sha256(data)\n-        h = sha256(th)\n-        tmsg += h[:4]\n-        tmsg += data\n-        return tmsg\n+        if self.supports_v2_p2p:\n+            msgtype = message.msgtype\n+            data = message.serialize()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409654837",
      "id" : 1409654837,
      "line" : 399,
      "node_id" : "PRRC_kwDOABII585UBaA1",
      "original_commit_id" : "985791c38ff90c09dfd4fa727e326e395ebc1406",
      "original_line" : 393,
      "original_position" : 25,
      "original_start_line" : 392,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 279,
      "pull_request_review_id" : 1755780494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409654837/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 398,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409654837",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409687151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409687151"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "to verify each connection's transport protocol version, could additionally take the node's perspective into account via `getpeerinfo()`, e.g.:\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/test/functional/p2p_v2_encrypted.py b/test/functional/p2p_v2_encrypted.py\r\nindex 177c3ed42f..8f5c4bb925 100755\r\n--- a/test/functional/p2p_v2_encrypted.py\r\n+++ b/test/functional/p2p_v2_encrypted.py\r\n@@ -56,23 +56,28 @@ class P2PEncrypted(BitcoinTestFramework):\r\n         self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\r\n         peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\r\n         assert peer1.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\r\n \r\n         self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\r\n         peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\r\n         assert not peer2.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n \r\n         self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\r\n         peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\r\n         assert not peer3.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n \r\n         # v2 TestNode performs downgrading here\r\n         self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v2 is v1\")\r\n         peer4 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, supports_v2_p2p=False, advertise_v2_p2p=True)\r\n         assert not peer4.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n \r\n         self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\r\n         peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\r\n         assert peer5.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\r\n \r\n         self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\r\n         assert_equal(len(node0.getpeerinfo()), 5)  # check if above 5 connections are present in node0's getpeerinfo()\r\n@@ -88,6 +93,7 @@ class P2PEncrypted(BitcoinTestFramework):\r\n             # Add v2 P2P connection to node0\r\n             peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\r\n             assert peer6.supports_v2_p2p\r\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\r\n \r\n             if i:\r\n                 # check if node1 connected to node0 (but not to node0's p2p connection directly)\r\n@@ -115,6 +121,7 @@ class P2PEncrypted(BitcoinTestFramework):\r\n         self.restart_node(0, [\"-v2transport=0\"])\r\n         peer7 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\r\n         assert not peer7.supports_v2_p2p\r\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\r\n         check_node_connections(node=node0, num_in=1, num_out=0)\r\n```\r\n</details>\r\n(same for the downgrading check commit after)",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T18:09:34Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409687151",
      "id" : 1409687151,
      "line" : 58,
      "node_id" : "PRRC_kwDOABII585UBh5v",
      "original_commit_id" : "a1109bfc250263d629070bcb0763b76e9ebc1689",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : 56,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 58,
      "pull_request_review_id" : 1755780494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409687151/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 56,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409687151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409717469"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409717469"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah, now that `use_v2transport` with the correct restart behavior is used, CI fails because it is necessary to fix the `test_service_flags` subtest from rpc_net.py already in this PR, to something like\r\n```\r\nif self.options.v2transport:\r\n    assert_equal(['UNKNOWN[2^4]', 'P2P_V2', 'UNKNOWN[2^63]'], self.nodes[0].getpeerinfo()[-1]['servicesnames'])\r\nelse:\r\n    assert_equal(['UNKNOWN[2^4]', 'UNKNOWN[2^63]'], self.nodes[0].getpeerinfo()[-1]['servicesnames'])\r\n```",
      "commit_id" : "70830539d17ba7ab5c17489597ba1bf9fadff6ac",
      "created_at" : "2023-11-29T18:37:35Z",
      "diff_hunk" : "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1409717469",
      "id" : 1409717469,
      "line" : 666,
      "node_id" : "PRRC_kwDOABII585UBpTd",
      "original_commit_id" : "47e72daf656ea6dc6766f71e5c8bda5717dc5362",
      "original_line" : 666,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : 37,
      "pull_request_review_id" : 1755965923,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409717469/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-29T18:37:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1409717469",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410160755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410160755"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "great idea! done.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:08:49Z",
      "diff_hunk" : "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410160755",
      "id" : 1410160755,
      "in_reply_to_id" : 1409600332,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UDVhz",
      "original_commit_id" : "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "original_line" : 60,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1756640775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410160755/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:08:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410160755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161591"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "interesting! i've kept a `MSGTYPE_TO_SHORTID` dictionary and used this construct in [`build_message`](https://github.com/bitcoin/bitcoin/blob/6567fe2aafa43b99e8298018b0665222eec4daff/test/functional/test_framework/p2p.py#L398).",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:10:27Z",
      "diff_hunk" : "@@ -4,10 +4,90 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+\n+def GetShortIDFromMessageType(msgtype):\n+    \"\"\"Returns 1-byte short message type ID for the P2P message\"\"\"\n+    msgtype_to_shortid = dict(map(reversed, SHORTID.items()))\n+    return msgtype_to_shortid[msgtype].to_bytes(1, 'big') if msgtype in msgtype_to_shortid else b\"\\x00\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161591",
      "id" : 1410161591,
      "in_reply_to_id" : 1409605417,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UDVu3",
      "original_commit_id" : "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "original_line" : 61,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1756641992,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:10:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161655"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:10:32Z",
      "diff_hunk" : "@@ -18,3 +98,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(\"sending %d bytes of garbage data\" % garbage_len)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161655",
      "id" : 1410161655,
      "in_reply_to_id" : 1409620992,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UDVv3",
      "original_commit_id" : "95d57de31f6e1fd251ffb1db4dd6959cf4f90a36",
      "original_line" : 107,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1756642068,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161655/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:10:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161655",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161736"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yay! looks pythonic! done.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:10:42Z",
      "diff_hunk" : "@@ -301,23 +302,47 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:] # msg is set to be payload\n+                    else:\n+                        # a short id\n+                        if shortid in SHORTID:\n+                            msgtype = SHORTID[shortid]\n+                        else:\n+                            msgtype = \"unknown-\" + str(shortid)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161736",
      "id" : 1410161736,
      "in_reply_to_id" : 1409649019,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UDVxI",
      "original_commit_id" : "07be9af55860b447edbb7069114881abdd1d85a4",
      "original_line" : 325,
      "original_position" : 49,
      "original_start_line" : 322,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1756642205,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161736/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:10:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161807"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161807"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:10:47Z",
      "diff_hunk" : "@@ -387,17 +388,29 @@ def maybe_write():\n \n     def build_message(self, message):\n         \"\"\"Build a serialized P2P message\"\"\"\n-        msgtype = message.msgtype\n-        data = message.serialize()\n-        tmsg = self.magic_bytes\n-        tmsg += msgtype\n-        tmsg += b\"\\x00\" * (12 - len(msgtype))\n-        tmsg += struct.pack(\"<I\", len(data))\n-        th = sha256(data)\n-        h = sha256(th)\n-        tmsg += h[:4]\n-        tmsg += data\n-        return tmsg\n+        if self.supports_v2_p2p:\n+            msgtype = message.msgtype\n+            data = message.serialize()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161807",
      "id" : 1410161807,
      "in_reply_to_id" : 1409654837,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UDVyP",
      "original_commit_id" : "985791c38ff90c09dfd4fa727e326e395ebc1406",
      "original_line" : 393,
      "original_position" : 25,
      "original_start_line" : 392,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1756642260,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161807/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:10:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161807",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161873"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161873"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good suggestion! done.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:10:53Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410161873",
      "id" : 1410161873,
      "in_reply_to_id" : 1409687151,
      "line" : 58,
      "node_id" : "PRRC_kwDOABII585UDVzR",
      "original_commit_id" : "a1109bfc250263d629070bcb0763b76e9ebc1689",
      "original_line" : 58,
      "original_position" : 58,
      "original_start_line" : 56,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 58,
      "pull_request_review_id" : 1756642336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161873/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 56,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:10:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410161873",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410162030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410162030"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "missed that! i've updated the subtest in `rpc_net.py`.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-11-30T05:11:12Z",
      "diff_hunk" : "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1410162030",
      "id" : 1410162030,
      "in_reply_to_id" : 1409717469,
      "line" : 666,
      "node_id" : "PRRC_kwDOABII585UDV1u",
      "original_commit_id" : "47e72daf656ea6dc6766f71e5c8bda5717dc5362",
      "original_line" : 666,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : 37,
      "pull_request_review_id" : 1756642573,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410162030/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-30T05:11:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1410162030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks @theStack, @mzumsande! I've updated the PR to address your comments.\r\nAlso made this change to `MSGTYPE_TO_SHORTID` construction because of `lint-python.py` failure in the CI\r\n\r\n```diff\r\ndiff --git a/test/functional/test_framework/v2_p2p.py b/test/functional/test_framework/v2_p2p.py\r\nindex fe44351a13..b4efd1ac58 100644\r\n--- a/test/functional/test_framework/v2_p2p.py\r\n+++ b/test/functional/test_framework/v2_p2p.py\r\n@@ -55,7 +55,7 @@ SHORTID = {\r\n }\r\n \r\n # Dictionary which contains short message type ID for the P2P message\r\n-MSGTYPE_TO_SHORTID = dict(map(reversed, SHORTID.items()))\r\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\r\n \r\n \r\n class EncryptedP2PState:\r\n```",
      "created_at" : "2023-11-30T07:11:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#issuecomment-1833222343",
      "id" : 1833222343,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24748",
      "node_id" : "IC_kwDOABII585tRMDH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1833222343/reactions"
      },
      "updated_at" : "2023-11-30T07:11:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1833222343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1418061039"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1418061039"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "One thing to consider is that now we have two locks for p2p, we need to worry about deadlocks.\r\nThere is an implied lock order, `on_message` locks `p2p_lock`, and can call messages (e.g. `on_inv`) that will call `send_message` and lock `_send_lock`. So we must make sure never to take `p2p_lock` after `_send_lock`. I don't think that this is currently possible, but maybe we should add a comment about this.",
      "commit_id" : "f479a99cc92c7966266804e8c33338cebbc44fbc",
      "created_at" : "2023-12-06T22:43:13Z",
      "diff_hunk" : "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1418061039",
      "id" : 1418061039,
      "line" : 167,
      "node_id" : "PRRC_kwDOABII585UheTv",
      "original_commit_id" : "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "original_line" : 166,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 38,
      "pull_request_review_id" : 1768762854,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1418061039/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-06T22:47:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1418061039",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419447076"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419447076"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nIt would be helpful to explain what the return value of the various functions in this class means. In several cases the return value seems to be bytes-that-should-be-sent-to-the-peer, but there are exceptions (-1 meaning downgrade for `respond_v2_handshake`, and `v2_ecdh` returning the shared secret).",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T18:32:41Z",
      "diff_hunk" : "@@ -4,10 +4,87 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419447076",
      "id" : 1419447076,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Umwsk",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 62,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1770812972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419447076/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-07T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419447076",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419473256"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419473256"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nIt seems a bit strange to always send exactly 10 decoy packets before the version packet. Maybe randomize that too?",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T18:55:33Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419473256",
      "id" : 1419473256,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Um3Fo",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 138,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1770812972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419473256/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-07T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419473256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419502857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419502857"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nAs I understand it, this function does not distinguish between \"valid packet with 0-byte contents\" and \"decoy packet\", which I believe is incorrect (the version packet can have 0-byte contents, but if it's a decoy, we should still listen for more packets). This isn't caught because Bitcoin Core's V2Transport implementation never sends decoys, but if it did, I believe the tests would break.\r\n\r\nMy suggestion would be to return `None` instead of `b\"\"` for decoys.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T19:22:31Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419502857",
      "id" : 1419502857,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Um-UJ",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 225,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1770812972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419502857/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-07T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419502857",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419509492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419509492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nI don't think we should be hardcoding this assumption. Decoy packets with 0-byte contents are very much correct and possibly useful. See my other comment on `v2_receive_packet` about distinguishing decoys from 0-byte content packets.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T19:28:15Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419509492",
      "id" : 1419509492,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Um_70",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 168,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1770812972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419509492/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-07T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419509492",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419512254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419512254"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Introduce EncryptedP2PState object in P2PConnection\"\r\n\r\nNit: I'd find it a bit cleaner to *not* give this variable such an accurate name for reasons of abstractions. The code here shouldn't care about *what* it is that the `EncryptedP2PState` tells us to send; it should just be sent. Maybe call it \"send_handshake_bytes\" ?",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T19:30:17Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            ellswift_and_garbage_data = self.v2_state.initiate_v2_handshake()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419512254",
      "id" : 1419512254,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UnAm-",
      "original_commit_id" : "e378d8af14e302fb34900c403d698445ade5f582",
      "original_line" : 217,
      "original_position" : 52,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1770812972,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419512254/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-07T19:37:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419512254",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419733098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419733098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If the length returned by `v2_receive_packet(...)` is -1 due to a MAC tag mismatch, `processed_length` is decreased by one here, which is very likely unintended. Currently this is not a problem (the call-site in the later introduced method `P2PConnection.v2_handshake` throws an exception then anyways and doesn't do anything with the returned length), but it's probably better if the `processed_length` increase happens after the length-checks and returns a few lines below.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T22:37:31Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419733098",
      "id" : 1419733098,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Un2hq",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 162,
      "original_position" : 157,
      "original_start_line" : 161,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1771245412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419733098/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-08T00:01:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419733098",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419736521"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419736521"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: as the `v1_prefix` only depends on `self.net` and never changes, could set it once before the loop (or even in the constructor and store it as member, if we'd ever need it somewhere else), rather than repeatedly on each iteration.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T22:41:55Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419736521",
      "id" : 1419736521,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Un3XJ",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 120,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1771245412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419736521/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-08T00:01:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419736521",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419777979"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419777979"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: could check that `msg` has the required minimum length (13) and raise an error if it doesn't, to avoid a potential index out-of-bounds exception (even though this is more theoretical now, as bitcoind wouldn't send such an invalid message).",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T23:53:04Z",
      "diff_hunk" : "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:]  # msg is set to be payload",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419777979",
      "id" : 1419777979,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UoBe7",
      "original_commit_id" : "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "original_line" : 333,
      "original_position" : 43,
      "original_start_line" : 317,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1771245412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419777979/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-08T00:01:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419777979",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419779955"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419779955"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this early check needed? I think `v2_receive_packet` already takes care of these \"only part of packet is received\" cases and indicates this with a corresponding return code.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-07T23:56:54Z",
      "diff_hunk" : "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1419779955",
      "id" : 1419779955,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585UoB9z",
      "original_commit_id" : "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "original_line" : 310,
      "original_position" : 34,
      "original_start_line" : 309,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1771245412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419779955/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-08T00:01:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1419779955",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525133"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525133"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good find! i've added a comment.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:17Z",
      "diff_hunk" : "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525133",
      "id" : 1427525133,
      "in_reply_to_id" : 1418061039,
      "line" : 169,
      "node_id" : "PRRC_kwDOABII585VFk4N",
      "original_commit_id" : "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "original_line" : 169,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 40,
      "pull_request_review_id" : 1783087789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525133/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525133",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525183"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525183"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "definitely useful to have. done.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:24Z",
      "diff_hunk" : "@@ -4,10 +4,87 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for performing v2 P2P protocol functions on P2PConnection:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525183",
      "id" : 1427525183,
      "in_reply_to_id" : 1419447076,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk4_",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 62,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783087850,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525183/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525201"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "changed it to send 0-9 number of decoy packets randomly.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:28Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525201",
      "id" : 1427525201,
      "in_reply_to_id" : 1419473256,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk5R",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 138,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783087889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525201/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525236"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525236"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good catch! changed it to `None`.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:33Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't\n+                    if length == LENGTH_FIELD_LEN + HEADER_LEN + CHACHA20POLY1305_EXPANSION:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+        Returns:\n+            1. length - length of packet processed in order to update recvbuf.\n+                      - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+                      - return -1 if there's a MAC tag mismatch and disconnect.\n+            2. decrypted packet contents\n+                     - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525236",
      "id" : 1427525236,
      "in_reply_to_id" : 1419502857,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk50",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 225,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783087939,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525236/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525236",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525256"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525256"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "right! done.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:36Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    # currently version packet has empty content while decoy packets don't",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525256",
      "id" : 1427525256,
      "in_reply_to_id" : 1419509492,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk6I",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 168,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783087968,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525256/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525305"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525305"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "oh makes sense to `s/ellswift_and_garbage_data/send_handshake_bytes` in `p2p.py`. didn't change the name in a test where we [send ellswift in parts](https://github.com/bitcoin/bitcoin/blob/ad0ae3d2128d04ff4f62a4bf612286d153dc314b/test/functional/p2p_v2_earlykeyresponse.py#L78). ",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:46Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            ellswift_and_garbage_data = self.v2_state.initiate_v2_handshake()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525305",
      "id" : 1427525305,
      "in_reply_to_id" : 1419512254,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk65",
      "original_commit_id" : "e378d8af14e302fb34900c403d698445ade5f582",
      "original_line" : 217,
      "original_position" : 52,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783088067,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525305/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525305",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525326"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:50Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(10)]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+        Returns:\n+            1. length of bytes that were processed so that recvbuf can be updated\n+            2. True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    processed_length += length",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525326",
      "id" : 1427525326,
      "in_reply_to_id" : 1419733098,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk7O",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 162,
      "original_position" : 157,
      "original_start_line" : 161,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783088100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525326/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525326",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525347"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice, i've kept it outside the loop since we don't need it anywhere else for now.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:53Z",
      "diff_hunk" : "@@ -18,3 +95,148 @@ def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\"\"\"\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525347",
      "id" : 1427525347,
      "in_reply_to_id" : 1419736521,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk7j",
      "original_commit_id" : "1e070587145a307477328bd313b2eebf72d3a208",
      "original_line" : 120,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783088132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525347/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525364"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:01:57Z",
      "diff_hunk" : "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    self.recvbuf = self.recvbuf[msglen:]\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command\n+                        msgtype = msg[1:13].rstrip(b'\\x00')\n+                        msg = msg[13:]  # msg is set to be payload",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525364",
      "id" : 1427525364,
      "in_reply_to_id" : 1419777979,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk70",
      "original_commit_id" : "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "original_line" : 333,
      "original_position" : 43,
      "original_start_line" : 317,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783088159,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525364/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:01:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525400"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "true, replaced it with a check using `v2_receive_packet` return values which are anyways computed.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-15T04:02:00Z",
      "diff_hunk" : "@@ -301,23 +302,44 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+                    # v2 P2P messages are read\n+                    if len(self.recvbuf) < 3 + 1 + 16:\n+                        return",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1427525400",
      "id" : 1427525400,
      "in_reply_to_id" : 1419779955,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VFk8Y",
      "original_commit_id" : "74187afea19284f1ccf576321a57ff18b6e2b1d0",
      "original_line" : 310,
      "original_position" : 34,
      "original_start_line" : 309,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1783088186,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525400/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-15T04:02:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427525400",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1435835891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435835891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "more-pythonic-nit:\r\n```suggestion\r\n            kwargs['services'] = kwargs.get('services', P2P_SERVICES) | NODE_P2P_V2\r\n```\r\n(also in the `add_outbound_p2p_connection` method below)",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-24T14:35:41Z",
      "diff_hunk" : "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1435835891",
      "id" : 1435835891,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VlR3z",
      "original_commit_id" : "52a1719d604befeb799588cd43d7e241772de38a",
      "original_line" : 666,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1795584001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435835891/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-24T15:04:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435835891",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1435840695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435840695"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: IIUC, `b\"\"` is also returned if the decrypted package content is empty. As call-sites currently use\r\nthe length integer return value (0) to check for the \"only part of packet is received\" condition, this isn't a problem, but maybe the description can be improved to avoid confusion.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2023-12-24T14:58:45Z",
      "diff_hunk" : "@@ -4,17 +4,275 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:\n+        1. int - length of packet processed in order to update recvbuf.\n+               - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+               - return -1 if there's a MAC tag mismatch and disconnect.\n+        2. bytes - decrypted packet contents\n+                 - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1435840695",
      "id" : 1435840695,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VlTC3",
      "original_commit_id" : "d4d9f673046c05ca1eb638c9c763dc5d90947fe0",
      "original_line" : 260,
      "original_position" : 259,
      "original_start_line" : 259,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1795584001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435840695/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-12-24T15:04:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435840695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1439634994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439634994"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice! done.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-02T16:53:56Z",
      "diff_hunk" : "@@ -642,18 +643,30 @@ def assert_start_raises_init_error(self, extra_args=None, expected_msg=None, mat\n                     assert_msg += \"with expected error \" + expected_msg\n                 self._raise_assertion_error(assert_msg)\n \n-    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *, wait_for_verack=True, send_version=True, supports_v2_p2p=False, **kwargs):\n         \"\"\"Add an inbound p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n-        returns the connection to the caller.\"\"\"\n+        returns the connection to the caller.\n+\n+        When self.use_v2transport is True, TestNode advertises NODE_P2P_V2 service flag\n+\n+        An inbound connection is made from TestNode <------ P2PConnection\n+        - if TestNode doesn't advertise NODE_P2P_V2 service, P2PConnection sends version message and v1 P2P is followed\n+        - if TestNode advertises NODE_P2P_V2 service, (and if P2PConnections supports v2 P2P)\n+                P2PConnection sends ellswift bytes and v2 P2P is followed\n+        \"\"\"\n         if 'dstport' not in kwargs:\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n \n         p2p_conn.p2p_connected_to_node = True\n-        p2p_conn.peer_connect(**kwargs, send_version=send_version, net=self.chain, timeout_factor=self.timeout_factor)()\n+        if self.use_v2transport:\n+            kwargs['services'] = kwargs['services']|NODE_P2P_V2 if 'services' in kwargs else P2P_SERVICES|NODE_P2P_V2",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1439634994",
      "id" : 1439634994,
      "in_reply_to_id" : 1435835891,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585VzxYy",
      "original_commit_id" : "52a1719d604befeb799588cd43d7e241772de38a",
      "original_line" : 666,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1800723563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439634994/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-02T16:53:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439634994",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1439635162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439635162"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "added a [description](https://github.com/bitcoin/bitcoin/blob/42203f84bba7e4ba206c9f951c3f4b6922a44f81/test/functional/test_framework/v2_p2p.py#L260-L265) and also an [extra assert](https://github.com/bitcoin/bitcoin/blob/42203f84bba7e4ba206c9f951c3f4b6922a44f81/test/functional/test_framework/p2p.py#L326) to make sure we don't receive b\"\" as an application layer message.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-02T16:54:07Z",
      "diff_hunk" : "@@ -4,17 +4,275 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:\n+        1. int - length of packet processed in order to update recvbuf.\n+               - return 0 if only part of packet is received. (recvbuf not updated since decryption not done yet)\n+               - return -1 if there's a MAC tag mismatch and disconnect.\n+        2. bytes - decrypted packet contents\n+                 - return b\"\" if only part of packet is received/MAC tag mismatch.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1439635162",
      "id" : 1439635162,
      "in_reply_to_id" : 1435840695,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Vzxba",
      "original_commit_id" : "d4d9f673046c05ca1eb638c9c763dc5d90947fe0",
      "original_line" : 260,
      "original_position" : 259,
      "original_start_line" : 259,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1800723770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439635162/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-01-02T16:54:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439635162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1445399806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1445399806"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "here, and in `peer_accept_connection`: I think the default values aren't necessary and could be dropped. They are not used right now, and it seems better if future callers are forced make a decision on whether to use v2 or not!",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-08T22:09:17Z",
      "diff_hunk" : "@@ -174,16 +180,22 @@ def peer_connect_helper(self, dstaddr, dstport, net, timeout_factor):\n         self.recvbuf = b\"\"\n         self.magic_bytes = MAGIC_BYTES[net]\n \n-    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor):\n+    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor, supports_v2_p2p=False):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1445399806",
      "id" : 1445399806,
      "line" : 189,
      "node_id" : "PRRC_kwDOABII585WJwz-",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 183,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 53,
      "pull_request_review_id" : 1810107436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1445399806/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-10T21:23:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1445399806",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447657783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447657783"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Trying to wrap my head around this: \r\nLet's say we receive the garbage and then receive one or more decoy packages. Then we cut the response here, but if no version package has been received so far, we can still return `0, True` earlier in the while loop and try again later.\r\nBut then the next time this function is called, wouldn't authentication fail because we've already removed the garbage terminator from the response?\r\n\r\nNot a big deal though - because bitcoind doesn't send any decoy messages currently, this cannot be triggered.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-10T16:52:10Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447657783",
      "id" : 1447657783,
      "line" : 202,
      "node_id" : "PRRC_kwDOABII585WSYE3",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 202,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 202,
      "pull_request_review_id" : 1810107436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447657783/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-10T21:23:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447657783",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447884179"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447884179"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `reject` sounds like we actively do something, `ignore` seems better.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-10T19:50:23Z",
      "diff_hunk" : "@@ -321,6 +321,8 @@ def _on_data(self):\n                         return\n                     self.recvbuf = self.recvbuf[msglen:]\n \n+                    if msg is None:  # reject decoy messages",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447884179",
      "id" : 1447884179,
      "line" : 324,
      "node_id" : "PRRC_kwDOABII585WTPWT",
      "original_commit_id" : "7da31532af882dabbd5d9d6e89634513a24189ea",
      "original_line" : 324,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 197,
      "pull_request_review_id" : 1810107436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447884179/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-10T21:23:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447884179",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447962448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447962448"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that this should be moved outside of the `if connection_type == \"feeler\":` clause and be done before:\r\nAfter all the v2 reconnection stuff logically comes first, and then all the existing v1 logic still applies to the downgraded v1 connection - for example, the reconnection logic should also work if `add_outbound_p2p_connection` specified a feeler connection - in which case we currently wouldn't call `wait_for_reconnect`.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-10T21:00:13Z",
      "diff_hunk" : "@@ -741,7 +741,10 @@ def addconnection_callback(address, port):\n             p2p_conn.wait_until(lambda: p2p_conn.message_count[\"version\"] == 1, check_connected=False)\n             p2p_conn.wait_until(lambda: not p2p_conn.is_connected, check_connected=False)\n         else:\n-            p2p_conn.wait_for_connect()\n+            if reconnect:\n+                p2p_conn.wait_for_reconnect()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447962448",
      "id" : 1447962448,
      "line" : 745,
      "node_id" : "PRRC_kwDOABII585WTidQ",
      "original_commit_id" : "689318cd83ca5b17b73e56a0c1544072973718c5",
      "original_line" : 745,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : 95,
      "pull_request_review_id" : 1810107436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447962448/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-10T21:25:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447962448",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448895458"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448895458"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nThis needs to be `return processed_length, True`, as there may be been decoys before (I can trigger a failure in p2p_v2_encrypted.py by making Bitcoin Core send large decoys before the version packet). <details><summary>Code to trigger it:</summary>\r\n```diff\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -1130,6 +1130,15 @@ bool V2Transport::ProcessReceivedKeyBytes() noexcept\r\n                   m_cipher.GetSendGarbageTerminator().end(),\r\n                   MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::GARBAGE_TERMINATOR_LEN).begin());\r\n \r\n+        unsigned decoys = GetRand<unsigned>(10);\r\n+        while (decoys--) {\r\n+            unsigned decoysize = GetRand<unsigned>(4000000);\r\n+            m_send_buffer.resize(m_send_buffer.size() + BIP324Cipher::EXPANSION + decoysize);\r\n+            std::vector<std::byte> decoy_data(decoysize);\r\n+            m_cipher.Encrypt(decoy_data, MakeByteSpan(m_send_garbage), true, MakeWritableByteSpan(m_send_buffer).last(BIP324Cipher::EXPANSION + decoysize));\r\n+            ClearShrink(m_send_garbage);\r\n+        }\r\n+\r\n         // Construct version packet in the send buffer, with the sent garbage data as AAD.\r\n```\r\n</details>\r\n\r\nI think it would be even cleaner to change `v2_receive_packet` to also return `contents = None` in case no complete packet was received. In that case, the whole `elif length == 0:` branch can go away.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T13:49:48Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448895458",
      "id" : 1448895458,
      "line" : 195,
      "node_id" : "PRRC_kwDOABII585WXGPi",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 195,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 195,
      "pull_request_review_id" : 1814350455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448895458/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T16:40:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448895458",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448904297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448904297"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In \"In commit \"[test] Construct class to handle v2 P2P protocol functions\"\r\n\r\nNit: see above, I think it would be cleaner to return `(0, None)` in case no complete packet is present, and `(-1, None)` in case of error. That would make the description:\r\n* int: number of bytes consumed (or -1 if error)\r\n* bytes: contents of decrypted non-decoy packet if any (or None otherwise)\r\n\r\nSince the callers don't care about the distinction between \"no packet processed\" or \"decoy packet processed\" for what to do with the returned contents, I think this would let you remove some branches.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T13:56:39Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448904297",
      "id" : 1448904297,
      "line" : 255,
      "node_id" : "PRRC_kwDOABII585WXIZp",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 255,
      "original_position" : 254,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 255,
      "pull_request_review_id" : 1814350455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448904297/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T16:32:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448904297",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448911572"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448911572"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Introduce EncryptedP2PState object in P2PConnection\":\r\n\r\nNit: probably unnecessary to go into the detail of what gets sent, as that's the responsibility of `v2_p2p`. Maybe just say \"The initial handshake is sent immediately\".",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T14:02:23Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1448911572",
      "id" : 1448911572,
      "line" : 222,
      "node_id" : "PRRC_kwDOABII585WXKLU",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 215,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 79,
      "pull_request_review_id" : 1814350455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448911572/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T16:32:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1448911572",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449286884"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449286884"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: queued / queue of messages / messages queued",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T19:10:45Z",
      "diff_hunk" : "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p\n+        self.queue_messages = []  # queue messages to send after initial v2 handshake",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449286884",
      "id" : 1449286884,
      "line" : 173,
      "node_id" : "PRRC_kwDOABII585WYlzk",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 167,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 44,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449286884/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449286884",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449289058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449289058"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this field is redundant. This will always be `True` if `v2_state` is set, and `False` otherwise, so we could drop it and just check against whether v2_state is `None`.\r\n\r\nIf you think that's too verbose, you could also create a helper method:\r\n\r\n```python\r\ndef supports_v2_p2p(self):\r\n    return self.v2_state is not None\r\n```",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T19:13:30Z",
      "diff_hunk" : "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449289058",
      "id" : 1449289058,
      "line" : 171,
      "node_id" : "PRRC_kwDOABII585WYmVi",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 166,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 42,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449289058/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449289058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449320797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449320797"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: feels like this is something that you could do on `__init__()` instead of creating an empty array. It's not a big deal though, so feel free to disregard  ",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T19:46:55Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n         if self.on_connection_send_msg:\n-            self.send_message(self.on_connection_send_msg)\n+            self.queue_messages.append(self.on_connection_send_msg) if self.supports_v2_p2p else self.send_message(self.on_connection_send_msg)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449320797",
      "id" : 1449320797,
      "line" : 227,
      "node_id" : "PRRC_kwDOABII585WYuFd",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 220,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 85,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449320797/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449320797",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449336950"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449336950"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: space missing after responder, also I guess add \"the\" before to match the previous suggestion if you happen to take it",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T20:02:01Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449336950",
      "id" : 1449336950,
      "line" : 245,
      "node_id" : "PRRC_kwDOABII585WYyB2",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 237,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 104,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449336950/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449336950",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449337692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449337692"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: P2PConnection is \"the\" initiator?",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T20:02:51Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449337692",
      "id" : 1449337692,
      "line" : 244,
      "node_id" : "PRRC_kwDOABII585WYyNc",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 236,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 103,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449337692/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449337692",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449340059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449340059"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: caps in \"the\"",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T20:05:12Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449340059",
      "id" : 1449340059,
      "line" : 251,
      "node_id" : "PRRC_kwDOABII585WYyyb",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 243,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 110,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449340059/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449340059",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449352220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449352220"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is this necessary? \r\n\r\n`self.v2_state.received_prefix` is initialized to `b\"\"`, whose length is zero. Therefore, and given you are only using this as offset for `self.recvbuf`, I think you could just dump the variable and do (in line 266):\r\n\r\n```\r\nresponse = self.v2_state.complete_handshake(BytesIO(self.recvbuf[len(self.v2_state.received_prefix):]))\r\n```\r\n\r\nOr define the variable if you want a shorter call but just right before using it, without having to set it to zero first.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-11T20:17:11Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1449352220",
      "id" : 1449352220,
      "line" : 254,
      "node_id" : "PRRC_kwDOABII585WY1wc",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 246,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 113,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449352220/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449352220",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450623741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450623741"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Perform initial v2 handshake\":\r\n\r\nI think it's not very clean to reach into `self.v2_state`'s internals to figure out how much `respond_v2_handshake` has consumed. It would be better if the function just returned how much was consumed (if anything).",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T15:44:51Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450623741",
      "id" : 1450623741,
      "line" : 258,
      "node_id" : "PRRC_kwDOABII585WdsL9",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 250,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 117,
      "pull_request_review_id" : 1814350455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450623741/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T16:32:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450623741",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450663849"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450663849"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"[test] Perform initial v2 handshake\":\r\n\r\nI don't think this conditional is necessary. `authenticate_handshake` itself can figure out what it needs.",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T16:17:47Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64:\n+                return\n+            # `complete_handshake()` computes garbage terminator + optional decoy packets + transport version packet\n+            # to be sent as response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        # at least 16 bytes garbage terminator and 20 bytes empty transport version packet\n+        # is required to authenticate v2 handshake\n+        if len(self.recvbuf) < 16 + 20:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450663849",
      "id" : 1450663849,
      "line" : 284,
      "node_id" : "PRRC_kwDOABII585Wd1-p",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 276,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 143,
      "pull_request_review_id" : 1814350455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450663849/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T16:32:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450663849",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450676078"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450676078"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "just want to add that if this turned out annoying to fix (I didn't see an immediate trivial fix but haven't looked hard), I'd be fine with just throwing an assert / error if decoy packages are received in this PR (since bitcoind shouldn't send those anyway).",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T16:29:07Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450676078",
      "id" : 1450676078,
      "in_reply_to_id" : 1447657783,
      "line" : 202,
      "node_id" : "PRRC_kwDOABII585Wd49u",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 202,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 202,
      "pull_request_review_id" : 1818631409,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450676078/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T16:29:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450676078",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450804849"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450804849"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would it be worth changing how `p2p_lock` is acquired to prevent this? Instead of just grabbing it we could have a helper method being part of the `P2PConnection` that returns it as long as `_send_lock` is not being held, and fails otherwise. Something along the lines of:\r\n\r\n```python\r\ndef p2p_lock(self):\r\n    assert not self._send_lock.locked()\r\n    return p2p_lock\r\n```\r\n\r\nIf you make this change it may also be worth renaming `p2p_lock` to `_p2p_lock` to discourage it from being imported straightaway (and even comment that it shouldn't).\r\n\r\nGiven this will affect several parts of the tests suite it may be worth doing it as a followup",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T18:41:15Z",
      "diff_hunk" : "@@ -163,6 +163,7 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self._send_lock = threading.Lock()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450804849",
      "id" : 1450804849,
      "in_reply_to_id" : 1418061039,
      "line" : 169,
      "node_id" : "PRRC_kwDOABII585WeYZx",
      "original_commit_id" : "bc26a862b06257ce922b586ac5a7751e61e45e4b",
      "original_line" : 169,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 40,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450804849/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450804849",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450825617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450825617"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Giving this a second look, is this queue necessary? The current use of it is adding the `on_connection_send_msg` and setting that to `None`, meaning that the queue will have at most a single message. Not sure if this is intended to be used in the future, but I don't this it is used atm ",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T19:06:55Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n         if self.on_connection_send_msg:\n-            self.send_message(self.on_connection_send_msg)\n+            self.queue_messages.append(self.on_connection_send_msg) if self.supports_v2_p2p else self.send_message(self.on_connection_send_msg)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450825617",
      "id" : 1450825617,
      "in_reply_to_id" : 1449320797,
      "line" : 227,
      "node_id" : "PRRC_kwDOABII585WedeR",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 220,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 85,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450825617/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450825617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450866270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450866270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm really struggling to understand what is going on here based on these comments (and the ones bellow at L98-99).\r\n\r\nTo my understanding, what we are trying to test here is: given a peer of `node0` (`peer6`) that provides some blocks to it (decoy on the first iteration and regular on the second) check if after connecting `node0` and `node1` they do end up sharing the same tip. However, I feel the comments are hard to understand",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-12T19:48:25Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450866270",
      "id" : 1450866270,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585WenZe",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 94,
      "original_position" : 94,
      "original_start_line" : 93,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450866270/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-01-16T15:09:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450866270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450888252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888252"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: connection (for consistency with the rest)",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T20:15:55Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450888252",
      "id" : 1450888252,
      "line" : 56,
      "node_id" : "PRRC_kwDOABII585Wesw8",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 56,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 56,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888252/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888252",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450888980"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888980"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: connection (for consistency with the rest).\r\n\r\nAlso, it may be worth moving this right `peer2` so inbounds and outbounds are grouped",
      "commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "created_at" : "2024-01-12T20:16:58Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1450888980",
      "id" : 1450888980,
      "line" : 120,
      "node_id" : "PRRC_kwDOABII585Wes8U",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 114,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : 120,
      "pull_request_review_id" : 1816369526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888980/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-12T20:52:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1450888980",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457621863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457621863"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why is 32 here being passed in every tuple if it really is used as a constant?",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-18T15:38:26Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457621863",
      "id" : 1457621863,
      "line" : 232,
      "node_id" : "PRRC_kwDOABII585W4Ytn",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 232,
      "original_position" : 218,
      "original_start_line" : 217,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 232,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457621863/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 231,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:09:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457621863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457652467"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457652467"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why is `garbage_terminators` being actively deleted here instead of letting the deletion be managed by the interpreter once we go out of context (and `peer` is deleted as a whole)?",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-18T15:55:05Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457652467",
      "id" : 1457652467,
      "line" : 236,
      "node_id" : "PRRC_kwDOABII585W4gLz",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 236,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 236,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457652467/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:09:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457652467",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457654033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457654033"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I initially thought this had to do with:\r\n\r\n> \\# To achieve forward secrecy we must wipe the key material used to initialize the ciphers\r\n\r\nBut turns out we are not doing it for the key material.",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-18T15:56:06Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457654033",
      "id" : 1457654033,
      "in_reply_to_id" : 1457652467,
      "line" : 236,
      "node_id" : "PRRC_kwDOABII585W4gkR",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 236,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 236,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457654033/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:09:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457654033",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457665569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457665569"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We could even get rid of this whole re-assignment and just set it in the latter if/else:\r\n\r\n```\r\nself.peer['send_garbage_terminator'] = peer['garbage_terminators'][:16]\r\nself.peer['recv_garbage_terminator'] = peer['garbage_terminators'][16:]\r\n```",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-18T16:04:25Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457665569",
      "id" : 1457665569,
      "in_reply_to_id" : 1457652467,
      "line" : 236,
      "node_id" : "PRRC_kwDOABII585W4jYh",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 236,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 236,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457665569/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:09:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457665569",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457677043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457677043"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I wonder whether it may be worth defining a `Peer` class for this and move the peer-building logic of `initialize_v2_transport` here. I don't think this would make a huge difference, but it would make accessing the elements of peer cleaner for the callers. e.g. `self.peer.send_L` instead of `self.peer[\"send_L\"]`",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-18T16:13:06Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1457677043",
      "id" : 1457677043,
      "line" : 87,
      "node_id" : "PRRC_kwDOABII585W4mLz",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 87,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457677043/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:09:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1457677043",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466364"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice! done. removed default value for `reconnect` in `peer_accept_connection` too since that is also always passed from `add_outbound_p2p_connection`  ",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:22:26Z",
      "diff_hunk" : "@@ -174,16 +180,22 @@ def peer_connect_helper(self, dstaddr, dstport, net, timeout_factor):\n         self.recvbuf = b\"\"\n         self.magic_bytes = MAGIC_BYTES[net]\n \n-    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor):\n+    def peer_connect(self, dstaddr, dstport, *, net, timeout_factor, supports_v2_p2p=False):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466364",
      "id" : 1460466364,
      "in_reply_to_id" : 1445399806,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPK8",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 183,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834681957,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466364/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:22:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466533"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466533"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "great catch! i've changed the `authenticate_handshake` function to first deal with garbage terminator detection before processing decoy packets and version packet. hopefully this is not a concern now?",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:22:47Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466533",
      "id" : 1460466533,
      "in_reply_to_id" : 1447657783,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPNl",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 202,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834681995,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466533/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:22:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466533",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466611"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:22:54Z",
      "diff_hunk" : "@@ -321,6 +321,8 @@ def _on_data(self):\n                         return\n                     self.recvbuf = self.recvbuf[msglen:]\n \n+                    if msg is None:  # reject decoy messages",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466611",
      "id" : 1460466611,
      "in_reply_to_id" : 1447884179,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPOz",
      "original_commit_id" : "7da31532af882dabbd5d9d6e89634513a24189ea",
      "original_line" : 324,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466611/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:22:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466611",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466749"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "true! done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:23:09Z",
      "diff_hunk" : "@@ -741,7 +741,10 @@ def addconnection_callback(address, port):\n             p2p_conn.wait_until(lambda: p2p_conn.message_count[\"version\"] == 1, check_connected=False)\n             p2p_conn.wait_until(lambda: not p2p_conn.is_connected, check_connected=False)\n         else:\n-            p2p_conn.wait_for_connect()\n+            if reconnect:\n+                p2p_conn.wait_for_reconnect()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460466749",
      "id" : 1460466749,
      "in_reply_to_id" : 1447962448,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPQ9",
      "original_commit_id" : "689318cd83ca5b17b73e56a0c1544072973718c5",
      "original_line" : 745,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/test_node.py",
      "position" : null,
      "pull_request_review_id" : 1834682043,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466749/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:23:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460466749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467080"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice catch! done. i've changed `authenticate_handshake` function a bit as discussed in https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1447657783.\r\n\r\n> I think it would be even cleaner to change v2_receive_packet to also return contents = None in case no complete packet was received. In that case, the whole elif length == 0: branch can go away.\r\n\r\ni think we need the `elif length == 0:` now so that we can exit out of the `while not self.tried_v2_handshake:` loop in case we don't have sufficient bytes and need more bytes to be received on `recvbuf`? \r\n",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:23:55Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467080",
      "id" : 1460467080,
      "in_reply_to_id" : 1448895458,
      "line" : 204,
      "node_id" : "PRRC_kwDOABII585XDPWI",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 204,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 204,
      "pull_request_review_id" : 1834682138,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467080/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:23:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467080",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467126"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "much simpler! done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:24:03Z",
      "diff_hunk" : "@@ -4,17 +4,280 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']\n+        if self.initiating:\n+            self.peer['send_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['send_garbage_terminator'] = peer['initiator_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['recv_garbage_terminator'] = peer['responder_garbage_terminator']\n+        else:\n+            self.peer['send_L'] = FSChaCha20(peer['responder_L'])\n+            self.peer['send_P'] = FSChaCha20Poly1305(peer['responder_P'])\n+            self.peer['send_garbage_terminator'] = peer['responder_garbage_terminator']\n+            self.peer['recv_L'] = FSChaCha20(peer['initiator_L'])\n+            self.peer['recv_P'] = FSChaCha20Poly1305(peer['initiator_P'])\n+            self.peer['recv_garbage_terminator'] = peer['initiator_garbage_terminator']\n+        self.peer['session_id'] = peer['session_id']\n+\n+    def v2_enc_packet(self, contents, aad=b'', ignore=False):\n+        \"\"\"Encrypt a BIP324 packet.\n+\n+        Returns:\n+        bytes - encrypted packet contents\n+        \"\"\"\n+        assert len(contents) <= 2**24 - 1\n+        header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n+        plaintext = header + contents\n+        aead_ciphertext = self.peer['send_P'].encrypt(aad, plaintext)\n+        enc_plaintext_len = self.peer['send_L'].crypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n+        return enc_plaintext_len + aead_ciphertext\n+\n+    def v2_receive_packet(self, response, aad=b''):\n+        \"\"\"Decrypt a BIP324 packet\n+\n+        Returns:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467126",
      "id" : 1460467126,
      "in_reply_to_id" : 1448904297,
      "line" : 270,
      "node_id" : "PRRC_kwDOABII585XDPW2",
      "original_commit_id" : "76abc719f20243eb352633082421f33e9a2f66e4",
      "original_line" : 270,
      "original_position" : 254,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 270,
      "pull_request_review_id" : 1834682149,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467126/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:24:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467188"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467188"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:24:12Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467188",
      "id" : 1460467188,
      "in_reply_to_id" : 1448911572,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPX0",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 215,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682166,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467188/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:24:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467188",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467324"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "makes sense! I've changed `respond_v2_handshake` and `complete_v2_handshake` to return the bytes consumed info too.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:24:30Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467324",
      "id" : 1460467324,
      "in_reply_to_id" : 1450623741,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPZ8",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 250,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682199,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467324/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:24:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467324",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467380"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467380"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "true! done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:24:37Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                length = len(self.v2_state.received_prefix)\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+\n+            # if we're the responder, read ellswift bytes till the first mismatch from 12 bytes V1_PREFIX in\n+            # `respond_v2_handshake()`.\n+            # `complete_handshake()` reads the remaining `64 - length` ellswift bytes afterwards from recvbuf.\n+            # if we're the initiator, length = 0 and 64 bytes ellswift is read from recvbuf in `complete_handshake()`\n+            if len(self.recvbuf) < 64:\n+                return\n+            # `complete_handshake()` computes garbage terminator + optional decoy packets + transport version packet\n+            # to be sent as response after deriving shared ECDH secret using received ellswift bytes\n+            response = self.v2_state.complete_handshake(BytesIO(self.recvbuf[length:]))\n+            self.send_raw_message(response)\n+            self.recvbuf = self.recvbuf[64:]\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        # at least 16 bytes garbage terminator and 20 bytes empty transport version packet\n+        # is required to authenticate v2 handshake\n+        if len(self.recvbuf) < 16 + 20:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467380",
      "id" : 1460467380,
      "in_reply_to_id" : 1450663849,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPa0",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 276,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682211,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467380/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:24:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467380",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467496"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "oh i like this! done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:24:46Z",
      "diff_hunk" : "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467496",
      "id" : 1460467496,
      "in_reply_to_id" : 1449289058,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPco",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 166,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682228,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467496/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:24:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467496",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467897"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "hmm you're right. i used the idea of a queue initially because i liked the abstraction implied by queuing unsent messages to be sent after v2 handshake/reconnection.\r\n\r\nsince `on_connection_send_msg` is always the version message, i've changed the code to work with not clearing `on_connection_send_msg` before v2 handshake/reconnection is complete.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:25:14Z",
      "diff_hunk" : "@@ -199,8 +211,13 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n+        # in an inbound connection to the TestNode, P2PConnection is the initiator. [TestNode <---- P2PConnection]\n+        # ellswift is generated and sent immediately to begin the initial v2 handshake.\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n         if self.on_connection_send_msg:\n-            self.send_message(self.on_connection_send_msg)\n+            self.queue_messages.append(self.on_connection_send_msg) if self.supports_v2_p2p else self.send_message(self.on_connection_send_msg)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467897",
      "id" : 1460467897,
      "in_reply_to_id" : 1449320797,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPi5",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 220,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682270,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467897/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:25:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460467897",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468062"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "removed this variable as discussed in https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460467897.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:25:34Z",
      "diff_hunk" : "@@ -159,6 +162,9 @@ def __init__(self):\n         # The underlying transport of the connection.\n         # Should only call methods on this from the NetworkThread, c.f. call_soon_threadsafe\n         self._transport = None\n+        self.v2_state = None  # EncryptedP2PState object needed for v2 p2p connections\n+        self.supports_v2_p2p = False  # set if the connection supports v2 p2p\n+        self.queue_messages = []  # queue messages to send after initial v2 handshake",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468062",
      "id" : 1460468062,
      "in_reply_to_id" : 1449286884,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPle",
      "original_commit_id" : "f74c95758ed9437ae3aae5b7e63680dc64f37bcd",
      "original_line" : 167,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682296,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468062/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:25:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:25:41Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468098",
      "id" : 1460468098,
      "in_reply_to_id" : 1449336950,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPmC",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 237,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682305,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468098/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:25:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468098",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468173"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468173"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:25:52Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468173",
      "id" : 1460468173,
      "in_reply_to_id" : 1449337692,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPnN",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 236,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682330,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468173/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:25:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468173",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468220"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:25:58Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468220",
      "id" : 1460468220,
      "in_reply_to_id" : 1449340059,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPn8",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 243,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468220/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:25:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468220",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468278"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "makes sense! i've changed `respond_handshake` and `complete_handshake` to return length consumed too.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:26:05Z",
      "diff_hunk" : "@@ -231,12 +231,66 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is an initiator\n+        (in inbound connections to TestNode) and responder(in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. the rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            length = 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468278",
      "id" : 1460468278,
      "in_reply_to_id" : 1449352220,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPo2",
      "original_commit_id" : "6a7fe356d03182f89ad437dc29c786d9d6dbe99a",
      "original_line" : 246,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1834682354,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468278/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:26:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468278",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468407"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yes! i've simplified the comments. hopefully it's better now?",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:26:14Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468407",
      "id" : 1460468407,
      "in_reply_to_id" : 1450866270,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPq3",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 94,
      "original_position" : 94,
      "original_start_line" : 93,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1834682376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468407/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:26:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468407",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468434"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:26:19Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468434",
      "id" : 1460468434,
      "in_reply_to_id" : 1450888252,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPrS",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 56,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1834682383,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468434/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:26:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468434",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468510"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468510"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done.\r\n\r\n> Also, it may be worth moving this right peer2 so inbounds and outbounds are grouped\r\n\r\ndidn't follow. i've renamed `peer7` to `peer1` since this is first peer in restarted node. is that what you meant?",
      "commit_id" : "eb8a870603357d12a181d1e9845c561d80e9bded",
      "created_at" : "2024-01-20T14:26:27Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1460468510",
      "id" : 1460468510,
      "in_reply_to_id" : 1450888980,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XDPse",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 114,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1834682400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468510/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-20T14:26:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1460468510",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462241588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462241588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry, I meant right after peer2, referring to grouping the connections in the test by either inbound or outbound.\r\n\r\npeer1 does v2 **from** v2\r\npeer2 does v2 **from** v1\r\npeer3 does  v2 **to** v1\r\n[...] the rest are all x **to** y\r\nand then peer7 goes back to peer1 does v1 **from** v2\r\n\r\nCertainly not a big deal though\r\n",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-22T18:21:01Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462241588",
      "id" : 1462241588,
      "in_reply_to_id" : 1450888980,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XKAk0",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 114,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462241588/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:09:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462241588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462341834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462341834"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "line should be removed now that `supports_v2_p2p` is a property, it would probably throw an AttributeError if it was hit (which it isn't)",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-22T19:49:10Z",
      "diff_hunk" : "@@ -231,12 +231,61 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462341834",
      "id" : 1462341834,
      "line" : 260,
      "node_id" : "PRRC_kwDOABII585XKZDK",
      "original_commit_id" : "885fac3a13786d873b033c03e51d15e158eff3a7",
      "original_line" : 252,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 124,
      "pull_request_review_id" : 1837243116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462341834/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-22T20:32:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462341834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462877634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462877634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c950386eaaf41ec096606de81a3a60b278b156f0\r\nnit: since `v2transport` is named exactly the same in addconnection and as an init flag, perhaps either specify where exactly to see, or have extended description in both places (\"adding v2transport connections requires v2transport init flag to be set.\"). Current version is kinda confusing.",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T08:20:31Z",
      "diff_hunk" : "@@ -401,11 +402,16 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n     CConnman& connman = EnsureConnman(node);\n \n-    const bool success = connman.AddConnection(address, conn_type);\n+    if (use_v2transport && !(connman.GetLocalServices() & NODE_P2P_V2)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Error: v2transport requested but not enabled (see -v2transport)\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462877634",
      "id" : 1462877634,
      "line" : 411,
      "node_id" : "PRRC_kwDOABII585XMb3C",
      "original_commit_id" : "c950386eaaf41ec096606de81a3a60b278b156f0",
      "original_line" : 411,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/rpc/net.cpp",
      "position" : 30,
      "pull_request_review_id" : 1838102663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462877634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T10:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462877634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462899288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462899288"
         }
      },
      "author_association" : "MEMBER",
      "body" : "9b6425ce0fb74b40e12f92b704a41feec23cd754\r\nnit: \"at least one byte\" is confusing... what if it's half-a-byte? Sounds like that would be ignored, but i assume it won't be.",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T08:29:46Z",
      "diff_hunk" : "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462899288",
      "id" : 1462899288,
      "line" : 132,
      "node_id" : "PRRC_kwDOABII585XMhJY",
      "original_commit_id" : "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "original_line" : 132,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 132,
      "pull_request_review_id" : 1838102663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 2,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462899288/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T10:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462899288",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462920200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462920200"
         }
      },
      "author_association" : "MEMBER",
      "body" : "9b6425ce0fb74b40e12f92b704a41feec23cd754\r\n\r\nnit: might be cleaner this way\r\n```\r\n        received_prefix_len = 0\r\n        while received_prefix_len < 16:\r\n            byte = response.read(1)\r\n            # return b\"\" if we need to receive more bytes\r\n            if not byte:\r\n                return received_prefix_len, b\"\"\r\n            received_prefix_len += len(byte)\r\n            if byte != v1_prefix[received_prefix_len - 1]:\r\n                return received_prefix_len, self.generate_keypair_and_garbage()\r\n        # return -1 to decide v1 only after all 16 bytes processed\r\n        return received_prefix_len, -1\r\n```",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T08:47:04Z",
      "diff_hunk" : "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        1. int - length of bytes that were consumed so that recvbuf can be updated\n+        2. bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+                 - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+                 - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return len(self.received_prefix), b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462920200",
      "id" : 1462920200,
      "line" : 147,
      "node_id" : "PRRC_kwDOABII585XMmQI",
      "original_commit_id" : "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "original_line" : 147,
      "original_position" : 146,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 147,
      "pull_request_review_id" : 1838102663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462920200/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T10:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462920200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462949568"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462949568"
         }
      },
      "author_association" : "MEMBER",
      "body" : "9a2050275573eae31c5dc14fefedb612e951d0b8\r\n\r\ndo you mind adding a comment for what happened here?",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T09:10:36Z",
      "diff_hunk" : "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462949568",
      "id" : 1462949568,
      "line" : 308,
      "node_id" : "PRRC_kwDOABII585XMtbA",
      "original_commit_id" : "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "original_line" : 301,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 186,
      "pull_request_review_id" : 1838102663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462949568/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T10:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462949568",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462953624"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462953624"
         }
      },
      "author_association" : "MEMBER",
      "body" : "what does this mean?",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T09:13:37Z",
      "diff_hunk" : "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+\n+                    # v2 P2P messages are read\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    elif msglen == 0:  # need to receive more bytes in recvbuf\n+                        return\n+                    self.recvbuf = self.recvbuf[msglen:]\n+\n+                    assert msg  # application layer messages(which aren't decoy messages) are non-empty\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462953624",
      "id" : 1462953624,
      "line" : 324,
      "node_id" : "PRRC_kwDOABII585XMuaY",
      "original_commit_id" : "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "original_line" : 315,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 202,
      "pull_request_review_id" : 1838102663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462953624/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T10:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462953624",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462964155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462964155"
         }
      },
      "author_association" : "MEMBER",
      "body" : "why `on_connection_send_msg` is not sent here on reconnect (the new condition)?",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T09:21:31Z",
      "diff_hunk" : "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1462964155",
      "id" : 1462964155,
      "line" : 226,
      "node_id" : "PRRC_kwDOABII585XMw-7",
      "original_commit_id" : "125e24a9402950c395fad11ef800be49e6a37589",
      "original_line" : 226,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 89,
      "pull_request_review_id" : 1838102663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462964155/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T10:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1462964155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463495866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463495866"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I wonder if it'd be worth also checking that `len(self.recvbuf) > 15` to avoid calling `v2_handshake` when we potentially don't have enough data to decide whether this a v1 or v2 connection. This potentially will call `v2_handshake` 16 times, and process byte arrays of length from 1..16.\r\n\r\nIn practice I don't think this matters, given the logic never triggers: this happens when the python node is the responder, and the Core node will never send a half-baked `magic_bytes + version` (it may partially happen randomly, but its rather unlikely).\r\n\r\nStill, it feels a small enough change in case this ends up being reused.\r\n",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T15:46:30Z",
      "diff_hunk" : "@@ -205,27 +218,82 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n-        if self.on_connection_send_msg:\n+        # in an inbound connection to the TestNode with P2PConnection as the initiator, [TestNode <---- P2PConnection]\n+        # the initial handshake is sent immediately\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:\n             self.send_message(self.on_connection_send_msg)\n             self.on_connection_send_msg = None  # Never used again\n         self.on_open()\n \n     def connection_lost(self, exc):\n         \"\"\"asyncio callback when a connection is closed.\"\"\"\n-        if exc:\n+        # don't display warning if reconnection needs to be attempted using v1 P2P\n+        if exc and not self.reconnect:\n             logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n         else:\n             logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = None\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+                elif send_handshake_bytes == b\"\":\n+                    return  # only after send_handshake_bytes are sent can `complete_handshake()` be done\n+\n+            # `complete_handshake()` reads the remaining ellswift bytes from recvbuf\n+            # and sends response after deriving shared ECDH secret using received ellswift bytes\n+            length, response = self.v2_state.complete_handshake(BytesIO(self.recvbuf))\n+            self.recvbuf = self.recvbuf[length:]\n+            if response:\n+                self.send_raw_message(response)\n+            else:\n+                return  # only after response is sent can `authenticate_handshake()` be done\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        length, is_mac_auth = self.v2_state.authenticate_handshake(self.recvbuf)\n+        if not is_mac_auth:\n+            raise ValueError(\"invalid v2 mac tag in handshake authentication\")\n+        self.recvbuf = self.recvbuf[length:]\n+        if self.v2_state.tried_v2_handshake and self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None\n+\n     # Socket read methods\n \n     def data_received(self, t):\n         \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n+            if self.supports_v2_p2p and not self.v2_state.tried_v2_handshake:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463495866",
      "id" : 1463495866,
      "line" : 295,
      "node_id" : "PRRC_kwDOABII585XOyy6",
      "original_commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "original_line" : 295,
      "original_position" : 159,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 159,
      "pull_request_review_id" : 1829978188,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463495866/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:20:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463495866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463533897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463533897"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes! This reads much clearer now :)",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T16:11:35Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463533897",
      "id" : 1463533897,
      "in_reply_to_id" : 1450866270,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XO8FJ",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 94,
      "original_position" : 94,
      "original_start_line" : 93,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1839218378,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463533897/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:11:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463533897",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463600444"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463600444"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "i took the [text from the BIP](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#cite_note-handshake_progress_19) here. On the python side, [`data_received()` asyncio function](https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received) only gets called when a bytes object is received.\r\n\r\n(thinking about the c++ side)",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T16:43:44Z",
      "diff_hunk" : "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463600444",
      "id" : 1463600444,
      "in_reply_to_id" : 1462899288,
      "line" : 132,
      "node_id" : "PRRC_kwDOABII585XPMU8",
      "original_commit_id" : "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "original_line" : 132,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 132,
      "pull_request_review_id" : 1839322405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463600444/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:43:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463600444",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463620264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463620264"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`respond_v2_handshake()` is supposed keep reading bytes from `bitcoind` and shoot out ellswift bytes when first mismatch from 16 bytes `V1_PREFIX` happens. Let's say the mismatch happens after reading 3 bytes - we still need to store the 3 bytes read somewhere (currently stored in `self.received_prefix`) since it's actually the first 3 bytes of ellswift which `bitcoind` was sending us.\r\n\r\nwe need this 3 bytes later in `complete_handshake()` to read the remaining 64-3 bytes and to compute ellswift which bitcoind sent us. ",
      "commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "created_at" : "2024-01-23T16:55:01Z",
      "diff_hunk" : "@@ -4,17 +4,285 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n \n-from .crypto.ellswift import ellswift_ecdh_xonly\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n \n class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+        self.found_garbage_terminator = False\n+\n     @staticmethod\n     def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n-        \"\"\"Compute BIP324 shared secret.\"\"\"\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n         ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n         if initiating:\n             # Initiating, place our public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n         else:\n             # Responding, place their public key encoding first.\n             return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        1. int - length of bytes that were consumed so that recvbuf can be updated\n+        2. bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+                 - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+                 - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return len(self.received_prefix), b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1463620264",
      "id" : 1463620264,
      "in_reply_to_id" : 1462920200,
      "line" : 147,
      "node_id" : "PRRC_kwDOABII585XPRKo",
      "original_commit_id" : "9b6425ce0fb74b40e12f92b704a41feec23cd754",
      "original_line" : 147,
      "original_position" : 146,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 147,
      "pull_request_review_id" : 1839354213,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463620264/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-23T16:55:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1463620264",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464318846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464318846"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(originally because `on_connection_send_msg` would be end up being unused in v2 connection anyways and wanted to keep the `on_connection_send_msg` send during the v1 reconnection phase.)\r\n\r\ninteresting question! you're talking about a less common scenario where initiator node is preparing for v2 connection thinking responder node is v2 but v1 version message from responder node gets sent before v2 ellswift bytes from initiator node. if this happens the initiator node wouldn't attempt a reconnection using v1 since it's [receive buffer is not empty](https://github.com/bitcoin/bitcoin/blob/e69796c79c0aa202087a13ba62d9fbcc1c8754d4/src/net.cpp#L1525).",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T05:17:01Z",
      "diff_hunk" : "@@ -221,14 +223,15 @@ def connection_made(self, transport):\n         if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n             send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n             self.send_raw_message(send_handshake_bytes)\n-        if self.on_connection_send_msg and not self.supports_v2_p2p:\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464318846",
      "id" : 1464318846,
      "in_reply_to_id" : 1462964155,
      "line" : 226,
      "node_id" : "PRRC_kwDOABII585XR7t-",
      "original_commit_id" : "125e24a9402950c395fad11ef800be49e6a37589",
      "original_line" : 226,
      "original_position" : 24,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 89,
      "pull_request_review_id" : 1840432934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464318846/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T05:17:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464318846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464356180"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464356180"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "hmm other than the ellswift bytes, `v2_handshake()` also needs to read garbage bytes (could be received as separate chunks with size < 16 bytes) and other things like garbage terminator, decoy messages and version packet. i'm leaning towards keeping the interface generic and processing as we receive bytes.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:19:46Z",
      "diff_hunk" : "@@ -205,27 +218,82 @@ def connection_made(self, transport):\n         assert not self._transport\n         logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = transport\n-        if self.on_connection_send_msg:\n+        # in an inbound connection to the TestNode with P2PConnection as the initiator, [TestNode <---- P2PConnection]\n+        # the initial handshake is sent immediately\n+        if self.supports_v2_p2p and self.v2_state.initiating and not self.v2_state.tried_v2_handshake:\n+            send_handshake_bytes = self.v2_state.initiate_v2_handshake()\n+            self.send_raw_message(send_handshake_bytes)\n+        if self.on_connection_send_msg and not self.supports_v2_p2p and not self.reconnect:\n             self.send_message(self.on_connection_send_msg)\n             self.on_connection_send_msg = None  # Never used again\n         self.on_open()\n \n     def connection_lost(self, exc):\n         \"\"\"asyncio callback when a connection is closed.\"\"\"\n-        if exc:\n+        # don't display warning if reconnection needs to be attempted using v1 P2P\n+        if exc and not self.reconnect:\n             logger.warning(\"Connection lost to {}:{} due to {}\".format(self.dstaddr, self.dstport, exc))\n         else:\n             logger.debug(\"Closed connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self._transport = None\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False\n+                    self.v2_state = None\n+                    return\n+                elif send_handshake_bytes:\n+                    self.send_raw_message(send_handshake_bytes)\n+                elif send_handshake_bytes == b\"\":\n+                    return  # only after send_handshake_bytes are sent can `complete_handshake()` be done\n+\n+            # `complete_handshake()` reads the remaining ellswift bytes from recvbuf\n+            # and sends response after deriving shared ECDH secret using received ellswift bytes\n+            length, response = self.v2_state.complete_handshake(BytesIO(self.recvbuf))\n+            self.recvbuf = self.recvbuf[length:]\n+            if response:\n+                self.send_raw_message(response)\n+            else:\n+                return  # only after response is sent can `authenticate_handshake()` be done\n+\n+        # `self.v2_state.peer` is instantiated only after shared ECDH secret/BIP324 derived keys and ciphers\n+        # is derived in `complete_handshake()`.\n+        # so `authenticate_handshake()` which uses the BIP324 derived ciphers gets called after `complete_handshake()`.\n+        assert self.v2_state.peer\n+        length, is_mac_auth = self.v2_state.authenticate_handshake(self.recvbuf)\n+        if not is_mac_auth:\n+            raise ValueError(\"invalid v2 mac tag in handshake authentication\")\n+        self.recvbuf = self.recvbuf[length:]\n+        if self.v2_state.tried_v2_handshake and self.on_connection_send_msg:\n+            self.send_message(self.on_connection_send_msg)\n+            self.on_connection_send_msg = None\n+\n     # Socket read methods\n \n     def data_received(self, t):\n         \"\"\"asyncio callback when data is read from the socket.\"\"\"\n         if len(t) > 0:\n             self.recvbuf += t\n+            if self.supports_v2_p2p and not self.v2_state.tried_v2_handshake:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464356180",
      "id" : 1464356180,
      "in_reply_to_id" : 1463495866,
      "line" : 294,
      "node_id" : "PRRC_kwDOABII585XSE1U",
      "original_commit_id" : "a5e0d0b3abc70b7f8501743a0787880a32eb5b93",
      "original_line" : 294,
      "original_position" : 159,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : 159,
      "pull_request_review_id" : 1840489048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464356180/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:19:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464356180",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464363550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464363550"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "oh that way! the last test was for v1 behaviour and peer7 needed a v1 `TestNode` while all the others needed a v2 `TestNode` which is why it was kept separately in the end.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:30:41Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test encrypted v2 p2p proposed in BIP 324\n+\"\"\"\n+from test_framework.blocktools import (\n+    create_block,\n+    create_coinbase,\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    check_node_connections,\n+)\n+from test_framework.crypto.chacha20 import REKEY_INTERVAL\n+\n+\n+class P2PEncrypted(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-v2transport=1\"], [\"-v2transport=1\"]]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+\n+    def generate_blocks(self, node, number):\n+        test_blocks = []\n+        last_block = node.getbestblockhash()\n+        tip = int(last_block, 16)\n+        tipheight = node.getblockcount()\n+        last_block_time = node.getblock(last_block)['time']\n+        for _ in range(number):\n+            # Create some blocks\n+            block = create_block(tip, create_coinbase(tipheight + 1), last_block_time + 1)\n+            block.solve()\n+            test_blocks.append(block)\n+            tip = block.sha256\n+            tipheight += 1\n+            last_block_time += 1\n+        return test_blocks\n+\n+    def create_test_block(self, txs):\n+        block = create_block(self.tip, create_coinbase(self.tipheight + 1), self.last_block_time + 600, txlist=txs)\n+        block.solve()\n+        return block\n+\n+    def run_test(self):\n+        node0, node1 = self.nodes[0], self.nodes[1]\n+        self.log.info(\"Check inbound connections to v2 TestNode from v2 P2PConnection is v2\")\n+        peer1 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=True)\n+        assert peer1.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check inbound connection to v2 TestNode from v1 P2PConnection is v1\")\n+        peer2 = node0.add_p2p_connection(P2PInterface(), wait_for_verack=True, supports_v2_p2p=False)\n+        assert not peer2.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v1 P2PConnection advertised as v1 is v1\")\n+        peer3 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, supports_v2_p2p=False, advertise_v2_p2p=False)\n+        assert not peer3.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v1\")\n+\n+        self.log.info(\"Check outbound connection from v2 TestNode to v2 P2PConnection advertised as v2 is v2\")\n+        peer5 = node0.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, supports_v2_p2p=True, advertise_v2_p2p=True)\n+        assert peer5.supports_v2_p2p\n+        assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+        self.log.info(\"Check if version is sent and verack is received in inbound/outbound connections\")\n+        assert_equal(len(node0.getpeerinfo()), 4)  # check if above 4 connections are present in node0's getpeerinfo()\n+        for peer in node0.getpeerinfo():\n+            assert_greater_than(peer['bytessent_per_msg']['version'], 0)\n+            assert_greater_than(peer['bytesrecv_per_msg']['verack'], 0)\n+\n+        self.log.info(\"Testing whether blocks propagate - check if tips sync when number of blocks >= REKEY_INTERVAL\")\n+        # tests whether rekeying(which happens every REKEY_INTERVAL packets) works correctly\n+        test_blocks = self.generate_blocks(node0, REKEY_INTERVAL+1)\n+\n+        for i in range(2):\n+            # Add v2 P2P connection to node0\n+            peer6 = node0.add_p2p_connection(P2PDataStore(), supports_v2_p2p=True)\n+            assert peer6.supports_v2_p2p\n+            assert_equal(node0.getpeerinfo()[-1][\"transport_protocol_type\"], \"v2\")\n+\n+            if i:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly)\n+                # gets blocks produced by node0's p2p connection\n+                self.log.info(\"Check if blocks produced by node0's p2p connection is received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=True) # node0's tip advances\n+            else:\n+                # check if node1 connected to node0 (but not to node0's p2p connection directly) and node0 - both\n+                # do not get blocks produced by node0's p2p connection if the messages sent are decoys\n+                self.log.info(\"Check if blocks produced by node0's p2p connection sent as decoys aren't received by node0\")\n+                peer6.send_blocks_and_test(test_blocks, node0, success=False, is_decoy=True) # node0's tip doesn't advance\n+            # Connect node0 and node1 using v2\n+            self.connect_nodes(0, 1, peer_advertises_v2=True)\n+            self.log.info(\"Wait for node1 to receive all the blocks from node0\")\n+            self.sync_all()\n+            self.log.info(\"Make sure node0 and node1 have same block tips\")\n+            assert_equal(node0.getbestblockhash(), node1.getbestblockhash())\n+\n+            self.disconnect_nodes(0, 1)\n+\n+        self.log.info(\"Check the connections opened as expected\")\n+        check_node_connections(node=node0, num_in=4, num_out=2)\n+\n+        self.log.info(\"Check inbound connections to v1 TestNode from v2 P2PConnection is v1\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464363550",
      "id" : 1464363550,
      "in_reply_to_id" : 1450888980,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSGoe",
      "original_commit_id" : "c79372470c6949f0ac1e19f94a3d3ca670370af3",
      "original_line" : 114,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "test/functional/p2p_v2_encrypted.py",
      "position" : null,
      "pull_request_review_id" : 1840500869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464363550/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:30:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464363550",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464367456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367456"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good catch! done.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:35:35Z",
      "diff_hunk" : "@@ -231,12 +231,61 @@ def connection_lost(self, exc):\n         self.recvbuf = b\"\"\n         self.on_close()\n \n+    # v2 handshake method\n+    def v2_handshake(self):\n+        \"\"\"v2 handshake performed before P2P messages are exchanged (see BIP324). P2PConnection is the initiator\n+        (in inbound connections to TestNode) and the responder (in outbound connections from TestNode).\n+        Performed by:\n+            * initiator using `initiate_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+            * responder using `respond_v2_handshake()`, `complete_handshake()` and `authenticate_handshake()`\n+\n+        `initiate_v2_handshake()` is immediately done by the initiator when the connection is established in\n+        `connection_made()`. The rest of the initial v2 handshake functions are handled here.\n+        \"\"\"\n+        if not self.v2_state.peer:\n+            if not self.v2_state.initiating and not self.v2_state.sent_garbage:\n+                # if the responder hasn't sent garbage yet, the responder is still reading ellswift bytes\n+                # reads ellswift bytes till the first mismatch from 12 bytes V1_PREFIX\n+                length, send_handshake_bytes = self.v2_state.respond_v2_handshake(BytesIO(self.recvbuf))\n+                self.recvbuf = self.recvbuf[length:]\n+                if send_handshake_bytes == -1:\n+                    self.supports_v2_p2p = False",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464367456",
      "id" : 1464367456,
      "in_reply_to_id" : 1462341834,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSHlg",
      "original_commit_id" : "885fac3a13786d873b033c03e51d15e158eff3a7",
      "original_line" : 252,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1840508287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367456/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:35:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367456",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464367790"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367790"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done. liked the simpler language.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:36:07Z",
      "diff_hunk" : "@@ -401,11 +402,16 @@ static RPCHelpMan addconnection()\n     } else {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, self.ToString());\n     }\n+    bool use_v2transport = !request.params[2].isNull() && request.params[2].get_bool();\n \n     NodeContext& node = EnsureAnyNodeContext(request.context);\n     CConnman& connman = EnsureConnman(node);\n \n-    const bool success = connman.AddConnection(address, conn_type);\n+    if (use_v2transport && !(connman.GetLocalServices() & NODE_P2P_V2)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Error: v2transport requested but not enabled (see -v2transport)\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464367790",
      "id" : 1464367790,
      "in_reply_to_id" : 1462877634,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSHqu",
      "original_commit_id" : "c950386eaaf41ec096606de81a3a60b278b156f0",
      "original_line" : 411,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/rpc/net.cpp",
      "position" : null,
      "pull_request_review_id" : 1840508851,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367790/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:36:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464367790",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464368898"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464368898"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "good find! replaced it with an `else` pathway in `data_received()`. this was kept to not perform parsing/deserialising of P2P messages inside `_on_data()` in case `v2_handshake()` wasn't over.\r\n\r\ndone.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:37:42Z",
      "diff_hunk" : "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464368898",
      "id" : 1464368898,
      "in_reply_to_id" : 1462949568,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSH8C",
      "original_commit_id" : "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "original_line" : 301,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1840510614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464368898/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:37:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464368898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464371637"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464371637"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "added more comments. meant it as the [ASCII message type](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#v2-bitcoin-p2p-message-structure) like in v1.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:40:40Z",
      "diff_hunk" : "@@ -296,23 +297,49 @@ def _on_data(self):\n         the on_message callback for processing.\"\"\"\n         try:\n             while True:\n-                if len(self.recvbuf) < 4:\n-                    return\n-                if self.recvbuf[:4] != self.magic_bytes:\n-                    raise ValueError(\"magic bytes mismatch: {} != {}\".format(repr(self.magic_bytes), repr(self.recvbuf)))\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n-                    return\n-                msgtype = self.recvbuf[4:4+12].split(b\"\\x00\", 1)[0]\n-                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n-                checksum = self.recvbuf[4+12+4:4+12+4+4]\n-                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n-                    return\n-                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n-                th = sha256(msg)\n-                h = sha256(th)\n-                if checksum != h[:4]:\n-                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n-                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+                if self.supports_v2_p2p:\n+                    if not self.v2_state.tried_v2_handshake:\n+                        return\n+\n+                    # v2 P2P messages are read\n+                    msglen, msg = self.v2_state.v2_receive_packet(self.recvbuf)\n+                    if msglen == -1:\n+                        raise ValueError(\"invalid v2 mac tag \" + repr(self.recvbuf))\n+                    elif msglen == 0:  # need to receive more bytes in recvbuf\n+                        return\n+                    self.recvbuf = self.recvbuf[msglen:]\n+\n+                    assert msg  # application layer messages(which aren't decoy messages) are non-empty\n+                    shortid = msg[0]\n+                    if shortid == 0:\n+                        # a string command",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464371637",
      "id" : 1464371637,
      "in_reply_to_id" : 1462953624,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSIm1",
      "original_commit_id" : "9a2050275573eae31c5dc14fefedb612e951d0b8",
      "original_line" : 315,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/p2p.py",
      "position" : null,
      "pull_request_review_id" : 1840515494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464371637/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:40:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464371637",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464372562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372562"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "true! removed.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:41:26Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464372562",
      "id" : 1464372562,
      "in_reply_to_id" : 1457621863,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSI1S",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 232,
      "original_position" : 218,
      "original_start_line" : 217,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1840517253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372562/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:41:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372562",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464372887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372887"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice! done.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:41:56Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers\n+        self.privkey_ours = None\n+        self.ellswift_ours = None\n+        self.sent_garbage = b\"\"\n+        self.received_garbage = b\"\"\n+        self.received_prefix = b\"\"  # received ellswift bytes till the first mismatch from 16 bytes v1_prefix\n+        self.tried_v2_handshake = False  # True when the initial handshake is over\n+        # stores length of packet contents to detect whether first 3 bytes (which contains length of packet contents)\n+        # has been decrypted. set to -1 if decryption hasn't been done yet.\n+        self.contents_len = -1\n+\n+    @staticmethod\n+    def v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n+        \"\"\"Compute BIP324 shared secret.\n+\n+        Returns:\n+        bytes - BIP324 shared secret\n+        \"\"\"\n+        ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n+        if initiating:\n+            # Initiating, place our public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n+        else:\n+            # Responding, place their public key encoding first.\n+            return TaggedHash(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n+\n+    def generate_keypair_and_garbage(self):\n+        \"\"\"Generates ellswift keypair and 4095 bytes garbage at max\"\"\"\n+        self.privkey_ours, self.ellswift_ours = ellswift_create()\n+        garbage_len = random.randrange(MAX_GARBAGE_LEN + 1)\n+        self.sent_garbage = random.randbytes(garbage_len)\n+        logger.debug(f\"sending {garbage_len} bytes of garbage data\")\n+        return self.ellswift_ours + self.sent_garbage\n+\n+    def initiate_v2_handshake(self):\n+        \"\"\"Initiator begins the v2 handshake by sending its ellswift bytes and garbage\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as an initiator\n+        \"\"\"\n+        return self.generate_keypair_and_garbage()\n+\n+    def respond_v2_handshake(self, response):\n+        \"\"\"Responder begins the v2 handshake by sending its ellswift bytes and garbage. However, the responder\n+        sends this after having received at least one byte that mismatches 16-byte v1_prefix.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when starting the v2 handshake as a responder.\n+              - returns b\"\" if more bytes need to be received before we can respond and start the v2 handshake.\n+              - returns -1 to downgrade the connection to v1 P2P.\n+        \"\"\"\n+        v1_prefix = MAGIC_BYTES[self.net] + b'version\\x00\\x00\\x00\\x00\\x00'\n+        while len(self.received_prefix) < 16:\n+            byte = response.read(1)\n+            # return b\"\" if we need to receive more bytes\n+            if not byte:\n+                return b\"\"\n+            self.received_prefix += byte\n+            if self.received_prefix[-1] != v1_prefix[len(self.received_prefix) - 1]:\n+                return self.generate_keypair_and_garbage()\n+        # return -1 to decide v1 only after all 16 bytes processed\n+        return -1\n+\n+    def complete_handshake(self, response):\n+        \"\"\" Instantiates the encrypted transport and\n+        sends garbage terminator + optional decoy packets + transport version packet.\n+        Done by both initiator and responder.\n+\n+        Returns:\n+        bytes - bytes to be sent to the peer when completing the v2 handshake\n+        \"\"\"\n+        received_prefix = b'' if self.initiating else self.received_prefix\n+        ellswift_theirs = received_prefix + response.read(64 - len(received_prefix))\n+        ecdh_secret = self.v2_ecdh(self.privkey_ours, ellswift_theirs, self.ellswift_ours, self.initiating)\n+        self.initialize_v2_transport(ecdh_secret)\n+        # Send garbage terminator\n+        msg_to_send = self.peer['send_garbage_terminator']\n+        # Optionally send decoy packets after garbage terminator.\n+        aad = self.sent_garbage\n+        for decoy_content_len in [random.randint(1, 100) for _ in range(random.randint(0, 10))]:\n+            msg_to_send += self.v2_enc_packet(decoy_content_len * b'\\x00', aad=aad, ignore=True)\n+            aad = b''\n+        # Send version packet.\n+        msg_to_send += self.v2_enc_packet(TRANSPORT_VERSION, aad=aad)\n+        return msg_to_send\n+\n+    def authenticate_handshake(self, response):\n+        \"\"\" Ensures that the received optional decoy packets and transport version packet are authenticated.\n+        Marks the v2 handshake as complete. Done by both initiator and responder.\n+\n+        Returns:\n+        1. int - length of bytes that were processed so that recvbuf can be updated\n+        2. bool - True if the authentication was successful/more bytes need to be received and False otherwise\n+        \"\"\"\n+        received_garbage = response[:16]\n+        response = response[16:]\n+        processed_length = len(received_garbage)\n+        for i in range(MAX_GARBAGE_LEN + 1):\n+            if received_garbage[-16:] == self.peer['recv_garbage_terminator']:\n+                # Receive, decode, and ignore version packet.\n+                # This includes skipping decoys and authenticating the received garbage.\n+                aad = received_garbage[:-16]\n+                while not self.tried_v2_handshake:\n+                    length, contents = self.v2_receive_packet(response, aad=aad)\n+                    aad = b\"\"\n+                    if length == -1:\n+                        return processed_length, False\n+                    elif length == 0:\n+                        return 0, True\n+                    processed_length += length\n+                    # decoy packets have contents = None. v2 handshake is complete only when version packet\n+                    # (can be empty with contents = b\"\") with contents != None is received.\n+                    if contents is not None:\n+                        self.tried_v2_handshake = True\n+                        return processed_length, True\n+                    response = response[length:]\n+            else:\n+                # don't update recvbuf since more bytes need to be received\n+                if len(response) == 0:\n+                    return 0, True\n+                received_garbage += response[:1]\n+                processed_length += 1\n+                response = response[1:]\n+        # disconnect since garbage terminator was not seen after 4 KiB of garbage.\n+        return processed_length, False\n+\n+    def initialize_v2_transport(self, ecdh_secret):\n+        \"\"\"Sets the peer object with various BIP324 derived keys and ciphers.\"\"\"\n+        peer = {}\n+        salt = b'bitcoin_v2_shared_secret' + MAGIC_BYTES[self.net]\n+        for name, length in (('initiator_L', 32), ('initiator_P', 32), ('responder_L', 32), ('responder_P', 32),\n+                             ('garbage_terminators', 32), ('session_id', 32)):\n+            peer[name] = hkdf_sha256(salt=salt, ikm=ecdh_secret, info=name.encode('utf-8'), length=length)\n+        peer['initiator_garbage_terminator'] = peer['garbage_terminators'][:16]\n+        peer['responder_garbage_terminator'] = peer['garbage_terminators'][16:]\n+        del peer['garbage_terminators']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464372887",
      "id" : 1464372887,
      "in_reply_to_id" : 1457652467,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585XSI6X",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 236,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : null,
      "pull_request_review_id" : 1840517782,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372887/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:41:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464372887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464375410"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464375410"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "right, not much of a difference - leaving it as a follow up if desired.",
      "commit_id" : "fa4d9d5b39d5652de1d83564f19b1a0749863b16",
      "created_at" : "2024-01-24T06:45:25Z",
      "diff_hunk" : "@@ -0,0 +1,283 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Class for v2 P2P protocol (see BIP 324)\"\"\"\n+\n+import logging\n+import random\n+\n+from .crypto.bip324_cipher import FSChaCha20Poly1305\n+from .crypto.chacha20 import FSChaCha20\n+from .crypto.ellswift import ellswift_create, ellswift_ecdh_xonly\n+from .crypto.hkdf import hkdf_sha256\n+from .key import TaggedHash\n+from .messages import MAGIC_BYTES\n+\n+logger = logging.getLogger(\"TestFramework.v2_p2p\")\n+\n+CHACHA20POLY1305_EXPANSION = 16\n+HEADER_LEN = 1\n+IGNORE_BIT_POS = 7\n+LENGTH_FIELD_LEN = 3\n+MAX_GARBAGE_LEN = 4095\n+TRANSPORT_VERSION = b''\n+\n+SHORTID = {\n+    1: b\"addr\",\n+    2: b\"block\",\n+    3: b\"blocktxn\",\n+    4: b\"cmpctblock\",\n+    5: b\"feefilter\",\n+    6: b\"filteradd\",\n+    7: b\"filterclear\",\n+    8: b\"filterload\",\n+    9: b\"getblocks\",\n+    10: b\"getblocktxn\",\n+    11: b\"getdata\",\n+    12: b\"getheaders\",\n+    13: b\"headers\",\n+    14: b\"inv\",\n+    15: b\"mempool\",\n+    16: b\"merkleblock\",\n+    17: b\"notfound\",\n+    18: b\"ping\",\n+    19: b\"pong\",\n+    20: b\"sendcmpct\",\n+    21: b\"tx\",\n+    22: b\"getcfilters\",\n+    23: b\"cfilter\",\n+    24: b\"getcfheaders\",\n+    25: b\"cfheaders\",\n+    26: b\"getcfcheckpt\",\n+    27: b\"cfcheckpt\",\n+    28: b\"addrv2\",\n+}\n+\n+# Dictionary which contains short message type ID for the P2P message\n+MSGTYPE_TO_SHORTID = {msgtype: shortid for shortid, msgtype in SHORTID.items()}\n+\n+\n+class EncryptedP2PState:\n+    \"\"\"A class for managing the state when v2 P2P protocol is used. Performs initial v2 handshake and encrypts/decrypts\n+    P2P messages. P2PConnection uses an object of this class.\n+\n+\n+    Args:\n+        initiating (bool): defines whether the P2PConnection is an initiator or responder.\n+            - initiating = True for inbound connections in the test framework   [TestNode <------- P2PConnection]\n+            - initiating = False for outbound connections in the test framework [TestNode -------> P2PConnection]\n+\n+        net (string): chain used (regtest, signet etc..)\n+\n+    Methods:\n+        perform an advanced form of diffie-hellman handshake to instantiate the encrypted transport. before exchanging\n+        any P2P messages, 2 nodes perform this handshake in order to determine a shared secret that is unique to both\n+        of them and use it to derive keys to encrypt/decrypt P2P messages.\n+            - initial v2 handshakes is performed by: (see BIP324 section #overall-handshake-pseudocode)\n+                1. initiator using initiate_v2_handshake(), complete_handshake() and authenticate_handshake()\n+                2. responder using respond_v2_handshake(), complete_handshake() and authenticate_handshake()\n+            - initialize_v2_transport() sets various BIP324 derived keys and ciphers.\n+\n+        encrypt/decrypt v2 P2P messages using v2_enc_packet() and v2_receive_packet().\n+    \"\"\"\n+    def __init__(self, *, initiating, net):\n+        self.initiating = initiating  # True if initiator\n+        self.net = net\n+        self.peer = {}  # object with various BIP324 derived keys and ciphers",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24748#discussion_r1464375410",
      "id" : 1464375410,
      "in_reply_to_id" : 1457677043,
      "line" : 87,
      "node_id" : "PRRC_kwDOABII585XSJhy",
      "original_commit_id" : "42203f84bba7e4ba206c9f951c3f4b6922a44f81",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/v2_p2p.py",
      "position" : 87,
      "pull_request_review_id" : 1840522719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24748",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464375410/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-24T06:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1464375410",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   }
]
