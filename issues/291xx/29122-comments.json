[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29122).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [tdb3](https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1939902686) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n",
      "created_at" : "2023-12-20T16:00:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1864737433",
      "id" : 1864737433,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585vJaKZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1864737433/reactions"
      },
      "updated_at" : "2024-02-13T00:41:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1864737433",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "While the tests seem to run fine, I noticed a warning that appears every now and then:\r\n\r\n```\r\nTestFramework.p2p (WARNING): Connection lost to 0:0 due to [Errno 54] Connection reset by peer\r\n```\r\n\r\nI'm not sure if something unintended is happening under the hood. Disconnections are expected, but it's our node who is supposed to trigger them, so maybe I'm missing something.",
      "created_at" : "2023-12-20T16:02:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1864741013",
      "id" : 1864741013,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585vJbCV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1864741013/reactions"
      },
      "updated_at" : "2023-12-20T16:02:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1864741013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1434889375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1434889375"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've spent a ridiculous amount of time understanding what's going on here, and I'm still far from being 100% sure. Perhaps if you touch this comment, you can expand it even further? E.g., connecting to each of the conditions in `else if`",
      "commit_id" : "9ba568c816794698507793a7c1d2a9935bb269b2",
      "created_at" : "2023-12-22T09:34:52Z",
      "diff_hunk" : "@@ -5098,9 +5098,10 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n                 state.m_chain_sync.m_sent_getheaders = false;\n             }\n         } else if (state.m_chain_sync.m_timeout == 0s || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n-            // Our best block known by this peer is behind our tip, and we're either noticing\n-            // that for the first time, OR this peer was able to catch up to some earlier point\n-            // where we checked against our tip.\n+            // Either:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1434889375",
      "id" : 1434889375,
      "line" : 5101,
      "node_id" : "PRRC_kwDOABII585Vhqyf",
      "original_commit_id" : "9ba568c816794698507793a7c1d2a9935bb269b2",
      "original_line" : 5101,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 7,
      "pull_request_review_id" : 1794219517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1434889375/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-22T09:34:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1434889375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1435164703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435164703"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like I'm not the only one who took a minute to get this ð \r\n\r\nI wouldn't mind expanding the comment if there is am overall agreement that it is incomplete",
      "commit_id" : "9ba568c816794698507793a7c1d2a9935bb269b2",
      "created_at" : "2023-12-22T15:32:47Z",
      "diff_hunk" : "@@ -5098,9 +5098,10 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n                 state.m_chain_sync.m_sent_getheaders = false;\n             }\n         } else if (state.m_chain_sync.m_timeout == 0s || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n-            // Our best block known by this peer is behind our tip, and we're either noticing\n-            // that for the first time, OR this peer was able to catch up to some earlier point\n-            // where we checked against our tip.\n+            // Either:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1435164703",
      "id" : 1435164703,
      "in_reply_to_id" : 1434889375,
      "line" : 5101,
      "node_id" : "PRRC_kwDOABII585ViuAf",
      "original_commit_id" : "9ba568c816794698507793a7c1d2a9935bb269b2",
      "original_line" : 5101,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 7,
      "pull_request_review_id" : 1794642629,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435164703/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-12-22T15:32:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1435164703",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1440804107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440804107"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Rebased and updated the comment. I also extended the test slightly to cover all possible cases",
      "commit_id" : "1444a261a7fa4ed9ac54957468a2ab03c2b3a13d",
      "created_at" : "2024-01-03T18:48:12Z",
      "diff_hunk" : "@@ -5098,9 +5098,10 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n                 state.m_chain_sync.m_sent_getheaders = false;\n             }\n         } else if (state.m_chain_sync.m_timeout == 0s || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n-            // Our best block known by this peer is behind our tip, and we're either noticing\n-            // that for the first time, OR this peer was able to catch up to some earlier point\n-            // where we checked against our tip.\n+            // Either:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1440804107",
      "id" : 1440804107,
      "in_reply_to_id" : 1434889375,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585V4O0L",
      "original_commit_id" : "9ba568c816794698507793a7c1d2a9935bb269b2",
      "original_line" : 5101,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 1802898789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440804107/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-01-03T18:48:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440804107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased to fix CI",
      "created_at" : "2024-01-29T22:06:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1915658857",
      "id" : 1915658857,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585yLqJp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1915658857/reactions"
      },
      "updated_at" : "2024-01-29T22:06:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1915658857",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased. This has failed CI once when waiting for the disconnection after:\r\n\r\n```\r\ncur_mock_time += (HEADERS_RESPONSE_TIME + 1)\r\n```\r\nI've tried to reproduce it but I cannot in my local setup, the only thing that comes to mind is that mock time may be too close to the timeout (only one second ahead), so I gave it a delta of 10 seconds instead.\r\n\r\nPS: For context, you can check the failure here: https://cirrus-ci.com/task/4624744360706048?logs=ci#L6520. See how the peer is given the final notice by sending a getheaders message, but the check is performed before the peer gets disconnected. \r\n",
      "created_at" : "2024-02-06T14:55:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1929956244",
      "id" : 1929956244,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585zCMuU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1929956244/reactions"
      },
      "updated_at" : "2024-02-06T14:59:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1929956244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485367696"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485367696"
         }
      },
      "author_association" : "NONE",
      "body" : "I could be missing something, but a test case covering the reset of eviction timeout when an outbound peer sends us a valid block with more chainwork (i.e. the timeout set to 0 to prevent eviction, and m_work_header/m_sent_getheaders also reinitialized) was not observed.  Do you think it's worth adding?",
      "commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "created_at" : "2024-02-10T23:44:44Z",
      "diff_hunk" : "@@ -5132,16 +5132,19 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n         if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485367696",
      "id" : 1485367696,
      "line" : 5134,
      "node_id" : "PRRC_kwDOABII585YiOmQ",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 5134,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 3,
      "pull_request_review_id" : 1874277464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485367696/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-11T00:09:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485367696",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485370601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485370601"
         }
      },
      "author_association" : "NONE",
      "body" : "Added notes below to provide insight into what was reviewed:\r\n\r\nIf eviction does not occur when it should, then `wait_for_disconnect()` will raise (AssertionError, originally from `wait_until_helper_internal()`).  Confirmed by temporarily setting `cur_mock_time` to a value significantly lower than CHAIN_SYNC_TIMEOUT.\r\n\r\nSimilarly, if unexpected eviction occurs (e.g. in the \"keep catching up\" case), then `send_and_ping()` or `sync_with_ping()` will raise IOError (`from send_raw_message()`).  Confirmed by temporarily inserting a call to `disconnect_p2ps()`.\r\n",
      "commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "created_at" : "2024-02-10T23:51:51Z",
      "diff_hunk" : "@@ -122,6 +129,178 @@ def run_test(self):\n         self.log.debug(\"{} protected peers: {}\".format(len(protected_peers), protected_peers))\n         assert evicted_peers[0] not in protected_peers\n \n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_unprotected(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485370601",
      "id" : 1485370601,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII585YiPTp",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 134,
      "original_position" : 45,
      "original_start_line" : null,
      "path" : "test/functional/p2p_eviction.py",
      "position" : 45,
      "pull_request_review_id" : 1874277464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485370601/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-11T00:06:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485370601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485374401"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485374401"
         }
      },
      "author_association" : "NONE",
      "body" : "Added notes below to provide insight into what was reviewed:\r\n\r\nIn `test_outbound_eviction_protected()` if unexpected eviction occurs (i.e. the P2P connection is no longer present), then `sync_with_ping()` will raise (`IOError('Not connected')`, causing the test to fail.  Moved node.disconnect_p2ps() above the last test_node.sync_with_ping() call and, as expected, this occurred.\r\n\r\nnit: The heading comment in the `test_outbound_eviction_protected()` omits that a protected peer is also non-block-only, but this is implicit in the call to `add_outbound_p2p_connection()` using `outbound-full-relay` as the connection_type.\r\n\r\nnet_processing.cpp:\r\n```\r\nA peer is marked as protected if all of these are true:\r\n - its connection type is IsBlockOnlyConn() == false\r\n - it gave us a valid connecting header\r\n - we haven't reached MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT yet\r\n - its chain tip has at least as much work as ours\r\n```\r\n",
      "commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "created_at" : "2024-02-11T00:00:52Z",
      "diff_hunk" : "@@ -122,6 +129,178 @@ def run_test(self):\n         self.log.debug(\"{} protected peers: {}\".format(len(protected_peers), protected_peers))\n         assert evicted_peers[0] not in protected_peers\n \n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+        test_node.sync_with_ping()\n+        self.log.info(\"Keep catching up with the old tip and check that we are not evicted\")\n+        for _ in range(10):\n+            # Advance time but not enough to evict the peer\n+            best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+            cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+            node.setmocktime(cur_mock_time)\n+\n+            # Send a header with the old tip\n+            headers_message = msg_headers()\n+            headers_message.headers = [tip_header]\n+            test_node.send_and_ping(headers_message)\n+            tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+\n+            # Check that we are not evicted\n+            cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+            node.setmocktime(cur_mock_time)\n+            test_node.sync_with_ping()\n+\n+        self.log.info(\"Create an outbound connection and take some time to catch up, but do it in time\")\n+        # Check that if the peer manages to catch up within time, the timeouts are removed (and the peer is not disconnected)\n+        # We are reusing the peer from the previous case which already sent us a valid (but old) block and whose timer is ticking\n+\n+        # Send an updated headers message matching our tip\n+        headers_message = msg_headers()\n+        headers_message.headers = [from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Wait for long enough for the timeouts to have triggered and check that we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485374401",
      "id" : 1485374401,
      "line" : 222,
      "node_id" : "PRRC_kwDOABII585YiQPB",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 222,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "test/functional/p2p_eviction.py",
      "position" : 133,
      "pull_request_review_id" : 1874277464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485374401/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-11T00:14:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485374401",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485375517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485375517"
         }
      },
      "author_association" : "NONE",
      "body" : "nit:  I could be missing something, but a test case covering the limit of protected outbound peers (i.e. `MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT`) was not observed.  Do you think it's worth adding?  \r\n\r\nThinking out loud:\r\n`MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT = 4`, so maybe adding another peer that would normally be considered protected and seeing that it is not protected could test this?\r\n",
      "commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "created_at" : "2024-02-11T00:03:41Z",
      "diff_hunk" : "@@ -122,6 +129,178 @@ def run_test(self):\n         self.log.debug(\"{} protected peers: {}\".format(len(protected_peers), protected_peers))\n         assert evicted_peers[0] not in protected_peers\n \n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+        test_node.sync_with_ping()\n+        self.log.info(\"Keep catching up with the old tip and check that we are not evicted\")\n+        for _ in range(10):\n+            # Advance time but not enough to evict the peer\n+            best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+            cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+            node.setmocktime(cur_mock_time)\n+\n+            # Send a header with the old tip\n+            headers_message = msg_headers()\n+            headers_message.headers = [tip_header]\n+            test_node.send_and_ping(headers_message)\n+            tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+\n+            # Check that we are not evicted\n+            cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+            node.setmocktime(cur_mock_time)\n+            test_node.sync_with_ping()\n+\n+        self.log.info(\"Create an outbound connection and take some time to catch up, but do it in time\")\n+        # Check that if the peer manages to catch up within time, the timeouts are removed (and the peer is not disconnected)\n+        # We are reusing the peer from the previous case which already sent us a valid (but old) block and whose timer is ticking\n+\n+        # Send an updated headers message matching our tip\n+        headers_message = msg_headers()\n+        headers_message.headers = [from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Wait for long enough for the timeouts to have triggered and check that we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected(self):\n+        # This tests the eviction logic for **protected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        # Outbound connections are flagged as protected as long as they have sent us a connecting block with at least as\n+        # much work as our current tip and we have enough empty protected_peers slots.\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+\n+        self.log.info(\"Create an outbound connection to a peer that shares our tip so it gets granted protection\")\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [tip_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        self.log.info(\"Mine a new block and sync with our peer\")\n+        self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])\n+        test_node.sync_with_ping()\n+\n+        self.log.info(\"Let enough time pass for the timeouts to go off\")\n+        # Trigger the timeouts and check how we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the node does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected_mixed(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485375517",
      "id" : 1485375517,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII585YiQgd",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 252,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "test/functional/p2p_eviction.py",
      "position" : 163,
      "pull_request_review_id" : 1874277464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485375517/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-11T00:18:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1485375517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486346242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486346242"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's covered in the last part of `test_outbound_eviction_unprotected`\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/edc14bc9da332cae39f8803db559b532b3c74e16/test/functional/p2p_eviction.py#L202-L218",
      "commit_id" : "91005f7459993e1f7139e46b53eef1bb04860a7c",
      "created_at" : "2024-02-12T15:28:44Z",
      "diff_hunk" : "@@ -5132,16 +5132,19 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n         if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486346242",
      "id" : 1486346242,
      "in_reply_to_id" : 1485367696,
      "line" : 5134,
      "node_id" : "PRRC_kwDOABII585Yl9gC",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 5134,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 3,
      "pull_request_review_id" : 1875503633,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486346242/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-12T16:00:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486346242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486369882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486369882"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Protected peer actually implies `outbound-full-relay`. The comment you mentioned may be outdated. I may add an update to it to the PR.\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/edc14bc9da332cae39f8803db559b532b3c74e16/src/net_processing.cpp#L2875-L2885",
      "commit_id" : "91005f7459993e1f7139e46b53eef1bb04860a7c",
      "created_at" : "2024-02-12T15:44:54Z",
      "diff_hunk" : "@@ -122,6 +129,178 @@ def run_test(self):\n         self.log.debug(\"{} protected peers: {}\".format(len(protected_peers), protected_peers))\n         assert evicted_peers[0] not in protected_peers\n \n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+        test_node.sync_with_ping()\n+        self.log.info(\"Keep catching up with the old tip and check that we are not evicted\")\n+        for _ in range(10):\n+            # Advance time but not enough to evict the peer\n+            best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+            cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+            node.setmocktime(cur_mock_time)\n+\n+            # Send a header with the old tip\n+            headers_message = msg_headers()\n+            headers_message.headers = [tip_header]\n+            test_node.send_and_ping(headers_message)\n+            tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+\n+            # Check that we are not evicted\n+            cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+            node.setmocktime(cur_mock_time)\n+            test_node.sync_with_ping()\n+\n+        self.log.info(\"Create an outbound connection and take some time to catch up, but do it in time\")\n+        # Check that if the peer manages to catch up within time, the timeouts are removed (and the peer is not disconnected)\n+        # We are reusing the peer from the previous case which already sent us a valid (but old) block and whose timer is ticking\n+\n+        # Send an updated headers message matching our tip\n+        headers_message = msg_headers()\n+        headers_message.headers = [from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Wait for long enough for the timeouts to have triggered and check that we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486369882",
      "id" : 1486369882,
      "in_reply_to_id" : 1485374401,
      "line" : 222,
      "node_id" : "PRRC_kwDOABII585YmDRa",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 222,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "test/functional/p2p_eviction.py",
      "position" : 133,
      "pull_request_review_id" : 1875503633,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486369882/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-12T16:00:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486369882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486391103"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486391103"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The limit is tested in this test. We create 8 connections, from which only 4 are protected. If you mean that there are no unprotected peers that behave properly, that could be added. e.g.\r\n\r\n4 protected, send initial headers, do nothing, don't get evicted\r\n2 unprotected, keep in sync, don't get evicted\r\n2 unprotected, do not keep up, get evicted ",
      "commit_id" : "91005f7459993e1f7139e46b53eef1bb04860a7c",
      "created_at" : "2024-02-12T15:58:29Z",
      "diff_hunk" : "@@ -122,6 +129,178 @@ def run_test(self):\n         self.log.debug(\"{} protected peers: {}\".format(len(protected_peers), protected_peers))\n         assert evicted_peers[0] not in protected_peers\n \n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+        test_node.sync_with_ping()\n+        self.log.info(\"Keep catching up with the old tip and check that we are not evicted\")\n+        for _ in range(10):\n+            # Advance time but not enough to evict the peer\n+            best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+            cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+            node.setmocktime(cur_mock_time)\n+\n+            # Send a header with the old tip\n+            headers_message = msg_headers()\n+            headers_message.headers = [tip_header]\n+            test_node.send_and_ping(headers_message)\n+            tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+\n+            # Check that we are not evicted\n+            cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+            node.setmocktime(cur_mock_time)\n+            test_node.sync_with_ping()\n+\n+        self.log.info(\"Create an outbound connection and take some time to catch up, but do it in time\")\n+        # Check that if the peer manages to catch up within time, the timeouts are removed (and the peer is not disconnected)\n+        # We are reusing the peer from the previous case which already sent us a valid (but old) block and whose timer is ticking\n+\n+        # Send an updated headers message matching our tip\n+        headers_message = msg_headers()\n+        headers_message.headers = [from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Wait for long enough for the timeouts to have triggered and check that we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected(self):\n+        # This tests the eviction logic for **protected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        # Outbound connections are flagged as protected as long as they have sent us a connecting block with at least as\n+        # much work as our current tip and we have enough empty protected_peers slots.\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+\n+        self.log.info(\"Create an outbound connection to a peer that shares our tip so it gets granted protection\")\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [tip_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        self.log.info(\"Mine a new block and sync with our peer\")\n+        self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])\n+        test_node.sync_with_ping()\n+\n+        self.log.info(\"Let enough time pass for the timeouts to go off\")\n+        # Trigger the timeouts and check how we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the node does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected_mixed(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486391103",
      "id" : 1486391103,
      "in_reply_to_id" : 1485375517,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII585YmIc_",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 252,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "test/functional/p2p_eviction.py",
      "position" : 163,
      "pull_request_review_id" : 1875503633,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486391103/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-12T16:00:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486391103",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486417918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486417918"
         }
      },
      "author_association" : "NONE",
      "body" : "Correct. >= rather than >.",
      "commit_id" : "91005f7459993e1f7139e46b53eef1bb04860a7c",
      "created_at" : "2024-02-12T16:12:37Z",
      "diff_hunk" : "@@ -5132,16 +5132,19 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n         if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486417918",
      "id" : 1486417918,
      "in_reply_to_id" : 1485367696,
      "line" : 5134,
      "node_id" : "PRRC_kwDOABII585YmO_-",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 5134,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 3,
      "pull_request_review_id" : 1875620153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486417918/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-12T16:12:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486417918",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I redefined how peers are split in `p2p_eviction:test_outbound_eviction_protected_mixed` to address https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1485375517. Both commits can be squashed (leaving them as they are for now in case someone does not agree with the approach)",
      "created_at" : "2024-02-12T16:22:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1939071798",
      "id" : 1939071798,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585zk-M2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939071798/reactions"
      },
      "updated_at" : "2024-02-12T16:22:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939071798",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486449111"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486449111"
         }
      },
      "author_association" : "NONE",
      "body" : "Thank you, yes, I should have been clearer.  The updated `test_outbound_eviction_protected_mixed` in 91005f7459993e1f7139e46b53eef1bb04860a7c looks great (includes 4 protected, 4 unprotected (2 honest, 2 misbehaving by sending no headers or old)).  ACK 91005f7459993e1f7139e46b53eef1bb04860a7c",
      "commit_id" : "91005f7459993e1f7139e46b53eef1bb04860a7c",
      "created_at" : "2024-02-12T16:28:29Z",
      "diff_hunk" : "@@ -122,6 +129,178 @@ def run_test(self):\n         self.log.debug(\"{} protected peers: {}\".format(len(protected_peers), protected_peers))\n         assert evicted_peers[0] not in protected_peers\n \n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 10)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+        test_node.sync_with_ping()\n+        self.log.info(\"Keep catching up with the old tip and check that we are not evicted\")\n+        for _ in range(10):\n+            # Advance time but not enough to evict the peer\n+            best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+            cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+            node.setmocktime(cur_mock_time)\n+\n+            # Send a header with the old tip\n+            headers_message = msg_headers()\n+            headers_message.headers = [tip_header]\n+            test_node.send_and_ping(headers_message)\n+            tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+\n+            # Check that we are not evicted\n+            cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+            node.setmocktime(cur_mock_time)\n+            test_node.sync_with_ping()\n+\n+        self.log.info(\"Create an outbound connection and take some time to catch up, but do it in time\")\n+        # Check that if the peer manages to catch up within time, the timeouts are removed (and the peer is not disconnected)\n+        # We are reusing the peer from the previous case which already sent us a valid (but old) block and whose timer is ticking\n+\n+        # Send an updated headers message matching our tip\n+        headers_message = msg_headers()\n+        headers_message.headers = [from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Wait for long enough for the timeouts to have triggered and check that we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected(self):\n+        # This tests the eviction logic for **protected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        # Outbound connections are flagged as protected as long as they have sent us a connecting block with at least as\n+        # much work as our current tip and we have enough empty protected_peers slots.\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime if node.mocktime else int(time.time())\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+\n+        self.log.info(\"Create an outbound connection to a peer that shares our tip so it gets granted protection\")\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [tip_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        self.log.info(\"Mine a new block and sync with our peer\")\n+        self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])\n+        test_node.sync_with_ping()\n+\n+        self.log.info(\"Let enough time pass for the timeouts to go off\")\n+        # Trigger the timeouts and check how we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the node does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected_mixed(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1486449111",
      "id" : 1486449111,
      "in_reply_to_id" : 1485375517,
      "line" : 252,
      "node_id" : "PRRC_kwDOABII585YmWnX",
      "original_commit_id" : "edc14bc9da332cae39f8803db559b532b3c74e16",
      "original_line" : 252,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "test/functional/p2p_eviction.py",
      "position" : 163,
      "pull_request_review_id" : 1875666331,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486449111/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-12T16:30:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1486449111",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Rebased. This has failed CI once when waiting for the disconnection after:\r\n> \r\n> ```\r\n> cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\r\n> ```\r\n> \r\n> I've tried to reproduce it but I cannot in my local setup, the only thing that comes to mind is that mock time may be too close to the timeout (only one second ahead), so I gave it a delta of 10 seconds instead.\r\n> \r\n> PS: For context, you can check the failure here: https://cirrus-ci.com/task/4624744360706048?logs=ci#L6520. See how the peer is given the final notice by sending a getheaders message, but the check is performed before the peer gets disconnected.\r\n\r\nI've been looking more into this, given an error showed up again on CI. I think the issue arose from the initial mock time not being properly set. I've reset the increments to be just one second apart, plus set the initial mock time before the tests were run.\r\n\r\nAlso, I've moved the outbound eviction tests to their own file, given `p2p_eviction` was being described as testing inbound eviction, plus used some custom classes that were only relevant for inbounds.",
      "created_at" : "2024-02-12T21:31:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1939619126",
      "id" : 1939619126,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585znD02",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939619126/reactions"
      },
      "updated_at" : "2024-02-12T21:31:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939619126",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--85328a0da195eb286784d51f73fa0af9-->\n\nð§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/21495911628</sub>",
      "created_at" : "2024-02-12T21:42:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1939637205",
      "id" : 1939637205,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585znIPV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939637205/reactions"
      },
      "updated_at" : "2024-02-12T21:42:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939637205",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> > Rebased. This has failed CI once when waiting for the disconnection after:\r\n> > ```\r\n> > cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > I've tried to reproduce it but I cannot in my local setup, the only thing that comes to mind is that mock time may be too close to the timeout (only one second ahead), so I gave it a delta of 10 seconds instead.\r\n> > PS: For context, you can check the failure here: https://cirrus-ci.com/task/4624744360706048?logs=ci#L6520. See how the peer is given the final notice by sending a getheaders message, but the check is performed before the peer gets disconnected.\r\n> \r\n> I've been looking more into this, given an error showed up again on CI. I think the issue arose from the initial mock time not being properly set. I've reset the increments to be just one second apart, plus set the initial mock time before the tests were run.\r\n> \r\n> Also, I've moved the outbound eviction tests to their own file, given `p2p_eviction` was being described as testing inbound eviction, plus used some custom classes that were only relevant for inbounds.\r\n\r\n(now non-stale) ACK for f06b50dfd45000f34bf258d48101718b4b5f9772.\r\nPulled.  Built.  Ran `p2p_eviction.py` and `p2p_outbound_eviction.py`.  Both passed.",
      "created_at" : "2024-02-13T00:41:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1939902686",
      "id" : 1939902686,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII585zoJDe",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939902686/reactions"
      },
      "updated_at" : "2024-02-13T00:41:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1939902686",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/106488469?v=4",
         "events_url" : "https://api.github.com/users/tdb3/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tdb3/followers",
         "following_url" : "https://api.github.com/users/tdb3/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tdb3/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tdb3",
         "id" : 106488469,
         "login" : "tdb3",
         "node_id" : "U_kgDOBljilQ",
         "organizations_url" : "https://api.github.com/users/tdb3/orgs",
         "received_events_url" : "https://api.github.com/users/tdb3/received_events",
         "repos_url" : "https://api.github.com/users/tdb3/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tdb3/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tdb3/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tdb3"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499234183"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499234183"
         }
      },
      "author_association" : "NONE",
      "body" : "`self.nodes[0]` => `node` here and in a few other places.",
      "commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "created_at" : "2024-02-22T13:22:08Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\" Test node outbound peer eviction logic\n+\n+A subset of out outbound peers are subject to eviction logic if they cannot keep up\n+with our vision of the best chain. This criteria applies only to non-protected peers,\n+and can be triggered by either not learning about any blocks from an outbound peer after\n+a certain deadline, or by them not being able to catch up fast enough (under the same deadline).\n+\n+This tests the different eviction paths based on the peer' behavior and on whether they are protected\n+or not.\n+\"\"\"\n+import time\n+\n+from test_framework.messages import (\n+    from_hex,\n+    msg_headers,\n+    CBlockHeader,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+# Timeouts (in minutes)\n+CHAIN_SYNC_TIMEOUT = 20 * 60\n+HEADERS_RESPONSE_TIME = 2 * 60\n+\n+\n+class P2POutEvict(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499234183",
      "id" : 1499234183,
      "line" : 84,
      "node_id" : "PRRC_kwDOABII585ZXH-H",
      "original_commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "original_line" : 84,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "test/functional/p2p_outbound_eviction.py",
      "position" : 84,
      "pull_request_review_id" : 1895842788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499234183/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-22T22:08:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499234183",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499234794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499234794"
         }
      },
      "author_association" : "NONE",
      "body" : "Nit: Why not make these more succinct, as in\r\n```python\r\n       test_node.send_and_ping(msg_headers([prev_header]))\r\n```\r\n? There's no risk of raising exceptions from the first 2 lines.",
      "commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "created_at" : "2024-02-22T13:22:37Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\" Test node outbound peer eviction logic\n+\n+A subset of out outbound peers are subject to eviction logic if they cannot keep up\n+with our vision of the best chain. This criteria applies only to non-protected peers,\n+and can be triggered by either not learning about any blocks from an outbound peer after\n+a certain deadline, or by them not being able to catch up fast enough (under the same deadline).\n+\n+This tests the different eviction paths based on the peer' behavior and on whether they are protected\n+or not.\n+\"\"\"\n+import time\n+\n+from test_framework.messages import (\n+    from_hex,\n+    msg_headers,\n+    CBlockHeader,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+# Timeouts (in minutes)\n+CHAIN_SYNC_TIMEOUT = 20 * 60\n+HEADERS_RESPONSE_TIME = 2 * 60\n+\n+\n+class P2POutEvict(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499234794",
      "id" : 1499234794,
      "line" : 67,
      "node_id" : "PRRC_kwDOABII585ZXIHq",
      "original_commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : 65,
      "path" : "test/functional/p2p_outbound_eviction.py",
      "position" : 67,
      "pull_request_review_id" : 1895842788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499234794/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 65,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-02-22T22:08:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499234794",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499242364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499242364"
         }
      },
      "author_association" : "NONE",
      "body" : "Suggestion: rename `unprotected_peers_misbehaving` => `misbehaving_unprotected_peers` to match `honest_unprotected_peers`.",
      "commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "created_at" : "2024-02-22T13:28:14Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\" Test node outbound peer eviction logic\n+\n+A subset of out outbound peers are subject to eviction logic if they cannot keep up\n+with our vision of the best chain. This criteria applies only to non-protected peers,\n+and can be triggered by either not learning about any blocks from an outbound peer after\n+a certain deadline, or by them not being able to catch up fast enough (under the same deadline).\n+\n+This tests the different eviction paths based on the peer' behavior and on whether they are protected\n+or not.\n+\"\"\"\n+import time\n+\n+from test_framework.messages import (\n+    from_hex,\n+    msg_headers,\n+    CBlockHeader,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+# Timeouts (in minutes)\n+CHAIN_SYNC_TIMEOUT = 20 * 60\n+HEADERS_RESPONSE_TIME = 2 * 60\n+\n+\n+class P2POutEvict(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and keep lagging behind, but not too much\")\n+        # Test that if the peer never catches up with our current tip, but it does with the\n+        # expected work that we set when setting the timer (that is, our tip at the time)\n+        # we do not disconnect the peer\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        self.log.info(\"Mine a block so our peer starts lagging\")\n+        best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+        test_node.sync_with_ping()\n+        self.log.info(\"Keep catching up with the old tip and check that we are not evicted\")\n+        for _ in range(10):\n+            # Advance time but not enough to evict the peer\n+            best_block_hash = self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])[\"hash\"]\n+            cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+            node.setmocktime(cur_mock_time)\n+\n+            # Send a header with the old tip\n+            headers_message = msg_headers()\n+            headers_message.headers = [tip_header]\n+            test_node.send_and_ping(headers_message)\n+            tip_header = from_hex(CBlockHeader(), node.getblockheader(best_block_hash, False))\n+\n+            # Check that we are not evicted\n+            cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+            node.setmocktime(cur_mock_time)\n+            test_node.sync_with_ping()\n+\n+        self.log.info(\"Create an outbound connection and take some time to catch up, but do it in time\")\n+        # Check that if the peer manages to catch up within time, the timeouts are removed (and the peer is not disconnected)\n+        # We are reusing the peer from the previous case which already sent us a valid (but old) block and whose timer is ticking\n+\n+        # Send an updated headers message matching our tip\n+        headers_message = msg_headers()\n+        headers_message.headers = [from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Wait for long enough for the timeouts to have triggered and check that we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected(self):\n+        # This tests the eviction logic for **protected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        # Outbound connections are flagged as protected as long as they have sent us a connecting block with at least as\n+        # much work as our current tip and we have enough empty protected_peers slots.\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+\n+        self.log.info(\"Create an outbound connection to a peer that shares our tip so it gets granted protection\")\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [tip_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        self.log.info(\"Mine a new block and sync with our peer\")\n+        self.generateblock(self.nodes[0], output=\"raw(42)\", transactions=[])\n+        test_node.sync_with_ping()\n+\n+        self.log.info(\"Let enough time pass for the timeouts to go off\")\n+        # Trigger the timeouts and check how we are still connected\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the node does not get evicted\")\n+        test_node.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_outbound_eviction_protected_mixed(self):\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+\n+        self.log.info(\"Create a mix of protected and unprotected outbound connections to check against eviction\")\n+\n+        # Lets try this logic having multiple peers, some protected and some unprotected\n+        # We protect up to 4 peers as long as they have provided a block with the same amount of work as our tip\n+        self.log.info(\"The first 4 peers are protected by sending us a valid block with enough work\")\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        headers_message = msg_headers()\n+        headers_message.headers = [tip_header]\n+        protected_peers = []\n+        for i in range(4):\n+            peer = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\")\n+            peer.send_and_ping(headers_message)\n+            protected_peers.append(peer)\n+\n+        # We can create 4 additional outbound connections to peers that are unprotected. 2 of them will be well behaved,\n+        # whereas the other 2 will misbehave (1 sending no headers, 1 sending old ones)\n+        self.log.info(\"The remaining 4 peers will be mixed between honest (2) and misbehaving peers (2)\")\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        honest_unprotected_peers = []\n+        for i in range(2):\n+            peer = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4+i, connection_type=\"outbound-full-relay\")\n+            peer.send_and_ping(headers_message)\n+            honest_unprotected_peers.append(peer)\n+\n+        unprotected_peers_misbehaving = []",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499242364",
      "id" : 1499242364,
      "line" : 185,
      "node_id" : "PRRC_kwDOABII585ZXJ98",
      "original_commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : 179,
      "path" : "test/functional/p2p_outbound_eviction.py",
      "position" : 185,
      "pull_request_review_id" : 1895842788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499242364/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 179,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2024-02-22T22:08:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499242364",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499971404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499971404"
         }
      },
      "author_association" : "NONE",
      "body" : "It's a bit opaque to me that `.sync_with_ping()` doesn't sync `test_node` all the way up to the tip of `node`. What is preventing that from happening?",
      "commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "created_at" : "2024-02-22T21:43:58Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\" Test node outbound peer eviction logic\n+\n+A subset of out outbound peers are subject to eviction logic if they cannot keep up\n+with our vision of the best chain. This criteria applies only to non-protected peers,\n+and can be triggered by either not learning about any blocks from an outbound peer after\n+a certain deadline, or by them not being able to catch up fast enough (under the same deadline).\n+\n+This tests the different eviction paths based on the peer' behavior and on whether they are protected\n+or not.\n+\"\"\"\n+import time\n+\n+from test_framework.messages import (\n+    from_hex,\n+    msg_headers,\n+    CBlockHeader,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+# Timeouts (in minutes)\n+CHAIN_SYNC_TIMEOUT = 20 * 60\n+HEADERS_RESPONSE_TIME = 2 * 60\n+\n+\n+class P2POutEvict(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499971404",
      "id" : 1499971404,
      "line" : 72,
      "node_id" : "PRRC_kwDOABII585ZZ79M",
      "original_commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "original_line" : 72,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "test/functional/p2p_outbound_eviction.py",
      "position" : 72,
      "pull_request_review_id" : 1895842788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499971404/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-22T22:08:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499971404",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499975415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499975415"
         }
      },
      "author_association" : "NONE",
      "body" : "How about also verifying whether `MaybeSendGetHeaders()` is actually sent (or not) from `node` to `test_node` by `PeerManagerImpl::ConsiderEviction()` in relevant cases?",
      "commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "created_at" : "2024-02-22T21:48:40Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\" Test node outbound peer eviction logic\n+\n+A subset of out outbound peers are subject to eviction logic if they cannot keep up\n+with our vision of the best chain. This criteria applies only to non-protected peers,\n+and can be triggered by either not learning about any blocks from an outbound peer after\n+a certain deadline, or by them not being able to catch up fast enough (under the same deadline).\n+\n+This tests the different eviction paths based on the peer' behavior and on whether they are protected\n+or not.\n+\"\"\"\n+import time\n+\n+from test_framework.messages import (\n+    from_hex,\n+    msg_headers,\n+    CBlockHeader,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+# Timeouts (in minutes)\n+CHAIN_SYNC_TIMEOUT = 20 * 60\n+HEADERS_RESPONSE_TIME = 2 * 60\n+\n+\n+class P2POutEvict(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def test_outbound_eviction_unprotected(self):\n+        # This tests the eviction logic for **unprotected** outbound peers (that is, PeerManagerImpl::ConsiderEviction)\n+        node = self.nodes[0]\n+        cur_mock_time = node.mocktime\n+\n+        self.log.info(\"Create an outbound connection and don't send any headers\")\n+        # Test disconnect due to no block being announced in 22+ minutes (headers are not even exchanged)\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        # Wait for over 20 min to trigger the first eviction timeout. This sets the last call past 2 min in the future.\n+        test_node.sync_with_ping()\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        # Wait for over 2 more min to trigger the disconnection\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)\n+        node.setmocktime(cur_mock_time)\n+        self.log.info(\"Test that the peer gets evicted\")\n+        test_node.wait_for_disconnect()\n+\n+        self.log.info(\"Create an outbound connection and send header but never catch up\")\n+        # Mimic a node that just falls behind for long enough\n+        # This should also apply for a node doing IBD that does not catch up in time\n+        # Get our tip header and its parent\n+        tip_header = from_hex(CBlockHeader(), node.getblockheader(node.getbestblockhash(), False))\n+        prev_header = from_hex(CBlockHeader(), node.getblockheader(f\"{tip_header.hashPrevBlock:064x}\", False))\n+\n+        # Connect a peer and make it send us headers ending in our tip's parent\n+        test_node = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"outbound-full-relay\")\n+        headers_message = msg_headers()\n+        headers_message.headers = [prev_header]\n+        test_node.send_and_ping(headers_message)\n+\n+        # Trigger the timeouts\n+        cur_mock_time += (CHAIN_SYNC_TIMEOUT + 1)\n+        node.setmocktime(cur_mock_time)\n+        test_node.sync_with_ping()\n+        cur_mock_time += (HEADERS_RESPONSE_TIME + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1499975415",
      "id" : 1499975415,
      "line" : 73,
      "node_id" : "PRRC_kwDOABII585ZZ873",
      "original_commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "original_line" : 73,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "test/functional/p2p_outbound_eviction.py",
      "position" : 73,
      "pull_request_review_id" : 1895842788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499975415/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-22T22:08:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1499975415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Couldn't reproduce the CI timeout issue btw. But I have encountered the warning:\r\n```\r\n2024-02-22T22:01:47.354000Z TestFramework.p2p (WARNING): Connection lost to 0:0 due to [Errno 104] Connection reset by peer\r\n```",
      "created_at" : "2024-02-22T22:15:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#issuecomment-1960407242",
      "id" : 1960407242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/29122",
      "node_id" : "IC_kwDOABII58502XDK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1960407242/reactions"
      },
      "updated_at" : "2024-02-22T22:15:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1960407242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/581308?v=4",
         "events_url" : "https://api.github.com/users/cbergqvist/events{/privacy}",
         "followers_url" : "https://api.github.com/users/cbergqvist/followers",
         "following_url" : "https://api.github.com/users/cbergqvist/following{/other_user}",
         "gists_url" : "https://api.github.com/users/cbergqvist/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/cbergqvist",
         "id" : 581308,
         "login" : "cbergqvist",
         "node_id" : "MDQ6VXNlcjU4MTMwOA==",
         "organizations_url" : "https://api.github.com/users/cbergqvist/orgs",
         "received_events_url" : "https://api.github.com/users/cbergqvist/received_events",
         "repos_url" : "https://api.github.com/users/cbergqvist/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/cbergqvist/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/cbergqvist/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/cbergqvist"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1500100950"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1500100950"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: It looks like the backslash at the end of this line is a typo, yes? Could be removed for clarity.",
      "commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "created_at" : "2024-02-23T00:30:17Z",
      "diff_hunk" : "@@ -5132,16 +5132,19 @@ void PeerManagerImpl::ConsiderEviction(CNode& pto, Peer& peer, std::chrono::seco\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n         if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= m_chainman.ActiveChain().Tip()->nChainWork) {\n+            // The outbound peer has sent us a block with at least as much work as our current tip, so reset the timeout if it was set\n             if (state.m_chain_sync.m_timeout != 0s) {\n                 state.m_chain_sync.m_timeout = 0s;\n                 state.m_chain_sync.m_work_header = nullptr;\n                 state.m_chain_sync.m_sent_getheaders = false;\n             }\n-        } else if (state.m_chain_sync.m_timeout == 0s || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n-            // Our best block known by this peer is behind our tip, and we're either noticing\n-            // that for the first time, OR this peer was able to catch up to some earlier point\n-            // where we checked against our tip.\n-            // Either way, set a new timeout based on current tip.\n+        } else if (state.m_chain_sync.m_timeout == 0s || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/29122#discussion_r1500100950",
      "id" : 1500100950,
      "line" : 5141,
      "node_id" : "PRRC_kwDOABII585ZablW",
      "original_commit_id" : "f06b50dfd45000f34bf258d48101718b4b5f9772",
      "original_line" : 5141,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 15,
      "pull_request_review_id" : 1897212961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/29122",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1500100950/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2024-02-23T00:30:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1500100950",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/95179662?v=4",
         "events_url" : "https://api.github.com/users/marcofleon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/marcofleon/followers",
         "following_url" : "https://api.github.com/users/marcofleon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/marcofleon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/marcofleon",
         "id" : 95179662,
         "login" : "marcofleon",
         "node_id" : "U_kgDOBaxTjg",
         "organizations_url" : "https://api.github.com/users/marcofleon/orgs",
         "received_events_url" : "https://api.github.com/users/marcofleon/received_events",
         "repos_url" : "https://api.github.com/users/marcofleon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/marcofleon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/marcofleon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/marcofleon"
      }
   }
]
