[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r160607899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/160607899"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`SignPartialTransaction` sounds after we have partial transactions. Suggest `SignPartialSignedTransaction`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-01-10T07:47:17Z",
      "diff_hunk" : "@@ -302,6 +381,218 @@ struct Stacks\n };\n }\n \n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+bool SignPartialTransaction(PartiallySignedTransaction& psbt, const CKeyStore* keystore, int nHashType)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r160607899",
      "id" : 160607899,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MDYwNzg5OQ==",
      "original_commit_id" : "324f4e3b830a86044710b97460ce827c7b059493",
      "original_position" : 126,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 87753024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/160607899",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Great work!\r\nGeneral concept ack, though the PR is large and maybe there is a way to make smaller steps towards BIP174 (reduce of risks).",
      "created_at" : "2018-01-10T07:51:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-356525975",
      "id" : 356525975,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-01-10T07:51:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356525975",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm not sure what's causing the travis failure.",
      "created_at" : "2018-01-10T21:27:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-356742198",
      "id" : 356742198,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-01-10T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356742198",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK!",
      "created_at" : "2018-01-11T20:37:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-357053808",
      "id" : 357053808,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-01-11T20:37:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357053808",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2018-01-16T22:27:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-358128846",
      "id" : 358128846,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-01-16T22:27:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/358128846",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/413395?v=4",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "author_association" : "OWNER",
      "body" : "Neat! Concept ACK.",
      "created_at" : "2018-02-14T13:53:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-365613381",
      "id" : 365613381,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-02-14T13:53:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/365613381",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r168284628"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/168284628"
         }
      },
      "author_association" : "MEMBER",
      "body" : "this may segfault when there is no corresponding `partial_sig`, I believe this is the cause of your test failure.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-14T19:29:47Z",
      "diff_hunk" : "@@ -302,6 +381,218 @@ struct Stacks\n };\n }\n \n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+bool SignPartialTransaction(PartiallySignedTransaction& psbt, const CKeyStore* keystore, int nHashType)\n+{\n+    CMutableTransaction mtx = psbt.tx;\n+    bool solved = true;\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        CScript script = utxo.scriptPubKey;\n+        const CAmount& amount = utxo.nValue;\n+\n+        MutableTransactionSignatureCreator creator(keystore, &mtx, i, amount, nHashType);\n+\n+        std::vector<valtype> sig_ret;\n+        std::vector<valtype> script_ret; // Only for the signer to put redemscripts to be used later.\n+        std::vector<CPubKey> key_ret;\n+        txnouttype whichType;\n+        solved = SignSigsOnly(creator, script, sig_ret, whichType, SIGVERSION_BASE, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts);\n+\n+        if (solved && whichType == TX_SCRIPTHASH)\n+        {\n+            script = CScript(script_ret[0].begin(), script_ret[0].end());\n+            solved = solved && SignSigsOnly(creator, script, sig_ret, whichType, SIGVERSION_BASE, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts) && whichType != TX_SCRIPTHASH;\n+        }\n+\n+        if (solved && whichType == TX_WITNESS_V0_KEYHASH)\n+        {\n+            CScript witnessscript;\n+            witnessscript << OP_DUP << OP_HASH160 << ToByteVector(script_ret[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n+            txnouttype subType;\n+            solved = solved && SignSigsOnly(creator, witnessscript, sig_ret, subType, SIGVERSION_WITNESS_V0, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts);\n+        }\n+        else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n+        {\n+            CScript witnessscript(script_ret[0].begin(), script_ret[0].end());\n+            txnouttype subType;\n+            solved = solved && SignSigsOnly(creator, witnessscript, sig_ret, subType, SIGVERSION_WITNESS_V0, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        }\n+\n+        // Add to partial sigs\n+        if (solved) {\n+            for (unsigned int j = 0; j < key_ret.size(); ++j) {\n+                psbt.inputs[i].partial_sigs.emplace(key_ret[j], sig_ret[j]);\n+            }\n+        }\n+    }\n+\n+    return solved;\n+}\n+\n+// Finalizes the inputs that can be finalized\n+// Returns true for final tx, false for non final\n+bool FinalizePartialTransaction(PartiallySignedTransaction& psbt)\n+{\n+    CMutableTransaction mtx = psbt.tx;\n+    bool complete = true;\n+    const CTransaction const_tx(mtx);\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        // Combine partial sigs and create full scriptsig\n+        std::vector<valtype> vSolutions;\n+        CScript spk = utxo.scriptPubKey;\n+        bool loop = true;\n+        bool P2SH = false;\n+        bool witness = false;\n+        bool WSH = false;\n+        CScript redeemscript;\n+        CScript witnessscript;\n+        SignatureData sigdata;\n+        std::vector<valtype> script_ret; // Only for the signer to put redemscripts to be used later.\n+        txnouttype whichType;\n+        while (loop) {\n+            loop = false;\n+            uint160 h160;\n+            CScript script_ret2;\n+            CKeyID keyID;\n+            bool found_pk = false;\n+            if (Solver(spk, whichType, vSolutions)) {\n+                switch (whichType)\n+                {\n+                case TX_PUBKEY:\n+                    script_ret.push_back(psbt.inputs[i].partial_sigs.find(CPubKey(vSolutions[0]))->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r168284628",
      "id" : 168284628,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2ODI4NDYyOA==",
      "original_commit_id" : "55a72233626bec231d79d38440000a5cb7dd8a28",
      "original_position" : 237,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 96627328,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/168284628",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r168372462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/168372462"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-15T03:11:06Z",
      "diff_hunk" : "@@ -302,6 +381,218 @@ struct Stacks\n };\n }\n \n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+bool SignPartialTransaction(PartiallySignedTransaction& psbt, const CKeyStore* keystore, int nHashType)\n+{\n+    CMutableTransaction mtx = psbt.tx;\n+    bool solved = true;\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        CScript script = utxo.scriptPubKey;\n+        const CAmount& amount = utxo.nValue;\n+\n+        MutableTransactionSignatureCreator creator(keystore, &mtx, i, amount, nHashType);\n+\n+        std::vector<valtype> sig_ret;\n+        std::vector<valtype> script_ret; // Only for the signer to put redemscripts to be used later.\n+        std::vector<CPubKey> key_ret;\n+        txnouttype whichType;\n+        solved = SignSigsOnly(creator, script, sig_ret, whichType, SIGVERSION_BASE, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts);\n+\n+        if (solved && whichType == TX_SCRIPTHASH)\n+        {\n+            script = CScript(script_ret[0].begin(), script_ret[0].end());\n+            solved = solved && SignSigsOnly(creator, script, sig_ret, whichType, SIGVERSION_BASE, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts) && whichType != TX_SCRIPTHASH;\n+        }\n+\n+        if (solved && whichType == TX_WITNESS_V0_KEYHASH)\n+        {\n+            CScript witnessscript;\n+            witnessscript << OP_DUP << OP_HASH160 << ToByteVector(script_ret[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n+            txnouttype subType;\n+            solved = solved && SignSigsOnly(creator, witnessscript, sig_ret, subType, SIGVERSION_WITNESS_V0, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts);\n+        }\n+        else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n+        {\n+            CScript witnessscript(script_ret[0].begin(), script_ret[0].end());\n+            txnouttype subType;\n+            solved = solved && SignSigsOnly(creator, witnessscript, sig_ret, subType, SIGVERSION_WITNESS_V0, key_ret, script_ret, psbt.redeem_scripts, psbt.witness_scripts) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        }\n+\n+        // Add to partial sigs\n+        if (solved) {\n+            for (unsigned int j = 0; j < key_ret.size(); ++j) {\n+                psbt.inputs[i].partial_sigs.emplace(key_ret[j], sig_ret[j]);\n+            }\n+        }\n+    }\n+\n+    return solved;\n+}\n+\n+// Finalizes the inputs that can be finalized\n+// Returns true for final tx, false for non final\n+bool FinalizePartialTransaction(PartiallySignedTransaction& psbt)\n+{\n+    CMutableTransaction mtx = psbt.tx;\n+    bool complete = true;\n+    const CTransaction const_tx(mtx);\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        // Combine partial sigs and create full scriptsig\n+        std::vector<valtype> vSolutions;\n+        CScript spk = utxo.scriptPubKey;\n+        bool loop = true;\n+        bool P2SH = false;\n+        bool witness = false;\n+        bool WSH = false;\n+        CScript redeemscript;\n+        CScript witnessscript;\n+        SignatureData sigdata;\n+        std::vector<valtype> script_ret; // Only for the signer to put redemscripts to be used later.\n+        txnouttype whichType;\n+        while (loop) {\n+            loop = false;\n+            uint160 h160;\n+            CScript script_ret2;\n+            CKeyID keyID;\n+            bool found_pk = false;\n+            if (Solver(spk, whichType, vSolutions)) {\n+                switch (whichType)\n+                {\n+                case TX_PUBKEY:\n+                    script_ret.push_back(psbt.inputs[i].partial_sigs.find(CPubKey(vSolutions[0]))->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r168372462",
      "id" : 168372462,
      "in_reply_to_id" : 168284628,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2ODM3MjQ2Mg==",
      "original_commit_id" : "55a72233626bec231d79d38440000a5cb7dd8a28",
      "original_position" : 237,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 96727423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/168372462",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169384651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169384651"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should be:\r\n\r\n`if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-20T16:49:46Z",
      "diff_hunk" : "@@ -3520,6 +3520,336 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= BIP32_HARDENED_KEY_LIMIT;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hdMasterKeyID, key);\n+        CExtKey masterKey;\n+        masterKey.SetMaster(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169384651",
      "id" : 169384651,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTM4NDY1MQ==",
      "original_commit_id" : "03145519c72cd0a737f7fbd3a7b85473a45a8b46",
      "original_position" : 140,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 97902598,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169384651",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169386999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169386999"
         }
      },
      "author_association" : "MEMBER",
      "body" : "this isn't mentioned in the spec anywhere, but passing along the the change output's pubkey(s)/hdpath(s)/redeemscript allows hww to understand change outputs.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-20T16:56:54Z",
      "diff_hunk" : "@@ -3520,6 +3520,336 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= BIP32_HARDENED_KEY_LIMIT;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hdMasterKeyID, key);\n+        CExtKey masterKey;\n+        masterKey.SetMaster(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169386999",
      "id" : 169386999,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTM4Njk5OQ==",
      "original_commit_id" : "03145519c72cd0a737f7fbd3a7b85473a45a8b46",
      "original_position" : 171,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 168,
      "pull_request_review_id" : 97902598,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169386999",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169490318"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169490318"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-20T23:08:12Z",
      "diff_hunk" : "@@ -3520,6 +3520,336 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= BIP32_HARDENED_KEY_LIMIT;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hdMasterKeyID, key);\n+        CExtKey masterKey;\n+        masterKey.SetMaster(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169490318",
      "id" : 169490318,
      "in_reply_to_id" : 169384651,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTQ5MDMxOA==",
      "original_commit_id" : "03145519c72cd0a737f7fbd3a7b85473a45a8b46",
      "original_position" : 140,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 98024923,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169490318",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased and squashed fixup commits.",
      "created_at" : "2018-02-20T23:08:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-367153220",
      "id" : 367153220,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-02-20T23:08:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/367153220",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169497726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169497726"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-20T23:49:08Z",
      "diff_hunk" : "@@ -3520,6 +3520,336 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= BIP32_HARDENED_KEY_LIMIT;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hdMasterKeyID, key);\n+        CExtKey masterKey;\n+        masterKey.SetMaster(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169497726",
      "id" : 169497726,
      "in_reply_to_id" : 169386999,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTQ5NzcyNg==",
      "original_commit_id" : "03145519c72cd0a737f7fbd3a7b85473a45a8b46",
      "original_position" : 171,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 168,
      "pull_request_review_id" : 98033441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169497726",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169500813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169500813"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I decided to make this an option instead of the default. I'll add tests for it later.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-21T00:07:48Z",
      "diff_hunk" : "@@ -3520,6 +3520,336 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= BIP32_HARDENED_KEY_LIMIT;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hdMasterKeyID, key);\n+        CExtKey masterKey;\n+        masterKey.SetMaster(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169500813",
      "id" : 169500813,
      "in_reply_to_id" : 169386999,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTUwMDgxMw==",
      "original_commit_id" : "03145519c72cd0a737f7fbd3a7b85473a45a8b46",
      "original_position" : 171,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 168,
      "pull_request_review_id" : 98037043,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169500813",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169691012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169691012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "you need to edit number of allowed args, and include the optional one in parens above.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-21T16:15:40Z",
      "diff_hunk" : "@@ -4082,6 +4163,8 @@ UniValue walletcreatepsbt(const JSONRPCRequest& request)\n                             \"using fundrawtransaction.\\n\"\n                             \"\\nArguments:\\n\"\n                             \"1. \\\"hexstring\\\"            (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. \\\"include_output_info\\\"  (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169691012",
      "id" : 169691012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTY5MTAxMg==",
      "original_commit_id" : "05826621683d1a1f9d38deaf2c15f1b082f37a11",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 98258245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169691012",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169692049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169692049"
         }
      },
      "author_association" : "MEMBER",
      "body" : "you also need to add it to the list of arguments that will be parsed as json rather than strings in `rpc/client.cpp`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-21T16:18:33Z",
      "diff_hunk" : "@@ -4082,6 +4163,8 @@ UniValue walletcreatepsbt(const JSONRPCRequest& request)\n                             \"using fundrawtransaction.\\n\"\n                             \"\\nArguments:\\n\"\n                             \"1. \\\"hexstring\\\"            (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. \\\"include_output_info\\\"  (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169692049",
      "id" : 169692049,
      "in_reply_to_id" : 169691012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTY5MjA0OQ==",
      "original_commit_id" : "05826621683d1a1f9d38deaf2c15f1b082f37a11",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 98258245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169692049",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169694684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169694684"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What we really care about is that we have the hdkeypath, not particularly that the key is present or not. I don't think these `HaveKey` checks are necessary since `add_keypath_to_map` will deal with that case specifically.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-21T16:25:29Z",
      "diff_hunk" : "@@ -3956,6 +3956,84 @@ void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const\n             psbtx.inputs.push_back(input);\n         }\n     }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    if (!pwallet->HaveKey(keyID)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169694684",
      "id" : 169694684,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTY5NDY4NA==",
      "original_commit_id" : "05826621683d1a1f9d38deaf2c15f1b082f37a11",
      "original_position" : 64,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 98258245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169694684",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169860061"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169860061"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, fixed.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-22T05:47:27Z",
      "diff_hunk" : "@@ -3956,6 +3956,84 @@ void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const\n             psbtx.inputs.push_back(input);\n         }\n     }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    if (!pwallet->HaveKey(keyID)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169860061",
      "id" : 169860061,
      "in_reply_to_id" : 169694684,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTg2MDA2MQ==",
      "original_commit_id" : "05826621683d1a1f9d38deaf2c15f1b082f37a11",
      "original_position" : 64,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 98453809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169860061",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169860070"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169860070"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Dang, I knew I forgot something. Fixed.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-22T05:47:35Z",
      "diff_hunk" : "@@ -4082,6 +4163,8 @@ UniValue walletcreatepsbt(const JSONRPCRequest& request)\n                             \"using fundrawtransaction.\\n\"\n                             \"\\nArguments:\\n\"\n                             \"1. \\\"hexstring\\\"            (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. \\\"include_output_info\\\"  (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169860070",
      "id" : 169860070,
      "in_reply_to_id" : 169691012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTg2MDA3MA==",
      "original_commit_id" : "05826621683d1a1f9d38deaf2c15f1b082f37a11",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 98453823,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169860070",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169988690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169988690"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should be `1`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-22T15:13:48Z",
      "diff_hunk" : "@@ -102,6 +102,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n     { \"walletupdatepsbt\", 2, \"psbtformat\"},\n+    { \"walletupdatepsbt\", 3, \"include_output_info\"},\n+    { \"walletcreatepsbt\", 2, \"include_output_info\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r169988690",
      "id" : 169988690,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2OTk4ODY5MA==",
      "original_commit_id" : "f259cd513f6ec0efc9abc512bbb7e49a12a1c0e5",
      "original_position" : 5,
      "path" : "src/rpc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 98600585,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/169988690",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r170004555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/170004555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "fixed",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-02-22T15:58:29Z",
      "diff_hunk" : "@@ -102,6 +102,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n     { \"walletupdatepsbt\", 2, \"psbtformat\"},\n+    { \"walletupdatepsbt\", 3, \"include_output_info\"},\n+    { \"walletcreatepsbt\", 2, \"include_output_info\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r170004555",
      "id" : 170004555,
      "in_reply_to_id" : 169988690,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MDAwNDU1NQ==",
      "original_commit_id" : "f259cd513f6ec0efc9abc512bbb7e49a12a1c0e5",
      "original_position" : 5,
      "path" : "src/rpc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 98620692,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/170004555",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "light tACK\r\n\r\nI have rebased the externalhd branch onto this PR, with minor modifications, for ledger support, combined with @achow101 's HWI repo for signing. https://github.com/instagibbs/bitcoin/tree/external_psbt",
      "created_at" : "2018-03-06T14:13:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-370793854",
      "id" : 370793854,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-03-06T14:13:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/370793854",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "needs rebase",
      "created_at" : "2018-04-05T17:05:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-379006898",
      "id" : 379006898,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-04-05T17:05:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/379006898",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r179593431"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/179593431"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed to `SignPartiallySignedTransaction`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-05T20:37:55Z",
      "diff_hunk" : "@@ -302,6 +381,218 @@ struct Stacks\n };\n }\n \n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+bool SignPartialTransaction(PartiallySignedTransaction& psbt, const CKeyStore* keystore, int nHashType)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r179593431",
      "id" : 179593431,
      "in_reply_to_id" : 160607899,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3OTU5MzQzMQ==",
      "original_commit_id" : "324f4e3b830a86044710b97460ce827c7b059493",
      "original_position" : 126,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 109868427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/179593431",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-04-05T20:38:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-379068975",
      "id" : 379068975,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-04-05T20:38:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/379068975",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-04-26T23:16:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-384817087",
      "id" : 384817087,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-04-26T23:16:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/384817087",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184557822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184557822"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nThis constructor can take const reference arguments.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-26T23:25:07Z",
      "diff_hunk" : "@@ -441,3 +441,60 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction() : tx(), redeem_scripts(), witness_scripts(), inputs() {}\n+PartiallySignedTransaction::PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184557822",
      "id" : 184557822,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDU1NzgyMg==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 6,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184557822",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184557916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184557916"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nNit: method naming convention",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-26T23:25:30Z",
      "diff_hunk" : "@@ -441,3 +441,60 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction() : tx(), redeem_scripts(), witness_scripts(), inputs() {}\n+PartiallySignedTransaction::PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs)\n+{\n+    this->tx = tx;\n+    this->redeem_scripts = redeem_scripts;\n+    this->witness_scripts = witness_scripts;\n+    this->inputs = inputs;\n+\n+    sanitize_for_serialization();\n+}\n+\n+void PartiallySignedTransaction::sanitize_for_serialization()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184557916",
      "id" : 184557916,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDU1NzkxNg==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 16,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184557916",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184558052"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184558052"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nNit: `else` on the same line as `}` (and elsewhere).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-26T23:26:27Z",
      "diff_hunk" : "@@ -441,3 +441,60 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction() : tx(), redeem_scripts(), witness_scripts(), inputs() {}\n+PartiallySignedTransaction::PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs)\n+{\n+    this->tx = tx;\n+    this->redeem_scripts = redeem_scripts;\n+    this->witness_scripts = witness_scripts;\n+    this->inputs = inputs;\n+\n+    sanitize_for_serialization();\n+}\n+\n+void PartiallySignedTransaction::sanitize_for_serialization()\n+{\n+    // Remove sigs from inputs\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        CTxIn& in = tx.vin[i];\n+        PartiallySignedInput psbt_in = inputs[i];\n+        CTxOut vout;\n+        if (psbt_in.non_witness_utxo) {\n+            vout = psbt_in.non_witness_utxo->vout[in.prevout.n];\n+        }\n+        else if (!psbt_in.witness_utxo.IsNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184558052",
      "id" : 184558052,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDU1ODA1Mg==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 26,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184558052",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184558399"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184558399"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nYou can avoid making a copy here (use a const reference instead).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-26T23:28:53Z",
      "diff_hunk" : "@@ -441,3 +441,60 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction() : tx(), redeem_scripts(), witness_scripts(), inputs() {}\n+PartiallySignedTransaction::PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs)\n+{\n+    this->tx = tx;\n+    this->redeem_scripts = redeem_scripts;\n+    this->witness_scripts = witness_scripts;\n+    this->inputs = inputs;\n+\n+    sanitize_for_serialization();\n+}\n+\n+void PartiallySignedTransaction::sanitize_for_serialization()\n+{\n+    // Remove sigs from inputs\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        CTxIn& in = tx.vin[i];\n+        PartiallySignedInput psbt_in = inputs[i];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184558399",
      "id" : 184558399,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDU1ODM5OQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 21,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184558399",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184558613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184558613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nThese can be marked `constexpr` instead.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-26T23:30:15Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184558613",
      "id" : 184558613,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDU1ODYxMw==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 7,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184558613",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184559298"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184559298"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Using `std::move(key)` and `std::move(val_bytes)` here and below will avoid copies.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-26T23:34:59Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));\n+                    s << psbt_in.index;\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index of indexes are being used\n+                    if (!use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators - 1; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                // Make sure that the number of separators - 1 matches the number of inputs if the stream is going to be empty\n+                if (s.empty() && separators - 1 == num_ins) {\n+                    throw std::ios_base::failure(\"Inputs provided does not match the number of inputs stated.\");\n+                }\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type)\n+            {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CMutableTransaction mtx;\n+                        s >> mtx;\n+                        CTransaction prev_tx(mtx);\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx.GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = MakeTransactionRef(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                {\n+                    if (in_globals) {\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in key path\n+                        std::vector<uint32_t> keypath;\n+                        for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                            uint32_t index;\n+                            s >> index;\n+                            keypath.push_back(index);\n+                        }\n+\n+                        // Add to map\n+                        hd_keypaths.emplace(pubkey, keypath);\n+                    } else {\n+                        // Read in the sighash type\n+                        s >> input.sighash_type;\n+                    }\n+                    break;\n+                }\n+                // Number of inputs and input index\n+                case PSBT_NUM_IN_VIN:\n+                {\n+                    if (in_globals) {\n+                        num_ins = ReadCompactSize(s);\n+                    } else {\n+                        // Make sure that we are using inout indexes or this is the first input\n+                        if (!use_in_index && separators != 1) {\n+                            throw std::ios_base::failure(\"Input indexes being used but an input does not provide its index\");\n+                        }\n+\n+                        s >> input.index;\n+                        use_in_index = true;\n+                        input.use_in_index = true;\n+                    }\n+                }\n+                // Unknown stuff\n+                default:\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    Span<unsigned char> value = MakeSpan(val_bytes);\n+                    s >> value;\n+\n+                    // global data\n+                    if (in_globals) {\n+                        unknown.emplace(key, val_bytes);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184559298",
      "id" : 184559298,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDU1OTI5OA==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 374,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184559298",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184782824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184782824"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nI don't think any of these constructor initializers are necessary (the default constructor will do the same).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:16:10Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184782824",
      "id" : 184782824,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4MjgyNA==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 38,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184782824",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184782858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184782858"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nSpecify an initializer for index?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:16:21Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184782858",
      "id" : 184782858,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4Mjg1OA==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 35,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184782858",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184783148"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184783148"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nThese initializers are not necessary (they just invoke the default constructor).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:17:47Z",
      "diff_hunk" : "@@ -441,3 +441,60 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction() : tx(), redeem_scripts(), witness_scripts(), inputs() {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184783148",
      "id" : 184783148,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4MzE0OA==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 5,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184783148",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184783552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184783552"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nYou can use `non_witness_utxo.reset();` here.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:19:44Z",
      "diff_hunk" : "@@ -441,3 +441,60 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+PartiallySignedTransaction::PartiallySignedTransaction() : tx(), redeem_scripts(), witness_scripts(), inputs() {}\n+PartiallySignedTransaction::PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs)\n+{\n+    this->tx = tx;\n+    this->redeem_scripts = redeem_scripts;\n+    this->witness_scripts = witness_scripts;\n+    this->inputs = inputs;\n+\n+    sanitize_for_serialization();\n+}\n+\n+void PartiallySignedTransaction::sanitize_for_serialization()\n+{\n+    // Remove sigs from inputs\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        CTxIn& in = tx.vin[i];\n+        PartiallySignedInput psbt_in = inputs[i];\n+        CTxOut vout;\n+        if (psbt_in.non_witness_utxo) {\n+            vout = psbt_in.non_witness_utxo->vout[in.prevout.n];\n+        }\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            vout = psbt_in.witness_utxo;\n+        }\n+        else {\n+            // There is no input here, skip\n+            continue;\n+        }\n+\n+        // Check the input for sigs. Remove partial sigs. Assume that they are already in partial_sigs\n+        ScriptError serror = SCRIPT_ERR_OK;\n+        const CAmount& amount = vout.nValue;\n+        const CTransaction const_tx(tx);\n+        if (!VerifyScript(in.scriptSig, vout.scriptPubKey, &in.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&const_tx, i, amount), &serror)) {\n+            in.scriptSig.clear();\n+            in.scriptWitness.SetNull();\n+        }\n+        // If this passes, then remove all input data for this input\n+        else {\n+            inputs[i].SetNull();\n+        }\n+    }\n+}\n+\n+void PartiallySignedInput::SetNull()\n+{\n+    non_witness_utxo = CTransactionRef();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184783552",
      "id" : 184783552,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4MzU1Mg==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 51,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184783552",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184784166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184784166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nYou can replace this line + the next with `s << entry.second` (the default serializer for `CScript` uses length prefixing).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:22:00Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184784166",
      "id" : 184784166,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4NDE2Ng==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 78,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184784166",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184784273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184784273"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nLikewise, replace this line and the next with `s << entry.second`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:22:32Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184784273",
      "id" : 184784273,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4NDI3Mw==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 83,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184784273",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184784933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184784933"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nReplace this line and the line below with `s << keypath_pair.second;`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:25:33Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184784933",
      "id" : 184784933,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4NDkzMw==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 89,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184784933",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184786509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184786509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nThis record does not follow the keylen-key-valuelen-value format, and thus wouldn't be parseable by software that doesn't know about it.\r\n\r\nAlso, BIP174 question - why is this record necessary? It should be implied by `tx.vin.size()`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:32:51Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184786509",
      "id" : 184786509,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4NjUwOQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184786509",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184789102"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184789102"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nThis line and the next write the index as a 4-byte uint32, not a compact size as described by BIP174.\r\n\r\nThe correct way to follow the BIP would be to first write the size of the compactsize-encoded input index in compactsize encoding, and then the compactsize encoding of the input. This is a lot easier if you'd have a single-argument `SerializeToVector` first (see above).\r\n\r\nAlso, this record requires 4 bytes (for smallish transactions), while a separator is only 1. It's only advantageous to write it everywhere (as opposed to having separators for already-signed inputs) if over 75% of the inputs are already signed. Perhaps it's generally better to use the separator approach instead?\r\n",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:45:13Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184789102",
      "id" : 184789102,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4OTEwMg==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 147,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184789102",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184789407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184789407"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nNit: `{` on the same line as `switch`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:46:38Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));\n+                    s << psbt_in.index;\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index of indexes are being used\n+                    if (!use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators - 1; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                // Make sure that the number of separators - 1 matches the number of inputs if the stream is going to be empty\n+                if (s.empty() && separators - 1 == num_ins) {\n+                    throw std::ios_base::failure(\"Inputs provided does not match the number of inputs stated.\");\n+                }\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184789407",
      "id" : 184789407,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc4OTQwNw==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 233,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184789407",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184790215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184790215"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nOverall comment on the serialization code: you could simplify things a lot by also having a single-argument `SerializeToVector` (which takes an object but no header byte).\r\n\r\nAll instances of `WriteCompactSize(s, ::GetSerializeSize(foo)); s << foo;` could then turn into `s << SerializeToVector(foo);`. There are dozens of cases of this.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T19:50:39Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184790215",
      "id" : 184790215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc5MDIxNQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 59,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184790215",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184797335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184797335"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nYou can use `CTransactionRef prev_tx; s >> prev_tx;` instead here (and `input.non_witness_utxo = std::move(prev_tx);` below).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T20:21:37Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));\n+                    s << psbt_in.index;\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index of indexes are being used\n+                    if (!use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators - 1; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                // Make sure that the number of separators - 1 matches the number of inputs if the stream is going to be empty\n+                if (s.empty() && separators - 1 == num_ins) {\n+                    throw std::ios_base::failure(\"Inputs provided does not match the number of inputs stated.\");\n+                }\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type)\n+            {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CMutableTransaction mtx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184797335",
      "id" : 184797335,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDc5NzMzNQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 241,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184797335",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184800129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184800129"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nGeneral comment on deserialization code: check that keys and values (where relevant) have the expected length. Things like `uint160(key.begin() + 1, key.end())` will assertion fail if the length is wrong.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-27T20:33:55Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));\n+                    s << psbt_in.index;\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184800129",
      "id" : 184800129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDgwMDEyOQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 164,
      "path" : "src/script/sign.h",
      "position" : 224,
      "pull_request_review_id" : 115780552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184800129",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184838871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184838871"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It specifies the number of inputs that have input data in the PSBT, not the number of inputs in the transaction in general.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-28T03:59:11Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184838871",
      "id" : 184838871,
      "in_reply_to_id" : 184786509,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDgzODg3MQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116120524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184838871",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184839187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184839187"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> This is a lot easier if you'd have a single-argument SerializeToVector first (see above).\r\n\r\nAbove where?\r\n\r\nI'm not necessarily sure that that will always work due to the different data types.\r\n\r\n> Perhaps it's generally better to use the separator approach instead?\r\n\r\nI think it generally is better to use the separator approach. By default, this code does not use input indexes unless a psbt that uses input indexes was provided (at least that's what it is supposed to do). That option was provided at the suggestion of someone else in order to handle very large transactions where almost all inputs were signed.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-28T04:13:57Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184839187",
      "id" : 184839187,
      "in_reply_to_id" : 184789102,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDgzOTE4Nw==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 147,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116120856,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184839187",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addressed all of @sipa's comments.",
      "created_at" : "2018-04-28T04:32:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-385139552",
      "id" : 385139552,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-04-28T04:32:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/385139552",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184841051"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184841051"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This does not work because it will be prefixed with the number of items in the keypath, not with the total size in bytes that that will be. Each item in the keypath is a uint32_t, not an unsigned char.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-28T05:35:44Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184841051",
      "id" : 184841051,
      "in_reply_to_id" : 184784933,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDg0MTA1MQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 89,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116122506,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184841051",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184868701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184868701"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah yes, indeed.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-29T00:48:50Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r184868701",
      "id" : 184868701,
      "in_reply_to_id" : 184784933,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDg2ODcwMQ==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 89,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116152239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184868701",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r185129763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185129763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@achow101 Ok, makes sense.\r\n\r\nBut you're still writing PSB_NUM_IN_VIN without a keylength prefix here.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-30T22:35:58Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r185129763",
      "id" : 185129763,
      "in_reply_to_id" : 184786509,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTEyOTc2Mw==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116152239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185129763",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r185130522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185130522"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This and the line below can be written as `s << sig_pair.second`, I think - it's just an unsigned char vector.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-30T22:40:28Z",
      "diff_hunk" : "@@ -68,6 +71,405 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, GetSizeOfCompactSize(num_ins));\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r185130522",
      "id" : 185130522,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTEzMDUyMg==",
      "original_commit_id" : "e25f290841de2c446a237ad3942a0c2c0427ee62",
      "original_position" : 141,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116152239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185130522",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r185131652"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185131652"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Above where?\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/12136/commits/e25f290841de2c446a237ad3942a0c2c0427ee62#r184790215\r\n\r\n> I'm not necessarily sure that that will always work due to the different data types.\r\n\r\nIt should. Char vectors are always serialized as compactsize-in-bytes + data-bytes. SerializeToVector first serializes to a vector, and then you serialize that. I can create a small example if you want.\r\n\r\nThis is still writing the input index as a 4-byte int, rather than as a compactsize, btw.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-04-30T22:46:39Z",
      "diff_hunk" : "@@ -68,6 +68,392 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static const uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static const uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static const uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static const uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static const uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static const uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename X>\n+std::vector<unsigned char> SerializeToVector(uint8_t header, const X& x)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    ss << header << x;\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput(): non_witness_utxo(), witness_utxo(), partial_sigs(), unknown() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedTransaction();\n+    PartiallySignedTransaction(CMutableTransaction& tx, std::map<uint160, CScript>& redeem_scripts, std::map<uint256, CScript>& witness_scripts, std::vector<PartiallySignedInput>& inputs);\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+            s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+\n+            // Write serialized tx to a stream\n+            WriteCompactSize(s, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+            s << tx;\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            WriteCompactSize(s, entry.second.size());\n+            s << MakeSpan(entry.second);\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, Span<const unsigned char>(keypath_pair.first.begin(), keypath_pair.first.size()));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& key : keypath_pair.second) {\n+                s << key;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << PSBT_NUM_IN_VIN;\n+            WriteCompactSize(s, num_ins);\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    WriteCompactSize(s, sizeof(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO));\n+                    s << PSBT_UNSIGNED_TX_NON_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.non_witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.non_witness_utxo;\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    WriteCompactSize(s, sizeof(PSBT_REDEEMSCRIPT_WITNESS_UTXO));\n+                    s << PSBT_REDEEMSCRIPT_WITNESS_UTXO;\n+                    WriteCompactSize(s, ::GetSerializeSize(psbt_in.witness_utxo, SER_NETWORK, PROTOCOL_VERSION));\n+                    s << psbt_in.witness_utxo;\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, Span<const unsigned char>(sig_pair.first.begin(), sig_pair.first.size()));\n+                    WriteCompactSize(s, sig_pair.second.size());\n+                    s << MakeSpan(sig_pair.second);\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    WriteCompactSize(s, sizeof(PSBT_BIP32_KEYPATH_SIGHASH));\n+                    s << PSBT_BIP32_KEYPATH_SIGHASH;\n+                    WriteCompactSize(s, sizeof(psbt_in.sighash_type));\n+                    s << psbt_in.sighash_type;\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    WriteCompactSize(s, sizeof(PSBT_NUM_IN_VIN));\n+                    s << PSBT_NUM_IN_VIN;\n+                    WriteCompactSize(s, sizeof(psbt_in.index));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r185131652",
      "id" : 185131652,
      "in_reply_to_id" : 184789102,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTEzMTY1Mg==",
      "original_commit_id" : "15840187f587e29cbef57a896265f31d32d87dc0",
      "original_position" : 147,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 116152239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185131652",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "OWNER",
      "body" : "@achow101 Here's a commit with a few suggested improvements to the serialization code: https://github.com/sipa/bitcoin/commit/8733102e713b1ef8e96f6fca80e77a5d8c47fc0b",
      "created_at" : "2018-04-30T23:18:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-385556901",
      "id" : 385556901,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-04-30T23:18:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/385556901",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've included @sipa's serialization improvements.",
      "created_at" : "2018-05-01T15:41:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-385703183",
      "id" : 385703183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-05-01T15:41:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/385703183",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "needs rebase",
      "created_at" : "2018-05-14T16:55:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-388887658",
      "id" : 388887658,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-05-14T16:55:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/388887658",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2018-05-17T22:48:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-390037468",
      "id" : 390037468,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-05-17T22:48:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/390037468",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased this and did some reorganization.\r\n\r\nI squashed down a lot of the commits so that the changes to different parts aren't scattered around in different commits.\r\n\r\nI also de-duplicated the signing code by using a PSBT specific SIgningProvider and SignatureCreator. The SigningProvider handles providing pubkeys and scripts from the PSBT itself along with the wallet and the SignatureCreator adds signatures and public keys directly to the PSBT once the signature is created. This avoids the previous code duplication.\r\n\r\nHopefully the reorganization and the PSBT specific SigningProvider and SignatureCreator will make this easier to review.",
      "created_at" : "2018-05-26T04:42:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-392236221",
      "id" : 392236221,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-05-26T04:42:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/392236221",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191541037"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191541037"
         }
      },
      "author_association" : "MEMBER",
      "body" : "why *8? that doesn't look in line with 32 bit values (also the `uint64_t` below should probably be `uint32_t`).\r\n\r\nAlso, please add `LE` to make clear that this is always little-endian.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-29T19:13:55Z",
      "diff_hunk" : "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32(int pos) const\n+    {\n+        const uint8_t* ptr = data + pos * 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191541037",
      "id" : 191541037,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTU0MTAzNw==",
      "original_commit_id" : "21f67ff4f0d405e085e2ff42a1f80529959bccaa",
      "original_position" : 6,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 124133193,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191541037",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191541303"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191541303"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Single quote like the others?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-29T19:14:51Z",
      "diff_hunk" : "@@ -145,6 +145,7 @@\n     'feature_blocksdir.py',\n     'feature_config_args.py',\n     'feature_help.py',\n+    \"rpc_psbt.py\",",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191541303",
      "id" : 191541303,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTU0MTMwMw==",
      "original_commit_id" : "21f67ff4f0d405e085e2ff42a1f80529959bccaa",
      "original_position" : 4,
      "path" : "test/functional/test_runner.py",
      "position" : null,
      "pull_request_review_id" : 124133492,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191541303",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191561472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191561472"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Whoops. That's a bad copy-paste from the GetUint64 function above this one.\r\n\r\nFixed.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-29T20:23:19Z",
      "diff_hunk" : "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32(int pos) const\n+    {\n+        const uint8_t* ptr = data + pos * 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191561472",
      "id" : 191561472,
      "in_reply_to_id" : 191541037,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTU2MTQ3Mg==",
      "original_commit_id" : "21f67ff4f0d405e085e2ff42a1f80529959bccaa",
      "original_position" : 6,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 124157990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191561472",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191561504"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191561504"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-29T20:23:24Z",
      "diff_hunk" : "@@ -145,6 +145,7 @@\n     'feature_blocksdir.py',\n     'feature_config_args.py',\n     'feature_help.py',\n+    \"rpc_psbt.py\",",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191561504",
      "id" : 191561504,
      "in_reply_to_id" : 191541303,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTU2MTUwNA==",
      "original_commit_id" : "21f67ff4f0d405e085e2ff42a1f80529959bccaa",
      "original_position" : 4,
      "path" : "test/functional/test_runner.py",
      "position" : null,
      "pull_request_review_id" : 124158021,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191561504",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@achow101 have you thought about making this a 3rd party library for integration into other software,  and then integration here?",
      "created_at" : "2018-05-29T23:58:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-392986579",
      "id" : 392986579,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "updated_at" : "2018-05-29T23:58:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/392986579",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/413395?v=4",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191624853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191624853"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```\r\nrpc_psbt.py                           |  Passed  | 4 s\r\n.\r\n.\r\n.\r\nrpc_users.py                          |  Passed  | 3 s\r\n```\r\n\r\nSince `rpc_psbt.py` ran locally for me in 4 seconds and to avoid possible merge conflict, `'rpc_psbt.py'` can be inserted before `'rpc_users.py'` in this list.\r\n\r\n",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T02:08:12Z",
      "diff_hunk" : "@@ -145,6 +145,7 @@\n     'feature_blocksdir.py',\n     'feature_config_args.py',\n     'feature_help.py',\n+    'rpc_psbt.py',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191624853",
      "id" : 191624853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTYyNDg1Mw==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "test/functional/test_runner.py",
      "position" : null,
      "pull_request_review_id" : 124229917,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191624853",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1307806?v=4",
         "events_url" : "https://api.github.com/users/jeffrade/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jeffrade/followers",
         "following_url" : "https://api.github.com/users/jeffrade/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jeffrade/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jeffrade",
         "id" : 1307806,
         "login" : "jeffrade",
         "node_id" : "MDQ6VXNlcjEzMDc4MDY=",
         "organizations_url" : "https://api.github.com/users/jeffrade/orgs",
         "received_events_url" : "https://api.github.com/users/jeffrade/received_events",
         "repos_url" : "https://api.github.com/users/jeffrade/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jeffrade/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jeffrade/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jeffrade"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191672334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191672334"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nShould this be in `serialize.h`?\r\n\r\n(btw, the commit message has a typo (`serliazation`))",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T07:52:50Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191672334",
      "id" : 191672334,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3MjMzNA==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 36,
      "path" : "src/script/sign.h",
      "position" : 71,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191672334",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191674098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191674098"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nNit: space between `for` and `(`, here and on line 236.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T07:59:40Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191674098",
      "id" : 191674098,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3NDA5OA==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 135,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191674098",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191676655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191676655"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nDoesn't really make a huge difference, but I think `if (hash160 != rs_hash160)` is a tiny bit more readable.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:08:43Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191676655",
      "id" : 191676655,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3NjY1NQ==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 300,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191676655",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191676954"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191676954"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nSame here about `(hash != ws_sha256)`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:09:56Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191676954",
      "id" : 191676954,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3Njk1NA==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 337,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191676954",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191678066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191678066"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nWhy the `{}` here and in `case PSBT_NUM_IN_VIN:` below? No vars are declared.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:13:43Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191678066",
      "id" : 191678066,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3ODA2Ng==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 363,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191678066",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191678786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191678786"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nMight be good to check validity of the pubkey. E.g.\r\n```C++\r\nif (!pubkey.IsValid()) {\r\n  throw std::ios_base::failure(\"Invalid pubkey\");\r\n}\r\n```\r\n",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:16:20Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                {\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191678786",
      "id" : 191678786,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3ODc4Ng==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 370,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191678786",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191679623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191679623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe I am seeing outdated code, but it still says `* 8` here and `uint64_t` below.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:19:27Z",
      "diff_hunk" : "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32(int pos) const\n+    {\n+        const uint8_t* ptr = data + pos * 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191679623",
      "id" : 191679623,
      "in_reply_to_id" : 191541037,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY3OTYyMw==",
      "original_commit_id" : "21f67ff4f0d405e085e2ff42a1f80529959bccaa",
      "original_position" : 6,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191679623",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191680502"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191680502"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement a signer that takes an unserialized PSBT and signs it\":\r\n\r\nCheck result of `provider.GetPubKey()` and react if `false`?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:22:32Z",
      "diff_hunk" : "@@ -33,6 +33,23 @@ bool TransactionSignatureCreator::CreateSig(const SigningProvider& provider, std\n     return true;\n }\n \n+bool PSBTSignatureCreator::CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    CPubKey pubkey;\n+    provider.GetPubKey(address, pubkey);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191680502",
      "id" : 191680502,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY4MDUwMg==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 7,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191680502",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191680953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191680953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit/style: `{` on same line as `if`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:24:00Z",
      "diff_hunk" : "@@ -305,6 +322,118 @@ struct Stacks\n };\n }\n \n+bool PSBTSigningProvider::GetCScript(const CScriptID &scriptid, CScript& script) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetCScript(scriptid, script)) {\n+            return true;\n+        }\n+    }\n+    // Look for scripts in redeem_scripts\n+    auto mi = psbt->redeem_scripts.find(scriptid);\n+    if (mi != psbt->redeem_scripts.end())\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191680953",
      "id" : 191680953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY4MDk1Mw==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 38,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191680953",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191682770"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191682770"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement a signer that takes an unserialized PSBT and signs it\":\r\n\r\nMaybe add a comment about this function, in particular saying that it returns true if it was complete, and if `finalize` was set, and `false` does not necessarily mean failure to partially sign.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:30:00Z",
      "diff_hunk" : "@@ -497,9 +498,35 @@ struct PartiallySignedTransaction\n     void SanitizeForSerialization();\n };\n \n+class PSBTSignatureCreator : public MutableTransactionSignatureCreator {\n+private:\n+    std::map<CPubKey, std::vector<unsigned char>>* sigs;\n+    bool finalize_only;\n+\n+public:\n+    PSBTSignatureCreator(std::map<CPubKey, std::vector<unsigned char>>* sigs, CMutableTransaction* tx, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : MutableTransactionSignatureCreator(tx, nInIn, amountIn, nHashTypeIn), sigs(sigs) {}\n+    bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const override;\n+};\n+\n+class PSBTSigningProvider : public SigningProvider {\n+private:\n+    std::vector<SigningProvider*> providers;\n+    PartiallySignedTransaction* psbt;\n+\n+public:\n+    bool GetCScript(const CScriptID &scriptid, CScript& script) const override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    bool GetKey(const CKeyID &address, CKey& key) const override;\n+    void AddSigningProvider(SigningProvider* provider);\n+\n+    PSBTSigningProvider(PartiallySignedTransaction* psbt) : psbt(psbt) {}\n+};\n+\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n+bool SignPartiallySignedTransaction(PartiallySignedTransaction& psbt, SigningProvider* provider, int nHashType, bool finalize = false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191682770",
      "id" : 191682770,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY4Mjc3MA==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 39,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191682770",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191683025"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191683025"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement a signer that takes an unserialized PSBT and signs it\":\r\n\r\nWas this meant to go into the previous commit?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T08:30:54Z",
      "diff_hunk" : "@@ -91,13 +91,13 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n-    uint32_t GetUint32(int pos) const\n+    uint32_t GetUint32LE(int pos) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191683025",
      "id" : 191683025,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTY4MzAyNQ==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 5,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 124285408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191683025",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191755201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191755201"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Unnecessary else.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T12:55:18Z",
      "diff_hunk" : "@@ -70,6 +70,15 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    if (mapSigHashTypes.count(sighash_type)) {\n+        return mapSigHashTypes.find(sighash_type)->second;\n+    } else {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191755201",
      "id" : 191755201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTc1NTIwMQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 8,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 124388029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191755201",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191767639"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191767639"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The RPC's convention is confusing. WDYT of renaming all RPC from: \r\n- `walletcreatepsbt` to `createpartiallysignedtransaction`\r\n- `walletupdatepsbt` to `updatepartiallysignedtransaction`\r\n- `combinepsbt` to `combinepartiallysignedtransactions`\r\n- `decodepsbt` to `decodepartiallysignedtransaction`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T13:30:50Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191767639",
      "id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTc2NzYzOQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124388029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191767639",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191769857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191769857"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Unnecessary else.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T13:36:46Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191769857",
      "id" : 191769857,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTc2OTg1Nw==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 14,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124388029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191769857",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191770517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191770517"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Keep the `if` blocks consistent (with or without `{`).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T13:38:33Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we an sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wllets\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+            + HelpExampleRpc(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VSTR, UniValue::VBOOL});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Sign the transaction\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[1].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191770517",
      "id" : 191770517,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTc3MDUxNw==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 314,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124388029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191770517",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191805951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191805951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Might want `IsFullyValid()`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T15:07:22Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                {\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191805951",
      "id" : 191805951,
      "in_reply_to_id" : 191678786,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTgwNTk1MQ==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 370,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124451587,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191805951",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191818138"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191818138"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the `wallet` prefixes are helpful",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T15:39:52Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191818138",
      "id" : 191818138,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTgxODEzOA==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124466651,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191818138",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191823071"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191823071"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure, it's kind of specific to PSBT.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T15:51:31Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191823071",
      "id" : 191823071,
      "in_reply_to_id" : 191672334,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTgyMzA3MQ==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 36,
      "path" : "src/script/sign.h",
      "position" : 71,
      "pull_request_review_id" : 124472335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191823071",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191827125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191827125"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I prefer the `wallet` prefixes and expanding out `psbt` to `partiallysignedtransaction` just makes the RPC names too long IMO.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T16:02:55Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191827125",
      "id" : 191827125,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTgyNzEyNQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124477412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191827125",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191834984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191834984"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think the wallet prefixes are helpful\r\n\r\n>I prefer the wallet prefixes and expanding out psbt to partiallysignedtransaction just makes the RPC names too long IMO.\r\n\r\nWe now have several wallet RPC methods that are not prefixed with `wallet`, so IMO is an unnecessary prefix. \r\n\r\nAlso AFAIK, by the spec `PSBT` is a transaction format, so the transaction itself is a `partially signed transaction`, or `pst`, so using `psbt` as suffix somehow seems improper.\r\n\r\nGiven that, WDYT about not using the prefix `wallet`, use the `ps` (term for `partially signed`) as a transaction type, and use the suffix `transaction` (expect for `combine` because is more than one, so we use `transactions`):\r\n- `walletcreatepsbt` to `createpstransaction`\r\n- `walletupdatepsbt` to `updatepstransaction`\r\n- `combinepsbt` to `combinepstransactions`\r\n- `decodepsbt` to `decodepstransaction`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T16:27:15Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191834984",
      "id" : 191834984,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTgzNDk4NA==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124487048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191834984",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191838970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191838970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it's the other way around. Historically no RPCs had a wallet prefix, which led to a lot of confusion (e.g. gettransaction vs getrawtransaction).\n\nI'm in favor of having wallet in the name of RPCs that require a wallet to interact with.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T16:39:39Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191838970",
      "id" : 191838970,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTgzODk3MA==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124491627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191838970",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191912119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191912119"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`bip174-create`\r\n`bip174-update`\r\n`bip174-combine`\r\n`bip174-decode`\r\n\r\nUnambiguous, easily searched and semantics known to adhere to the BIP",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:29:25Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191912119",
      "id" : 191912119,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkxMjExOQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124579956,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191912119",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/413395?v=4",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "node_id" : "MDQ6VXNlcjQxMzM5NQ==",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920238"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920238"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:56:40Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920238",
      "id" : 191920238,
      "in_reply_to_id" : 191674098,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDIzOA==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 135,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124589818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920238",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920263"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:56:44Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920263",
      "id" : 191920263,
      "in_reply_to_id" : 191676655,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDI2Mw==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 300,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124589849,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920263",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920287"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:56:48Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920287",
      "id" : 191920287,
      "in_reply_to_id" : 191676954,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDI4Nw==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 337,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124589877,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920287",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920307"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:56:53Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920307",
      "id" : 191920307,
      "in_reply_to_id" : 191678066,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDMwNw==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 363,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124589902,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920307",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920347"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:57:00Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for(auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for(auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160.Compare(rs_hash160) != 0) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash.Compare(ws_sha256) != 0) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                {\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920347",
      "id" : 191920347,
      "in_reply_to_id" : 191678786,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDM0Nw==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 370,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124589939,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920347",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920486"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:57:25Z",
      "diff_hunk" : "@@ -33,6 +33,23 @@ bool TransactionSignatureCreator::CreateSig(const SigningProvider& provider, std\n     return true;\n }\n \n+bool PSBTSignatureCreator::CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    CPubKey pubkey;\n+    provider.GetPubKey(address, pubkey);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920486",
      "id" : 191920486,
      "in_reply_to_id" : 191680502,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDQ4Ng==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 7,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 124590107,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920486",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920516"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920516"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:57:31Z",
      "diff_hunk" : "@@ -305,6 +322,118 @@ struct Stacks\n };\n }\n \n+bool PSBTSigningProvider::GetCScript(const CScriptID &scriptid, CScript& script) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetCScript(scriptid, script)) {\n+            return true;\n+        }\n+    }\n+    // Look for scripts in redeem_scripts\n+    auto mi = psbt->redeem_scripts.find(scriptid);\n+    if (mi != psbt->redeem_scripts.end())\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920516",
      "id" : 191920516,
      "in_reply_to_id" : 191680953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDUxNg==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 38,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 124590143,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920516",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920546"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920546"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:57:35Z",
      "diff_hunk" : "@@ -497,9 +498,35 @@ struct PartiallySignedTransaction\n     void SanitizeForSerialization();\n };\n \n+class PSBTSignatureCreator : public MutableTransactionSignatureCreator {\n+private:\n+    std::map<CPubKey, std::vector<unsigned char>>* sigs;\n+    bool finalize_only;\n+\n+public:\n+    PSBTSignatureCreator(std::map<CPubKey, std::vector<unsigned char>>* sigs, CMutableTransaction* tx, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : MutableTransactionSignatureCreator(tx, nInIn, amountIn, nHashTypeIn), sigs(sigs) {}\n+    bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const override;\n+};\n+\n+class PSBTSigningProvider : public SigningProvider {\n+private:\n+    std::vector<SigningProvider*> providers;\n+    PartiallySignedTransaction* psbt;\n+\n+public:\n+    bool GetCScript(const CScriptID &scriptid, CScript& script) const override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    bool GetKey(const CKeyID &address, CKey& key) const override;\n+    void AddSigningProvider(SigningProvider* provider);\n+\n+    PSBTSigningProvider(PartiallySignedTransaction* psbt) : psbt(psbt) {}\n+};\n+\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n+bool SignPartiallySignedTransaction(PartiallySignedTransaction& psbt, SigningProvider* provider, int nHashType, bool finalize = false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191920546",
      "id" : 191920546,
      "in_reply_to_id" : 191682770,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMDU0Ng==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 39,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124590174,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191920546",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921147"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921147"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, yes. Fixed",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:59:46Z",
      "diff_hunk" : "@@ -91,13 +91,13 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n-    uint32_t GetUint32(int pos) const\n+    uint32_t GetUint32LE(int pos) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921147",
      "id" : 191921147,
      "in_reply_to_id" : 191683025,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMTE0Nw==",
      "original_commit_id" : "ed1a6e3ea2ed526dab76f15ec71b2f7031bd2335",
      "original_position" : 5,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 124590935,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921147",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921189"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921189"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T20:59:53Z",
      "diff_hunk" : "@@ -70,6 +70,15 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    if (mapSigHashTypes.count(sighash_type)) {\n+        return mapSigHashTypes.find(sighash_type)->second;\n+    } else {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921189",
      "id" : 191921189,
      "in_reply_to_id" : 191755201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMTE4OQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 8,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 124590984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921189",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921586"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921586"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree with @sipa and prefer to have the wallet prefix, especially because there will probably be a non-wallet version of those RPCs at some point in the future.\r\n\r\nI don't think psbt is really that ambiguous..",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T21:01:23Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921586",
      "id" : 191921586,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMTU4Ng==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124591485,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921586",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921609"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T21:01:29Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921609",
      "id" : 191921609,
      "in_reply_to_id" : 191769857,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMTYwOQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 14,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124591513,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921609",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921628"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921628"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T21:01:33Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we an sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wllets\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+            + HelpExampleRpc(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VSTR, UniValue::VBOOL});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Sign the transaction\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[1].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921628",
      "id" : 191921628,
      "in_reply_to_id" : 191770517,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMTYyOA==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 314,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124591538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921628",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921665"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921665"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-30T21:01:41Z",
      "diff_hunk" : "@@ -145,6 +145,7 @@\n     'feature_blocksdir.py',\n     'feature_config_args.py',\n     'feature_help.py',\n+    'rpc_psbt.py',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191921665",
      "id" : 191921665,
      "in_reply_to_id" : 191624853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTkyMTY2NQ==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "test/functional/test_runner.py",
      "position" : null,
      "pull_request_review_id" : 124591585,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191921665",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@dcousens I have, but I'm not sure what the third party library would really be.",
      "created_at" : "2018-05-30T21:02:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-393318266",
      "id" : 393318266,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzMxODI2Ng==",
      "updated_at" : "2018-05-30T21:02:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393318266",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191988609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191988609"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nTypo: `A_n_ structure`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T04:49:05Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191988609",
      "id" : 191988609,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk4ODYwOQ==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 38,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124669752,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191988609",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191993851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191993851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nNit: mis-aligned indentation. (remove 1 space I think?)",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T05:40:32Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191993851",
      "id" : 191993851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5Mzg1MQ==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 368,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124669752,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191993851",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191994777"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191994777"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nI think this (and other places where `Span` is used) would look less confusing if you did `s >> MakeSpan(val_bytes)`, since you are not using `value`, and it looks like the data is written to some unrelated thing (i.e. not `val_bytes`, but `value`). Not sure if that is possible though (it should be, if it isn't, but that's a separate story).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T05:48:31Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in key path\n+                        std::vector<uint32_t> keypath;\n+                        for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                            uint32_t index;\n+                            s >> index;\n+                            keypath.push_back(index);\n+                        }\n+\n+                        // Add to map\n+                        hd_keypaths.emplace(pubkey, keypath);\n+                    } else {\n+                        // Read in the sighash type\n+                        s >> input.sighash_type;\n+                    }\n+                    break;\n+                // Number of inputs and input index\n+                case PSBT_NUM_IN_VIN:\n+                    if (in_globals) {\n+                        num_ins = ReadCompactSize(s);\n+                    } else {\n+                        // Make sure that we are using inout indexes or this is the first input\n+                        if (!use_in_index && separators != 1) {\n+                            throw std::ios_base::failure(\"Input indexes being used but an input does not provide its index\");\n+                        }\n+\n+                        input.index = ReadCompactSize(s);\n+                        use_in_index = true;\n+                        input.use_in_index = true;\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default:\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    Span<unsigned char> value = MakeSpan(val_bytes);\n+                    s >> value;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191994777",
      "id" : 191994777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NDc3Nw==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 413,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124669752,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191994777",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995031"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks very generic, but I have no strong feelings about it (commit still has typo btw).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T05:50:44Z",
      "diff_hunk" : "@@ -68,6 +71,432 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995031",
      "id" : 191995031,
      "in_reply_to_id" : 191672334,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NTAzMQ==",
      "original_commit_id" : "c3d7c855d239943fb85a2fce1c5dae1a3f999a71",
      "original_position" : 36,
      "path" : "src/script/sign.h",
      "position" : 71,
      "pull_request_review_id" : 124669752,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995031",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995129"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nTypo: \"A_n_ structure\"",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T05:51:37Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995129",
      "id" : 191995129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NTEyOQ==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 38,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995129",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995286"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995286"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nNit: Mis-aligned indentation (delete 1 space?).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T05:53:03Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995286",
      "id" : 191995286,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NTI4Ng==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 368,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995286",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Implement PSBT structures and un/serliazation methods per BIP 174\":\r\n\r\nThis is a little confusing because `value` is not actually used, even though it is streamed to. Can this simply be\r\n```C++\r\ns >> MakeSpan(val_bytes);\r\n```\r\n?\r\n\r\n(Several other places where this is done as well, IIRC.)",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T05:54:31Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in key path\n+                        std::vector<uint32_t> keypath;\n+                        for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                            uint32_t index;\n+                            s >> index;\n+                            keypath.push_back(index);\n+                        }\n+\n+                        // Add to map\n+                        hd_keypaths.emplace(pubkey, keypath);\n+                    } else {\n+                        // Read in the sighash type\n+                        s >> input.sighash_type;\n+                    }\n+                    break;\n+                // Number of inputs and input index\n+                case PSBT_NUM_IN_VIN:\n+                    if (in_globals) {\n+                        num_ins = ReadCompactSize(s);\n+                    } else {\n+                        // Make sure that we are using inout indexes or this is the first input\n+                        if (!use_in_index && separators != 1) {\n+                            throw std::ios_base::failure(\"Input indexes being used but an input does not provide its index\");\n+                        }\n+\n+                        input.index = ReadCompactSize(s);\n+                        use_in_index = true;\n+                        input.use_in_index = true;\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default:\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    Span<unsigned char> value = MakeSpan(val_bytes);\n+                    s >> value;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191995420",
      "id" : 191995420,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NTQyMA==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 413,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191995420",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191996074"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191996074"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Create RPCs for PSBT\":\r\n\r\nIndentation.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T06:00:30Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191996074",
      "id" : 191996074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NjA3NA==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 25,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191996074",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191997916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191997916"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Create RPCs for PSBT\":\r\n\r\nTypo: an -> can",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T06:15:46Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we an sign for.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191997916",
      "id" : 191997916,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5NzkxNg==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 252,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191997916",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191998160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191998160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Create RPCs for PSBT\":\r\n\r\nTypo: `wllets`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T06:17:27Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we an sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wllets\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191998160",
      "id" : 191998160,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5ODE2MA==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 267,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191998160",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191998830"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191998830"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Create RPCs for PSBT\":\r\n\r\nAdd space before `)`. Also some inconsistency (other methods do `(x y)` while this does `( x y)`.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T06:22:29Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r191998830",
      "id" : 191998830,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTk5ODgzMA==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 250,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124677667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/191998830",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Sorry, some comments are duplicate (I thought I lost my review and re-did).",
      "created_at" : "2018-05-31T06:26:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-393420639",
      "id" : 393420639,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzQyMDYzOQ==",
      "updated_at" : "2018-05-31T06:26:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393420639",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192105577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192105577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should that be mentioned in the spec, then?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T13:50:31Z",
      "diff_hunk" : "@@ -3520,6 +3520,336 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n     return response;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= BIP32_HARDENED_KEY_LIMIT;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hdMasterKeyID, key);\n+        CExtKey masterKey;\n+        masterKey.SetMaster(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192105577",
      "id" : 192105577,
      "in_reply_to_id" : 169386999,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEwNTU3Nw==",
      "original_commit_id" : "03145519c72cd0a737f7fbd3a7b85473a45a8b46",
      "original_position" : 171,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 168,
      "pull_request_review_id" : 124813244,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192105577",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192107741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192107741"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: avoid double lookup\r\n```c++\r\nauto it = mapSigHashTypes.find(sighash_type);\r\nif (it != mapSigHashTypes.end()) {\r\n    return it->second;\r\n}\r\n```",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T13:56:55Z",
      "diff_hunk" : "@@ -70,6 +70,14 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    if (mapSigHashTypes.count(sighash_type)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192107741",
      "id" : 192107741,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEwNzc0MQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 6,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192107741",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192108063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192108063"
         }
      },
      "author_association" : "MEMBER",
      "body" : "+1 for wallet prefix. No naming opinions otherwise.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T13:57:57Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192108063",
      "id" : 192108063,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEwODA2Mw==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192108063",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192108675"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192108675"
         }
      },
      "author_association" : "MEMBER",
      "body" : "- Any reason to not simply return the string here? It's always cleared, anyhow. \"Write\" implies append to me otherwise.\r\n- Function name is in snakecase, `WriteHDKeypath` would be more akin to the rest of our style.\r\n- Could  it be static?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T13:59:42Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192108675",
      "id" : 192108675,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEwODY3NQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 4,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192108675",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192109932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192109932"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This wording is a bit confusing to me.\r\nMaybe \"The decoded network-serialized transaction. The layout is the same as the output of decoderawtransaction.\"?\r\nAlso you forgot a `\\n`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T14:03:30Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192109932",
      "id" : 192109932,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEwOTkzMg==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 35,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192109932",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192110391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192110391"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Help message capitalization inconsistent for this, and \"address\" below.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T14:04:50Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192110391",
      "id" : 192110391,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjExMDM5MQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 42,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192110391",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192120693"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192120693"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would make sense to factor this out, to a function that converts a uint32_t to a LE vector of uint8_t.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T14:34:21Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"\n+        \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+        \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+        \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+        \"          \\\"address\\\"           (string) bitcoin address\\n\"\n+        \"           ,...\\n\"\n+        \"        ],\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+        \"      \\\"script\\\" : {            (json object)\\n\"\n+        \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+        \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+        \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+        \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+        \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+        \"        ...\\n\"\n+        \"      },\\n\"\n+        \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+        \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+        \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+        \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+        \"          \\\"asm\\\" : \\\"asm\\\",            (string) the asm\\n\"\n+        \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+        \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+        \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+        \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+        \"            \\\"address\\\"               (string) bitcoin address\\n\"\n+        \"            ,...\\n\"\n+        \"          ]\\n\"\n+        \"        }\\n\"\n+        \"      },\\n\"\n+        \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+        \"        {\\n\"\n+        \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+        \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+        \"        }\\n\"\n+        \"        ,...\\n\"\n+        \"      ]\\n\"\n+        \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+        \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ]\\n\"\n+        \"}\\n\"\n+\n+        \"\\nExamples:\\n\"\n+        + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+        + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Redeem scripts\n+    if (!psbtx.redeem_scripts.empty()) {\n+        UniValue redeem_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.redeem_scripts) {\n+            UniValue redeem_script(UniValue::VOBJ);\n+            redeem_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            redeem_script.pushKV(\"script\", r);\n+\n+            redeem_scripts.push_back(redeem_script);\n+        }\n+        result.pushKV(\"redeem_scripts\", redeem_scripts);\n+    }\n+\n+    // Witness Scripts\n+    if (!psbtx.witness_scripts.empty()) {\n+        UniValue witness_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.witness_scripts) {\n+            UniValue witness_script(UniValue::VOBJ);\n+            witness_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            witness_script.pushKV(\"script\", r);\n+\n+            witness_scripts.push_back(witness_script);\n+        }\n+        result.pushKV(\"witness_scripts\", witness_scripts);\n+    }\n+\n+    // keypaths\n+    if (!psbtx.hd_keypaths.empty()) {\n+        UniValue keypaths(UniValue::VARR);\n+        for (auto entry : psbtx.hd_keypaths) {\n+            UniValue keypath(UniValue::VOBJ);\n+            keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+            uint32_t fingerprint = entry.second.at(0);\n+            std::vector<uint8_t> fingerprint_bytes;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192120693",
      "id" : 192120693,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEyMDY5Mw==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 178,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192120693",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192123288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192123288"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`}` on same line as `catch`",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T14:41:39Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"\n+        \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+        \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+        \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+        \"          \\\"address\\\"           (string) bitcoin address\\n\"\n+        \"           ,...\\n\"\n+        \"        ],\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+        \"      \\\"script\\\" : {            (json object)\\n\"\n+        \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+        \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+        \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+        \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+        \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+        \"        ...\\n\"\n+        \"      },\\n\"\n+        \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+        \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+        \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+        \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+        \"          \\\"asm\\\" : \\\"asm\\\",            (string) the asm\\n\"\n+        \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+        \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+        \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+        \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+        \"            \\\"address\\\"               (string) bitcoin address\\n\"\n+        \"            ,...\\n\"\n+        \"          ]\\n\"\n+        \"        }\\n\"\n+        \"      },\\n\"\n+        \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+        \"        {\\n\"\n+        \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+        \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+        \"        }\\n\"\n+        \"        ,...\\n\"\n+        \"      ]\\n\"\n+        \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+        \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ]\\n\"\n+        \"}\\n\"\n+\n+        \"\\nExamples:\\n\"\n+        + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+        + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192123288",
      "id" : 192123288,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEyMzI4OA==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 124,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192123288",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192124131"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192124131"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do you really intend to update the `psbtx` in place here?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T14:44:06Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"\n+        \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+        \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+        \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+        \"          \\\"address\\\"           (string) bitcoin address\\n\"\n+        \"           ,...\\n\"\n+        \"        ],\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+        \"      \\\"script\\\" : {            (json object)\\n\"\n+        \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+        \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+        \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+        \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+        \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+        \"        ...\\n\"\n+        \"      },\\n\"\n+        \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+        \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+        \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+        \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+        \"          \\\"asm\\\" : \\\"asm\\\",            (string) the asm\\n\"\n+        \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+        \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+        \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+        \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+        \"            \\\"address\\\"               (string) bitcoin address\\n\"\n+        \"            ,...\\n\"\n+        \"          ]\\n\"\n+        \"        }\\n\"\n+        \"      },\\n\"\n+        \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+        \"        {\\n\"\n+        \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+        \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+        \"        }\\n\"\n+        \"        ,...\\n\"\n+        \"      ]\\n\"\n+        \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+        \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ]\\n\"\n+        \"}\\n\"\n+\n+        \"\\nExamples:\\n\"\n+        + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+        + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Redeem scripts\n+    if (!psbtx.redeem_scripts.empty()) {\n+        UniValue redeem_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.redeem_scripts) {\n+            UniValue redeem_script(UniValue::VOBJ);\n+            redeem_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            redeem_script.pushKV(\"script\", r);\n+\n+            redeem_scripts.push_back(redeem_script);\n+        }\n+        result.pushKV(\"redeem_scripts\", redeem_scripts);\n+    }\n+\n+    // Witness Scripts\n+    if (!psbtx.witness_scripts.empty()) {\n+        UniValue witness_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.witness_scripts) {\n+            UniValue witness_script(UniValue::VOBJ);\n+            witness_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            witness_script.pushKV(\"script\", r);\n+\n+            witness_scripts.push_back(witness_script);\n+        }\n+        result.pushKV(\"witness_scripts\", witness_scripts);\n+    }\n+\n+    // keypaths\n+    if (!psbtx.hd_keypaths.empty()) {\n+        UniValue keypaths(UniValue::VARR);\n+        for (auto entry : psbtx.hd_keypaths) {\n+            UniValue keypath(UniValue::VOBJ);\n+            keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+            uint32_t fingerprint = entry.second.at(0);\n+            std::vector<uint8_t> fingerprint_bytes;\n+            fingerprint_bytes.push_back(fingerprint);\n+            fingerprint_bytes.push_back(fingerprint >> 8);\n+            fingerprint_bytes.push_back(fingerprint >> 16);\n+            fingerprint_bytes.push_back(fingerprint >> 24);\n+            keypath.pushKV(\"master_fingerprint\", HexStr(fingerprint_bytes));\n+\n+            std::string keypath_str;\n+            entry.second.erase(entry.second.begin());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192124131",
      "id" : 192124131,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjEyNDEzMQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 186,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124815960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192124131",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200553"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:48:41Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200553",
      "id" : 192200553,
      "in_reply_to_id" : 191988609,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDU1Mw==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 38,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124930544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200553",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200572"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200572"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:48:45Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200572",
      "id" : 192200572,
      "in_reply_to_id" : 191993851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDU3Mg==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 368,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124930566,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200572",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200655"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done here and everywhere else this happens.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:03Z",
      "diff_hunk" : "@@ -68,6 +71,434 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** An structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.first));\n+                    s << sig_pair.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            Span<unsigned char> key_data = MakeSpan(key);\n+            s >> key_data;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        Span<unsigned char> redeemscript_data = MakeSpan(redeemscript_bytes);\n+                        s >> redeemscript_data;\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        Span<unsigned char> witnessscript_data = MakeSpan(witnessscript_bytes);\n+                        s >> witnessscript_data;\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        Span<unsigned char> sig_data = MakeSpan(sig);\n+                        s >> sig_data;\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey, sig);\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                         if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in key path\n+                        std::vector<uint32_t> keypath;\n+                        for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                            uint32_t index;\n+                            s >> index;\n+                            keypath.push_back(index);\n+                        }\n+\n+                        // Add to map\n+                        hd_keypaths.emplace(pubkey, keypath);\n+                    } else {\n+                        // Read in the sighash type\n+                        s >> input.sighash_type;\n+                    }\n+                    break;\n+                // Number of inputs and input index\n+                case PSBT_NUM_IN_VIN:\n+                    if (in_globals) {\n+                        num_ins = ReadCompactSize(s);\n+                    } else {\n+                        // Make sure that we are using inout indexes or this is the first input\n+                        if (!use_in_index && separators != 1) {\n+                            throw std::ios_base::failure(\"Input indexes being used but an input does not provide its index\");\n+                        }\n+\n+                        input.index = ReadCompactSize(s);\n+                        use_in_index = true;\n+                        input.use_in_index = true;\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default:\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    Span<unsigned char> value = MakeSpan(val_bytes);\n+                    s >> value;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200655",
      "id" : 192200655,
      "in_reply_to_id" : 191994777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDY1NQ==",
      "original_commit_id" : "b408bfef3d990f1863a964a1e6965f8c471af33b",
      "original_position" : 413,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 124930662,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200655",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200696"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200696"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:11Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200696",
      "id" : 192200696,
      "in_reply_to_id" : 191996074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDY5Ng==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 25,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124930714,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200696",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200715"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200715"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:15Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we an sign for.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200715",
      "id" : 192200715,
      "in_reply_to_id" : 191997916,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDcxNQ==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 252,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124930738,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200715",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200735"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:19Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we an sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wllets\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200735",
      "id" : 192200735,
      "in_reply_to_id" : 191998160,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDczNQ==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 267,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124930760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200735",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200760"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200760"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:24Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200760",
      "id" : 192200760,
      "in_reply_to_id" : 191998830,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDc2MA==",
      "original_commit_id" : "78dadeac8586f2c4a51fe8bd2ef61e70e2c85752",
      "original_position" : 250,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 124930794,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200760",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200817"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200817"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:36Z",
      "diff_hunk" : "@@ -70,6 +70,14 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    if (mapSigHashTypes.count(sighash_type)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200817",
      "id" : 192200817,
      "in_reply_to_id" : 192107741,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDgxNw==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 6,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 124930870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200817",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:41Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200843",
      "id" : 192200843,
      "in_reply_to_id" : 192108675,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDg0Mw==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 4,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124930907,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200843",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200869"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:46Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200869",
      "id" : 192200869,
      "in_reply_to_id" : 192109932,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDg2OQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 35,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124930938,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200869",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200892"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:50Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200892",
      "id" : 192200892,
      "in_reply_to_id" : 192110391,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDg5Mg==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 42,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124930961,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200892",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200912"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:55Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"\n+        \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+        \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+        \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+        \"          \\\"address\\\"           (string) bitcoin address\\n\"\n+        \"           ,...\\n\"\n+        \"        ],\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+        \"      \\\"script\\\" : {            (json object)\\n\"\n+        \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+        \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+        \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+        \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+        \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+        \"        ...\\n\"\n+        \"      },\\n\"\n+        \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+        \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+        \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+        \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+        \"          \\\"asm\\\" : \\\"asm\\\",            (string) the asm\\n\"\n+        \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+        \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+        \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+        \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+        \"            \\\"address\\\"               (string) bitcoin address\\n\"\n+        \"            ,...\\n\"\n+        \"          ]\\n\"\n+        \"        }\\n\"\n+        \"      },\\n\"\n+        \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+        \"        {\\n\"\n+        \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+        \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+        \"        }\\n\"\n+        \"        ,...\\n\"\n+        \"      ]\\n\"\n+        \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+        \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ]\\n\"\n+        \"}\\n\"\n+\n+        \"\\nExamples:\\n\"\n+        + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+        + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Redeem scripts\n+    if (!psbtx.redeem_scripts.empty()) {\n+        UniValue redeem_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.redeem_scripts) {\n+            UniValue redeem_script(UniValue::VOBJ);\n+            redeem_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            redeem_script.pushKV(\"script\", r);\n+\n+            redeem_scripts.push_back(redeem_script);\n+        }\n+        result.pushKV(\"redeem_scripts\", redeem_scripts);\n+    }\n+\n+    // Witness Scripts\n+    if (!psbtx.witness_scripts.empty()) {\n+        UniValue witness_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.witness_scripts) {\n+            UniValue witness_script(UniValue::VOBJ);\n+            witness_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            witness_script.pushKV(\"script\", r);\n+\n+            witness_scripts.push_back(witness_script);\n+        }\n+        result.pushKV(\"witness_scripts\", witness_scripts);\n+    }\n+\n+    // keypaths\n+    if (!psbtx.hd_keypaths.empty()) {\n+        UniValue keypaths(UniValue::VARR);\n+        for (auto entry : psbtx.hd_keypaths) {\n+            UniValue keypath(UniValue::VOBJ);\n+            keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+            uint32_t fingerprint = entry.second.at(0);\n+            std::vector<uint8_t> fingerprint_bytes;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200912",
      "id" : 192200912,
      "in_reply_to_id" : 192120693,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDkxMg==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 178,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124930991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200912",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200925"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:49:59Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"\n+        \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+        \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+        \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+        \"          \\\"address\\\"           (string) bitcoin address\\n\"\n+        \"           ,...\\n\"\n+        \"        ],\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+        \"      \\\"script\\\" : {            (json object)\\n\"\n+        \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+        \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+        \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+        \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+        \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+        \"        ...\\n\"\n+        \"      },\\n\"\n+        \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+        \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+        \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+        \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+        \"          \\\"asm\\\" : \\\"asm\\\",            (string) the asm\\n\"\n+        \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+        \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+        \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+        \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+        \"            \\\"address\\\"               (string) bitcoin address\\n\"\n+        \"            ,...\\n\"\n+        \"          ]\\n\"\n+        \"        }\\n\"\n+        \"      },\\n\"\n+        \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+        \"        {\\n\"\n+        \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+        \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+        \"        }\\n\"\n+        \"        ,...\\n\"\n+        \"      ]\\n\"\n+        \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+        \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ]\\n\"\n+        \"}\\n\"\n+\n+        \"\\nExamples:\\n\"\n+        + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+        + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192200925",
      "id" : 192200925,
      "in_reply_to_id" : 192123288,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMDkyNQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 124,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124931016,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192200925",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192201005"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192201005"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Since entry is not a reference or a pointer, `psbtx` isn't actually modified.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-05-31T18:50:15Z",
      "diff_hunk" : "@@ -1259,6 +1259,422 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+void write_hd_keypath(std::vector<uint32_t>& keypath, std::string& keypath_str)\n+{\n+    keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+    throw std::runtime_error(\n+        \"decodepsbt \\\"hexstring\\\"\\n\"\n+        \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+        \"\\nArguments:\\n\"\n+        \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+        \"\\nResult:\\n\"\n+        \"{\\n\"\n+        \"  \\\"tx\\\" : {                   (json object) The decoded network serialized transaction\\n\"\n+        \"    ...                                      decoding is the same as decoderawtransaction's.\"\n+        \"  },\\n\"\n+        \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+        \"      \\\"script\\\" : {           (json object)\\n\"\n+        \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+        \"        \\\"hex\\\":\\\"hex\\\",         (string) hex encoded public key\\n\"\n+        \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+        \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+        \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+        \"          \\\"address\\\"           (string) bitcoin address\\n\"\n+        \"           ,...\\n\"\n+        \"        ],\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+        \"      \\\"script\\\" : {            (json object)\\n\"\n+        \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+        \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+        \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+        \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+        \"      }\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ],\\n\"\n+        \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+        \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+        \"    {\\n\"\n+        \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+        \"        ...\\n\"\n+        \"      },\\n\"\n+        \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+        \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+        \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+        \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+        \"          \\\"asm\\\" : \\\"asm\\\",            (string) the asm\\n\"\n+        \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+        \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+        \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+        \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+        \"            \\\"address\\\"               (string) bitcoin address\\n\"\n+        \"            ,...\\n\"\n+        \"          ]\\n\"\n+        \"        }\\n\"\n+        \"      },\\n\"\n+        \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+        \"        {\\n\"\n+        \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+        \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+        \"        }\\n\"\n+        \"        ,...\\n\"\n+        \"      ]\\n\"\n+        \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+        \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+        \"    }\\n\"\n+        \"    ,...\\n\"\n+        \"  ]\\n\"\n+        \"}\\n\"\n+\n+        \"\\nExamples:\\n\"\n+        + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+        + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Redeem scripts\n+    if (!psbtx.redeem_scripts.empty()) {\n+        UniValue redeem_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.redeem_scripts) {\n+            UniValue redeem_script(UniValue::VOBJ);\n+            redeem_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            redeem_script.pushKV(\"script\", r);\n+\n+            redeem_scripts.push_back(redeem_script);\n+        }\n+        result.pushKV(\"redeem_scripts\", redeem_scripts);\n+    }\n+\n+    // Witness Scripts\n+    if (!psbtx.witness_scripts.empty()) {\n+        UniValue witness_scripts(UniValue::VARR);\n+        for (auto& entry : psbtx.witness_scripts) {\n+            UniValue witness_script(UniValue::VOBJ);\n+            witness_script.pushKV(\"hash\", HexStr(entry.first));\n+\n+            CScript script(entry.second.begin(), entry.second.end());\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(script, r, true);\n+            witness_script.pushKV(\"script\", r);\n+\n+            witness_scripts.push_back(witness_script);\n+        }\n+        result.pushKV(\"witness_scripts\", witness_scripts);\n+    }\n+\n+    // keypaths\n+    if (!psbtx.hd_keypaths.empty()) {\n+        UniValue keypaths(UniValue::VARR);\n+        for (auto entry : psbtx.hd_keypaths) {\n+            UniValue keypath(UniValue::VOBJ);\n+            keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+            uint32_t fingerprint = entry.second.at(0);\n+            std::vector<uint8_t> fingerprint_bytes;\n+            fingerprint_bytes.push_back(fingerprint);\n+            fingerprint_bytes.push_back(fingerprint >> 8);\n+            fingerprint_bytes.push_back(fingerprint >> 16);\n+            fingerprint_bytes.push_back(fingerprint >> 24);\n+            keypath.pushKV(\"master_fingerprint\", HexStr(fingerprint_bytes));\n+\n+            std::string keypath_str;\n+            entry.second.erase(entry.second.begin());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192201005",
      "id" : 192201005,
      "in_reply_to_id" : 192124131,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjIwMTAwNQ==",
      "original_commit_id" : "30c0cf203e8c82798e047ab4b8805638612421a5",
      "original_position" : 186,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 124931107,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192201005",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Also rebased to (hopefully) fix the travis error\r\n\r\n~~edit: I have no idea why travis is failing. Builds without error for me..~~\r\nedit2: I didn't rebase far enough",
      "created_at" : "2018-05-31T19:12:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-393645080",
      "id" : 393645080,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5MzY0NTA4MA==",
      "updated_at" : "2018-05-31T20:21:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/393645080",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192675166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192675166"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think it's the other way around. Historically no RPCs had a wallet prefix, which led to a lot of confusion (e.g. gettransaction vs getrawtransaction).\r\n\r\nAgree on that. If all methods will be prefixed LGTM.\r\n\r\n",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T09:17:32Z",
      "diff_hunk" : "@@ -110,6 +110,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletupdatepsbt\", 2, \"psbtformat\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192675166",
      "id" : 192675166,
      "in_reply_to_id" : 191767639,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjY3NTE2Ng==",
      "original_commit_id" : "92cca779d6604762c0e2ee4bcd61dc17502e12f4",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 125492858,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192675166",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192902270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192902270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit,\r\n```cpp\r\nconst auto& it = ",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T22:48:34Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192902270",
      "id" : 192902270,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkwMjI3MA==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 6,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 125768353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192902270",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192902439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192902439"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit\r\n```cpp\r\nif (it == mapSigHashTypes.end()) return \"\";\r\nreturn it->second;",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T22:49:39Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);\n+    if (it != mapSigHashTypes.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192902439",
      "id" : 192902439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkwMjQzOQ==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 7,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 125768353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192902439",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192903536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192903536"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/psbt/PSBT?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T22:56:06Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info )\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192903536",
      "id" : 192903536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkwMzUzNg==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 251,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 125768353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192903536",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192903999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192903999"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit\r\n```cpp\r\n} catch (...) {",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T22:58:45Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info )\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wallets\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+            + HelpExampleRpc(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VSTR, UniValue::VBOOL});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192903999",
      "id" : 192903999,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkwMzk5OQ==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 296,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 125768353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192903999",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192904312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192904312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe this can be removed, `get_str()` below will validate it.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T23:00:37Z",
      "diff_hunk" : "@@ -1259,6 +1259,415 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"hexstring\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+            + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192904312",
      "id" : 192904312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkwNDMxMg==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 111,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 145,
      "pull_request_review_id" : 125768353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192904312",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192904970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192904970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use `ParseHexV` instead of `IsHex` + `ParseHex`?",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-04T23:04:50Z",
      "diff_hunk" : "@@ -1259,6 +1259,415 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"hexstring\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+            + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192904970",
      "id" : 192904970,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkwNDk3MA==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 118,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 125768353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192904970",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192914383"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192914383"
         }
      },
      "author_association" : "MEMBER",
      "body" : "First check?\r\n```cpp\r\nif (a.tx.vin.size() != b.tx.vin.size() || a.tx.vout.size() != b.tx.vout.size()) return false;\r\n```\r\nOtherwise this allows `b` to have more in/outputs and if `b` has fewer then it oob.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T00:06:28Z",
      "diff_hunk" : "@@ -61,6 +64,429 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192914383",
      "id" : 192914383,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjkxNDM4Mw==",
      "original_commit_id" : "446731a50c20ddb5c6a5544d507153dea3edd1c6",
      "original_position" : 76,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 125782495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192914383",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945767"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:58:37Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945767",
      "id" : 192945767,
      "in_reply_to_id" : 192902270,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTc2Nw==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 6,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 125819103,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945767",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945785"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945785"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:58:42Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);\n+    if (it != mapSigHashTypes.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945785",
      "id" : 192945785,
      "in_reply_to_id" : 192902439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTc4NQ==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 7,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 125819122,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945785",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945792"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:58:46Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info )\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945792",
      "id" : 192945792,
      "in_reply_to_id" : 192903536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTc5Mg==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 251,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 125819129,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945792",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945795"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:58:50Z",
      "diff_hunk" : "@@ -4292,6 +4292,408 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        for (auto& c : item) {\n+            if (!std::isdigit(c)) {\n+                return false;\n+            }\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    pwallet->GetPubKey(keyID, vchPubKey);\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    if (!meta.hdKeypath.empty()) {\n+        std::vector<uint32_t> keypath;\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), masterKey.key.GetPubKey().GetID().GetUint32LE(0));\n+        hd_keypaths.emplace(vchPubKey, keypath);\n+    }\n+}\n+\n+void fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, bool include_output_info)\n+{\n+    // Get all of the previous transactions\n+    bool psbtx_blank = psbtx.IsNull();\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PartiallySignedInput input;\n+        if (!psbtx_blank) {\n+            input = psbtx.inputs.at(i);\n+        }\n+\n+        // If this input is not empty, skip it\n+        if (!psbtx_blank && (!input.IsNull() || txin.scriptSig.empty() || txin.scriptWitness.IsNull())) {\n+            continue;\n+        }\n+\n+        uint256 txhash = txin.prevout.hash;\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        if (!pwallet->mapWallet.count(txhash)) {\n+            if (psbtx_blank) {\n+                psbtx.inputs.push_back(input);\n+            }\n+            continue;\n+        }\n+        const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+        const CTransaction& ctx = *wtx.tx;\n+\n+        // Get scriptpubkey and check for redeemScript or witnessscript\n+        CTxOut prevout = ctx.vout[txin.prevout.n];\n+        txnouttype type;\n+        std::vector<std::vector<unsigned char>> solns;\n+        Solver(prevout.scriptPubKey, type, solns);\n+        // Get script hashes\n+        if (type == TX_SCRIPTHASH) {\n+            // get the hash and find it in the wallet.\n+            CScript redeem_script;\n+            uint160 hash(solns[0]);\n+            pwallet->GetCScript(CScriptID(hash), redeem_script);\n+\n+            // put redeem_script in map\n+            psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+            // Now check whether the redeem_script is a witness script\n+            solns.clear();\n+            Solver(redeem_script, type, solns);\n+        }\n+        // Get witness scripts\n+        bool witness = false;\n+        if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+            witness = true;\n+            // Get the hash from the solver return\n+            uint160 hash;\n+            CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+            // Lookup hash from wallet\n+            CScript witness_script;\n+            pwallet->GetCScript(CScriptID(hash), witness_script);\n+\n+            // Put witness script in map\n+            uint256 hash256(solns[0]);\n+            psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+            // Decode the witness script\n+            solns.clear();\n+            Solver(witness_script, type, solns);\n+        }\n+        // Get public keys if hd is enabled\n+        if (pwallet->IsHDEnabled()) {\n+            if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                uint160 hash(solns[0]);\n+                CKeyID keyID(hash);\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_PUBKEY) {\n+                CPubKey vchPubKey(solns[0]);\n+                CKeyID keyID = vchPubKey.GetID();\n+                add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+            } else if (type == TX_MULTISIG) {\n+                for (auto& soln : solns) {\n+                    CPubKey vchPubKey(soln);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                }\n+            }\n+        }\n+\n+        // Put the witness utxo for witness outputs\n+        if (witness || type == TX_WITNESS_V0_KEYHASH || type == TX_WITNESS_V0_SCRIPTHASH || type == TX_WITNESS_UNKNOWN) {\n+            // Put the witness CTxOut in the input\n+            input.witness_utxo = prevout;\n+        }\n+        // Not witness, put non witness utxo\n+        else {\n+            input.non_witness_utxo = wtx.tx;\n+        }\n+\n+        if (psbtx_blank) {\n+            // Add to inputs\n+            psbtx.inputs.push_back(input);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    if (include_output_info) {\n+        for (const CTxOut& out : txConst->vout) {\n+            // Get scriptpubkey and check for redeemScript or witnessscript\n+            txnouttype type;\n+            std::vector<std::vector<unsigned char>> solns;\n+            Solver(out.scriptPubKey, type, solns);\n+            // Get script hashes\n+            if (type == TX_SCRIPTHASH) {\n+                // get the hash and find it in the wallet.\n+                CScript redeem_script;\n+                uint160 hash(solns[0]);\n+                if (!pwallet->GetCScript(CScriptID(hash), redeem_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // put redeem_script in map\n+                psbtx.redeem_scripts.emplace(hash, redeem_script);\n+\n+                // Now check whether the redeem_script is a witness script\n+                solns.clear();\n+                Solver(redeem_script, type, solns);\n+            }\n+            // Get witness scripts\n+            if (type == TX_WITNESS_V0_SCRIPTHASH) {\n+                // Get the hash from the solver return\n+                uint160 hash;\n+                CRIPEMD160().Write(&solns[0][0], solns[0].size()).Finalize(hash.begin());\n+\n+                // Lookup hash from wallet\n+                CScript witness_script;\n+                if (!pwallet->GetCScript(CScriptID(hash), witness_script)) {\n+                    // We don't have this script, skip it\n+                    continue;\n+                }\n+\n+                // Put witness script in map\n+                uint256 hash256(solns[0]);\n+                psbtx.witness_scripts.emplace(hash256, witness_script);\n+\n+                // Decode the witness script\n+                solns.clear();\n+                Solver(witness_script, type, solns);\n+            }\n+            // Get public keys if hd is enabled\n+            if (pwallet->IsHDEnabled()) {\n+                if (type == TX_PUBKEYHASH || type == TX_WITNESS_V0_KEYHASH) {\n+                    uint160 hash(solns[0]);\n+                    CKeyID keyID(hash);\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_PUBKEY) {\n+                    CPubKey vchPubKey(solns[0]);\n+                    CKeyID keyID = vchPubKey.GetID();\n+                    add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                } else if (type == TX_MULTISIG) {\n+                    for (auto& soln : solns) {\n+                        CPubKey vchPubKey(soln);\n+                        CKeyID keyID = vchPubKey.GetID();\n+                        add_keypath_to_map(pwallet, keyID, psbtx.hd_keypaths);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+UniValue walletupdatepsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletupdatepsbt \\\"hexstring\\\" ( sighashtype psbtformat include_output_info )\\n\"\n+            \"\\nUpdate a psbt with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"              (string, required) The transaction hex string\\n\"\n+            \"2. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"3. \\\"psbtformat\\\"              (boolean, optional, default=false) If true, return the complete transaction \\n\"\n+            \"                             in the PSBT format. Otherwise complete transactions will be in normal network serialization.\\n\"\n+            \"4. \\\"include_output_info\\\"     (boolean, optional, default=false) If true, returns the PSBT with the redeem scripts, witness\\n\"\n+            \"                             scripts, and bip32 keypaths of the outputs if they are available. This is useful for hardware wallets\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+            + HelpExampleRpc(\"walletupdatepsbt\", \"\\\"myhex\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VSTR, UniValue::VBOOL});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945795",
      "id" : 192945795,
      "in_reply_to_id" : 192903999,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTc5NQ==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 296,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 125819134,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945795",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945810"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945810"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't see the harm in leaving it.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:59:00Z",
      "diff_hunk" : "@@ -1259,6 +1259,415 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"hexstring\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+            + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945810",
      "id" : 192945810,
      "in_reply_to_id" : 192904312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTgxMA==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 111,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 145,
      "pull_request_review_id" : 125819153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945810",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945816"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945816"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:59:04Z",
      "diff_hunk" : "@@ -1259,6 +1259,415 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"hexstring\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"redeem_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",       (string) The hash160 of the redeem script\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"witness_scripts\\\" : [       (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"hash\\\" : \\\"hash\\\",        (string) The sha256 of the witness script\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  \\\"inputs_provided\\\" : n,       (numeric, optional) The number of inputs provided in the PSBT\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"n\\\" : n,                    (numeric) index\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) the hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"index\\\" : n                          (numeric) The input index of this input\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+            + HelpExampleRpc(\"decodepsbt\", \"\\\"hexstring\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    if (!IsHex(request.params[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, not hex\");\n+    }\n+    std::vector<unsigned char> txData(ParseHex(request.params[0].get_str()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945816",
      "id" : 192945816,
      "in_reply_to_id" : 192904970,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTgxNg==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 118,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 125819164,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945816",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945823"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T04:59:08Z",
      "diff_hunk" : "@@ -61,6 +64,429 @@ struct SignatureData {\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CPubKey, std::vector<unsigned char>> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r192945823",
      "id" : 192945823,
      "in_reply_to_id" : 192914383,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mjk0NTgyMw==",
      "original_commit_id" : "446731a50c20ddb5c6a5544d507153dea3edd1c6",
      "original_position" : 76,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 125819171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/192945823",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Have you thought of splitting it?\r\n\r\nSplitting into what components? All of it kind of goes together.",
      "created_at" : "2018-06-05T04:59:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-394582055",
      "id" : 394582055,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NDU4MjA1NQ==",
      "updated_at" : "2018-06-05T04:59:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/394582055",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193014272"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193014272"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Keep the code format consistent (other places without new lines before `return`). \r\n\r\nIMHO we should have some set of rules for code formatting (maybe a linter would be nice).",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T09:57:18Z",
      "diff_hunk" : "@@ -304,6 +323,119 @@ struct Stacks\n };\n }\n \n+bool PSBTSigningProvider::GetCScript(const CScriptID &scriptid, CScript& script) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetCScript(scriptid, script)) {\n+            return true;\n+        }\n+    }\n+    // Look for scripts in redeem_scripts\n+    auto mi = psbt->redeem_scripts.find(scriptid);\n+    if (mi != psbt->redeem_scripts.end()) {\n+        script = (*mi).second;\n+        return true;\n+    }\n+    // Look for scripts in witness_scripts\n+    for (auto& it : psbt->witness_scripts) {\n+        if (CScriptID(it.second) == scriptid) {\n+            script = it.second;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+bool PSBTSigningProvider::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetPubKey(address, vchPubKeyOut)) {\n+            return true;\n+        }\n+    }\n+    // Look for pubkey in hd_keypaths\n+    for (auto& it : psbt->hd_keypaths) {\n+        if (it.first.GetID() == address) {\n+            vchPubKeyOut = it.first;\n+            return true;\n+        }\n+    }\n+    // Look for pubkey in all partial sigs\n+    for (auto& in : psbt->inputs) {\n+        for (auto& it : in.partial_sigs) {\n+            if (it.first.GetID() == address) {\n+                vchPubKeyOut = it.first;\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool PSBTSigningProvider::GetKey(const CKeyID &address, CKey& key) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetKey(address, key)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+void PSBTSigningProvider::AddSigningProvider(SigningProvider* provider)\n+{\n+    if (provider) {\n+        providers.push_back(provider);\n+    }\n+}\n+\n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+// Returns true if the transaction is finalized, false otherwise. False does not necessarily mean that signing failed, just that a complete set of signatures\n+// for the transaction does not exist or the final transaction was not constructed.\n+bool SignPartiallySignedTransaction(PartiallySignedTransaction& psbt, SigningProvider* provider_in, int nHashType, bool finalize)\n+{\n+    // Create the psbt signing provider\n+    PSBTSigningProvider provider(&psbt);\n+    provider.AddSigningProvider(provider_in);\n+\n+    CMutableTransaction mtx = psbt.tx;\n+    bool solved = finalize;\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        CScript script = utxo.scriptPubKey;\n+        const CAmount& amount = utxo.nValue;\n+\n+        PSBTSignatureCreator creator(&psbt.inputs[i].partial_sigs, &mtx, i, amount, nHashType);\n+        SignatureData sigdata;\n+        bool sig_complete = ProduceSignature(provider, creator, script, sigdata);\n+        if (sig_complete && finalize) {\n+            // signatures are complete\n+            // Add scriptsig/scriptwitness to transaction\n+            psbt.tx.vin[i].scriptSig = sigdata.scriptSig;\n+            psbt.tx.vin[i].scriptWitness = sigdata.scriptWitness;\n+        }\n+        solved &= sig_complete;\n+    }\n+\n+    return solved;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193014272",
      "id" : 193014272,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzAxNDI3Mg==",
      "original_commit_id" : "aecb40ae5c873bff695e84ddc75c9be8a99822f8",
      "original_position" : 140,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 125898843,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193014272",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/4319748?v=4",
         "events_url" : "https://api.github.com/users/pedrobranco/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pedrobranco/followers",
         "following_url" : "https://api.github.com/users/pedrobranco/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pedrobranco/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pedrobranco",
         "id" : 4319748,
         "login" : "pedrobranco",
         "node_id" : "MDQ6VXNlcjQzMTk3NDg=",
         "organizations_url" : "https://api.github.com/users/pedrobranco/orgs",
         "received_events_url" : "https://api.github.com/users/pedrobranco/received_events",
         "repos_url" : "https://api.github.com/users/pedrobranco/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pedrobranco/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pedrobranco/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pedrobranco"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased to fix a silent merge conflict.",
      "created_at" : "2018-06-05T23:14:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-394889918",
      "id" : 394889918,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NDg4OTkxOA==",
      "updated_at" : "2018-06-05T23:14:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/394889918",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193250135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193250135"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IMO this doesn't matter",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-05T23:15:02Z",
      "diff_hunk" : "@@ -304,6 +323,119 @@ struct Stacks\n };\n }\n \n+bool PSBTSigningProvider::GetCScript(const CScriptID &scriptid, CScript& script) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetCScript(scriptid, script)) {\n+            return true;\n+        }\n+    }\n+    // Look for scripts in redeem_scripts\n+    auto mi = psbt->redeem_scripts.find(scriptid);\n+    if (mi != psbt->redeem_scripts.end()) {\n+        script = (*mi).second;\n+        return true;\n+    }\n+    // Look for scripts in witness_scripts\n+    for (auto& it : psbt->witness_scripts) {\n+        if (CScriptID(it.second) == scriptid) {\n+            script = it.second;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+bool PSBTSigningProvider::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetPubKey(address, vchPubKeyOut)) {\n+            return true;\n+        }\n+    }\n+    // Look for pubkey in hd_keypaths\n+    for (auto& it : psbt->hd_keypaths) {\n+        if (it.first.GetID() == address) {\n+            vchPubKeyOut = it.first;\n+            return true;\n+        }\n+    }\n+    // Look for pubkey in all partial sigs\n+    for (auto& in : psbt->inputs) {\n+        for (auto& it : in.partial_sigs) {\n+            if (it.first.GetID() == address) {\n+                vchPubKeyOut = it.first;\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool PSBTSigningProvider::GetKey(const CKeyID &address, CKey& key) const\n+{\n+    for (SigningProvider* provider : providers) {\n+        if (provider->GetKey(address, key)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+void PSBTSigningProvider::AddSigningProvider(SigningProvider* provider)\n+{\n+    if (provider) {\n+        providers.push_back(provider);\n+    }\n+}\n+\n+// Iterates through all inputs of the partially signed transaction and just produces signatures for what it can and adds them to the psbt partial sigs\n+// Returns true if the transaction is finalized, false otherwise. False does not necessarily mean that signing failed, just that a complete set of signatures\n+// for the transaction does not exist or the final transaction was not constructed.\n+bool SignPartiallySignedTransaction(PartiallySignedTransaction& psbt, SigningProvider* provider_in, int nHashType, bool finalize)\n+{\n+    // Create the psbt signing provider\n+    PSBTSigningProvider provider(&psbt);\n+    provider.AddSigningProvider(provider_in);\n+\n+    CMutableTransaction mtx = psbt.tx;\n+    bool solved = finalize;\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+        CTxIn& txin = mtx.vin[i];\n+        PartiallySignedInput psbt_in = psbt.inputs[i];\n+\n+        // Find the non witness utxo first\n+        CTxOut utxo;\n+        if (psbt_in.non_witness_utxo) {\n+            utxo = psbt_in.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!psbt_in.witness_utxo.IsNull()) {\n+            utxo = psbt_in.witness_utxo;\n+        }\n+        // If there is no nonwitness or witness utxo, then this input is fully signed and we are done here\n+        else {\n+            continue;\n+        }\n+\n+        CScript script = utxo.scriptPubKey;\n+        const CAmount& amount = utxo.nValue;\n+\n+        PSBTSignatureCreator creator(&psbt.inputs[i].partial_sigs, &mtx, i, amount, nHashType);\n+        SignatureData sigdata;\n+        bool sig_complete = ProduceSignature(provider, creator, script, sigdata);\n+        if (sig_complete && finalize) {\n+            // signatures are complete\n+            // Add scriptsig/scriptwitness to transaction\n+            psbt.tx.vin[i].scriptSig = sigdata.scriptSig;\n+            psbt.tx.vin[i].scriptWitness = sigdata.scriptWitness;\n+        }\n+        solved &= sig_complete;\n+    }\n+\n+    return solved;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193250135",
      "id" : 193250135,
      "in_reply_to_id" : 193014272,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzI1MDEzNQ==",
      "original_commit_id" : "aecb40ae5c873bff695e84ddc75c9be8a99822f8",
      "original_position" : 140,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 126186553,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193250135",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193594571"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193594571"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing change here and above.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-07T00:03:59Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);\n+    if (it != mapSigHashTypes.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193594571",
      "id" : 193594571,
      "in_reply_to_id" : 192902439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzU5NDU3MQ==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 7,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 126596760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193594571",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193596555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193596555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Alternative\r\n```cpp\r\nreturn { uint8_t(in), uint8_t(in >> 8), uint8_t(in >> 16), uint8_t(in >> 24) };\r\n```",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-07T00:18:58Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);\n+    if (it != mapSigHashTypes.end()) {\n+        return it->second;\n+    }\n+    return \"\";\n+}\n+\n+std::vector<uint8_t> Uint32ToUint8VectorLE(uint32_t in)\n+{\n+    std::vector<uint8_t> bytes;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193596555",
      "id" : 193596555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MzU5NjU1NQ==",
      "original_commit_id" : "3f6d5d43e7aec0d7d2b079d08d293fc97ce23deb",
      "original_position" : 15,
      "path" : "src/core_write.cpp",
      "position" : 13,
      "pull_request_review_id" : 126599113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193596555",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Hello,\r\n\r\nWhy not using JSON(like protocolbuffer) instead this BIP format? Its more simpler.",
      "created_at" : "2018-06-07T03:44:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-395283391",
      "id" : 395283391,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NTI4MzM5MQ==",
      "updated_at" : "2018-06-07T03:44:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/395283391",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/36975573?v=4",
         "events_url" : "https://api.github.com/users/tokutech/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tokutech/followers",
         "following_url" : "https://api.github.com/users/tokutech/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tokutech/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tokutech",
         "id" : 36975573,
         "login" : "tokutech",
         "node_id" : "MDQ6VXNlcjM2OTc1NTcz",
         "organizations_url" : "https://api.github.com/users/tokutech/orgs",
         "received_events_url" : "https://api.github.com/users/tokutech/received_events",
         "repos_url" : "https://api.github.com/users/tokutech/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tokutech/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tokutech/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tokutech"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@tokutech Because stuff like JSON or protobufs are more cumbersome to use. For JSON, the size of  the objects  are much larger. They are also in a form that is human readable and human readability doesn't matter for this.  Furthermore, in order for devices to use something that is JSON formatted, it needs to have a JSON parser, which is not necessarily something that exists on such devices. While those devices need to have a PSBT parser to use PSBT, that is easier as much of the functionality required for a PSBT parser is already required to parse other Bitcoin network messages, including normal transactions.\r\n\r\nAs for protobufs, that introduces another dependency and we don't want to do that.",
      "created_at" : "2018-06-07T09:14:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-395351254",
      "id" : 395351254,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NTM1MTI1NA==",
      "updated_at" : "2018-06-07T09:14:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/395351254",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193845471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193845471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Whoops, should be fixed now.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-07T18:24:35Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);\n+    if (it != mapSigHashTypes.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193845471",
      "id" : 193845471,
      "in_reply_to_id" : 192902439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mzg0NTQ3MQ==",
      "original_commit_id" : "47103a1b2e261d9828ec3e3eb3e17df1f2a3d4b3",
      "original_position" : 7,
      "path" : "src/core_write.cpp",
      "position" : null,
      "pull_request_review_id" : 126902393,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193845471",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193845671"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193845671"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it is more readable as it is now so I will leave it as is.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-07T18:25:15Z",
      "diff_hunk" : "@@ -70,6 +70,25 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    auto it = mapSigHashTypes.find(sighash_type);\n+    if (it != mapSigHashTypes.end()) {\n+        return it->second;\n+    }\n+    return \"\";\n+}\n+\n+std::vector<uint8_t> Uint32ToUint8VectorLE(uint32_t in)\n+{\n+    std::vector<uint8_t> bytes;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r193845671",
      "id" : 193845671,
      "in_reply_to_id" : 193596555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mzg0NTY3MQ==",
      "original_commit_id" : "3f6d5d43e7aec0d7d2b079d08d293fc97ce23deb",
      "original_position" : 15,
      "path" : "src/core_write.cpp",
      "position" : 13,
      "pull_request_review_id" : 126902640,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T00:17:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/193845671",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "From travis:\r\n```\r\nThe locale dependent function isdigit(...) appears to be used:\r\nsrc/wallet/rpcwallet.cpp:            if (!std::isdigit(c)) {\r\nUnnecessary locale dependence can cause bugs that are very\r\ntricky to isolate and fix. Please avoid using locale dependent\r\nfunctions if possible.\r\nAdvice not applicable in this specific case? Add an exception\r\nby updating the ignore list in test/lint/lint-locale-dependence.sh\r\n^---- failure generated from test/lint/lint-locale-dependence.sh",
      "created_at" : "2018-06-07T19:25:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-395536652",
      "id" : 395536652,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NTUzNjY1Mg==",
      "updated_at" : "2018-06-07T19:25:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/395536652",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I think I fixed the linter error.",
      "created_at" : "2018-06-07T19:46:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-395542481",
      "id" : 395542481,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NTU0MjQ4MQ==",
      "updated_at" : "2018-06-07T19:46:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/395542481",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Apparently I lost some changes in a rebase or something. They should be back.",
      "created_at" : "2018-06-09T00:22:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-395924864",
      "id" : 395924864,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NTkyNDg2NA==",
      "updated_at" : "2018-06-09T00:22:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/395924864",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on top of #13425 which simplifies the signer logic.",
      "created_at" : "2018-06-10T00:18:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-396008565",
      "id" : 396008565,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NjAwODU2NQ==",
      "updated_at" : "2018-06-10T00:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396008565",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242552"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why is this needed? Signing a TX_PUBKEY should always result in a full signature.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-10T01:06:41Z",
      "diff_hunk" : "@@ -86,16 +92,21 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_NULL_DATA:\n     case TX_WITNESS_UNKNOWN:\n         return false;\n-    case TX_PUBKEY:\n-        if (!creator.CreateSig(provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(vSolutions[0]);\n+        keyID = pubkey.GetID();\n+        if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n+        sigdata.signatures.emplace(keyID, SigPair(pubkey, sig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242552",
      "id" : 194242552,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDI0MjU1Mg==",
      "original_commit_id" : "4fe585eacfb9563b76631f73d24193d09a9ff552",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : 81,
      "pull_request_review_id" : 127382256,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T01:07:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242552",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242556"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-10T01:06:54Z",
      "diff_hunk" : "@@ -86,16 +92,21 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_NULL_DATA:\n     case TX_WITNESS_UNKNOWN:\n         return false;\n-    case TX_PUBKEY:\n-        if (!creator.CreateSig(provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(vSolutions[0]);\n+        keyID = pubkey.GetID();\n+        if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n+        sigdata.signatures.emplace(keyID, SigPair(pubkey, sig));\n         ret.push_back(std::move(sig));\n         return true;\n+    }\n     case TX_PUBKEYHASH: {\n         keyID = CKeyID(uint160(vSolutions[0]));\n         if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n-        ret.push_back(std::move(sig));\n         CPubKey pubkey;\n         GetPubKey(&provider, &sigdata, keyID, pubkey);\n+        sigdata.signatures.emplace(keyID, SigPair(pubkey, sig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242556",
      "id" : 194242556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDI0MjU1Ng==",
      "original_commit_id" : "4fe585eacfb9563b76631f73d24193d09a9ff552",
      "original_position" : 33,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 127382256,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T01:07:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242556",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242720"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242720"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A PSBT does not have to create the final scriptSig even when a complete set of signatures is available. The user has the option to not finalize the scriptSigs even when they can be.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-10T01:19:58Z",
      "diff_hunk" : "@@ -86,16 +92,21 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_NULL_DATA:\n     case TX_WITNESS_UNKNOWN:\n         return false;\n-    case TX_PUBKEY:\n-        if (!creator.CreateSig(provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(vSolutions[0]);\n+        keyID = pubkey.GetID();\n+        if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n+        sigdata.signatures.emplace(keyID, SigPair(pubkey, sig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242720",
      "id" : 194242720,
      "in_reply_to_id" : 194242552,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDI0MjcyMA==",
      "original_commit_id" : "4fe585eacfb9563b76631f73d24193d09a9ff552",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : 81,
      "pull_request_review_id" : 127382432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T01:19:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242720",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242923"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242923"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In that case you should also be able to deal with unfinalized signatures already present, and turn them into scriptSigs. In other words, you need to test whether sigdata.signatures contains a matching signature and reuse it. If that's the case, we're probably better off reintroducing SignatureDataSignatureCreator and SignatureDataSigningProvider, so these keys/script/signatures are automatically available everywhere.\r\n\r\nAnother interpretation is that TX_PUBKEY and TX_PUBKEYHASH etc just don't have \"partial\" forms - they're either fully signed or not, and as a result there never is anything to finalize.",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-10T01:34:57Z",
      "diff_hunk" : "@@ -86,16 +92,21 @@ static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator\n     case TX_NULL_DATA:\n     case TX_WITNESS_UNKNOWN:\n         return false;\n-    case TX_PUBKEY:\n-        if (!creator.CreateSig(provider, sig, CPubKey(vSolutions[0]).GetID(), scriptPubKey, sigversion)) return false;\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(vSolutions[0]);\n+        keyID = pubkey.GetID();\n+        if (!creator.CreateSig(provider, sig, keyID, scriptPubKey, sigversion)) return false;\n+        sigdata.signatures.emplace(keyID, SigPair(pubkey, sig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194242923",
      "id" : 194242923,
      "in_reply_to_id" : 194242552,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDI0MjkyMw==",
      "original_commit_id" : "4fe585eacfb9563b76631f73d24193d09a9ff552",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : 81,
      "pull_request_review_id" : 127382636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-10T01:34:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194242923",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194366112"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194366112"
         }
      },
      "author_association" : "NONE",
      "body" : "small typo: Make sure that we are using input indexes or this is the first input",
      "commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "created_at" : "2018-06-11T11:03:38Z",
      "diff_hunk" : "@@ -53,26 +59,456 @@ class MutableTransactionSignatureCreator : public BaseSignatureCreator {\n /** A signature creator that just produces 72-byte empty signatures. */\n extern const BaseSignatureCreator& DUMMY_SIGNATURE_CREATOR;\n \n+typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n+\n struct SignatureData {\n-    CScript scriptSig;\n-    CScriptWitness scriptWitness;\n+    bool complete = false; // Stores whether the scriptSig and scriptWitness are complete\n+    CScript scriptSig; // The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n+    CScriptWitness scriptWitness; // The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format\n+    std::map<CKeyID, SigPair> signatures; // BIP 174 style partial signatures for the input. May contain complete signatures\n+    std::map<CScriptID, CScript> scripts; // BIP 174 style scripts for the input\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n+    void MergeSignatureData(SignatureData sigdata);\n+};\n+\n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+static constexpr uint8_t PSBT_UNSIGNED_TX_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_REDEEMSCRIPT_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_WITNESSSCRIPT_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_BIP32_KEYPATH_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_NUM_IN_VIN = 0x04;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename... X>\n+std::vector<unsigned char> SerializeToVector(const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    return ret;\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+    uint64_t index = 0;\n+    bool use_in_index = false;\n+\n+    PartiallySignedInput() {}\n+    void SetNull();\n+    bool IsNull();\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::map<uint160, CScript> redeem_scripts;\n+    std::map<uint256, CScript> witness_scripts;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    void SetNull();\n+    bool IsNull();\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const CMutableTransaction& tx, const std::map<uint160, CScript>& redeem_scripts, const std::map<uint256, CScript>& witness_scripts, const std::vector<PartiallySignedInput>& inputs, const std::map<CPubKey, std::vector<uint32_t>> hd_keypaths);\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        if (a.tx.vin.size() != b.tx.vin.size() || a.tx.vout.size() != b.tx.vout.size()) return false;\n+        // Check the inputs\n+        for (unsigned int i = 0; i < a.tx.vin.size(); ++i) {\n+            if (a.tx.vin[i].prevout != b.tx.vin[i].prevout\n+                || a.tx.vin[i].nSequence != b.tx.vin[i].nSequence) {\n+                    return false;\n+                }\n+        }\n+        // Check the outputs\n+        for (unsigned int i = 0; i < a.tx.vout.size(); ++i) {\n+            if (a.tx.vout[i] != b.tx.vout[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // Write transaction if it exists\n+        if (!CTransaction(tx).IsNull()) {\n+            // unsigned tx flag\n+            s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+\n+            // Write serialized tx to a stream\n+            s << SerializeToVector(tx);\n+        }\n+\n+        // Write redeem scripts and witness scripts\n+        for (auto& entry : redeem_scripts) {\n+            s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO, entry.first);\n+            s << entry.second;\n+        }\n+        for (auto& entry : witness_scripts) {\n+            s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, entry.first);\n+            s << entry.second;\n+        }\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write the number of inputs\n+        if (num_ins > 0) {\n+            s << SerializeToVector(PSBT_NUM_IN_VIN);\n+            s << SerializeToVector(COMPACTSIZE(num_ins));\n+        }\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            CTxIn in = tx.vin[i];\n+            PartiallySignedInput psbt_in = inputs[i];\n+            if (in.scriptSig.empty() && in.scriptWitness.IsNull()) {\n+                // Write the utxo\n+                // If there is a non-witness utxo, then don't add the witness one.\n+                if (psbt_in.non_witness_utxo) {\n+                    s << SerializeToVector(PSBT_UNSIGNED_TX_NON_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.non_witness_utxo);\n+                } else if (!psbt_in.witness_utxo.IsNull()) {\n+                    s << SerializeToVector(PSBT_REDEEMSCRIPT_WITNESS_UTXO);\n+                    s << SerializeToVector(psbt_in.witness_utxo);\n+                }\n+\n+                // Write any partial signatures\n+                for (auto sig_pair : psbt_in.partial_sigs) {\n+                    s << SerializeToVector(PSBT_WITNESSSCRIPT_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                    s << sig_pair.second.second;\n+                }\n+\n+                // Write the sighash type\n+                if (psbt_in.sighash_type > 0) {\n+                    s << SerializeToVector(PSBT_BIP32_KEYPATH_SIGHASH);\n+                    s << SerializeToVector(psbt_in.sighash_type);\n+                }\n+\n+                // Write the index\n+                if (use_in_index) {\n+                    s << SerializeToVector(PSBT_NUM_IN_VIN);\n+                    s << SerializeToVector(COMPACTSIZE(psbt_in.index));\n+                }\n+            }\n+\n+            // Write unknown things\n+            for (auto& entry : psbt_in.unknown) {\n+                s << entry.first;\n+                s << entry.second;\n+            }\n+\n+            s << PSBT_SEPARATOR;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // hashers\n+        CHash160 hash160_hasher;\n+        CSHA256 sha256_hasher;\n+\n+        // Read loop\n+        uint32_t separators = 0;\n+        PartiallySignedInput input;\n+        input.index = 0; // Make the first input at index 0\n+        bool in_globals = true;\n+        while(!s.empty()) {\n+            // Reset hashers\n+            hash160_hasher.Reset();\n+            sha256_hasher.Reset();\n+\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+\n+                // If we ever hit a separator, we are no longer in globals\n+                in_globals = false;\n+\n+                if (separators > 0) {\n+                    // Make sure this input has an index if indexes are being used\n+                    if (use_in_index && !input.use_in_index) {\n+                        throw std::ios_base::failure(\"Input indexes being used but an input was provided without an index\");\n+                    }\n+                    // If indexes are being used, add a bunch of empty inputs to the input vector so that it matches the number of inputs in the transaction so far\n+                    if (use_in_index) {\n+                        for (unsigned int i = inputs.size(); i < input.index; ++i) {\n+                            PartiallySignedInput empty_input;\n+                            inputs.push_back(empty_input);\n+                        }\n+                    }\n+\n+                    // Add input to vector\n+                    inputs.push_back(input);\n+                    input.SetNull();\n+                    input.index = separators; // Set the inputs index. This will be overwritten if an index is provided.\n+                }\n+\n+                ++separators;\n+\n+                continue;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Read in value length\n+            uint64_t value_len = ReadCompactSize(s);\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                // Raw transaction or a non witness utxo\n+                case PSBT_UNSIGNED_TX_NON_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        s >> tx;\n+                    } else {\n+                        // Read in the transaction\n+                        CTransactionRef prev_tx;\n+                        s >> prev_tx;\n+\n+                        // Check that this utxo matches this input\n+                        if (tx.vin[input.index].prevout.hash.Compare(prev_tx->GetHash()) != 0) {\n+                            throw std::ios_base::failure(\"Provided non witness utxo does not match the required utxo for input\");\n+                        }\n+\n+                        // Add to input\n+                        input.non_witness_utxo = std::move(prev_tx);\n+                    }\n+                    break;\n+                // redeemscript or a witness utxo\n+                case PSBT_REDEEMSCRIPT_WITNESS_UTXO:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint160 + 1\n+                        if (key.size() != 21) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type redeem script\");\n+                        }\n+                        // Retrieve hash160 from key\n+                        uint160 hash160(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> redeemscript_bytes;\n+                        redeemscript_bytes.resize(value_len);\n+                        s >> MakeSpan(redeemscript_bytes);\n+                        CScript redeemscript(redeemscript_bytes.begin(), redeemscript_bytes.end());\n+\n+                        // Check that the redeemscript hash160 matches the one provided\n+                        hash160_hasher.Write(&redeemscript_bytes[0], redeemscript_bytes.size());\n+                        unsigned char rs_hash160_data[hash160_hasher.OUTPUT_SIZE];\n+                        hash160_hasher.Finalize(rs_hash160_data);\n+                        uint160 rs_hash160(std::vector<unsigned char>(rs_hash160_data, rs_hash160_data + hash160_hasher.OUTPUT_SIZE));\n+                        if (hash160 != rs_hash160) {\n+                            throw std::ios_base::failure(\"Provided hash160 does not match the redeemscript's hash160\");\n+                        }\n+\n+                        // Add to map\n+                        redeem_scripts.emplace(hash160, redeemscript);\n+                    } else {\n+                        // Read in the utxo\n+                        CTxOut vout;\n+                        s >> vout;\n+\n+                        // Add to map\n+                        input.witness_utxo = vout;\n+                    }\n+                    break;\n+                // witnessscript or a partial signature\n+                case PSBT_WITNESSSCRIPT_PARTIAL_SIG:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of uint256 + 1\n+                        if (key.size() != 33) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type witness script\");\n+                        }\n+                        // Retrieve sha256 from key\n+                        uint256 hash(std::vector<unsigned char>(key.begin() + 1, key.end()));\n+\n+                        // Read in the redeemscript\n+                        std::vector<unsigned char> witnessscript_bytes;\n+                        witnessscript_bytes.resize(value_len);\n+                        s >> MakeSpan(witnessscript_bytes);\n+                        CScript witnessscript(witnessscript_bytes.begin(), witnessscript_bytes.end());\n+\n+                        // Check that the witnessscript sha256 matches the one provided\n+                        sha256_hasher.Write(&witnessscript_bytes[0], witnessscript_bytes.size());\n+                        unsigned char ws_sha256_data[sha256_hasher.OUTPUT_SIZE];\n+                        sha256_hasher.Finalize(ws_sha256_data);\n+                        uint256 ws_sha256(std::vector<unsigned char>(ws_sha256_data, ws_sha256_data + sha256_hasher.OUTPUT_SIZE));\n+                        if (hash != ws_sha256) {\n+                            throw std::ios_base::failure(\"Provided sha256 does not match the witnessscript's sha256\");\n+                        }\n+\n+                        // Add to map\n+                        witness_scripts.emplace(hash, witnessscript);\n+                    } else {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in the signature from value\n+                        std::vector<unsigned char> sig;\n+                        sig.resize(value_len);\n+                        s >> MakeSpan(sig);\n+\n+                        // Add to list\n+                        input.partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    }\n+                    break;\n+                // BIP 32 HD Keypaths and sighash types\n+                case PSBT_BIP32_KEYPATH_SIGHASH:\n+                    if (in_globals) {\n+                        // Make sure that the key is the size of pubkey + 1\n+                        if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                            throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                        }\n+                        // Read in the pubkey from key\n+                        CPubKey pubkey(key.begin() + 1, key.end());\n+                        if (!pubkey.IsFullyValid()) {\n+                           throw std::ios_base::failure(\"Invalid pubkey\");\n+                        }\n+\n+                        // Read in key path\n+                        std::vector<uint32_t> keypath;\n+                        for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                            uint32_t index;\n+                            s >> index;\n+                            keypath.push_back(index);\n+                        }\n+\n+                        // Add to map\n+                        hd_keypaths.emplace(pubkey, keypath);\n+                    } else {\n+                        // Read in the sighash type\n+                        s >> input.sighash_type;\n+                    }\n+                    break;\n+                // Number of inputs and input index\n+                case PSBT_NUM_IN_VIN:\n+                    if (in_globals) {\n+                        num_ins = ReadCompactSize(s);\n+                    } else {\n+                        // Make sure that we are using inout indexes or this is the first input",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#discussion_r194366112",
      "id" : 194366112,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDM2NjExMg==",
      "original_commit_id" : "7b636e91804301a43f3e899894b404b654a7873a",
      "original_position" : 429,
      "path" : "src/script/sign.h",
      "position" : 429,
      "pull_request_review_id" : 127522332,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12136",
      "updated_at" : "2018-06-11T11:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/194366112",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/2931875?v=4",
         "events_url" : "https://api.github.com/users/araspitzu/events{/privacy}",
         "followers_url" : "https://api.github.com/users/araspitzu/followers",
         "following_url" : "https://api.github.com/users/araspitzu/following{/other_user}",
         "gists_url" : "https://api.github.com/users/araspitzu/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/araspitzu",
         "id" : 2931875,
         "login" : "araspitzu",
         "node_id" : "MDQ6VXNlcjI5MzE4NzU=",
         "organizations_url" : "https://api.github.com/users/araspitzu/orgs",
         "received_events_url" : "https://api.github.com/users/araspitzu/received_events",
         "repos_url" : "https://api.github.com/users/araspitzu/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/araspitzu/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/araspitzu/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/araspitzu"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated the title to indicate that this is primarily serializations and RPCs.",
      "created_at" : "2018-06-12T19:03:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12136#issuecomment-396699040",
      "id" : 396699040,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12136",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NjY5OTA0MA==",
      "updated_at" : "2018-06-12T19:03:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396699040",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
